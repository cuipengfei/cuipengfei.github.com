<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: MOOC | 崔鹏飞的Octopress Blog]]></title>
  <link href="http://cuipengfei.github.com/blog/categories/mooc/atom.xml" rel="self"/>
  <link href="http://cuipengfei.github.com/"/>
  <updated>2016-05-28T23:25:13+08:00</updated>
  <id>http://cuipengfei.github.com/</id>
  <author>
    <name><![CDATA[崔鹏飞]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Principles of Reactive Programming Week Two作业导学]]></title>
    <link href="http://cuipengfei.github.com/blog/2015/04/26/principles-of-reactive-programming-week-2/"/>
    <updated>2015-04-26T17:56:00+08:00</updated>
    <id>http://cuipengfei.github.com/blog/2015/04/26/principles-of-reactive-programming-week-2</id>
    <content type="html"><![CDATA[<h1>声明</h1>

<p>这系列博文的目标读者仅限于报名参加了这门课并且看完了视频，看完了作业的instruction之后仍有困难的同学。</p>

<p>这系列博文不会公布作业的答案，那是违反Coursera的code of honor的。</p>

<p>我只会试着解释作业中已有的代码，以及应该如何入手。</p>

<p>其实，写这个系列博文对我的帮助比对读者的帮助要大。</p>

<p>这周的作业不太难，主要就是一个观察者模式。</p>

<h1>Signal是怎么work的？</h1>

<p>```scala
scala> val a = Var(1)
a: calculator.Var[Int] = calculator.Var@7ca6f5b9</p>

<p>scala> val b = Var(2)
b: calculator.Var[Int] = calculator.Var@2286d26</p>

<p>scala> val c = Signal(a() + b())
c: calculator.Signal[Int] = calculator.Signal@5c60548d</p>

<p>scala> c()
res8: Int = 3</p>

<p>scala> a()=10</p>

<p>scala> c()
res10: Int = 12</p>

<p>scala> b()=20</p>

<p>scala> c()
res12: Int = 30
```</p>

<p>如果能搞懂上面的代码是如何work的，作业题中需要用到Signal的地方就不会有太大问题了。</p>

<p>a=1，b=2，c=a+b，所以c就是3。</p>

<p>a变成10之后c就变成了12（10+2）。</p>

<p>b再变成20之后，c就变成了30（10+29）。</p>

<p>这个级联的变化是如何发生的呢？</p>

<p>有两个关键点：</p>

<ul>
<li>Signal的constructor</li>
<li>Signal的update方法</li>
</ul>


<p>先看Signal的constructor。</p>

<p><code>scala
class Signal[T](expr: =&gt; T) {
  //......
}
</code></p>

<p>以上是它的签名，关键在于expr的类型签名，expr的类型不是T，而是=>T。</p>

<p>这就意味着expr可以是任何类型为T的表达式，可以是一个字面量，也可以是任意复杂的代码块。</p>

<p>比如Signal(123)是可以的，Signal(complicatedMethodCall())也可以。</p>

<p>最上面那块代码中的val c = Signal(a() + b())就属于后一种。</p>

<p>a() + b()不会被立即求值成3然后传入Signal的constructor，而是整体作为一个可以被反复求值的表达式被记录在Signal的实例中。</p>

<p>constructor的入口参数可以被反复求值是级联变化的基础，那是什么触发了真正的变化呢？</p>

<p>那就是关键点之二：update方法。</p>

<p>update方法的妙处在于，如果一个类A有update方法，那么：</p>

<p><code>scala
val x = new A()
x(y)=z
</code></p>

<p>在编译之后会变成这样：</p>

<p><code>scala
val x = new A()
x.update(y,z)
</code></p>

<p>详情请见我之前的一篇博客：<a href="http://cuipengfei.me/blog/2014/06/12/scala-update-method/">http://cuipengfei.me/blog/2014/06/12/scala-update-method/</a></p>

<p>Signal的update方法是protected的，不可访问，所以它只可以从变，不可自变。</p>

<p>而Var把update方法public出来了，这样，在下面这样的代码执行时：</p>

<p><code>scala
a()=10
//a.update(10)
</code></p>

<p>a就会通知它的observers去重新求值。
这样就实现了a或者b这样的Var变化的时候，c这样的Signal跟着变化的效果。</p>

<p>搞懂了上面的内容就足以去做作业了。</p>

<h1>怎么和html页面结合起来的？</h1>

<p>执行instruction里提到的webUI/fastOptJS这个task就会把Scala作业代码编译成js。</p>

<p>这个task是scalajs这个dependency带进来的（在webui.sbt里）。</p>

<p>webui这个项目里有一个CalculatorUI.scala文件，也会被编译成js。其中的代码就把作业代码和html的UI结合起来了。</p>

<p>就是这样了，这周的作业不难懂也不太难做。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Principles of Reactive Programming Week One作业导学]]></title>
    <link href="http://cuipengfei.github.com/blog/2015/04/19/principles-of-reactive-programming-week-one/"/>
    <updated>2015-04-19T13:59:00+08:00</updated>
    <id>http://cuipengfei.github.com/blog/2015/04/19/principles-of-reactive-programming-week-one</id>
    <content type="html"><![CDATA[<h1>前尘</h1>

<p>Principles of Reactive Programming在4月13号又开课了。
<a href="https://www.coursera.org/course/reactive">https://www.coursera.org/course/reactive</a></p>

<p>上次开课是在2013年的11月，当时我刚第一次上完Functional programming principles in Scala，热情很高于是就报名参加了这门课。
还群发了一个邮件找人一起上课。</p>

<p>但是上了几周发现有点难，于是就放弃了。现在去bitbucket看，最后一次push停留在了2013-11-18。</p>

<p>后来还在上海被8x鄙视于无形之中。</p>

<h1>后世</h1>

<p>14年做了几个月的Scala开发，后来Functional programming principles in Scala再次开课又上了一遍，拿了个认证证书。</p>

<p>感觉似乎可以再挑战一次。</p>

<h1>今生</h1>

<p>上课习得的知识放在脑子里是不牢靠的。大脑有遗忘周期。</p>

<p>需要有成文或者成代码的产出，作为日后回忆和做spaced repetition的资料。</p>

<p>于是就有了这个即将成为系列的博文中的第一篇《Principles of Reactive Programming Week One作业导学》。</p>

<p>这系列博文的目标读者仅限于报名参加了这门课并且看完了视频，看完了作业的instruction之后仍有困难的同学。</p>

<p>这系列博文不会公布作业的答案，那是违反Coursera的code of honor的。</p>

<p>我只会试着解释作业中已有的代码，以及应该如何入手。</p>

<p>其实，写这个系列博文对我的帮助比对读者的帮助要大。</p>

<h1>正文</h1>

<h2>Heap.scala</h2>

<p>第一周的代码下载下来之后，先来看一下Heap.scala这个文件。</p>

<p>这个文件里定义了很多个trait。现在只需要关注其中一个Heap。</p>

<p>这个就是所有其他trait都会去extend的基类（这个说法合适吗？）。
它定义了所有Heap的实现者都需要实现的方法。</p>

<p>然后BinomialHeap完整实现了Heap定义的所有东西。</p>

<p>Bogus1BinomialHeap到Bogus5BinomialHeap都是继承自BinomialHeap，其中各自覆盖了BinomialHeap的不同方法，以不同的方式引入了bug。
第一周作业的目的就是用ScalaCheck把其中的bug找出来。</p>

<p>这个文件里还有一个IntHeap，这个稍后再说。</p>

<p>实现代码其实就只有这一个文件，接下来看测试代码。</p>

<h2>QuickCheckSuite.scala</h2>

<p>这个文件里主要定义了QuickCheckSuite这个测试类。</p>

<p>这个测试类继承自FunSuite，这是ScalaTest的测试基类。同时mix in了Checkers，这是ScalaTest为了与ScalaCheck集成而提供的trait。</p>

<p>接下来看测试的case：</p>

<p>```scala
def checkBogus(p: Prop) {
  var foundBug = false
  try {</p>

<pre><code>check(p)
</code></pre>

<p>  } catch {</p>

<pre><code>case e: TestFailedException =&gt;
  foundBug = true
</code></pre>

<p>  }
  assert(foundBug, "A bogus heap should NOT satisfy all properties. Try to find the bug!")
}</p>

<p>test("Binomial heap satisfies properties.") {
  check(new QuickCheckHeap with BinomialHeap)
}</p>

<p>test("Bogus (1) binomial heap does not satisfy properties.") {
  checkBogus(new QuickCheckHeap with Bogus1BinomialHeap)
}</p>

<p>test("Bogus (2) binomial heap does not satisfy properties.") {
  checkBogus(new QuickCheckHeap with Bogus2BinomialHeap)
}
```</p>

<p>可以看到，每个case都调用了check这个方法，或者是check的变体-checkBogus。</p>

<p>checkBogus里面则调用了check，并且assert说一定要出现TestFailedException异常了，测试才算成功。也就是说checkBogus的目的就是要在某些Heap的实现中找到bug。</p>

<p>现在来看check这个方法本身。它接受一个类型为Prop的参数，这些参数从哪儿来呢？这些参数就是：
```scala
new QuickCheckHeap with BinomialHeap</p>

<p>new QuickCheckHeap with Bogus1BinomialHeap
```
这些代码。</p>

<p>这就意味着QuickCheckHeap一定要是一个Prop，是不是这样呢？</p>

<h2>QuickCheckHeap.scala</h2>

<p>那就到QuickCheckHeap.scala这个文件中来看一下。</p>

<p>可以看到QuickCheckHeap这个抽象类确实是extends了Properties，而properties又extends了Prop。那么，没问题，这个类型是匹配的。</p>

<p>QuickCheckHeap里可以定义任意多个property，这些property将会检查Heap的实现正确与否。</p>

<p>而且它还mix in了IntHeap，就是前面略过的那个trait。它的目的是锁定Heap这个trait里所定义的A这个元素的类型到Int。</p>

<h2>全部连起来</h2>

<p>第一周作业的已有代码很少，有用的就是这三个文件。</p>

<p>Heap.scala定义了很多个Heap的不同实现。有些是正确的，有些是有bug的。</p>

<p>QuickCheckSuite.scala则是测试的入口点，它由JunitRunner拽着跑起来。
其中的test case使用ScalaCheck去检查对于Heap这种数据结构恒定为true的properties是不是hold住的。</p>

<p>对于Heap这种数据结构恒定为true的properties从哪儿来呢？就来自于QuickCheckHeap.scala。
QuickCheckHeap本身是一个抽象类，不可以被实例化。但是由于有了牛逼的trait，就可以用这种代码：
```scala
new QuickCheckHeap with BinomialHeap</p>

<p>new QuickCheckHeap with Bogus1BinomialHeap
```
创建出实例，进行测试了。</p>

<p>最后，我们的任务就是在QuickCheckHeap.scala添加更多的properties，把所有实现有误的Heap都揪出来。</p>

<h1>题外话</h1>

<p>有没有发现QuickCheckHeap.scala里面有些奇怪的代码？</p>

<p><code>scala
property("min1") = forAll { (heap: H, a: A) =&gt;
  val min = if (isEmpty(heap)) a else findMin(heap)
  findMin(insert(min, heap)) == min
}
</code></p>

<p>property("min should be min")，这看起来像是一个方法调用啊。</p>

<p>尼玛，方法调用后面怎么跟着一个等号啊？等号后面还有一个有返回值的表达式啊？</p>

<p>这是啥啊？</p>

<p>这是个乍一看很自然，但是仔细一想很费解的Scala语言特性-update方法。</p>

<p>详情请见我之前的一篇博客：<a href="http://cuipengfei.me/blog/2014/06/12/scala-update-method/">http://cuipengfei.me/blog/2014/06/12/scala-update-method/</a></p>
]]></content>
  </entry>
  
</feed>

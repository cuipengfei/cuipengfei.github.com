<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Desugar_Scala | 崔鹏飞的Octopress Blog]]></title>
  <link href="http://cuipengfei.github.com/blog/categories/desugar-scala/atom.xml" rel="self"/>
  <link href="http://cuipengfei.github.com/"/>
  <updated>2015-07-10T16:30:51+05:30</updated>
  <id>http://cuipengfei.github.com/</id>
  <author>
    <name><![CDATA[崔鹏飞]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Desugar Scala(17) -- Option和for，以及脑子里发生的事情]]></title>
    <link href="http://cuipengfei.github.com/blog/2014/08/30/options-for/"/>
    <updated>2014-08-30T11:36:00+05:30</updated>
    <id>http://cuipengfei.github.com/blog/2014/08/30/options-for</id>
    <content type="html"><![CDATA[<p>Scala里的for关键字是个很有趣的东西。可以用来把多层嵌套for循环写成一层。比如这样：</p>

<p><code>scala
for(i&lt;-1 to 10;j&lt;-1 to 10;k&lt;-1 to 10) yield(s"$i $j $k")
</code></p>

<p>这行代码执行的结果是这样的：</p>

<p><code>scala
1 1 1
1 1 2
1 1 3
1 1 4
1 1 5
1 1 6
1 1 7
1 1 8
1 1 9
1 1 10
1 2 1
1 2 2
1 2 3
1 2 4
1 2 5
1 2 6
1 2 7
1 2 8
1 2 9
1 2 10
......
......
</code></p>

<p>这样，就可以用一行代码写出三层循环的效果。代码看起来非常紧凑，噪音很少。</p>

<p>但是今天主要要说的不是这种for，而是它和Option结合的写法。</p>

<p>Option本身是一个抽象类，代表一个可能存在，也可能不存在的值（那谁谁的喵？）。它有两个实现类，分别是Some和None。顾名思义，Some代表有值，None代表没有。</p>

<p>实际上，上面的说法不够准确，Some是一个实现类，而None实际是一个单例，不过这点对后面的内容没影响。</p>

<p>现在设想一个很简单的场景，需要用单价和数量来算总价，而单价和数量未必拿得到，那代码大概会是这样的：</p>

<p>```scala
  def calculateTotal: Option[Int] = {</p>

<pre><code>val price: Option[Int] = getPrice
val amount: Option[Int] = getAmount

if (price.isEmpty || amount.isEmpty) {
  None
} else {
  Some(price.get * amount.get)
}
</code></pre>

<p>  }
```</p>

<p>getPrice和getAmount都返回一个Option[Int]，就类似Java中Integer可以为null一样。计算出来的总价也是一个Option[Int]，说不定会有，也说不定没有。</p>

<p>在这段代码中先检查单价和数量是否存在，如果二者中任意一个不存在，那就返回None，代表无法求得总价。如果二者都存在，那就将二者的乘积用Some包起来返回。</p>

<p>这代码看起来还ok，很常规的写法，但是稍显啰嗦。如果用上for的话，可以大大简化这段代码：</p>

<p>```scala
  def calculateTotalWithFor: Option[Int] = {</p>

<pre><code>for (price &lt;- getPrice; amount &lt;- getAmount) yield price * amount
</code></pre>

<p>  }
```</p>

<p>这个方法体只有一行了，而它实现出来的行为和上面那段代码是完全一致的。</p>

<p>这感觉好神奇啊，不用判断价格和数量是否存在，也不需要根据判断结果决定到底返回None还是Some。它是怎么搞的呢？</p>

<p>看一下反编译的结果吧：</p>

<p>```java</p>

<pre><code>public Option&lt;Object&gt; calculateTotalWithFor() {
    return getPrice().flatMap(new AbstractFunction1() {
        public final Option&lt;Object&gt; apply(final int price) {
            return OptionAndFor..MODULE$.account$of$OptionAndFor$$getAmount().map(new AbstractFunction1.mcII.sp() {
                private final int price$1;

                public final int apply(int amount) {
                    return apply$mcII$sp(amount);
                }

                public int apply$mcII$sp(int amount) {
                    return price * amount;
                }
            });
        }
    });
}
</code></pre>

<p>```</p>

<p>这个反编译的结果很不好读，不过还是可以看出个大概。它先是对getPrice的返回值调用了flatMap，给其传入一个匿名函数（AbstractFunction1），在这个匿名函数里面又对getAmount的返回值调用了map，也给其传入了一个匿名函数，再在这第二层匿名函数里做了乘法运算。</p>

<p>如果用Scala把它表达出来，是这样的：</p>

<p>```scala
  def calculateTotalWithFlatMapAndMap: Option[Int] = {</p>

<pre><code>getPrice.flatMap(price =&gt; getAmount.map(amount =&gt; amount * price))
</code></pre>

<p>  }
```</p>

<p>由此可见，上面使用for的代码的神奇之处在于它利用了Option的flatMap和map方法。</p>

<p>这两个方法具有一个共同特征：如果被调用flatMap或者map的当前Option实例为None的话，则忽略传入的匿名函数，直接返回None。</p>

<p>这很容易理解，要参与运算的成员之一已经是None了，那就不用管剩下的成员到底是啥了，它随便是啥，最终的计算结果都会是None。这和最初写出的用 || 运算符的代码的逻辑是一致的。</p>

<p>到此为止，我们给Option和for的结合使用脱光了衣服，它就是利用Option的flatMap和map来实现紧凑的代码的。</p>

<h3>神奇之处不仅在于更短的代码，还在于它提高了信噪比，给我们提供了更加简化的思考模型</h3>

<p>最初那段用if else的代码，在写它或者读它的时候，我们的脑子里面发生了什么呢？</p>

<pre><code>1. 要获取价格和数量
2. 要判断价格是否为空，要判断数量是否为空        （与业务关联较小，属于技术范畴）
3. 如果任意一个为空，结果是空                 （与业务关联较小，属于技术范畴）
4. 如果两个都不是空，再做乘法运算
</code></pre>

<p>而在写或者读用for的那段代码的时候，脑子里又是怎么想的呢？</p>

<pre><code>1. 获取价格和数量
2. 做乘法运算
</code></pre>

<p>我们写这段代码的目的是要表述业务逻辑，是要给未来读代码的人传递和业务相关的信息。</p>

<p>而空值判断是偏技术的，把这种代码消掉，我们传递给其他程序员的信息里就含有更少的与业务无关的噪音。而且我们自己写起来的时候，脑子里也不需要考虑那么多的东西。</p>

<p>对自己，对他人都有利。这实在是一个美妙的语言特性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Desugar Scala(16) -- lower bound]]></title>
    <link href="http://cuipengfei.github.com/blog/2014/06/21/desugar-scala-lower-bound/"/>
    <updated>2014-06-21T11:32:00+05:30</updated>
    <id>http://cuipengfei.github.com/blog/2014/06/21/desugar-scala-lower-bound</id>
    <content type="html"><![CDATA[<p>Lower bound，不知道这个词的确切中文翻译是怎样的。我们直接看例子吧。</p>

<p><code>scala
class Pair[T](val first: T, val second: T) {
  def replaceFirst[R &gt;: T](newFirst: R): Pair[R] = new Pair[R](newFirst, second)
}
</code></p>

<p>我们定义一个叫做Pair的类，其中可以包含两个元素，元素类型为泛型的T。</p>

<p>Pair类中有一个replaceFirst方法，用来把第二个元素和一个新的元素结合起来组成一个新的Pair。新的元素的类型是泛型的R。新组成的Pair的类型是Pair[R]。</p>

<p>到这里我们就要想了，一个T和一个R，它们俩怎么组成新的Pair呢？新的Pair的类型怎么能是Pair[R]呢？</p>

<p>replaceFirst的签名给我们说明了这一点。[R >: T]。这种标记的含义是说R是T的基类。那么一个T和一个R自然可以组合成一个R的Pair了。</p>

<p>单是这样干说，有点不好理解，我们看一个例子：</p>

<p>```scala
class Vehicle {}</p>

<p>class Car extends Vehicle {}</p>

<p>class Tank extends Vehicle {}
```</p>

<p>汽车和坦克都是机动车。</p>

<p>然后我们可以这样使用它们：</p>

<p><code>scala
  val twoCars: Pair[Car] = new Pair(new Car(), new Car())
  val tankAndCar: Pair[Vehicle] = twoCars.replaceFirst(new Tank())
</code></p>

<p>首先我们用两辆汽车组成一个Pair，其类型为Pair[Car]。</p>

<p>然后我们用一辆坦克替代原来的Pair中的第一个元素，让坦克和第二辆车组成一个新的Pair。新的Pari的类型是Pair[Vehicle]。</p>

<p>这里有一点tricky。我们调用replaceFirst的时候传递的参数的类型是Tank，这是否意味着在这里R就是Tank呢？</p>

<p>不是的，因为很明显Tank不是Car的基类，然而Tank是一个（is a）Vehicle，Vehicle同时也是Car的基类。于是此处的R就是Vehicle。得到的新的Pair自然就是Pair[Vehicle]。</p>

<p>也就是说R会被什么具体类型替换呢？这取决于T和newFirst的类型。</p>

<p>如果newFirst的类型刚好是T的基类，那太好了，R就直接是newFirst的类型。如果newFirst的类型不是T的基类，那R就会是T和newFirst的类型的共同基类。</p>

<h3>这个东西挺麻烦的，它有啥用呢？</h3>

<p>保证类型安全，Java没有提供给我们的类型安全。</p>

<p>还是刚才的那段代码：</p>

<p><code>scala
  val twoCars: Pair[Car] = new Pair(new Car(), new Car())
  val tankAndCar: Pair[Vehicle] = twoCars.replaceFirst(new Tank())
</code></p>

<p>其中的第二行，Scala可以很聪明的推断出replaceFirst的返回值类型是Pair[Vehicle]。实际上，如果我们试图把tankAndCar声明为Pair[Tank]的话，会看到编译时错误。</p>

<p>而类似的代码在Java里则没有这么幸运了：</p>

<p>```java
public class PairJ<T> {</p>

<pre><code>private T first;
private T second;

public PairJ(T first, T second) {
    this.first = first;
    this.second = second;
}

public T first() {
    return this.first;
}

public T second() {
    return this.second;
}

public &lt;R&gt; Pair&lt;R&gt; replaceFirst(R newFirst) {
    return new Pair(newFirst, second());
}
</code></pre>

<p>}
```</p>

<p>为了标明区别，我们这次称之为PairJ。到这里忍不住要小小的黑Java一下，21行代码，和Scala的3行是等价的：）</p>

<p>我们重点看一下replaceFirst在这里的声明，其中声明了一个泛型参数R，但是R和T是没有任何关系的。实际上，在Java中，我们无法表达方法的泛型参数和类型的泛型参数之间的关系。（其原因请参看<a href="http://www.angelikalanger.com/GenericsFAQ/FAQSections/TypeParameters.html#FAQ107">这里</a>）</p>

<p>我们写出如下的代码：</p>

<p>```java</p>

<pre><code>    PairJ&lt;Car&gt; twoCars = new PairJ(new Car(), new Car());
    Tank actuallyACar = twoCars.replaceFirst(new Tank()).second();
</code></pre>

<p>```</p>

<p>先创建两辆车的Pair，然后把第一辆车替换成坦克。再把新组成的Pair里面的第二个元素（其类型是车）取出来，赋值给一个类型为坦克的变量。</p>

<p>如果我们编译这段代码，Java编译器会允许其通过。但是运行起来就会跑出类型转换异常。原因很明显，Car不能转换成Tank。</p>

<p>这个，就是刚才所说的类型安全性上的差异。</p>

<h3>等等，脱衣服的部分呢？</h3>

<p>之前的每一篇博客都会把Scala代码编译出的bytecode反编译成Java，来探索其语言特性是如何实现的。</p>

<p>而这一次颇为不同。之前的语言特性虽说Scala写起来比Java会简便一些，但是还没有超出Java的能力范围。多费点劲，用Java还是能做到。</p>

<p>而这一次，这种编译时类型安全检验的严格性，实在是在Java中无法表达的。这全靠了Scala编译器的功劳。</p>

<p>这就意味着，上面所定义的Pair这个类，如果你在Java中使用它，就会失去这种类型安全性。</p>

<p>Scala，这次算你牛，没扒掉你。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Desugar Scala(15) -- unapply和unapplySeq方法]]></title>
    <link href="http://cuipengfei.github.com/blog/2014/06/14/scala-unapply-method/"/>
    <updated>2014-06-14T14:46:00+05:30</updated>
    <id>http://cuipengfei.github.com/blog/2014/06/14/scala-unapply-method</id>
    <content type="html"><![CDATA[<p>实在想不到什么动词可以当做脱衣服来讲了，所以从现在开始这系列博文就叫做Desugar Scala了。除非哪天才思泉涌，又想到了新词：）</p>

<p>开始正文。</p>

<p>名字叫做unapply和unapplySeq的方法在Scala里也是有特殊含义的。</p>

<p>我们前面说过case class在做pattern match时很好用，而除case class之外，有unapply或unapplySeq方法的对象在pattern match时也有很好的应用场景。</p>

<p>比如这段代码：</p>

<p><code>scala
object Square {
  def unapply(z: Double): Option[Double] = Some(math.sqrt(z))
}
</code></p>

<p>我们定义了一个unapply方法，用来计算平方根。
我们可以像调用普通方法一样的调用它：</p>

<p><code>scala
val number: Double = 36.0
Square.unapply(number)
</code></p>

<p>这样会得到36的平方根:6。实际上返回值是Some(6)。</p>

<p>上面的方式是对unapply的浪费，unapply真正的好处是这样的：</p>

<p>```scala
val number: Double = 36.0
number match {</p>

<pre><code>case Square(n) =&gt; println(s"square root of $number is $n")
case _ =&gt; println("nothing matched")
</code></pre>

<p>}
```</p>

<p>这样我们无需显式调用unapply方法，而把是它用在pattern match中，让编译器替我们调用它。</p>

<p>当我们写下这段pattern match的代码时，编译器其实替我们做了好几件事：</p>

<ol>
<li>调用unapply，传入number</li>
<li>接收返回值并判断返回值是None，还是Some</li>
<li>如果是Some，则将其解开，并将其中的值赋值给n（就是case Square(n)中的n）</li>
</ol>


<p>这段代码反编译出来是这个样子的：</p>

<p>```java</p>

<pre><code>  double number = 36.0D;
  double d1 = number;
  Option localOption = Square..MODULE$.unapply(d1);
  //调用unapply，传入number
  BoxedUnit localBoxedUnit;
  if (localOption.isEmpty()) {//判断返回值是None
    Predef..MODULE$.println("nothing matched");
    localBoxedUnit = BoxedUnit.UNIT;
  }
  else {//判断返回值是Some
    double n = BoxesRunTime.unboxToDouble(localOption.get());
    //将Some解开，并将其中的值赋值给n
    Predef..MODULE$.println(new StringContext(Predef..MODULE$.wrapRefArray((Object[]) new String[] {
      "square root of ", " is ", ""
    }) ).s(Predef..MODULE$.genericWrapArray(new Object[] {
      BoxesRunTime.boxToDouble(number), BoxesRunTime.boxToDouble(n)
    })));
    localBoxedUnit = BoxedUnit.UNIT;
  }
</code></pre>

<p>```</p>

<p>如果没有unapply方法和pattern match语法之间的这种结合，我们自己写代码要写成什么样子呢？</p>

<p>或许会比上面反编译的代码简单一些，但是显式地调用开平方的方法，用if else来判断Option，以及将真正的返回值从Option里面解出来这三件事是免不掉的。</p>

<p>unapplySeq和unapply的作用很是类似，例如这样：</p>

<p>```scala
object Names {
  def unapplySeq(str: String): Option[Seq[String]] = {</p>

<pre><code>if (str.contains(",")) Some(str.split(","))
else None
</code></pre>

<p>  }
}
```</p>

<p>我们定义一个unapplySeq方法，用逗号作为分隔符来把字符串拆开。</p>

<p>然后我们可以这样应用它：</p>

<p>```scala
val namesString = "xiao ming,xiao hong,tom"
namesString match {
  case Names(first, second, third) => {</p>

<pre><code>println("the string contains three people's names")
println(s"$first $second $third")
</code></pre>

<p>  }
  case _ => println("nothing matched")
}
```</p>

<p>与上面的例子很是类似，不过编译器在这里替我们做的事情更多了：</p>

<ol>
<li>调用unapplySeq，传入namesString</li>
<li>接收返回值并判断返回值是None，还是Some</li>
<li>如果是Some，则将其解开</li>
<li>判断解开之后得到的sequence中的元素的个数是否是三个</li>
<li>如果是三个，则把三个元素分别取出，赋值给first，second和third</li>
</ol>


<p>如果没有unapplySeq方法和pattern match语法之间的这种结合，我们自己写代码来做这五件事会显得很是繁琐。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[抹掉Scala的糖衣(14) -- update method]]></title>
    <link href="http://cuipengfei.github.com/blog/2014/06/12/scala-update-method/"/>
    <updated>2014-06-12T18:42:00+05:30</updated>
    <id>http://cuipengfei.github.com/blog/2014/06/12/scala-update-method</id>
    <content type="html"><![CDATA[<p>在Scala中，名字叫做update的方法是有特殊作用的。</p>

<p>比如：</p>

<p><code>scala
val scores = new scala.collection.mutable.HashMap[String, Int]
scores("Bob") = 100
val bobsScore = scores("Bob")
</code></p>

<p>以上三行代码，我们创建了一个可变的map来存储得分情况，然后我们记录了Bob的得分是100分，最后我们又把Bob的分数取出来了。</p>

<p>这三行代码看似平淡无奇，实则暗藏了一点点玄机。</p>

<p>第二行实际是调用了HashMap的update方法。</p>

<p>第三行实际是调用了HashMap的apply方法。</p>

<p>我们可以把上面的代码改写成下面的等价形式：</p>

<p><code>scala
val scores = new scala.collection.mutable.HashMap[String, Int]
scores.update("Bob", 100)
val bobsScore = scores.apply("Bob”)
</code></p>

<p>虽然等价，但是可读性却降低了一些。</p>

<p>apply方法我们之前讲过，就不再赘述。</p>

<p>update方法也不太复杂，它的规则就是：</p>

<p><code>scala
x(y) = z
</code></p>

<p>这样的代码会被编译为：</p>

<p><code>scala
x.update(y, z)
</code></p>

<p>这次博文名字虽然以抹掉糖衣开头，实则有点名不符实，因为这个语言特性过于简单，糖衣很薄，一抹就透。</p>

<p>这次的目的主要是介绍一个update方法的适用场景。</p>

<p>我们来看用来修改某个人地址的一段代码：</p>

<p>```scala
class AddressChanger {</p>

<p>  def update(name: String, age: Int, newAddress: String) = {</p>

<pre><code>println(s"changing address of $name, whose age is $age to $newAddress")
//actually change the address
</code></pre>

<p>  }</p>

<p>}
```</p>

<p>我们可以这样来调用它：</p>

<p><code>scala
val changer = new AddressChanger()
changer.update("xiao ming", 23, "beijing")
</code></p>

<p>或者，我们也可以这样来调用它：</p>

<p><code>scala
val addressOf = new AddressChanger()
addressOf(name = "xiao ming", age = 23) = "beijing"
</code></p>

<p>这两段代码是等价的。</p>

<p>比较一下，前一种用法显得中规中矩，没什么特别好的，也没啥特大的毛病。</p>

<p>可是后一种用法就不同了，读起来很通顺，有读英语语句的感觉：把名字叫做小明，年龄23岁的人的地址改为北京。</p>

<p>如果再给AddressChanger加上一个apply方法，我们还可以写这样的代码：</p>

<p><code>scala
val currentAddress = addressOf(name = "xiao ming", age = 23)
</code></p>

<p>这样，读取和更新的代码都看起来非常自然。</p>

<p>如果我们把这两段代码连起来看：</p>

<p><code>scala
val currentAddress = addressOf(name = "xiao ming", age = 23)
addressOf(name = "xiao ming", age = 23) = "beijing"
</code></p>

<p>感觉甚好。</p>

<p>addressOf(name = "xiao ming", age = 23)可以看做一个整体，它就如同一个可读可写的属性。</p>

<p>我们把它放到赋值语句的右侧，就能取到小明的当前住址。</p>

<p>我们把它放到赋值语句的左侧，就能修改小明的住址。</p>

<p>apply和update都是蛮简单的语言特性，但是加以合适的应用，却能得到可读性极强的代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[除去Scala的糖衣(13) -- default parameter value]]></title>
    <link href="http://cuipengfei.github.com/blog/2014/06/09/desugar-scala-default-parameter-value/"/>
    <updated>2014-06-09T21:34:00+05:30</updated>
    <id>http://cuipengfei.github.com/blog/2014/06/09/desugar-scala-default-parameter-value</id>
    <content type="html"><![CDATA[<p>好久没有写博客了，上一次更新竟然是一月份。</p>

<p>说工作忙都是借口，咋有空看美剧呢。</p>

<p>这半年荒废掉博客说到底就是懒，惯性的懒惰。写博客这事儿，一丢掉就很久捡不起来。</p>

<p>闲话到此为止，下面进入正题。</p>

<p>Default parameter value，默认参数值。
这个很容易理解，给参数一个默认值，如果调用者不显式指明参数值，则使用默认值。如果显式指明了，那就用显式指明的值。</p>

<p>举个例子：</p>

<p><code>scala
def hello(name: String = "world") = println("hello " + name)
</code></p>

<p>这个函数，如果我们不给它传参数，它就会打印hello world。就像这样：</p>

<p><code>scala
hello()
</code></p>

<p>如果给了参数：</p>

<p><code>scala
hello("everybody")
</code></p>

<p>则打印hello everybody。</p>

<p>这个语言特性都有哪些应用场景呢？</p>

<p>它经常用来避免过多的重载。一个很常见很典型的例子就是构造函数重载。</p>

<p>在Java中，为了让调用者能够比较容易的创建某个类的实例，我们通常会提供几个参数列表比较短的构造函数。而这些构造函数存在的唯一意义就是为了写死某几个参数值。而在Scala中，有了这个语言特性，我们就无需那么麻烦了。</p>

<p>那这个语言特性是如何实现的呢？实际上简单的一塌糊涂。</p>

<p>这样一段代码：</p>

<p>```scala
class Greeter {
  def hello(name: String = "world") = println("hello " + name)
}</p>

<p>class AnotherClass {
  new Greeter().hello()
}
```</p>

<p>我们的Greeter类含有前面提到过的hello方法。在AnotherClass里调用了hello，并且没有显式指明参数值。</p>

<p>上面的Scala代码生成的bytecode反编译成Java是这样的：</p>

<p>```java
public class Greeter {</p>

<pre><code>public void hello(String name) {
    Predef..MODULE$.println(new StringBuilder().append("hello ").append(name).toString());
}

public String hello$default$1() {
    return "world";
}
</code></pre>

<p>}</p>

<p>public class AnotherClass {</p>

<pre><code>public AnotherClass() {
    Greeter qual$1 = new Greeter();
    String x$1 = qual$1.hello$default$1();
    qual$1.hello(x$1);
}
</code></pre>

<p>}
```</p>

<p>可以看到，我们所定义的hello方法反编译出来看起来很普通，就是个接受一个参数的方法。</p>

<p>而在Greeter类中，编译器为我们加入了另一个方法hello$default$1，这个方法就是返回一个写死的字符串，其值为world。</p>

<p>在AnotherClass中调用hello时，写死的字符串被取到，然后传进了hello里。</p>

<p>这样，被调用者提供了参数的默认值，调用者在调用时取得该值，然后传入方法。</p>

<h3>题外话</h3>

<p>到这里我不禁联想起C#中的默认参数值的实现方式。</p>

<p>在C#中，默认参数的值会被编译成调用者的一个常量，而不是像Scala一样的由被调用者提供。</p>

<p>这样看起来貌似没啥区别，不就是写死的值换个地方吗？</p>

<p>其实不然，如果被调用者在A程序集内，调用者在B程序集内，那么A更新时，B就必须重新编译才能得到最新的默认值。也就是说，如果当前部署环境中同时存在A和B，而后我们拿一个新版的A来替换老的，这时B仍然在传递老的默认参数值给A。这样就会造成一些看似很诡异的行为偏差。</p>

<p>如果对C#的默认参数值的实现有兴趣，请看<a href="http://www.cnblogs.com/cuipengfei/archive/2011/04/13/2014325.html">我很久很久之前写的博客</a></p>

<p>现在想来，C#这一语言特性的设计者为什么要把它设计成如此容易出错的样子呢？</p>

<p>思而不得其解。</p>
]]></content>
  </entry>
  
</feed>

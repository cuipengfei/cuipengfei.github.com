<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"cuipengfei.me","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12,"onmobile":false},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":null,"show_result":true},"fold":{"enable":false,"height":500},"language":false,"highlight_theme":"galactic"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="当泛型遇上现实：从表象到本质的技术思考最近在优化一个序列化框架时，遇到了一些类型安全方面的意外行为。这让我重新审视了JVM泛型系统的底层机制。虽然类型擦除是个老话题，但当我深入分析Kotlin的reified实现时，发现了一些值得思考的细节。 一个简单现象引发的思考我们都知道Java的类型擦除，但最近在排查问题时，我又重新观察了这个现象： 12345List&lt;String&gt; strin">
<meta property="og:type" content="article">
<meta property="og:title" content="当泛型遇上现实：从表象到本质的技术思考">
<meta property="og:url" content="https://cuipengfei.me/blog/2025/09/14/generic-type-erasure-deep-dive/index.html">
<meta property="og:site_name" content="崔鹏飞的Blog">
<meta property="og:description" content="当泛型遇上现实：从表象到本质的技术思考最近在优化一个序列化框架时，遇到了一些类型安全方面的意外行为。这让我重新审视了JVM泛型系统的底层机制。虽然类型擦除是个老话题，但当我深入分析Kotlin的reified实现时，发现了一些值得思考的细节。 一个简单现象引发的思考我们都知道Java的类型擦除，但最近在排查问题时，我又重新观察了这个现象： 12345List&lt;String&gt; strin">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-09-14T12:30:00.000Z">
<meta property="article:modified_time" content="2025-09-14T12:30:00.000Z">
<meta property="article:author" content="崔鹏飞">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Kotlin">
<meta property="article:tag" content="反射">
<meta property="article:tag" content="泛型">
<meta property="article:tag" content="类型擦除">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://cuipengfei.me/blog/2025/09/14/generic-type-erasure-deep-dive/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://cuipengfei.me/blog/2025/09/14/generic-type-erasure-deep-dive/","path":"blog/2025/09/14/generic-type-erasure-deep-dive/","title":"当泛型遇上现实：从表象到本质的技术思考"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>当泛型遇上现实：从表象到本质的技术思考 | 崔鹏飞的Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-46270419-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-46270419-1","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js" defer></script>








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/pjax.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"options":null,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>



  <script src="/js/third-party/pace.js" defer></script>


  




<script data-ad-client="ca-pub-2529393324217872" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2529393324217872"></script>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="崔鹏飞的Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">崔鹏飞的Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="sitemap fa-fw"></i>站点地图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BD%93%E6%B3%9B%E5%9E%8B%E9%81%87%E4%B8%8A%E7%8E%B0%E5%AE%9E%EF%BC%9A%E4%BB%8E%E8%A1%A8%E8%B1%A1%E5%88%B0%E6%9C%AC%E8%B4%A8%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%9D%E8%80%83"><span class="nav-number">1.</span> <span class="nav-text">当泛型遇上现实：从表象到本质的技术思考</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%8E%B0%E8%B1%A1%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83"><span class="nav-number">1.1.</span> <span class="nav-text">一个简单现象引发的思考</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%8F%AD%E7%A4%BA%E7%9A%84%E7%9C%9F%E7%9B%B8"><span class="nav-number">1.2.</span> <span class="nav-text">反射揭示的真相</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84API%E7%9A%84%E8%83%BD%E5%8A%9B%E8%BE%B9%E7%95%8C"><span class="nav-number">1.3.</span> <span class="nav-text">反射API的能力边界</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kotlin-reified%E7%9A%84%E5%B7%A7%E6%80%9D"><span class="nav-number">1.4.</span> <span class="nav-text">Kotlin reified的巧思</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">1.4.1.</span> <span class="nav-text">Java编译器的处理方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kotlin%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">1.4.2.</span> <span class="nav-text">Kotlin编译器的处理方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%8D%8F%E4%BD%9C%E7%9A%84%E7%B2%BE%E5%A6%99%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.5.</span> <span class="nav-text">编译器协作的精妙设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E2%80%9C%E4%B8%80%E4%BD%93%E4%B8%A4%E9%9D%A2%E2%80%9D%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.5.1.</span> <span class="nav-text">1. “一体两面”的架构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%9B%9B%E5%B1%82%E5%8D%8F%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="nav-number">1.5.2.</span> <span class="nav-text">2. 四层协作机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%BC%96%E8%AF%91%E5%99%A8%E5%8D%8F%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.5.3.</span> <span class="nav-text">3. 编译器协作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%86%85%E8%81%94%E7%B1%BB%E7%94%9F%E6%88%90%E7%9A%84%E5%AE%9E%E9%99%85%E8%AF%81%E6%8D%AE"><span class="nav-number">1.5.4.</span> <span class="nav-text">4. 内联类生成的实际证据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E7%90%86%E8%A7%A3%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="nav-number">1.6.</span> <span class="nav-text">重新理解类型系统的层次</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Signature%E5%B1%9E%E6%80%A7%EF%BC%9A%E5%AE%8C%E6%95%B4%E6%B3%9B%E5%9E%8B%E4%BF%A1%E6%81%AF%E7%9A%84%E4%BF%9D%E7%95%99"><span class="nav-number">1.6.1.</span> <span class="nav-text">Signature属性：完整泛型信息的保留</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LocalVariableTypeTable%EF%BC%9A%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BF%BD%E8%B8%AA"><span class="nav-number">1.6.2.</span> <span class="nav-text">LocalVariableTypeTable：调试信息中的类型追踪</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%9D%83%E8%A1%A1%E7%9A%84%E6%80%9D%E8%80%83"><span class="nav-number">1.6.3.</span> <span class="nav-text">设计权衡的思考</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="崔鹏飞"
      src="/images/favicon-32x32-next.png">
  <p class="site-author-name" itemprop="name">崔鹏飞</p>
  <div class="site-description" itemprop="description">专注分布式系统、函数式编程、测试与架构实践的技术博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">182</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">90</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/cuipengfei" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cuipengfei" rel="noopener me" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/290284/" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;290284&#x2F;" rel="noopener me" target="_blank"><i class="stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="rss fa-fw"></i>RSS</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
        <div class="pjax">
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cuipengfei.me/blog/2025/09/14/generic-type-erasure-deep-dive/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon-32x32-next.png">
      <meta itemprop="name" content="崔鹏飞">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔鹏飞的Blog">
      <meta itemprop="description" content="专注分布式系统、函数式编程、测试与架构实践的技术博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="当泛型遇上现实：从表象到本质的技术思考 | 崔鹏飞的Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          当泛型遇上现实：从表象到本质的技术思考
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-14 20:30:00" itemprop="dateCreated datePublished" datetime="2025-09-14T20:30:00+08:00">2025-09-14</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2025/09/14/generic-type-erasure-deep-dive/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="blog/2025/09/14/generic-type-erasure-deep-dive/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="当泛型遇上现实：从表象到本质的技术思考"><a href="#当泛型遇上现实：从表象到本质的技术思考" class="headerlink" title="当泛型遇上现实：从表象到本质的技术思考"></a>当泛型遇上现实：从表象到本质的技术思考</h1><p>最近在优化一个序列化框架时，遇到了一些类型安全方面的意外行为。这让我重新审视了JVM泛型系统的底层机制。虽然类型擦除是个老话题，但当我深入分析Kotlin的reified实现时，发现了一些值得思考的细节。</p>
<h2 id="一个简单现象引发的思考"><a href="#一个简单现象引发的思考" class="headerlink" title="一个简单现象引发的思考"></a>一个简单现象引发的思考</h2><p>我们都知道Java的类型擦除，但最近在排查问题时，我又重新观察了这个现象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; intList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在运行时，它们的Class信息完全相同</span></span><br><span class="line">System.out.println(stringList.getClass() == intList.getClass()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这是类型擦除的基本表现：编译器将泛型参数替换为边界类型。不过这让我想到一个问题：既然编译器会进行严格的泛型类型检查，那反射是如何绕过这些检查机制的？</p>
<h2 id="反射揭示的真相"><a href="#反射揭示的真相" class="headerlink" title="反射揭示的真相"></a>反射揭示的真相</h2><p>为了理解这个机制，我做了个实验：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射调用add方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> List.class.getMethod(<span class="string">&quot;add&quot;</span>, Object.class); <span class="comment">// 注意参数是Object</span></span><br><span class="line">add.invoke(list, <span class="number">42</span>); <span class="comment">// 成功添加Integer到String List</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历时才会出错</span></span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123; <span class="comment">// 这里会ClassCastException</span></span><br><span class="line">    System.out.println(<span class="string">&quot;String: &quot;</span> + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个结果其实很有启发性。关键在于<code>getMethod(&quot;add&quot;, Object.class)</code>——我们必须用<code>Object.class</code>，因为编译后的方法签名就是<code>add(Object obj)</code>。</p>
<p>通过字节码分析可以看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// List.add方法的实际签名</span><br><span class="line">11: invokeinterface #12,  2           // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span><br><span class="line"></span><br><span class="line">// 遍历时的类型转换</span><br><span class="line">138: invokeinterface #87,  1           // InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;</span><br><span class="line">143: checkcast     #62                 // class java/lang/String</span><br></pre></td></tr></table></figure>

<p>类型擦除的巧妙之处在于：编译器在需要类型转换的地方插入<code>checkcast</code>指令，将类型检查推迟到实际使用时。反射之所以能绕过编译期检查，是因为它直接操作字节码层面，而JVM运行时只验证原始类型，不验证泛型参数。</p>
<p>但这又让我思考另一个问题：如果反射能绕过类型检查，为什么反射API还能获取到一些泛型信息呢？</p>
<h2 id="反射API的能力边界"><a href="#反射API的能力边界" class="headerlink" title="反射API的能力边界"></a>反射API的能力边界</h2><p>为了深入理解类型擦除的补偿机制，我创建了一个具体的泛型类来测试反射API能获取哪些泛型信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个简单的泛型类，用于测试反射能力</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericClassDemo</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; items = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addItem</span><span class="params">(T item)</span> &#123;</span><br><span class="line">        items.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">getItems</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">processWithGenericMethod</span><span class="params">(E element, List&lt;? <span class="built_in">super</span> E&gt; sink)</span> &#123;</span><br><span class="line">        sink.add(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在让我们测试反射API在这个类上的表现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line">Class&lt;GenericClassDemo&gt; clazz = GenericClassDemo.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类级别的类型参数 - 可以获取！</span></span><br><span class="line">TypeVariable&lt;?&gt;[] typeParameters = clazz.getTypeParameters();</span><br><span class="line"><span class="keyword">for</span> (TypeVariable&lt;?&gt; typeParam : typeParameters) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Type Parameter: &quot;</span> + typeParam.getName());</span><br><span class="line">    Type[] bounds = typeParam.getBounds();</span><br><span class="line">    <span class="keyword">for</span> (Type bound : bounds) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;  Bound: &quot;</span> + bound.getTypeName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：Type Parameter: T</span></span><br><span class="line"><span class="comment">//       Bound: java.lang.Number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字段的泛型信息 - 可以获取！</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">itemsField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;items&quot;</span>);</span><br><span class="line"><span class="type">Type</span> <span class="variable">fieldType</span> <span class="operator">=</span> itemsField.getGenericType();</span><br><span class="line">System.out.println(<span class="string">&quot;Field type: &quot;</span> + fieldType);</span><br><span class="line"><span class="comment">// 输出：Field type: java.util.List&lt;T&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法的泛型信息 - 可以获取！</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">addMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;addItem&quot;</span>, Number.class);</span><br><span class="line">Type[] paramTypes = addMethod.getGenericParameterTypes();</span><br><span class="line">System.out.println(<span class="string">&quot;addItem parameter type: &quot;</span> + paramTypes[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 输出：addItem parameter type: T</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型方法的参数信息 - 也可以获取！</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">genericMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;processWithGenericMethod&quot;</span>, Object.class, List.class);</span><br><span class="line">Type[] genericParamTypes = genericMethod.getGenericParameterTypes();</span><br><span class="line">System.out.println(<span class="string">&quot;processWithGenericMethod parameter types: &quot;</span> + Arrays.toString(genericParamTypes));</span><br><span class="line"><span class="comment">// 输出：processWithGenericMethod parameter types: [E, java.util.List&lt;? super E&gt;]</span></span><br></pre></td></tr></table></figure>

<p>但是有一个关键的限制——当我们创建具体的实例时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GenericClassDemo&lt;Integer&gt; instance = <span class="keyword">new</span> <span class="title class_">GenericClassDemo</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 运行时实例的具体类型参数 - 无法获取！</span></span><br><span class="line">System.out.println(<span class="string">&quot;Instance class: &quot;</span> + instance.getClass());</span><br><span class="line">System.out.println(<span class="string">&quot;Instance type parameter: Cannot retrieve (type erasure)&quot;</span>);</span><br><span class="line"><span class="comment">// 输出：Instance class: class com.example.GenericClassDemo</span></span><br><span class="line"><span class="comment">//       Instance type parameter: Cannot retrieve (type erasure)</span></span><br></pre></td></tr></table></figure>

<p>这个对比很有启发性：<strong>泛型声明信息可以通过Signature属性保留</strong>，但<strong>运行时实例的具体类型参数确实被擦除</strong>。反射API的能力边界恰好体现了类型擦除的精确范围。</p>
<p>在字节码层面，编译器会保存完整的泛型签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// GenericClassDemo类的签名</span><br><span class="line">Signature: #25  // &lt;T:Ljava/lang/Number;&gt;Ljava/lang/Object;</span><br><span class="line"></span><br><span class="line">// addItem方法的签名</span><br><span class="line">Signature: #18  // (TT;)V</span><br></pre></td></tr></table></figure>
<p>这就是为什么反射API能获取泛型信息——信息并未完全消失，而是以另一种形式保留在字节码中。</p>
<p>这里需要澄清一个重要概念：<strong>类型擦除</strong> ≠ <strong>类型信息完全消失</strong>。更准确地说，类型擦除是一个分层的过程——编译期的泛型类型检查被移除，但通过Signature属性等机制，足够的信息仍被保留以支持反射API。反射绕过类型检查的根本原因不是”信息丢失”，而是它<strong>直接操作字节码层面</strong>，跳过了编译器设置的类型安全护栏。</p>
<p>不过这又让我想到另一个问题：既然JVM在类型擦除后只保留原始类型信息，Kotlin的reified是怎么做到的？</p>
<h2 id="Kotlin-reified的巧思"><a href="#Kotlin-reified的巧思" class="headerlink" title="Kotlin reified的巧思"></a>Kotlin reified的巧思</h2><p>在使用Jackson的Kotlin扩展时，我注意到这样的API：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mapper = jacksonObjectMapper()</span><br><span class="line"><span class="keyword">val</span> person: Person = mapper.readValue&lt;Person&gt;(json) <span class="comment">// 看起来保留了类型信息</span></span><br></pre></td></tr></table></figure>

<p>这看起来超越了JVM类型擦除的限制。为了理解这个机制，我对比了普通泛型函数和reified函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通泛型函数 - 无法检查类型</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">checkNormal</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// return obj is T  // 编译错误！类型T被擦除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reified函数 - 可以检查类型</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">checkReified</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj <span class="keyword">is</span> T  <span class="comment">// 编译通过且工作正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>reified的关键在于<code>inline</code>修饰符。当我们调用<code>checkReified&lt;String&gt;(&quot;hello&quot;)</code>时，<strong>Kotlin编译器</strong>会将函数体内联到调用点，并将类型参数<code>T</code>替换为具体的<code>String</code>。</p>
<p>这样，原本的<code>obj is T</code>在字节码中就变成了<code>obj is String</code>的直接类型检查。这里体现了<strong>Java编译器和Kotlin编译器的根本差异</strong>：</p>
<h3 id="Java编译器的处理方式"><a href="#Java编译器的处理方式" class="headerlink" title="Java编译器的处理方式"></a>Java编译器的处理方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java泛型方法</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj <span class="keyword">instanceof</span> T;  <span class="comment">// 编译错误！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java编译器<strong>直接拒绝编译</strong>这种写法，实际的错误信息为：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TestInstanceof.java:<span class="number">3</span>: error: Object cannot be safely cast <span class="keyword">to</span> T</span><br><span class="line">        return obj instanceof T<span class="punctuation">;</span></span><br><span class="line">               ^</span><br><span class="line">  <span class="keyword">where</span> T <span class="keyword">is</span> a <span class="keyword">type</span>-variable:</span><br><span class="line">    T extends Object declared <span class="keyword">in</span> <span class="keyword">method</span> &lt;<span class="title function_">T</span>&gt;<span class="title function_">check</span><span class="params">(Object)</span></span><br><span class="line">1 <span class="title function_">error</span></span><br></pre></td></tr></table></figure>

<p>这是因为类型擦除后，编译器无法在运行时获取<code>T</code>的具体类型信息。Java设计者选择了在编译期就阻止这种潜在错误的做法。</p>
<h3 id="Kotlin编译器的处理方式"><a href="#Kotlin编译器的处理方式" class="headerlink" title="Kotlin编译器的处理方式"></a>Kotlin编译器的处理方式</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">checkReified</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj <span class="keyword">is</span> T  <span class="comment">// 编译通过！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kotlin编译器通过<strong>内联展开</strong>在编译时解决了这个问题：</p>
<p>我们可以通过字节码验证这一点。当调用<code>checkReified&lt;String&gt;(&quot;hello&quot;)</code>时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Kotlin内联展开后的实际字节码指令</span><br><span class="line">60: ldc           #87                 // class java/lang/String</span><br><span class="line">...</span><br><span class="line">134: instanceof    #87                 // class java/lang/String</span><br></pre></td></tr></table></figure>
<p>注意第134行的<code>instanceof #87</code>指令——<strong>Kotlin编译器直接引用具体的<code>java/lang/String</code>类</strong>，而不是擦除后的<code>Object</code>。这证明了编译器确实将类型参数<code>T</code>替换为了具体的<code>String</code>类型。</p>
<p>但这又引出了一个新的疑问：第三方库的reified函数是如何跨JAR边界工作的？</p>
<h2 id="编译器协作的精妙设计"><a href="#编译器协作的精妙设计" class="headerlink" title="编译器协作的精妙设计"></a>编译器协作的精妙设计</h2><p>Jackson Kotlin模块提供的reified函数让我很好奇——如果reified依赖于内联展开，那么如何跨JAR包边界工作？</p>
<p>这里需要理解”编译单元”的概念：<strong>编译单元是指一次编译操作处理的代码范围</strong>。比如Jackson Kotlin模块是一个独立的JAR包（一个编译单元），而我们的应用代码是另一个编译单元。当我们在应用代码中调用Jackson的<code>readValue&lt;Person&gt;(json)</code>时，就是在跨编译单元使用reified函数。</p>
<p>深入分析后发现，<strong>Kotlin编译器</strong>为第三方库reified函数设计了一个巧妙的<strong>四层协作机制</strong>：</p>
<h3 id="1-“一体两面”的架构设计"><a href="#1-“一体两面”的架构设计" class="headerlink" title="1. “一体两面”的架构设计"></a>1. “一体两面”的架构设计</h3><p>第三方库中的inline reified函数在编译后会产生两个不同的组件：</p>
<p><strong>方法存根（Method Stub）</strong>：为Java调用者准备的后备方案</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字节码中实际存在的方法存根（Java方法签名）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> synthetic Object <span class="title function_">readValue</span><span class="params">(ObjectMapper, String)</span>;</span><br><span class="line"><span class="comment">// 调用时会立即抛出异常，提示需要内联</span></span><br></pre></td></tr></table></figure>

<p><strong>元数据函数体（Inlinable Body）</strong>：存储在<code>@kotlin.Metadata</code>中的完整逻辑</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储在元数据中的实际实现</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> ObjectMapper.<span class="title">readValue</span><span class="params">(content: <span class="type">String</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> readValue(content, T::<span class="keyword">class</span>.java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-四层协作机制"><a href="#2-四层协作机制" class="headerlink" title="2. 四层协作机制"></a>2. 四层协作机制</h3><p><strong>@Metadata注解</strong>：存储Kotlin特有信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java注解语法（在字节码中的表现）</span></span><br><span class="line"><span class="meta">@kotlin</span>.Metadata(</span><br><span class="line">  mv = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>&#125;,    <span class="comment">// Kotlin版本信息</span></span><br><span class="line">  bv = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>&#125;,    <span class="comment">// 二进制版本</span></span><br><span class="line">  k = <span class="number">2</span>,             <span class="comment">// 文件类型</span></span><br><span class="line">  <span class="comment">// 包含完整的内联函数体序列化数据</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>ACC_SYNTHETIC标记</strong>：标记编译器生成的特殊方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static final synthetic boolean needClassReification();</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL, ACC_SYNTHETIC</span><br></pre></td></tr></table></figure>

<p><strong>needClassReification()函数</strong>：编译器识别标记</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于标记需要类型具体化的函数</span></span><br><span class="line"><span class="meta">@PublishedApi</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">needClassReification</span><span class="params">()</span></span>: <span class="built_in">Nothing</span> =</span><br><span class="line">    <span class="keyword">throw</span> UnsupportedOperationException(<span class="string">&quot;Function with reified type parameter&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>reifiedOperationMarker()占位符</strong>：编译时替换点</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器占位符，运行时永不执行</span></span><br><span class="line"><span class="meta">@PublishedApi</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">reifiedOperationMarker</span><span class="params">()</span></span>: <span class="built_in">Nothing</span> =</span><br><span class="line">    <span class="keyword">throw</span> UnsupportedOperationException(<span class="string">&quot;This function should be called only during compilation&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-编译器协作流程"><a href="#3-编译器协作流程" class="headerlink" title="3. 编译器协作流程"></a>3. 编译器协作流程</h3><p>当我们调用<code>mapper.readValue&lt;Person&gt;(json)</code>时：</p>
<ol>
<li><strong>库扫描</strong>：Kotlin编译器发现<code>@kotlin.Metadata</code>注解</li>
<li><strong>方法分析</strong>：识别<code>ACC_SYNTHETIC</code>标记和特殊函数</li>
<li><strong>内联展开</strong>：从元数据中读取完整函数体</li>
<li><strong>类型替换</strong>：将<code>T::class.java</code>替换为<code>Person::class.java</code></li>
<li><strong>代码生成</strong>：生成最终调用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最终生成的Java字节码调用</span></span><br><span class="line">readValue(content, Person.class)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这个机制的精妙之处在于：完全使用JVM标准特性，无需定制JVM，但为Kotlin编译器提供了执行内联和类型具体化所需的所有信息。</p>
<h3 id="4-内联类生成的实际证据"><a href="#4-内联类生成的实际证据" class="headerlink" title="4. 内联类生成的实际证据"></a>4. 内联类生成的实际证据</h3><p>当我们实际编译调用第三方reified函数的代码时，可以观察到编译器确实生成了具体的TypeReference类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 为 Person 类型生成的内联类</span><br><span class="line">public final class com.example.ThirdPartyReifiedTestKt$testJacksonReifiedFunctions$$inlined$readValue$1</span><br><span class="line">extends com.fasterxml.jackson.core.type.TypeReference&lt;com.example.Person&gt;</span><br><span class="line"></span><br><span class="line">// 完整的泛型签名保留</span><br><span class="line">Signature: #3  // Lcom/fasterxml/jackson/core/type/TypeReference&lt;Lcom/example/Person;&gt;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 为 List&lt;Person&gt; 类型生成的内联类</span><br><span class="line">public final class com.example.ThirdPartyReifiedTestKt$testJacksonReifiedFunctions$$inlined$readValue$3</span><br><span class="line">extends com.fasterxml.jackson.core.type.TypeReference&lt;java.util.List&lt;? extends com.example.Person&gt;&gt;</span><br><span class="line"></span><br><span class="line">// 复杂泛型签名的完整保留</span><br><span class="line">Signature: #3  // Lcom/fasterxml/jackson/core/type/TypeReference&lt;Ljava/util/List&lt;+Lcom/example/Person;&gt;;&gt;;</span><br></pre></td></tr></table></figure>

<p>这些编译器生成的类名揭示了内联展开的命名规律：</p>
<ul>
<li><code>$$inlined$readValue$1</code>：表示第一个内联的readValue调用</li>
<li><code>$$inlined$readValue$3</code>：表示第三个内联的readValue调用，每个类型参数对应一个独立的TypeReference类</li>
</ul>
<h2 id="重新理解类型系统的层次"><a href="#重新理解类型系统的层次" class="headerlink" title="重新理解类型系统的层次"></a>重新理解类型系统的层次</h2><p>经过这一轮分析，我对JVM泛型系统有了更清晰的认识。类型擦除不是简单的”删除”，而是多层次类型系统的协调：</p>
<p><strong>源码层</strong>：我们编写强类型的泛型代码，享受IDE的类型检查</p>
<p><strong>编译期</strong>：编译器执行类型安全检查，同时通过多种机制保留泛型信息：</p>
<h3 id="Signature属性：完整泛型信息的保留"><a href="#Signature属性：完整泛型信息的保留" class="headerlink" title="Signature属性：完整泛型信息的保留"></a>Signature属性：完整泛型信息的保留</h3><p>Java编译器会在字节码中保存完整的泛型签名，这是类型擦除的重要补偿机制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 泛型类的签名（GenericClassDemo&lt;T extends Number&gt;）</span><br><span class="line">Signature: #25  // &lt;T:Ljava/lang/Number;&gt;Ljava/lang/Object;</span><br><span class="line"></span><br><span class="line">// 泛型方法的签名</span><br><span class="line">Signature: #18  // (TT;)V                           // addItem(T item)</span><br><span class="line">Signature: #21  // ()Ljava/util/List&lt;TT;&gt;;         // getItems()</span><br><span class="line">Signature: #24  // &lt;E:Ljava/lang/Object;&gt;(TE;Ljava/util/List&lt;-TE;&gt;;)V  // processWithGenericMethod</span><br></pre></td></tr></table></figure>

<h3 id="LocalVariableTypeTable：调试信息中的类型追踪"><a href="#LocalVariableTypeTable：调试信息中的类型追踪" class="headerlink" title="LocalVariableTypeTable：调试信息中的类型追踪"></a>LocalVariableTypeTable：调试信息中的类型追踪</h3><p>在启用调试信息编译时，还会生成额外的类型表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 普通变量表（总是存在）</span><br><span class="line">LocalVariableTable:</span><br><span class="line">  Start  Length  Slot  Name   Signature</span><br><span class="line">      8     227     1 stringList   Ljava/util/List;</span><br><span class="line"></span><br><span class="line">// 泛型变量表（仅调试模式）</span><br><span class="line">LocalVariableTypeTable:</span><br><span class="line">  Start  Length  Slot  Name   Signature</span><br><span class="line">      8     227     1 stringList   Ljava/util/List&lt;Ljava/lang/String;&gt;;</span><br></pre></td></tr></table></figure>

<p>注意两个表的关键差异：普通表显示擦除后的类型<code>List</code>，而泛型表保留完整信息<code>List&lt;String&gt;</code>。</p>
<p><strong>字节码层</strong>：不同的类型检查策略：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Java: 延迟类型检查</span><br><span class="line">143: checkcast     #62                 // class java/lang/String</span><br><span class="line"></span><br><span class="line">// Kotlin reified: 直接类型检查</span><br><span class="line">134: instanceof    #87                 // class java/lang/String</span><br></pre></td></tr></table></figure>

<p><strong>运行时</strong>：JVM执行擦除后的代码，但仍可通过Signature属性访问泛型信息</p>
<h3 id="设计权衡的思考"><a href="#设计权衡的思考" class="headerlink" title="设计权衡的思考"></a>设计权衡的思考</h3><p>通过对比分析，我们可以看到不同语言的设计权衡：</p>
<table>
<thead>
<tr>
<th>方面</th>
<th>Java 类型擦除</th>
<th>Kotlin Reified</th>
</tr>
</thead>
<tbody><tr>
<td><strong>字节码大小</strong></td>
<td>紧凑，共享字节码</td>
<td>内联展开，每个调用点独立</td>
</tr>
<tr>
<td><strong>运行时开销</strong></td>
<td>checkcast 指令检查</td>
<td>编译时优化，无运行时开销</td>
</tr>
<tr>
<td><strong>API 设计</strong></td>
<td>需要传递 Class 参数</td>
<td>直接使用类型参数</td>
</tr>
<tr>
<td><strong>互操作性</strong></td>
<td>完全兼容</td>
<td>Java 无法调用真正的 reified</td>
</tr>
</tbody></table>
<p>Kotlin的reified机制在编译期和运行时之间找到了巧妙的平衡点：通过内联函数在编译时恢复类型信息，同时通过编译器协作机制实现跨库调用。</p>
<p>这种设计思路反映了现代语言发展的趋势——不是对抗底层平台的限制，而是在编译器层面提供更好的抽象，通过巧妙的工程实现来突破技术约束。</p>
<p>你在项目中遇到过类似的类型系统边界问题吗？或者发现了其他语言处理这类问题的有趣方案？</p>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>崔鹏飞
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://cuipengfei.me/blog/2025/09/14/generic-type-erasure-deep-dive/" title="当泛型遇上现实：从表象到本质的技术思考">https://cuipengfei.me/blog/2025/09/14/generic-type-erasure-deep-dive/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/Kotlin/" rel="tag"><i class="fa fa-tag"></i> Kotlin</a>
              <a href="/tags/%E6%B3%9B%E5%9E%8B/" rel="tag"><i class="fa fa-tag"></i> 泛型</a>
              <a href="/tags/JVM/" rel="tag"><i class="fa fa-tag"></i> JVM</a>
              <a href="/tags/%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4/" rel="tag"><i class="fa fa-tag"></i> 类型擦除</a>
              <a href="/tags/%E5%8F%8D%E5%B0%84/" rel="tag"><i class="fa fa-tag"></i> 反射</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/2025/08/27/agent-building-seductive-traps/" rel="prev" title="Agent 构建中的三个诱人陷阱">
                  <i class="fa fa-angle-left"></i> Agent 构建中的三个诱人陷阱
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="user"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">崔鹏飞</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">405k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">6:08</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/cuipengfei" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"cuipengfeioctopressblog","count":true,"lazyload":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js" defer></script>

</body>
</html>

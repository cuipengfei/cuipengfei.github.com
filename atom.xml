<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>崔鹏飞的Blog</title>
  
  
  <link href="https://cuipengfei.me/atom.xml" rel="self"/>
  
  <link href="https://cuipengfei.me/"/>
  <updated>2025-06-28T12:30:00.000Z</updated>
  <id>https://cuipengfei.me/</id>
  
  <author>
    <name>崔鹏飞</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AI 时代，我们是在写代码，还是在“写知识”？—— 极客时间 8x 课程笔记</title>
    <link href="https://cuipengfei.me/blog/2025/06/28/geektime-8x-ai/"/>
    <id>https://cuipengfei.me/blog/2025/06/28/geektime-8x-ai/</id>
    <published>2025-06-28T12:30:00.000Z</published>
    <updated>2025-06-28T12:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>本文是极客时间 8x 课程的读书笔记。我本想取名 G8 (Geekbang 8x)，但听起来不太对劲，所以就有了现在这个标题。</em></p></blockquote><blockquote><p>“软件的价值，最终由其承载的知识决定。代码，只是这些知识的可执行形态。”</p></blockquote><h2 id="引言：从“构建者”到“知识工程师”的身份转变"><a href="#引言：从“构建者”到“知识工程师”的身份转变" class="headerlink" title="引言：从“构建者”到“知识工程师”的身份转变"></a>引言：从“构建者”到“知识工程师”的身份转变</h2><p>我们习惯于将软件开发看作一种“建造”活动，谈论“构建”软件、“编写”代码。</p><p>但随着 AI 大语言模型（LLM）的普及，我们或许需要换个角度审视自己的工作。</p><p>如果说编码是软件开发的“最后一公里”，那在此之前的需求讨论、架构设计和技术选型，又是什么呢？</p><p>这些过程，更像是一种知识的传递、提炼与组织。</p><p>本文想探讨一个观点：在 AI 时代，软件工程的核心正从“构造软件”转向“管理知识”。</p><p>这一转变，对我们的日常工作意味着什么？</p><h2 id="一、软件：一种可执行的知识"><a href="#一、软件：一种可执行的知识" class="headerlink" title="一、软件：一种可执行的知识"></a>一、软件：一种可执行的知识</h2><p>让我们暂时抛开代码，思考软件的本质。</p><ul><li><strong>软件是知识的载体</strong>：真正的“产品”，是软件中蕴含的业务逻辑、领域规则和架构决策。代码只是这些知识的最终表现形式。</li><li><strong>软件是知识的“可执行”形态</strong>：它让抽象的知识能够在现实世界中产生具体影响。</li><li><strong>软件开发的核心，是知识的获取、学习与传递</strong>：编码只是这一漫长知识旅程的最终环节。</li></ul><p>如果把开发过程比作拍电影，最终的代码就像发行的拷贝，而剧本、分镜、导演构思和演员对角色的理解，才是构成电影价值的核心“知识”。</p><h3 id="LLM：认知杠杆，而非认知替代"><a href="#LLM：认知杠杆，而非认知替代" class="headerlink" title="LLM：认知杠杆，而非认知替代"></a>LLM：认知杠杆，而非认知替代</h3><p>LLM 在这个新范式中扮演什么角色？它是一个强大的<strong>认知杠杆</strong>，极大地提升了知识转化为代码的效率，但它并未替代人类的认知过程。</p><ul><li><strong>人的认知水平是协作的上限</strong>：人与 LLM 协作的最终产出质量，取决于人对问题的理解深度和判断力。</li><li><strong>LLM 的核心能力是基于上下文的理解与生成</strong>：通过提供精准的上下文，我们可以将其“调教”为特定领域的辅助专家。</li><li><strong>LLM 存在固有技术限制</strong>：<ul><li><strong>上下文与 Token 限制</strong>，使其难以一次性处理庞杂的系统。</li><li><strong>“幻觉”现象</strong>，意味着其产出需要严格验证。</li></ul></li></ul><p>因此，将 LLM 视为无所不能的“代码生成器”是一种误解。</p><p>它的真正价值在于成为知识传递链条中的高效“处理器”，而我们则需要成为高效的“知识管理者”。</p><h2 id="二、知识工程：一种新的工作模式"><a href="#二、知识工程：一种新的工作模式" class="headerlink" title="二、知识工程：一种新的工作模式"></a>二、知识工程：一种新的工作模式</h2><p>如果软件开发是知识工作，我们该如何实践？</p><p><strong>知识工程</strong>，可以理解为：<strong>将软件开发视为一个“提取、组织知识，使其能被 LLM 理解，并最终通过 LLM 将这些知识转化为可工作软件”的完整过程。</strong></p><p>这里的<strong>关键瓶颈</strong>，不再是编码速度，而是<strong>知识传递的效率与保真度</strong>。</p><h3 id="1-知识与任务分离：与-LLM-精准对话"><a href="#1-知识与任务分离：与-LLM-精准对话" class="headerlink" title="1. 知识与任务分离：与 LLM 精准对话"></a>1. 知识与任务分离：与 LLM 精准对话</h3><p>与 LLM 交互时，清晰地分离**知识（背景信息）<strong>与</strong>任务（具体指令）**至关重要。这能帮助 LLM 建立正确的上下文，形成明确的关注点。</p><p>例如，与其直接说“写一个登录函数”，不如先提供知识：</p><ul><li><strong>知识（Context）</strong>：“系统使用 JWT 认证，密码采用 bcrypt 加密，用户信息存储在 <code>users</code> 表中。”</li><li><strong>任务（Task）</strong>：“基于以上信息，编写一个 <code>login(username, password)</code> 函数，验证成功后返回 JWT。”</li></ul><p>有趣的是，敏捷开发中的<strong>用户故事（User Story）</strong>，恰好是一种优秀的知识管理工具。它天然地侧重于<strong>定义问题（“我是谁”、“我想要什么”、“为什么”）</strong>，而非预设解决方案，这使其成为向 LLM 传递需求的理想形式。</p><h3 id="2-通过反馈迭代：提炼隐性知识"><a href="#2-通过反馈迭代：提炼隐性知识" class="headerlink" title="2. 通过反馈迭代：提炼隐性知识"></a>2. 通过反馈迭代：提炼隐性知识</h3><p>知识工程并非单向传递，而是一个双向的、迭代的探索过程。</p><blockquote><p>通过 LLM 的反馈来反思并修正我们对知识的描述，是知识工程的核心循环。</p></blockquote><p>这个过程的本质，是<strong>消除误解、对齐思路</strong>。它的最终目标是**“校准人”的理解**，而非仅仅“修复代码”。当 LLM 对你的描述产生“误解”时，或许我们首先要反思的是，自己对知识的表达是否足够清晰、准确。</p><h3 id="3-驾驭不同类型的知识"><a href="#3-驾驭不同类型的知识" class="headerlink" title="3. 驾驭不同类型的知识"></a>3. 驾驭不同类型的知识</h3><p>软件开发涉及的知识远非单一类型，我们必须学会驾驭它们：</p><ul><li><strong>显式知识（Explicit Knowledge）</strong>：能够被清晰表达、记录和传播的”know-what”，如技术文档、业务规则。</li><li><strong>隐式知识（Implicit Knowledge）</strong>：尚未被记录，但可以通过交流和文档化转为显式知识。</li><li><strong>默会知识（Tacit Knowledge）</strong>：这是最宝贵也最难处理的部分。它是个人经验、直觉、技能的核心，是难以形式化的”know-how”。例如，一位资深架构师在众多方案中做出权衡的直觉，或是一位高级工程师对代码“坏味道”的敏锐嗅觉。<strong>定义问题通常比解决问题更难</strong>，而对问题的敏锐感知，正是默会知识的体现。</li></ul><p>为何同样的技术文档（显式知识）在不同人手中，会产生天壤之别的实现？</p><p>为何有经验的工程师能在看似平静的代码中，直觉性地感知到潜在的设计缺陷？</p><p>这些都彰显了默会知识的核心价值。</p><h2 id="三、研发流程重塑：从代码管理到知识管理"><a href="#三、研发流程重塑：从代码管理到知识管理" class="headerlink" title="三、研发流程重塑：从代码管理到知识管理"></a>三、研发流程重塑：从代码管理到知识管理</h2><p>在新范式下，现有研发流程需要<strong>重构为以知识为中心的管理过程</strong>，其核心目标是从流程中捕获关键知识，并通过 LLM 有效沉淀。</p><p><strong>围绕“默会知识”的传递来构建流程，是实现知识工程的关键。</strong></p><h3 id="1-应用与提取“默会知识”"><a href="#1-应用与提取“默会知识”" class="headerlink" title="1. 应用与提取“默会知识”"></a>1. 应用与提取“默会知识”</h3><ul><li><strong>应用知识</strong>：对于成熟的、有明确解决方案的问题（例如，为新项目搭建 CI&#x2F;CD 流水线），我们可以通过<strong>提示词模板</strong>对成熟的任务流程进行建模，高效应用那些已被充分学习的默会知识。</li><li><strong>提取知识</strong>：默会知识的提取，本质上是**提炼“思维链”（Chain of Thought, CoT）**的过程。通过鼓励 LLM 解释其推理过程，我们可以反向形式化那些隐性的专家经验。RAG（检索增强生成）等模式，同样有助于新知识的学习与提取。</li></ul><h3 id="2-应对认知偏差：先对齐思路，再写代码"><a href="#2-应对认知偏差：先对齐思路，再写代码" class="headerlink" title="2. 应对认知偏差：先对齐思路，再写代码"></a>2. 应对认知偏差：先对齐思路，再写代码</h3><p><strong>认知偏差</strong>是团队协作中的巨大障碍：不同成员对同一问题可能持有完全不同的假设和理解，导致共识难以形成。</p><p>这种分歧的<strong>后果</strong>是：团队难以形成统一共识，讨论陷入循环，新人培养周期延长，系统设计出现不一致，引入大量隐蔽的质量缺陷。我们是否曾困惑，为何同样的技术讨论，有些团队能迅速聚焦并达成一致，而有些团队却在表面问题上争论不休？认知偏差往往是根源。</p><p>知识工程强调<strong>先对齐思路，再动手编码</strong>。</p><ul><li><strong>推行任务审查（Task Review）</strong>：将审查的重心从代码（Code Review）上移至任务本身，在编码前，就通过讨论、文档或图表，确保团队对“做什么”和“为什么做”达成一致。</li><li><strong>建立认知行为基线</strong>：管理者应着力于建立团队统一的认知与行为基线，确保对问题的理解和处理方式有一致的标准。</li></ul><h3 id="3-混乱中的清醒：及时止损"><a href="#3-混乱中的清醒：及时止损" class="headerlink" title="3. 混乱中的清醒：及时止损"></a>3. 混乱中的清醒：及时止损</h3><p>当个体或团队对问题感到<strong>混乱（Chaotic）</strong>——即无法理解问题、被恐慌驱动而盲目行动时，任何试图“解决”问题的努力都可能加剧混乱。</p><p>此时，<strong>理性地及时止损</strong>，暂停行动，回归问题的澄清与理解，是避免大量返工的明智选择。</p><h2 id="四、任务划分与质量内建：新范式下的交付关键"><a href="#四、任务划分与质量内建：新范式下的交付关键" class="headerlink" title="四、任务划分与质量内建：新范式下的交付关键"></a>四、任务划分与质量内建：新范式下的交付关键</h2><h3 id="1-任务划分：与-LLM-协作的“接口”"><a href="#1-任务划分：与-LLM-协作的“接口”" class="headerlink" title="1. 任务划分：与 LLM 协作的“接口”"></a>1. 任务划分：与 LLM 协作的“接口”</h3><p>由于 LLM 的技术限制，需求必须被分解为<strong>足够小的、原子化的任务</strong>，才能转化为高质量的提示词。这个过程并非随意的拆分，而需同时兼顾<strong>软件架构与测试策略</strong>。</p><p><strong>可测试性（Testability）是进程内架构最重要的属性之一</strong>。一个好的任务划分，本身就应该导向一个易于测试的实现。</p><h3 id="2-质量控制优先于生成效率"><a href="#2-质量控制优先于生成效率" class="headerlink" title="2. 质量控制优先于生成效率"></a>2. 质量控制优先于生成效率</h3><p>在 LLM 辅助开发中，我们的精力分配需要发生根本转变：<strong>将更多精力投入质量控制，而非一味追求生成效率。</strong></p><p>反馈循环的瓶颈在于<strong>如何高效验证 LLM 生成结果的正确性与有效性</strong>。因此，我们必须大力倡导**内建质量（Build Quality In）**的理念，通过测试驱动（TDD&#x2F;BDD）来提炼需要给予 LLM 的精准反馈，而非仅仅依赖于编码后的手动调试。</p><p>我们应当转变思维，从”如何修复 LLM 生成的错误代码”到”如何设计流程，使 LLM 更容易生成正确代码”。</p><p>当我们过于关注生成速度时，往往因大量调试修复而降低总体效率；而当我们专注于质量时，整体进度反而可能加快。</p><p>这是否意味着，在 AI 时代，“慢即是快”可能成为新的工程法则？</p><h2 id="五、工程师的转型：从“编码者”到“知识工程师”"><a href="#五、工程师的转型：从“编码者”到“知识工程师”" class="headerlink" title="五、工程师的转型：从“编码者”到“知识工程师”"></a>五、工程师的转型：从“编码者”到“知识工程师”</h2><p>这场范式转型，最终将重塑工程师的核心价值。</p><ul><li><p><strong>角色转变</strong>：从专注于编码实现的**“编码者”（Coder）<strong>，转向侧重于知识管理、任务分解与验证的</strong>“知识工程师”（Knowledge Engineer）<strong>。对纯粹编码技能的要求或许会降低，但对</strong>知识提炼、系统思考、质量保障**等能力的要求将显著提升。</p><p>技能重组正在发生：</p><ul><li><strong>知识提炼能力</strong>：从复杂、模糊的业务需求中提取清晰、结构化的知识。</li><li><strong>系统性思考</strong>：在碎片化任务中保持整体视角，确保局部解决方案符合全局最优。</li><li><strong>元认知水平</strong>：对自身思考过程的觉察、监控与调整能力。</li><li><strong>跨学科整合</strong>：将技术、业务、用户体验等多维度知识有机融合。</li></ul></li><li><p><strong>核心价值</strong>：工程师的核心价值，在于为 LLM 提供<strong>足够丰富且精准的上下文信息</strong>——这包括功能需求、业务知识、架构决策、测试策略等一切关乎“生产正确代码”的关键信息。</p></li></ul><p>我们的关注点，正从“如何构造软件”，历史性地转向**“如何提取和组织知识，让知识变成 LLM 能够理解的形式”**。</p><p>从这个角度看，“提示词工程”的本质，是如何精准地组织与表达知识。</p><p>因此，<strong>“知识工程”</strong>，或许是一个更合理、也更深刻的名称。</p><h2 id="结语：不确定性中的确定性"><a href="#结语：不确定性中的确定性" class="headerlink" title="结语：不确定性中的确定性"></a>结语：不确定性中的确定性</h2><p>我们正站在一个技术剧变的时代，前方的道路充满不确定性。</p><p>然而，在不确定性中，有一点是确定的：<strong>知识将始终是软件的核心价值载体</strong>，而知识的有效传递与组织，将成为决定性因素。</p><p>软件工程或许正从“建筑学”迈向“认知科学”，从物质构造迈向知识组织。面对这一转变，我们需要保持敏锐的观察力，也需要务实的探索精神。</p><p>这不是终点，而是重新思考软件工程本质的起点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;本文是极客时间 8x 课程的读书笔记。我本想取名 G8 (Geekbang 8x)，但听起来不太对劲，所以就有了现在这个标题。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;“软件的价值，最终由其承载的知识决</summary>
      
    
    
    
    <category term="技术思考" scheme="https://cuipengfei.me/categories/%E6%8A%80%E6%9C%AF%E6%80%9D%E8%80%83/"/>
    
    <category term="AI" scheme="https://cuipengfei.me/categories/%E6%8A%80%E6%9C%AF%E6%80%9D%E8%80%83/AI/"/>
    
    <category term="软件工程" scheme="https://cuipengfei.me/categories/%E6%8A%80%E6%9C%AF%E6%80%9D%E8%80%83/AI/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
    <category term="软件开发" scheme="https://cuipengfei.me/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="知识工程" scheme="https://cuipengfei.me/tags/%E7%9F%A5%E8%AF%86%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="LLM" scheme="https://cuipengfei.me/tags/LLM/"/>
    
    <category term="认知模型" scheme="https://cuipengfei.me/tags/%E8%AE%A4%E7%9F%A5%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>如何给 GitHub Copilot &quot;洗脑”，让 AI 精准遵循指令产出高质量代码</title>
    <link href="https://cuipengfei.me/blog/2025/06/17/how-to-brainwash-copilot-to-follow-orders/"/>
    <id>https://cuipengfei.me/blog/2025/06/17/how-to-brainwash-copilot-to-follow-orders/</id>
    <published>2025-06-17T02:00:00.000Z</published>
    <updated>2025-06-17T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>最近在项目中使用 GitHub Copilot 的过程中，我发现了一个很有趣的现象。</p><p>当我让 Copilot 帮我写代码时，它总是热情满满地给出一大段实现。但当我仔细审视这些代码时，却经常会发现各种小问题——缺少错误处理、异常情况没考虑、命名不规范、没有单元测试，有时甚至会出现一些”魔法数字”。</p><p>这让我想起了那些刚入行的程序员，技术不错，但是对软件工程的规范和最佳实践还不够了解。他们写出来的代码能跑，但总让资深工程师皱眉头。</p><p>这些 AI 工具确实能提高效率，但如何让它们不仅提高效率，更能精准地产出符合工程实践的高质量代码，甚至达到一种”洗脑”般的效果，让它们乖乖听话，这成了一个值得思考的问题。</p><h2 id="不是魔法，是系统指令"><a href="#不是魔法，是系统指令" class="headerlink" title="不是魔法，是系统指令"></a>不是魔法，是系统指令</h2><p>经过一段时间的研究和实践，我发现 Copilot 这类 AI 工具实际上可以被深度”引导”，甚至达到一种”洗脑”的效果，让它们按照我们的意愿来行动。</p><p>它们并不是魔术盒子，而是遵循一套输入-输出原则的系统。如果我们能给它提供明确的指导和原则，它就能相应地调整自己的输出。</p><p>这个思路促使我整理了一个专门用来给 GitHub Copilot”洗脑”的指令集：<a href="https://github.com/cuipengfei/prompts">prompts</a>。</p><p>这个仓库里不是代码，而是一系列指导 AI 行为的 Markdown 文件。每个文件就像是给 AI 的一份规范或指南，告诉它应该怎样思考和行动。</p><h2 id="这套指令能解决什么问题？"><a href="#这套指令能解决什么问题？" class="headerlink" title="这套指令能解决什么问题？"></a>这套指令能解决什么问题？</h2><p>使用 AI 编程助手时，我们通常会遇到这些问题：</p><ul><li>生成的代码能运行，但结构混乱，难以维护</li><li>没有考虑边界情况和异常处理</li><li>代码风格不一致，命名随意</li><li>缺乏适当的测试覆盖</li><li>不遵循项目已有的架构模式</li></ul><p>这套指令集就是为了解决这些问题而设计的。它告诉 AI 该如何思考软件设计、如何编写清晰的代码、如何进行测试驱动开发，以及如何分解复杂问题。</p><h2 id="指令集的构成"><a href="#指令集的构成" class="headerlink" title="指令集的构成"></a>指令集的构成</h2><p>整个指令集分为几个主要部分：</p><ol><li><p><strong>核心行为定义</strong>：这部分告诉 AI 应该如何进行思考和工作，包括：</p><ul><li>如何保持项目知识的连贯性（memory-bank）</li><li>如何有条理地回应用户（response-and-prompt-guidelines）</li><li>如何遵循 TDD 工作流（programming-workflow）</li><li>如何分解复杂任务（workflow-and-task-splitting）</li></ul></li><li><p><strong>代码质量规范</strong>：这部分告诉 AI 什么是好代码，什么是坏代码：</p><ul><li>代码标准和最佳实践（code-standards）</li><li>代码异味和应避免的反模式（avoid-bad-smells）</li><li>如何编写有效的测试（testing-guidelines）</li></ul></li><li><p><strong>流程模板</strong>：这部分提供了从需求到实现的结构化方法：</p><ul><li>如何将模糊的想法转化为明确的计划（req）</li><li>如何协助业务分析师编写用户故事（ba）</li></ul></li><li><p><strong>工具使用指南</strong>：这部分包含了一些高级技巧：</p><ul><li>如何使用顺序思考解决问题（sequential-thinking）</li><li>快捷指令系统（shortcut-system-instruction）</li></ul></li></ol><h2 id="这些指令是怎么起作用的？"><a href="#这些指令是怎么起作用的？" class="headerlink" title="这些指令是怎么起作用的？"></a>这些指令是怎么起作用的？</h2><p>你可能会好奇，为什么一些 Markdown 文件就能让 AI 变得这么听话？</p><p>我在研究这些指令的时候发现，它们其实就是几个简单的套路。比如，我给 AI 安排了不同的”角色”——有时候它是个健忘的工程师（所以必须写文档），有时候它是业务分析师的助手。这样一来，AI 就会按照角色来思考问题。</p><p>还有一个很有效的技巧是强制它”慢思考”。很多指令都要求 AI 必须一步一步地展示思考过程，不能直接给答案。这就像我们做数学题时要求”列出解题步骤”一样。</p><p>最有意思的是”自我批判”这一招。我发现如果让 AI 在给出解决方案后，再强制它自己找毛病，代码质量会提升很多。就像程序员写完代码后再做一遍 code review。</p><p>另外，我还设计了一些结构化的模板。比如写测试用例必须按照固定格式，写需求必须一个章节一个章节地来。这样 AI 就没法偷懒，必须把每个环节都考虑到。</p><p>说白了，这套指令的核心就是不让 AI “想当然”。它必须按照预设的流程来工作，该问的问题不能跳过，该考虑的边界情况不能遗漏。</p><h2 id="如何在实际工作中使用这套指令"><a href="#如何在实际工作中使用这套指令" class="headerlink" title="如何在实际工作中使用这套指令"></a>如何在实际工作中使用这套指令</h2><p>经过实践，我发现在 VS Code 中配置 Copilot 使用这些指令非常简单：</p><ol><li>打开 VS Code 设置（Ctrl+, 或 Cmd+,）</li><li>搜索 <code>github.copilot.chat.codeGeneration.instructions</code></li><li>添加指向指令文件的配置，例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;github.copilot.chat.codeGeneration.instructions&quot;: [</span><br><span class="line">    &#123; &quot;text&quot;: &quot;避免生成与公共代码完全匹配的代码&quot; &#125;,</span><br><span class="line">    &#123; &quot;file&quot;: &quot;../prompts/.github/instructions/req.md&quot; &#125;,</span><br><span class="line">    &#123; &quot;file&quot;: &quot;../prompts/.github/instructions/ba.md&quot; &#125;,</span><br><span class="line">    // 其它指令文件...</span><br><span class="line">    &#123; &quot;file&quot;: &quot;../prompts/.github/instructions/shortcut-system-instruction.md&quot; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>需要注意的是，文件路径要正确。这里的路径是相对于你的 workspace 的。如果你的 prompts 仓库和当前项目不在同一位置，可能需要调整路径。</p><p>设置完成后，你会发现 Copilot 生成的代码质量明显提升：更规范、更健壮、考虑更周全。</p><h2 id="一点思考"><a href="#一点思考" class="headerlink" title="一点思考"></a>一点思考</h2><p>给 AI 工具”洗脑”，或者说深度引导它们，其实和带新人有些相似 —— 你需要清晰地表达期望，提供良好的指导和范例，然后持续进行纠正和反馈。</p><p>这不是一项精确的科学，而是一个持续改进的过程。不同项目可能需要对指令进行一些定制和调整，以适应特定的技术栈和团队风格。</p><p>对我来说，这套指令系统的价值不仅在于提升了 AI 工具的输出质量，更在于它促使我思考：什么是好的代码？什么是好的软件工程实践？这些思考反过来又能帮助我们在日常工作中做得更好。</p><hr><p>如果你也在使用 AI 编程助手，不妨试试这套指令。如果有任何想法或改进建议，欢迎到 <a href="https://github.com/cuipengfei/prompts">prompts</a> 仓库提交 PR 或 Issue。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;最近在项目中使用 GitHub Copilot 的过程中，我发现了一个很有趣的现象。&lt;/p&gt;
&lt;p&gt;当我让 Copilot 帮我写代码时，它</summary>
      
    
    
    
    <category term="技术思考" scheme="https://cuipengfei.me/categories/%E6%8A%80%E6%9C%AF%E6%80%9D%E8%80%83/"/>
    
    
    <category term="AI" scheme="https://cuipengfei.me/tags/AI/"/>
    
    <category term="GitHub Copilot" scheme="https://cuipengfei.me/tags/GitHub-Copilot/"/>
    
    <category term="软件开发" scheme="https://cuipengfei.me/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="代码质量" scheme="https://cuipengfei.me/tags/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"/>
    
    <category term="提示工程" scheme="https://cuipengfei.me/tags/%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Feedly硬广-回归RSS</title>
    <link href="https://cuipengfei.me/blog/2025/01/05/go-back-to-rss/"/>
    <id>https://cuipengfei.me/blog/2025/01/05/go-back-to-rss/</id>
    <published>2025-01-04T16:00:00.000Z</published>
    <updated>2025-01-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="highlight mermaid">flowchart TD  subgraph 被动信息接收    style 被动信息接收 fill:#f9d6c1,stroke:#000,stroke-width:2px;    A[被动接受信息] --&gt; B[算法过度控制]    B --&gt; C[信息茧房]    C --&gt; D[注意力消耗]  end  subgraph 信息主动消费    style 信息主动消费 fill:#c1e1f9,stroke:#000,stroke-width:2px;    E[回归RSS] --&gt; F[掌握信息主动权]    F --&gt; G[自主订阅]    G --&gt; H[控制信息摄入质量]    H --&gt; I[主动选择信息来源]    I --&gt; J[避免无用信息轰炸]    J --&gt; K[减少干扰]    K --&gt; L[专注高质量内容]    L --&gt; M[享受纯粹阅读乐趣]    M --&gt; N[高质量阅读体验]    N --&gt; O[注意力回归有价值内容]    O --&gt; F  end  D --&gt; E</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code class=&quot;highlight mermaid&quot;&gt;flowchart TD
  subgraph 被动信息接收
    style 被动信息接收 fill:#f9d6c1,stroke:#000,stroke-width:2px;
    A[被动接受信息</summary>
      
    
    
    
    
    <category term="RSS" scheme="https://cuipengfei.me/tags/RSS/"/>
    
    <category term="Feedly" scheme="https://cuipengfei.me/tags/Feedly/"/>
    
  </entry>
  
  <entry>
    <title>解决 LibreOffice 导出Excel 到 PDF 超链接丢失问题</title>
    <link href="https://cuipengfei.me/blog/2024/07/28/libre-jod-single-page-excel/"/>
    <id>https://cuipengfei.me/blog/2024/07/28/libre-jod-single-page-excel/</id>
    <published>2024-07-27T16:00:00.000Z</published>
    <updated>2024-07-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在使用LibreOffice的Calc组件将电子表格导出为PDF文件时，如果启用了“Whole sheet export”（整页导出）选项，导出的PDF文件中的超链接将不会保留原始的URL，而是显示为本地文件路径。</p><p>这个问题在</p><ol><li><a href="https://ask.libreoffice.org/t/web-hyperlinks-not-preserved-after-export-to-pdf/96762">LibreOffice 官方论坛上的提问</a></li><li><a href="https://stackoverflow.com/questions/78799273/implementing-a-custom-whole-sheet-export-via-uno-api-to-preserve-hyperlinks-in">Stack Overflow 上的提问</a></li></ol><p>上都有讨论。</p><h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>为了解决这个问题，我们考虑使用LibreOffice的UNO API来实现一个自定义的解决方案。这个方案的核心思想是：</p><ul><li>遍历Calc文档中的每个工作表。</li><li>计算每个工作表内容适应一页所需的总宽度和高度。</li><li>根据这些尺寸为每个工作表生成自定义的纸张大小。</li><li>使用自定义纸张大小导出PDF，同时确保不使用“Whole sheet export”选项，以保留超链接。</li></ul><h1 id="ExcelSinglePageFilter解决方案"><a href="#ExcelSinglePageFilter解决方案" class="headerlink" title="ExcelSinglePageFilter解决方案"></a>ExcelSinglePageFilter解决方案</h1><p>针对上述问题，<code>ExcelSinglePageFilter</code>Java类实现了自定义的PDF导出过滤器。</p><p>以下是该过滤器如何解决问题的详细解析。</p><h1 id="过滤器初始化与文档检查"><a href="#过滤器初始化与文档检查" class="headerlink" title="过滤器初始化与文档检查"></a>过滤器初始化与文档检查</h1><p><code>ExcelSinglePageFilter</code>首先检查传入的文档是否为Excel文档。如果不是，它将直接调用链式调用<code>chain.doFilter</code>继续处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">XSpreadsheetDocument</span> <span class="variable">xSpreadsheetDocument</span> <span class="operator">=</span> queryInterface(XSpreadsheetDocument.class, document);</span><br><span class="line"><span class="keyword">if</span> (xSpreadsheetDocument == <span class="literal">null</span>) &#123;</span><br><span class="line">    chain.doFilter(context, document);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="工作表遍历与处理"><a href="#工作表遍历与处理" class="headerlink" title="工作表遍历与处理"></a>工作表遍历与处理</h1><p>接着，该过滤器遍历所有工作表，并为每个工作表异步执行调整操作。对于隐藏的工作表，它将跳过处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] sheetNames = xSpreadsheetDocument.getSheets().getElementNames();</span><br><span class="line">CompletableFuture[] futures = Arrays.stream(sheetNames).map(sheetName -&gt; CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ... 省略部分代码 ...</span></span><br><span class="line">    adjustOneSheet(sheetName, sheet, xPageStyles);</span><br><span class="line">&#125;)).toList().toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><h1 id="处理每个工作表"><a href="#处理每个工作表" class="headerlink" title="处理每个工作表"></a>处理每个工作表</h1><p>对于每个工作表，代码首先检查工作表是否可见，然后计算工作表的总宽度和高度，包括单元格和图形对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustOneSheet</span><span class="params">(String sheetName, XSpreadsheet sheet, XNameAccess xPageStyles)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算工作表的总宽度和高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">totalWidth</span> <span class="operator">=</span> getTotalWidth(getxColumnRowRange(sheet), getLastColumn(sheet));</span><br><span class="line">    <span class="type">int</span> <span class="variable">totalHeight</span> <span class="operator">=</span> getTotalHeight(getxColumnRowRange(sheet), getLastRow(sheet));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包括图形对象的尺寸</span></span><br><span class="line">    <span class="type">Size</span> <span class="variable">graphicalSize</span> <span class="operator">=</span> getGraphicalObjectsSize(sheet);</span><br><span class="line">    totalWidth = Math.max(totalWidth, graphicalSize.Width);</span><br><span class="line">    totalHeight = Math.max(totalHeight, graphicalSize.Height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置页面样式属性</span></span><br><span class="line">    <span class="type">XPropertySet</span> <span class="variable">xPageStyleProps</span> <span class="operator">=</span> getPageStyleProps(sheet, xPageStyles);</span><br><span class="line">    xPageStyleProps.setPropertyValue(<span class="string">&quot;Size&quot;</span>, <span class="keyword">new</span> <span class="title class_">Size</span>(totalWidth, totalHeight));</span><br><span class="line">    setMarginToZero(xPageStyleProps);</span><br><span class="line">    xPageStyleProps.setPropertyValue(<span class="string">&quot;ScaleToPages&quot;</span>, (<span class="type">short</span>) <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计算图形对象尺寸"><a href="#计算图形对象尺寸" class="headerlink" title="计算图形对象尺寸"></a>计算图形对象尺寸</h1><p>getGraphicalObjectsSize方法用于计算工作表中所有图形对象所占的最大宽度和高度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Size <span class="title function_">getGraphicalObjectsSize</span><span class="params">(XSpreadsheet sheet)</span> &#123;</span><br><span class="line">    <span class="type">XDrawPageSupplier</span> <span class="variable">drawPageSupplier</span> <span class="operator">=</span> queryInterface(XDrawPageSupplier.class, sheet);</span><br><span class="line">    <span class="type">XDrawPage</span> <span class="variable">drawPage</span> <span class="operator">=</span> drawPageSupplier.getDrawPage();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> drawPage.getCount();</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxWidth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxHeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="type">XShape</span> <span class="variable">shape</span> <span class="operator">=</span> queryInterface(XShape.class, drawPage.getByIndex(i));</span><br><span class="line">        <span class="type">Point</span> <span class="variable">position</span> <span class="operator">=</span> shape.getPosition();</span><br><span class="line">        <span class="type">Size</span> <span class="variable">size</span> <span class="operator">=</span> shape.getSize();</span><br><span class="line">        maxWidth = Math.max(maxWidth, position.X + size.Width);</span><br><span class="line">        maxHeight = Math.max(maxHeight, position.Y + size.Height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Size</span>(maxWidth, maxHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计算总宽度和总高度"><a href="#计算总宽度和总高度" class="headerlink" title="计算总宽度和总高度"></a>计算总宽度和总高度</h1><p>getTotalWidth和getTotalHeight方法分别用于计算工作表的总宽度和总高度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getTotalWidth</span><span class="params">(XColumnRowRange columnRowRange, <span class="type">int</span> endColumn)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">totalWidth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= endColumn; j++) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">column</span> <span class="operator">=</span> columnRowRange.getColumns().getByIndex(j);</span><br><span class="line">        <span class="type">XPropertySet</span> <span class="variable">columnProps</span> <span class="operator">=</span> queryInterface(XPropertySet.class, column);</span><br><span class="line">        totalWidth += (<span class="type">int</span>) columnProps.getPropertyValue(<span class="string">&quot;Width&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> totalWidth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getTotalHeight</span><span class="params">(XColumnRowRange columnRowRange, <span class="type">int</span> endRow)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">totalHeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= endRow; i++) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">row</span> <span class="operator">=</span> columnRowRange.getRows().getByIndex(i);</span><br><span class="line">        <span class="type">XPropertySet</span> <span class="variable">rowProps</span> <span class="operator">=</span> queryInterface(XPropertySet.class, row);</span><br><span class="line">        totalHeight += (<span class="type">int</span>) rowProps.getPropertyValue(<span class="string">&quot;Height&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> totalHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完成导出"><a href="#完成导出" class="headerlink" title="完成导出"></a>完成导出</h1><p>最后，等待所有异步任务完成后，调用链式调用chain.doFilter继续执行标准的PDF导出流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.allOf(futures).join();</span><br><span class="line">chain.doFilter(context, document);</span><br></pre></td></tr></table></figure><h1 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h1><p>上述解决方案的原始代码可以在GitHub上找到，链接为：</p><p><a href="https://github.com/cuipengfei/jodconverter-samples/blob/main/samples/spring-boot-rest/src/main/java/org/jodconverter/sample/rest/ExcelSinglePageFilter.java">https://github.com/cuipengfei/jodconverter-samples/blob/main/samples/spring-boot-rest/src/main/java/org/jodconverter/sample/rest/ExcelSinglePageFilter.java</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ExcelSinglePageFilter通过自定义的PDF导出逻辑，成功避免了使用“Whole sheet export”选项，从而解决了超链接在PDF中丢失的问题。这种方法不仅保留了超链接的完整性，而且还提供了一种灵活的方式来调整每个工作表的显示尺寸，确保它们在PDF中以单页的形式呈现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;在使用LibreOffice的Calc组件将电子表格导出为PDF文件时，如果启用了“Whole sheet export”（</summary>
      
    
    
    
    
    <category term="LibreOffice" scheme="https://cuipengfei.me/tags/LibreOffice/"/>
    
    <category term="PDF" scheme="https://cuipengfei.me/tags/PDF/"/>
    
    <category term="JODConverter" scheme="https://cuipengfei.me/tags/JODConverter/"/>
    
  </entry>
  
  <entry>
    <title>基于LibreOffice的MS Office文档格式转换</title>
    <link href="https://cuipengfei.me/blog/2024/02/04/libre-jod/"/>
    <id>https://cuipengfei.me/blog/2024/02/04/libre-jod/</id>
    <published>2024-02-04T07:21:24.000Z</published>
    <updated>2024-02-04T07:21:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="将Microsoft-Office文件转换为其他格式的场景"><a href="#将Microsoft-Office文件转换为其他格式的场景" class="headerlink" title="将Microsoft Office文件转换为其他格式的场景"></a>将Microsoft Office文件转换为其他格式的场景</h1><p>在一些情况下，可能需要将Microsoft Office文件转换为其他格式：</p><ul><li>兼容性问题：与不同的办公软件或操作系统进行交互，可能需要将MS Office文件转换为更通用的格式。例如，如果要与没有安装Microsoft Office的人分享文档，将其转换为PDF格式可能更合适。</li><li>归档和存档：将Office文件转换为更稳定、可持久保存的格式可以确保文件的长期保存和归档。某些文件格式（如PDF&#x2F;A）专门用于长期存档目的，以确保文件内容的完整性和可访问性。</li><li>数据提取：你可能只对文档中的特定数据或内容感兴趣。通过将Office文件转换为其他格式（如纯文本或CSV），可以更容易地提取所需的数据，并在其他应用程序中进行分析或处理。</li><li>网页发布：如果要将MS Office文件发布到网页上，可能需要将其转换为HTML或其他网页友好的格式，以确保文件在网页上正确显示。</li></ul><h1 id="LibreOffice-微软Office的开源替代"><a href="#LibreOffice-微软Office的开源替代" class="headerlink" title="LibreOffice - 微软Office的开源替代"></a>LibreOffice - 微软Office的开源替代</h1><p>LibreOffice是一个免费、开源的办公套件，在某种程度上可以被视为微软Office的开源替代品。</p><ul><li>LibreOffice Writer：对应于Microsoft Word。</li><li>LibreOffice Calc：对应于Microsoft Excel。</li><li>LibreOffice Impress：对应于Microsoft PowerPoint。</li></ul><p><img data-src="/images/libre/image.png" alt="alt text"></p><h1 id="LibreOffice支持的转换格式"><a href="#LibreOffice支持的转换格式" class="headerlink" title="LibreOffice支持的转换格式"></a>LibreOffice支持的转换格式</h1><p>LibreOffice支持广泛的转换格式。具体请参考如下的表格：</p><table aligh="center">    <tr><th align="left">Format Family</th><th align="left">From (any of)</th><th align="left">To (any of)</th></tr>    <tr valign="top">        <th align="left">Text</th>        <td>            <samp><b>*.odt</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Text<br>            <samp><b>*.ott</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Text Template<br>            <samp><b>*.sxw</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenOffice.org 1.0 Text<br>            <samp><b>*.rtf</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Rich Text Format<br>            <samp><b>*.doc</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Microsoft Word<br>            <samp><b>*.docx</b>&nbsp;&nbsp;&nbsp;</samp>Microsoft Word XML<br>            <samp><b>*.wpd</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>WordPerfect<br>            <samp><b>*.txt</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Plain Text<br>            <samp><b>*.html</b>&nbsp;&nbsp;&nbsp;</samp>HTML        </td>        <td>            <samp><b>*.pdf</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Portable Document Format<br>            <samp><b>*.odt</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Text<br>            <samp><b>*.ott</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Text Template<br>            <samp><b>*.sxw</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenOffice.org 1.0 Text<br>            <samp><b>*.rtf</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Rich Text Format<br>            <samp><b>*.doc</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Microsoft Word<br>            <samp><b>*.docx</b>&nbsp;&nbsp;&nbsp;</samp>Microsoft Word XML<br>            <samp><b>*.txt</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Plain Text<br>            <samp><b>*.html</b>&nbsp;&nbsp;&nbsp;</samp>HTML<br>            <samp><b>*.wiki</b>&nbsp;&nbsp;&nbsp;</samp>MediaWiki wikitext        </td>    </tr>    <tr valign="top">        <th align="left">Spreadsheet</th>        <td>            <samp><b>*.ods</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Spreadsheet<br>            <samp><b>*.ots</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Spreadsheet Template<br>            <samp><b>*.sxc</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenOffice.org 1.0 Spreadsheet<br>            <samp><b>*.xls</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Microsoft Excel<br>            <samp><b>*.xlsx</b>&nbsp;&nbsp;&nbsp;</samp>Microsoft Excel XML<br>            <samp><b>*.csv</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Comma-Separated Values<br>            <samp><b>*.tsv</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Tab-Separated Values        </td>        <td>            <samp><b>*.pdf</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Portable Document Format<br>            <samp><b>*.ods</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Spreadsheet<br>            <samp><b>*.ots</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Spreadsheet Template<br>            <samp><b>*.sxc</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenOffice.org 1.0 Spreadsheet<br>            <samp><b>*.xls</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Microsoft Excel<br>            <samp><b>*.xlsx</b>&nbsp;&nbsp;&nbsp;</samp>Microsoft Excel XML<br>            <samp><b>*.csv</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Comma-Separated Values<br>            <samp><b>*.tsv</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Tab-Separated Values<br>            <samp><b>*.html</b>&nbsp;&nbsp;&nbsp;</samp>HTML        </td>    </tr>    <tr valign="top">        <th align="left">Presentation</th>        <td>            <samp><b>*.odp</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Presentation<br>            <samp><b>*.otp</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Presentation Template<br>            <samp><b>*.sxi</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenOffice.org 1.0 Presentation<br>            <samp><b>*.ppt</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Microsoft PowerPoint<br>            <samp><b>*.pptx</b>&nbsp;&nbsp;&nbsp;</samp>Microsoft PowerPoint XML        </td>        <td>            <samp><b>*.pdf</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Portable Document Format<br>            <samp><b>*.swf</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Macromedia Flash<br>            <samp><b>*.odp</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Presentation<br>            <samp><b>*.otp</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Presentation Template<br>            <samp><b>*.sxi</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenOffice.org 1.0 Presentation<br>            <samp><b>*.ppt</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Microsoft PowerPoint<br>            <samp><b>*.pptx</b>&nbsp;&nbsp;&nbsp;</samp>Microsoft PowerPoint XML<br>            <samp><b>*.html</b>&nbsp;&nbsp;&nbsp;</samp>HTML        </td>    </tr>    <tr valign="top">        <th align="left">Drawing</th>        <td>            <samp><b>*.odg</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Drawing<br>            <samp><b>*.otg</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Drawing Template        </td>        <td>            <samp><b>*.svg</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Scalable Vector Graphics<br>            <samp><b>*.swf</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Macromedia Flash        </td>    </tr></table><h1 id="LibreOffice的headless模式"><a href="#LibreOffice的headless模式" class="headerlink" title="LibreOffice的headless模式"></a>LibreOffice的headless模式</h1><p>与常见的Chromium的headless模式类似，LibreOffice也提供headless模式。</p><ul><li>没有图形用户界面（GUI）：无论是LibreOffice的headless模式还是Chromium的headless模式，都在没有GUI的情况下运行，不会显示可见的窗口或用户界面。</li><li>命令行接口（CLI）控制：通过命令行接口进行控制和操作。可以在命令行中使用特定的命令和参数来执行相应的任务和操作。</li><li>自动化和批处理：LibreOffice的headless模式和Chromium的headless模式都适用于自动化和批处理任务。</li><li>服务器环境中的应用：适用于在服务器环境中使用。</li></ul><p>这就给在<strong>服务端自动化进行文档类型转换</strong>提供了很大的便利。</p><h1 id="资源池管理与容器化-JodConverter"><a href="#资源池管理与容器化-JodConverter" class="headerlink" title="资源池管理与容器化 - JodConverter"></a>资源池管理与容器化 - JodConverter</h1><p>JodConverter是一个用于将Office文档转换为其他格式的Java库。它支持与LibreOffice（也可以是OpenOffice）进行集成。</p><p>我们可以选择自己直接与headless的LibreOffice直接通信来完成文档格式转换，不过由JodConverter来代劳的好处是很明显的：</p><ul><li>资源池化</li><li>容器化</li></ul><p>JODConverter 的进程管理器（Process Manager）在资源池内维护 LibreOffice 进程。<br>将 LibreOffice 进程保持在资源池内，可以避免每次进行文档转换时都需要启动和终止 LibreOffice 进程的开销。<br>它可以检测到进程的健康状态，例如进程异常退出或崩溃，然后采取相应的措施，如重新启动进程。</p><p>JODConverter 还提供一个基于Debian的基础docker image，其中已经包含了LibreOffice。</p><p>我们的调用JODConverter的Java应用只需要基于该镜像build出来就好。</p><p><img data-src="/images/libre/libreoffice_logos_printed_on_dockers.png" alt="alt text"></p><h1 id="MS-Office存量文件的兼容性-字体的开源替代"><a href="#MS-Office存量文件的兼容性-字体的开源替代" class="headerlink" title="MS Office存量文件的兼容性 - 字体的开源替代"></a>MS Office存量文件的兼容性 - 字体的开源替代</h1><p><img data-src="/images/libre/compare.png" alt="alt text"></p><p>上面这张图左侧是原版的PPT，右侧是用JOD + LibreOffice转换出来的PDF。</p><p>可以看到右侧转换出PDF，文字之间出现了互相交叉重叠的现象，整个样式都乱掉了。<br>这其实并不是JOD或者是LibreOffice的bug。</p><p>而是由于左侧的PPT当中使用了一些微软的商用字体。<br>而LibreOffice运行在docker里面，它是拿不到这些微软的商用字体的，我们也不应该把有商用版权的字体置入docker image中。</p><p>这时我们可以使用一些<strong>开源的字体来代替微软的商用字体</strong>。</p><p>下图来自于LibreOffice的一篇博客： <a href="https://blog.documentfoundation.org/blog/2020/09/08/libreoffice-tt-replacing-microsoft-fonts/">https://blog.documentfoundation.org/blog/2020/09/08/libreoffice-tt-replacing-microsoft-fonts/</a></p><p><img data-src="https://blog.documentfoundation.org/wp-content/uploads/2020/09/Options-LibreOffice-Fonts.png" alt="font"></p><p>LibreOffice提供了一个Font Replacement Table的功能。</p><p>左侧Font列是商用字体，右侧Replace with列是开源字体。<br>例如：当LibreOffice见到一个ppt文件内的某段文字使用了Arial字体时，就会自动用Arimo字体去渲染这段文字。<br>这样，既能够尽量保持视觉效果的一致性，也避免使用商用字体。</p><p>下图是使用了开源字体替代后的转换效果，右侧的PDF和左侧的PPT视觉差异已经不太大了。<br><img data-src="/images/libre/compare2.png" alt="alt text"></p><p>作为一个LibreOffice<strong>桌面应用的使用者</strong>可以按照上述说明来做配置，从而最大程度的去兼容微软的商用字体。<br>而当我们使用headless模式时该如何做出等效的配置呢？</p><h1 id="LibreOffice-User-Profile"><a href="#LibreOffice-User-Profile" class="headerlink" title="LibreOffice - User Profile"></a>LibreOffice - User Profile</h1><p>上面提到的配置项，会被保存在LibreOffice User Profile内，在不同的OS内保存的路径为：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Windows</span><br><span class="line">%APPDATA%\libreoffice\<span class="number">4</span>\<span class="keyword">user</span> <span class="title">(LibreOffice</span> <span class="number">4</span> <span class="keyword">and</span> above)</span><br><span class="line"></span><br><span class="line">GNU/Linux</span><br><span class="line">/home/<span class="tag">&lt;user name&gt;</span>/.config/libreoffice/<span class="number">4</span>/<span class="keyword">user</span> <span class="title">(LibreOffice</span> <span class="number">4</span> <span class="keyword">and</span> above)</span><br></pre></td></tr></table></figure><p>我们可以把开源字体文件以及保存下来的配置文件内置入docker image内。<br>并通过JOD指定启动LibreOffice时的参数，让headless模式下运行的LibreOffice加载到正确的配置文件，进而也能达成上图所示一样转换的效果。</p><p><a href="https://github.com/cuipengfei/docker-image-jodconverter-examples/blob/909d9c62859b9c55b49afca0c7df7e04546042cc/Dockerfile#L38-L44">如下Dockerfile示例</a>中把开源字体和配置文件copy进Docker image</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># support more fonts</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> cjk-fonts/* /usr/share/fonts/cjk/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> condensed-fonts/* /usr/share/fonts/condensed/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ms-sub-fonts/* /usr/share/fonts/ms-sub-fonts/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add user profile config files</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./profile/LibreOffice/4/user /tmp/jodconverter/user</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/cuipengfei/jodconverter-samples/blob/98c2a6d73d3d9dfc88b0c7122b065dcd39e9ae61/samples/spring-boot-rest/src/main/resources/application.yml#L22-L26">如下示例</a>中指定template-profile-dir</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jodconverter:</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">port-numbers:</span> <span class="number">2002</span><span class="string">,2003</span></span><br><span class="line">    <span class="attr">template-profile-dir:</span> <span class="string">/tmp/jodconverter</span></span><br></pre></td></tr></table></figure><p>这样可以确保JODConverter在启动LibreOffice进程的时候可以明确地告诉LibreOffice去加载哪一份配置文件。</p><h1 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h1><p><a href="https://github.com/jodconverter/jodconverter/wiki/Getting-Started">JODConverter Wiki</a></p><p><a href="https://github.com/jodconverter/docker-image-jodconverter-runtime/pkgs/container/jodconverter-runtime">jodconverter-runtime docker基础镜像</a></p><p><a href="https://help.libreoffice.org/latest/en-US/text/shared/guide/pdf_params.html">LibreOffice PDF转换支持的命令行参数</a></p><p><a href="https://ask.libreoffice.org/t/libreoffice-xls-to-pdf-conversion-breaks-single-page-content-into-multiple-pages-on-ubuntu-18-04/49104/2">宽度过大的Excel转PDF的问题</a></p><p><a href="https://blog.documentfoundation.org/blog/2020/09/08/libreoffice-tt-replacing-microsoft-fonts/">微软字体兼容性问题</a></p><p><a href="https://wiki.documentfoundation.org/UserProfile#Default_locations">LibreOffice User Profile默认路径</a></p><p><a href="https://github.com/cuipengfei/docker-image-jodconverter-examples/blob/909d9c62859b9c55b49afca0c7df7e04546042cc/Dockerfile#L38-L44">把自定义的字体与User Profile加入Docker Image</a></p><p><a href="https://github.com/cuipengfei/jodconverter-samples/blob/98c2a6d73d3d9dfc88b0c7122b065dcd39e9ae61/samples/spring-boot-rest/src/main/resources/application.yml#L22-L26">给JODConverter指定User Profile路径</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;将Microsoft-Office文件转换为其他格式的场景&quot;&gt;&lt;a href=&quot;#将Microsoft-Office文件转换为其他格式的场景&quot; class=&quot;headerlink&quot; title=&quot;将Microsoft Office文件转换为其他格式的场景&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="LibreOffice" scheme="https://cuipengfei.me/tags/LibreOffice/"/>
    
    <category term="JOD" scheme="https://cuipengfei.me/tags/JOD/"/>
    
  </entry>
  
  <entry>
    <title>Spring Integration JDBC分布式锁 - Transactions与Threads</title>
    <link href="https://cuipengfei.me/blog/2023/12/25/spring-integration-jdbc-distributed-lock-with-transaction-and-threads/"/>
    <id>https://cuipengfei.me/blog/2023/12/25/spring-integration-jdbc-distributed-lock-with-transaction-and-threads/</id>
    <published>2023-12-25T03:16:17.000Z</published>
    <updated>2023-12-25T03:16:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一个问题：在多个线程中同时运行隔离级别为serializable的事务而导致的无法重试获取锁的问题"><a href="#第一个问题：在多个线程中同时运行隔离级别为serializable的事务而导致的无法重试获取锁的问题" class="headerlink" title="第一个问题：在多个线程中同时运行隔离级别为serializable的事务而导致的无法重试获取锁的问题"></a>第一个问题：在多个线程中同时运行隔离级别为serializable的事务而导致的无法重试获取锁的问题</h1><p>Spring Integration JDBC分布式锁的实现会需要使用一个serializable级别的事务来<strong>获取锁</strong>。</p><p>如果多个线程同时尝试获取锁，这些事务之间可能会出现顺序问题。</p><p>具体而言，可能会遇到以下错误：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.postgresql.util.PSQLException: ERROR: could <span class="keyword">not</span> serialize access due <span class="built_in">to</span> <span class="built_in">read</span>/<span class="built_in">write</span> dependencies <span class="keyword">among</span> transactions</span><br></pre></td></tr></table></figure><p>发生这样的问题其实也不可怕，因为JDBC锁会进行重试。</p><p>然而，当使用JPA Transaction Manager时，由于某些异常类型的原因，JDBC锁无法在发生这种错误的情况下进行重试。</p><p>可以在以下GitHub Issue中查看详细信息：<br><a href="https://github.com/spring-projects/spring-integration/issues/3733">https://github.com/spring-projects/spring-integration/issues/3733</a></p><p>可以使用以下代码重现此问题：<br><a href="https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/service/Problem1Service.java">https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/service/Problem1Service.java</a></p><h1 id="使用Data-Source-Transaction-Manager来workaround第一个问题"><a href="#使用Data-Source-Transaction-Manager来workaround第一个问题" class="headerlink" title="使用Data Source Transaction Manager来workaround第一个问题"></a>使用Data Source Transaction Manager来workaround第一个问题</h1><p>可以明确指定让JDBC锁不使用JPA Transaction Manager，而是使用Data Source Transaction Manager来绕过此问题。</p><p>具体代码请参考：<br><a href="https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/configs/CustomJDBCLockConfigs.java">https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/configs/CustomJDBCLockConfigs.java</a></p><p>可以执行该代码以观察workaround的效果：<br><a href="https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/service/Problem1FixService.java">https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/service/Problem1FixService.java</a></p><h1 id="第二个问题：在同一个线程中先使用JpaTransactionManager启动一个事务，然后尝试用DataSourceTransactionManager获取JDBC锁所导致的事务隔离级别变化的问题"><a href="#第二个问题：在同一个线程中先使用JpaTransactionManager启动一个事务，然后尝试用DataSourceTransactionManager获取JDBC锁所导致的事务隔离级别变化的问题" class="headerlink" title="第二个问题：在同一个线程中先使用JpaTransactionManager启动一个事务，然后尝试用DataSourceTransactionManager获取JDBC锁所导致的事务隔离级别变化的问题"></a>第二个问题：在同一个线程中先使用JpaTransactionManager启动一个事务，然后尝试用DataSourceTransactionManager获取JDBC锁所导致的事务隔离级别变化的问题</h1><p>该问题的显著特征是：如果在一个方法上标注了@Transactional，然后在该方法内部先执行了一些JPA的SQL操作，然后再尝试获取JDBC分布式锁，就会出现无法更改事务隔离级别的问题。</p><p>问题的关键在于并行流（parallel stream）并不总是仅利用其自己线程池中的线程，它也会利用当前线程。<br>而恰好落在当前线程上的那一次尝试获取JDBC分布式锁的操作就会出现无法更改事务隔离级别的问题。</p><p>这是因为我们用来解决第一个问题而引入的DataSourceTransactionManager的文档中提及它具有如下行为：</p><blockquote><p>Note: The DataSource that this transaction manager operates on needs to return independent Connections. The Connections typically come from a connection pool but the DataSource must not return specifically scoped or constrained Connections. This transaction manager will associate Connections with thread-bound transactions, according to the specified propagation behavior. It assumes that a separate, independent Connection can be obtained even during an ongoing transaction.</p></blockquote><p>可以通过以下代码观察parallel stream的行为：<br><a href="https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/TestParallelStreamThreads.java">https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/TestParallelStreamThreads.java</a></p><p>可以使用以下代码重现该问题：<br><a href="https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/service/Problem2Service.java">https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/service/Problem2Service.java</a></p><h1 id="第二个问题的不完善解决方法：强制parallel-stream不使用当前线程"><a href="#第二个问题的不完善解决方法：强制parallel-stream不使用当前线程" class="headerlink" title="第二个问题的不完善解决方法：强制parallel stream不使用当前线程"></a>第二个问题的不完善解决方法：强制parallel stream不使用当前线程</h1><p>在解决该问题的过程中，我尝试了一种不太明智的方法，在这里也记录一下。</p><p>我最初的想法是，既然parallel stream会利用当前线程，从而导致落在当前线程上的那一次获取锁的操作失败，那么我干脆强制它不要使用当前线程。然而，这是一种非常简单粗暴的做法。</p><p>尽管这样做可以成功获取JDBC锁，但它也会导致一部分SQL游离在事务之外执行。<br>不仅仅是这个解决方法，<strong>上述的三份代码也都会有这个问题</strong>。</p><p>不太理想的解决方法的代码如下：<br><a href="https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/service/Problem2BadFixService.java">https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/service/Problem2BadFixService.java</a></p><h1 id="第二个问题的较优解决方法：缩小事务范围，避免将业务操作和获取JDBC锁的操作混合在同一个被-Transactional标注的方法内"><a href="#第二个问题的较优解决方法：缩小事务范围，避免将业务操作和获取JDBC锁的操作混合在同一个被-Transactional标注的方法内" class="headerlink" title="第二个问题的较优解决方法：缩小事务范围，避免将业务操作和获取JDBC锁的操作混合在同一个被@Transactional标注的方法内"></a>第二个问题的较优解决方法：缩小事务范围，避免将业务操作和获取JDBC锁的操作混合在同一个被@Transactional标注的方法内</h1><p><strong>上述四份代码都存在一个共同的缺点</strong>，即@Transactional注解的范围太广。</p><p>这容易导致JPA Transaction Manager的范畴以及用于获取JDBC分布式锁的Data Source Transaction Manager的范畴互相交叉。</p><p>当这两者混在一起时，很容易出现DataSourceTransactionManager试图去改变一个已经被open过的transaction的隔离级别的问题。</p><p>第二个问题的较优解决方法的代码请参考：<br><a href="https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/service/Problem2GoodFixService.java">https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/service/Problem2GoodFixService.java</a></p><h1 id="用图来总结一下"><a href="#用图来总结一下" class="headerlink" title="用图来总结一下"></a>用图来总结一下</h1><pre><code class="highlight mermaid">flowchart TD        style dstm fill:lightgreen,stroke:#333,stroke-width:4px    style nrt fill:#FFCCCB,stroke:#333,stroke-width:4px    jl[JDBC分布式锁]    str[Serializable级别的事务]    mt[多个线程]    jtm[JPA Transaction Manager]    dstm[❤️Data Source Transaction Manager❤️]    nrt[🪳无法重试获取锁🪳]    se[Serialization Error]    se2[Serialization Error]    subgraph 在多个线程中同时运行隔离级别为serializable的事务而导致的无法重试获取锁的问题    jl--&gt;|默认使用|str    mt--&gt;|同时获取|jl    jl--&gt;|恰好用了|jtm    str--&gt;|容易撞车而导致|se    jtm--&gt;|hold不住|se    se--&gt;|从而导致|nrt    jl--&gt;|替换成使用|dstm    dstm--&gt;|可以hold住|se2    se2--&gt;|从而解决|nrt    end</code></pre><pre><code class="highlight mermaid">flowchart TD        style nd fill:lightgreen,stroke:#333,stroke-width:4px    style ile fill:#FFCCCB,stroke:#333,stroke-width:4px    st[同一个线程中]    t[事务]    t2[事务]    tm[一个范围很宽的标注了@Transactional的方法]    js[JPA的SQL操作]    tl[获取JDBC分布式锁]    js2[JPA的SQL操作]    tl2[获取JDBC分布式锁]    ps[Parallel Stream]    op[其自己线程池中的线程]    ct[当前线程]    ile[🪳无法更改事务隔离级别的问题🪳]    nd[❤️正确做法应该是缩小@Transactional的范围❤️]    subgraph 在同一个线程中先使用JpaTransactionManager启动一个事务然后尝试用DataSourceTransactionManager获取JDBC锁所导致的事务隔离级别变化的问题    ps--&gt;|并不总是仅利用|op    ps--&gt;|也会利用|ct    ct--&gt;|那么就会在|st    st--&gt;|跑|tm    tm--&gt;|先执行了一些|js    tm--&gt;|然后再尝试|tl    js--&gt;|已经open了|t    tl--&gt;|再去试图更改其隔离等级|t    t--&gt;|从而导致|ile    nd--&gt;|可以及时关闭|t2    t2--&gt;|避免把二者混在一起|js2    t2--&gt;|避免把二者混在一起|tl2    js2--&gt;|从而避免|ile    tl2--&gt;|从而避免|ile    end</code></pre><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>上面的问题都是由于业务代码和获取锁的代码二者同时依赖于同一个数据库。</p><p>而Spring Integration的分布式锁除了可以使用JDBC，其实也可以使用Redis或其他底层技术。<br>如果把上述代码中的JdbcLockRegistry全部替换为RedisLockRegistry，而保持其它代码不变，所有错误都会消失，不会再重现。</p><p>因为无论用到了哪一个线程，哪一个DB Transaction，也无论@Transactional标记的宽或者窄，Redis总是不会和JDBC&#x2F;DB撞车的。</p><p>可以通过修改上述代码中的此处来试用Redis：<br><a href="https://github.com/cuipengfei/Spikes/blob/c887a6f802bbfffc45ee29cbb91dac731243b7cd/jpa/lock-transaction-threads/src/main/resources/application.properties#L17-L18">https://github.com/cuipengfei/Spikes/blob/c887a6f802bbfffc45ee29cbb91dac731243b7cd/jpa/lock-transaction-threads/src/main/resources/application.properties#L17-L18</a></p><h2 id="Spring-Boot-3"><a href="#Spring-Boot-3" class="headerlink" title="Spring Boot 3"></a>Spring Boot 3</h2><p>如果升级到Spring Boot 3.1.5 + JDK 17，则Spring Integration JDBC会升到6.1.4(上述代码用的是5.x)，甚至不用替换成Data Source Transaction Manager，上述问题也会消失。</p><p>因为这一版本的Spring Integration JDBC的分布式锁实现在acquire lock时不再使用serializable的事务，而是改成了read committed。</p><p>这样，自然就规避了第一个问题，不再有serializable事务撞车。</p><p>而由于不再需要给锁使用Data Source Transaction Manager，自然也就解决了第二个问题，不再有同一个线程上两个transaction managers打架的问题。<br>不过，即便如此，缩小@Transactional的范围仍然是值得建议的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一个问题：在多个线程中同时运行隔离级别为serializable的事务而导致的无法重试获取锁的问题&quot;&gt;&lt;a href=&quot;#第一个问题：在多个线程中同时运行隔离级别为serializable的事务而导致的无法重试获取锁的问题&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    
    <category term="Java" scheme="https://cuipengfei.me/tags/Java/"/>
    
    <category term="分布式" scheme="https://cuipengfei.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="锁" scheme="https://cuipengfei.me/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>内存涨上去不肯下来 - 未必是内存泄漏</title>
    <link href="https://cuipengfei.me/blog/2023/08/26/not-mem-leak/"/>
    <id>https://cuipengfei.me/blog/2023/08/26/not-mem-leak/</id>
    <published>2023-08-26T13:45:00.000Z</published>
    <updated>2023-08-26T13:45:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在一个Kubernetes（K8s）集群中，部署了Prometheus和Grafana用于监控集群本身和应用的状态。</p><p>在其中一个Java应用对应的Pod级别观察到了内存上升的现象。具体而言，当该应用刚启动时，内存占用并不高。如果不发送请求给应用，内存将保持在启动时的水平上。</p><p>如果大量发送请求给应用并在短时间内持续发送，内存会迅速增加。这在一定程度上是正常的。</p><p>一旦内存增加之后，即使停止发送请求和压力，内存使用也不会下降，一直保持在高峰水平。</p><p>上面的状况是由Grafana中观察到的。</p><p>观察到的现象看起来像是内存泄漏，但实际上并不一定是内存泄漏。</p><p>原因有以下两点：</p><h1 id="1-在K8s中运行的Prometheus默认只使用了Node-Exporter"><a href="#1-在K8s中运行的Prometheus默认只使用了Node-Exporter" class="headerlink" title="1 在K8s中运行的Prometheus默认只使用了Node Exporter"></a>1 在K8s中运行的Prometheus默认只使用了Node Exporter</h1><p>这意味着Prometheus收集的数据是从操作系统的角度来看进程的内存使用情况，而不是从Java虚拟机（JVM）进程内部观察。</p><p>如果想要从JVM内部的视角观察堆内存的使用情况，例如堆的大小和使用情况，就需要让应用容器内包含有Prometheus的jmx exporter。</p><h1 id="2-关键是要观察堆内存的使用情况"><a href="#2-关键是要观察堆内存的使用情况" class="headerlink" title="2 关键是要观察堆内存的使用情况"></a>2 关键是要观察堆内存的使用情况</h1><p>要检查和确诊Java应用的内存泄漏，不能仅仅从操作系统的角度观察整个进程的内存使用情况，认为内存没有释放就是泄漏。这种观察方式是不准确的。</p><p>应该从JVM内部观察堆内存的使用情况，即使进行了垃圾回收（GC），堆内存仍然无法下降是一个明确的征兆。</p><p>例如，堆使用量（heap usage）基本上接近堆大小（heap size），并且堆使用量出现了频繁的小锯齿波动，这基本上表明GC在尝试清理旧的内存，但无法成功清理，这就是比较明显的迹象了。</p><p>因为JVM有时候不愿意释放从操作系统那里要来的内存。因此，仅仅根据从操作系统的角度观察内存是否增加而不下降来诊断为Java的内存泄漏是不准确的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在一个Kubernetes（K8s）集群中，部署了Prometheus和Grafana用于监控集群本身和应用的状态。&lt;/p&gt;
&lt;p&gt;在其中一个Java应用对应的Pod级别观察到了内存上升的现象。具体而言，当该应用刚启动时，内存占用并不高。如果不发送请求给应用，内存将保持在启</summary>
      
    
    
    
    
    <category term="Java" scheme="https://cuipengfei.me/tags/Java/"/>
    
    <category term="jvm" scheme="https://cuipengfei.me/tags/jvm/"/>
    
    <category term="内存" scheme="https://cuipengfei.me/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Spring Integration JDBC分布式锁 - TTL</title>
    <link href="https://cuipengfei.me/blog/2023/07/29/spring%20integration%20jdbc%20distributed%20lock/"/>
    <id>https://cuipengfei.me/blog/2023/07/29/spring%20integration%20jdbc%20distributed%20lock/</id>
    <published>2023-07-28T16:30:00.000Z</published>
    <updated>2023-07-28T16:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在项目中需要使用Spring Integration提供的基于JDBC实现的分布式锁。</p><p>在实践的过程中，我们遇到了一些有趣的问题，现在在此记录和总结一下。</p><p>一共遇到了两个问题，第一个和time to live有关，第二个还是和time to live有关。</p><h1 id="第一个问题：由于time-to-live默认值不够长而导致被动失去锁的问题"><a href="#第一个问题：由于time-to-live默认值不够长而导致被动失去锁的问题" class="headerlink" title="第一个问题：由于time to live默认值不够长而导致被动失去锁的问题"></a>第一个问题：由于time to live默认值不够长而导致被动失去锁的问题</h1><pre><code class="highlight mermaid">sequenceDiagramactor event_initiatorparticipant instance_1participant instance_2event_initiator-&gt;&gt;instance_1: do somethingnote over instance_1: instance 1 获得了 lockinstance_1-&gt;&gt;instance_1: start doing its thingevent_initiator-&gt;&gt;instance_2: do another thingnote over instance_2: instance 2 等待 locknote over instance_2: 等 ......note over instance_2: 等 ......note over instance_1: lock的超时时间TTL到，instance 1还没干完活，但是它失去了 lock&lt;br&gt;失去不同于主动release&lt;br&gt;失去lock后，instance 1还会继续干活&lt;br&gt;而这些活里面可能会有SQL写操作note over instance_2: instance 2 获得了 lockinstance_2-&gt;&gt;instance_2: start doing its thingnote over instance_1,instance_2: 此时二者同时干活，有撞车的风险，因为二者干活的先后顺序没有保证&lt;br&gt; instance 1尚未把它干完活后才能确定的状态写入DB，而instance 2已经开始干活了note over event_initiator,instance_2: 为了降低风险，可以： &lt;br&gt; ① 想办法尽量让instance 1能在超时前干完活 &lt;br&gt; ② 以防万一可以考虑在合适的时间节点延长锁的过期时间</code></pre><p>根据上图所示，我们有两个实例。</p><p>事件的触发者首先让第一个实例去处理一个事件。第一个实例获取了一个锁并开始执行相应的任务。</p><p>此时，事件的触发者又让第二个实例去处理另一个事件。第二个实例也想获取同一个锁，但由于第一个实例已经开始处理了，第二个实例无法获取锁，只能等待。</p><p>在理想情况下，第一个实例会在完成任务后释放锁，然后第二个实例就可以获取锁并开始执行相应的任务，这样就不会有任何问题。</p><p>但是，如果由于某种原因第一个实例处理任务的速度太慢，就会出现问题。</p><p>因为Spring Integration JDBC分布式锁会遵循Time to Live的参数，该参数确定了在获取锁后最长可持有锁的时间。</p><p>如果超出了这个时间，而另一个人想要获取该锁，则可以获取到锁。<strong>这是为了避免锁的持有者挂掉而导致其他人全部干等的防死锁机制。</strong></p><p>在这种情况下，就会有两个人同时运行。</p><p>我们本意是让锁保护资源以避免同时访问，但在这种情况下，资源会被同时访问。</p><p>如果这些访问中涉及到读取共享状态以决定后续行为以及写入其他人可能会读取的状态的操作，那么就会出现混乱。</p><p>在这种情况下，我们可以选择进行两个操作。</p><h2 id="给time-to-live一个合理的值"><a href="#给time-to-live一个合理的值" class="headerlink" title="给time to live一个合理的值"></a>给time to live一个合理的值</h2><p>实际上，相当于需要对运行时间进行合理的估算，然后尽量将time to live设置为能够覆盖该估算值的数值。</p><p>把这个估算出来的数字赋值给default lock repository的time to live就好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specify the time (in milliseconds) to expire deadlocks.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeToLive the time to expire deadlocks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTimeToLive</span><span class="params">(<span class="type">int</span> timeToLive)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.ttl = Duration.ofMillis(timeToLive);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/spring-projects/spring-integration/blob/7dcc0bb125eb5d72d9dc6cec0cc91bd4114336be/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/DefaultLockRepository.java#L190-L196">DefaultLockRepository</a></p><h2 id="选择在合适的时机renew"><a href="#选择在合适的时机renew" class="headerlink" title="选择在合适的时机renew"></a>选择在合适的时机renew</h2><p>即使我们进行了合理的估算，但这只是一个估计值，不是绝对精确的值。</p><p>换言之，在某些情况下，运行时间仍可能延续到time to live过期之后，从而面临两个人同时访问的风险。</p><p>为了避免这种情况，可以在适当的时候进行renew操作。</p><p>例如，在执行耗时较长的操作之前调用lock registry的renewLock方法，这样就相当于在执行耗时较长的操作之前重新获取了一次锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RenewableLockRegistry</span> <span class="keyword">extends</span> <span class="title class_">LockRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Renew the time to live of the lock is associated with the parameter object.</span></span><br><span class="line"><span class="comment"> * The lock must be held by the current thread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lockKey The object with which the lock is associated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">renewLock</span><span class="params">(Object lockKey)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/spring-projects/spring-integration/blob/7dcc0bb125eb5d72d9dc6cec0cc91bd4114336be/spring-integration-core/src/main/java/org/springframework/integration/support/locks/RenewableLockRegistry.java#L28-L37">RenewableLockRegistry</a></p><h1 id="第二个问题：time-to-live对于运行在同一个进程中的两个线程来说是不会自动生效的"><a href="#第二个问题：time-to-live对于运行在同一个进程中的两个线程来说是不会自动生效的" class="headerlink" title="第二个问题：time to live对于运行在同一个进程中的两个线程来说是不会自动生效的"></a>第二个问题：time to live对于运行在同一个进程中的两个线程来说是不会自动生效的</h1><pre><code class="highlight mermaid">sequenceDiagramactor event_initiatorparticipant instance_1participant instance_2event_initiator-&gt;&gt;instance_1: do somethingnote over instance_1: instance 1 获得了 lockinstance_1-&gt;&gt;instance_1: start doing its thingevent_initiator-&gt;&gt;instance_2: do another thingnote over instance_2: instance 2 等待 locknote over instance_2: 等 ......note over instance_2: 等 ......note over instance_1:instance 1的当前线程由于某种原因卡死了，没机会释放锁note over instance_1: lock的超时时间TTL到note over instance_2: instance 2 获得了 lockinstance_2-&gt;&gt;instance_2: start doing its thingnote over event_initiator,instance_2: instance 1的线程由于某种原因卡死而没机会释放锁&lt;br&gt;在TTL过后instance 2可以拿到锁并做事&lt;br&gt;这是我们希望看到的事情，因为这样可以避免由于一个线程卡死不释放锁而导致别人干等的局面</code></pre><p>在上述图中，我们描述了两个实例，即在不同机器（或容器）上运行的两个不同Java进程。这是跨进程协作的情况，这正是我们需要<strong>分布式</strong>锁的主要原因。</p><p>在这种场景下，time to live是有效的。它可以防止一个进程无法释放锁，从而导致其他进程一直等待锁而无法继续工作的局面的出现。</p><p>在跨进程协作中，time to live可以发挥作用，那对于同一个进程中的两个线程，<strong>是否同样有效呢？</strong></p><p>从概念上来说，如果能将其设计成同样有效的，则可以减轻使用者的认知负担。</p><p>但是，在Spring Integration JDBC的分布式锁实现中，time to live<strong>并不是这样的。它对于同一个Java进程中的两个线程来说是不会自动生效的。</strong></p><p>下面的图是一个它不会生效的具体例子。 </p><pre><code class="highlight mermaid">sequenceDiagramactor event_initiatorevent_initiator-&gt;&gt;instance_1: do somethinginstance_1-&gt;&gt;instance_1_thread_1: 分配工作给线程1note over instance_1_thread_1: instance 1 - thread 1 获得了 lockinstance_1_thread_1-&gt;&gt;instance_1_thread_1: start doing its thingevent_initiator-&gt;&gt;instance_1: do another thinginstance_1-&gt;&gt;instance_1_thread_2: 分配工作给线程2note over instance_1_thread_2: instance 1 - thread 2 等待 locknote over instance_1_thread_2: 等 ......note over instance_1_thread_2: 等 ......note over instance_1_thread_1: thread 1由于某种原因卡死了，没机会释放锁note over instance_1_thread_1: lock的超时时间TTL到note over instance_1_thread_2: thread 2 仍然获获取不到 locknote over instance_1_thread_2: 继续等也没用</code></pre><p>正如上图所示，第二个线程或同一个进程中的任何其他线程，即使继续等待锁，也无济于事。这也解释了time to live在这种情况下的无效性。</p><p><a href="https://github.com/cuipengfei/Spikes/blob/master/jpa/spring-jdbc-distributed-lock-issue/src/test/java/com/github/spring/example/LockTest.java">这份代码可以重现上面两幅图所描述的场景</a></p><p>要解决这种情况下的问题，则需要用到下面提到的这个expireUnusedOlderThan方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExpirableLockRegistry</span> <span class="keyword">extends</span> <span class="title class_">LockRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove locks last acquired more than &#x27;age&#x27; ago that are not currently locked.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> age the time since the lock was last obtained.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if the registry configuration does not support this feature.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">expireUnusedOlderThan</span><span class="params">(<span class="type">long</span> age)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/spring-projects/spring-integration/blob/7dcc0bb125eb5d72d9dc6cec0cc91bd4114336be/spring-integration-core/src/main/java/org/springframework/integration/support/locks/ExpirableLockRegistry.java#L27-L36">ExpirableLockRegistry </a></p><p>如果一个Java进程中的一个线程因为某种原因卡死了，从而无法释放锁。<br>在TTL过期之后，另一个线程在尝试获取同一个锁之前，可以调用expireUnusedOlderThan来强制释放该锁。<br>然后再尝试获取锁，就可以成功获取并继续工作。</p><h2 id="为什么不把time-to-live设计的更具有概念上的一致性？"><a href="#为什么不把time-to-live设计的更具有概念上的一致性？" class="headerlink" title="为什么不把time to live设计的更具有概念上的一致性？"></a>为什么不把time to live设计的更具有概念上的一致性？</h2><p>当涉及到跨越两个进程时，time to live会发挥作用。但是对于同一个进程中的两个线程来说，time to live就不再有效。这种同一个概念在不同的场景下表现出不同的行为，缺乏概念上的一致性，这可能会增加使用者的认知负担。</p><p>那Spring为什么要把它设计成这样呢？</p><p>以下是我的<strong>解读</strong>：</p><p>在分布式系统中，如果两个进程想要获得同一个锁，那么来得晚一些的进程实际上并不知道前一个进程目前处于什么状态，它是否已经死亡。在这种情况下，time to live成为了<strong>决策的唯一依据</strong>。如果time to live还没有过期，那么来得晚的进程认为它不应该获取该锁。一旦time to live过期，后续进程将把锁置于自己的控制之下，而不管前一个进程是否仍然活着。简而言之，由于<strong>缺少其他的决策依据</strong>，这种情况下只能选择依照time to live来简单粗暴的办事。</p><p>然而，对于同一个进程中的两个线程来说，情况就不同了。它们共享同一块内存空间(从实现层面来讲，同一个进程中的两个线程是共享<strong>同一份registry和repository</strong>的)。如果后续线程发现前一个线程在TTL过后还没有释放锁，则默认认为前一个线程仍然有继续工作的能力，因此它默认不会强制抢占锁。除非他在TTL之后等过一段时间之后觉得等不及了，这时候他<strong>可以选择</strong>强制把锁抢过来。</p><p>举个例子，就像在古代<strong>缺乏无线电通信</strong>的战争中。一支小队去执行任务，另一支小队待命。三个小时后，不论先前的小队是否成功，后续小队都必须出发参加战斗。因为除了这三个小时之外，你没有其他的决策依据。只要时间到了，我就开始行动。</p><p>但是，如果是同一支小队中的两个士兵，后面的士兵实际上可以在目视距离内看到前面的士兵是否仍然在执行任务。因此，<strong>即便是战友行动太慢</strong>了，他也可以选择多等待一会，让前面的士兵可以继续完成任务。当然，如果后面的士兵等不及了，想要立即行动，他也可以选择这样做。在这种情况下，后面的士兵<strong>具有更多的决策依据</strong>，因此他可以选择多等待一段时间或立即采取行动。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>第一个问题：由于time to live默认值不够长，而导致在还不该失去锁的时间点上过早地失去了锁（<strong>防死锁机制过早地介入了</strong>），解决方法是把TTL设置的足够大，以及在合适的时机做renew从而避免过早地失去锁。</p><p>第二个问题：time to live对于运行在同一个进程中的两个线程来说是<strong>不会默认生效</strong>的，从而导致应该失去锁的时间已经过了，但卡住的线程还没有释放锁，进而导致后续的线程拿不到锁的情况。解决方法是<strong>可以选择</strong>让同一个进程内的后来者线程使用expireUnusedOlderThan来强制剥夺锁(同一个进程中的两个线程，其中后来的那个具有更高的自由裁量权，不必只依据TTL一个指标来行事)。</p><pre><code class="highlight mermaid">mindmap  root(Spring Integration JDBC Distributed Lock)    默认TTL太短        设置长一些        renew    卡死了，没机会释放锁        其它进程可以在TTL过后拿到锁        同一个进程内的其它线程可以选择使用expireUnusedOlderThan</code></pre><p>锁的事，该失去就失去，不失去也强制失去。</p><p>锁的事，不该失去就不能失去，要失去也不许失去。</p><p><img data-src="/../images/spring-lock/LiuLuoGuo.jpg" alt="llg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在项目中需要使用Spring Integration提供的基于JDBC实现的分布式锁。&lt;/p&gt;
&lt;p&gt;在实践的过程中，我们遇到了一些有趣的问题，现在在此记录和总结一下。&lt;/p&gt;
&lt;p&gt;一共遇到了两个问题，第一个和time to live有关，第二个还是和time to </summary>
      
    
    
    
    
    <category term="Java" scheme="https://cuipengfei.me/tags/Java/"/>
    
    <category term="分布式" scheme="https://cuipengfei.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="锁" scheme="https://cuipengfei.me/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>当测试代码使用随机生成的输入数据时，该如何去做出断言</title>
    <link href="https://cuipengfei.me/blog/2023/03/18/generative-tests/"/>
    <id>https://cuipengfei.me/blog/2023/03/18/generative-tests/</id>
    <published>2023-03-18T14:34:00.000Z</published>
    <updated>2023-03-18T14:34:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一份有意思的代码"><a href="#一份有意思的代码" class="headerlink" title="一份有意思的代码"></a>一份有意思的代码</h1><p>最近看到了一份<span style="color:orange;">使用随机生成的数据作为测试输入</span>的有趣代码，把其大致思路用伪代码描述如下 </p><h2 id="需要被测的实现代码"><a href="#需要被测的实现代码" class="headerlink" title="需要被测的实现代码"></a>需要被测的实现代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calculateSomething</span>(<span class="params">inputData</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用inputData来计算结果</span></span><br><span class="line">    <span class="comment">// 假装这里有一些很复杂的逻辑</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是被测的函数，在此不管它算的是什么，总之它接受input，返回result。</p><h2 id="测试代码的helpers"><a href="#测试代码的helpers" class="headerlink" title="测试代码的helpers"></a>测试代码的helpers</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">generateInputData</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 用来生成测试所需的input数据</span></span><br><span class="line">    <span class="comment">// 所生成的数据具有一定的随机性</span></span><br><span class="line">    <span class="keyword">return</span> randomlyGeneratedInputData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fuction <span class="title function_">calculateExpectedResult</span>(<span class="params">inputData</span>)&#123;</span><br><span class="line">    <span class="comment">// 用来计算assertion所需要的expected值</span></span><br><span class="line">    <span class="keyword">return</span> expectedResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是测试代码的helper函数，一个用来生成测试所需的input，一个用来计算expected的值。</p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> repeatTimes = <span class="number">100</span>; <span class="comment">//总之是一个较大的数字，不一定非得是100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;repeatTimes; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> randomInputData = <span class="title function_">generateInputData</span>(); <span class="comment">//生成具有一定随机性的输入</span></span><br><span class="line">    <span class="keyword">var</span> expected = <span class="title function_">calculatedExpectedResult</span>(randomInputData); <span class="comment">//用测试helper算出expected</span></span><br><span class="line">    <span class="keyword">var</span> actual = <span class="title function_">calculateSomething</span>(randomInputData); <span class="comment">//用被测方法算出actual</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">expect</span>(actual).<span class="title function_">toEqual</span>(expected); <span class="comment">//断言二者相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是测试代码，反复运行多次，每次都生成具有随机性的input，然后把input传递给<code>calculatedExpectedResult</code>和<code>calculateSomething</code>，最后断言二者返回值是一致的。</p><p>这份代码和常见的测试不同，<span style="color:orange;">它使用的input data不是预先设定好的</span>，而是运行时随机生成的。这也是它有趣的原因。</p><h1 id="如何解读测试结果"><a href="#如何解读测试结果" class="headerlink" title="如何解读测试结果"></a>如何解读测试结果</h1><p>通常来说，当测试通过时，它意味着针对给定的输入，程序给出了<strong>符合预期</strong>的输出。</p><p>但是对于这一份代码来说，却并非如此。因为<span style="color:orange;">它的expected值是由一个helper函数计算得来，而非是一个已经被验证过是正确的值</span>。</p><p>那么，<span style="color:orange;">如果上述的测试代码能够执行通过，它是在传递什么信息给开发者呢？</span></p><ul><li><p>它意味着<code>calculatedExpectedResult</code>这个helper函数和<code>calculateSomething</code>这个被测函数之间，具有<span style="color:orange;">较高的相似性</span>，二者针对<span style="color:orange;">多组</span>一样的输入，可以给出一样的输出</p></li><li><p>如果我们把<code>repeatTimes</code>的数值<span style="color:orange;">调到非常高</span>，测试还能通过的话，那就说明<code>calculatedExpectedResult</code>这个helper函数和<code>calculateSomething</code>这个被测函数之间的<span style="color:orange;">相似性非常高，简直可以达到同卵双胞胎甚至是克隆体这种以假乱真的程度</span></p></li></ul><p><span style="color:orange;"><strong>这是我们需要的吗？</strong></span></p><p><span style="color:orange;">我们<strong>需要去探寻世界上是否存在那么一个函数，它的行为可以做到和<code>calculateSomething</code>极其贴近吗？</strong></span></p><p>我认为我们是不需要的。</p><p>我们需要的是去验证<code>calculateSomething</code>的行为是符合预期的。而不是去验证我能写出另一个和它的行为很像的函数来。</p><p>这就如同是：如果我去测试洗衣机的话，我希望验证的是某款洗衣机可以把衣服洗涤干净，并且不会损伤衣物。</p><p>而不是希望验证存在另一台洗衣机和我手里这一台表现一样。</p><p>要不然的话，我说不定会得到两台洗不干净衣服，还会损伤布料的洗衣机😄</p><h1 id="当测试代码使用随机生成的输入数据时，该如何去做出断言"><a href="#当测试代码使用随机生成的输入数据时，该如何去做出断言" class="headerlink" title="当测试代码使用随机生成的输入数据时，该如何去做出断言"></a>当测试代码使用随机生成的输入数据时，该如何去做出断言</h1><p>上面的代码虽然做的并不妥当，但是想要用随机生成的input数据去做测试其实<strong>并不是一个不合理的想法</strong>。</p><p>当我们人工编制的测试数据对于整体样本空间来说显得太小时，用随机数据去作为input数据也是一个不错的补充。</p><p>其关键在于，<span style="color:orange;"><strong>当我们给input引入了随机性的时候，我们该如何去assert其output是符合预期的？</strong></span></p><p>如果我们还是想要和常规测试一样，严格地去assert输出的值和预期<strong>相等</strong>，那么就会陷入上述代码的误区里。</p><p>但是如果思路换一下，不一定非得强求能够严格地去assert输出的值和预期<strong>相等</strong>，而是去assert输出值符合一定的规则。<br>这样，就无需在测试代码里重复去实现一遍，而只需要描述我们预期输入和输出之间符合哪种规则。</p><h1 id="Property-Based-Testing"><a href="#Property-Based-Testing" class="headerlink" title="Property Based Testing"></a>Property Based Testing</h1><p>而这，恰好就是Property Based Testing。</p><p>Property Based Testing是一种基于属性规约的测试方法，通过使用随机输入数据来验证程序的行为是否符合预期的属性规约。</p><p>在 Property Based Testing 中，<span style="color:orange;">测试用例是基于属性规约自动生成的</span>。</p><p>Property Based Testing 的基本流程如下：</p><ul><li><p>定义属性规约：定义程序的行为应该满足的属性规约，这些规约通常是<span style="color:orange;"><strong>通用的、可重用的、抽象</strong>的，而<strong>不是特定的测试用例</strong></span>。</p></li><li><p>生成随机数据：通过随机数据生成器生成随机数据，并将随机数据输入到程序中。</p></li><li><p>检查属性规约：将实际输出与定义的属性规约进行比较，如果程序的输出符合属性规约，则测试通过，否则测试失败。</p></li><li><p>修复代码：如果测试失败，则需要对程序进行修复，直到程序能够符合所有属性规约。</p></li></ul><p>一些常用的 Property Based Testing 框架包括 QuickCheck、Hypothesis、ScalaCheck、fast-check 等。</p><p>下面是一段使用Property Based Testing的样例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fc = <span class="built_in">require</span>(<span class="string">&#x27;fast-check&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Property-Based Testing，测试加法函数</span></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;加法满足交换律&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fc.<span class="title function_">assert</span>(fc.<span class="title function_">property</span>(fc.<span class="title function_">integer</span>(), fc.<span class="title function_">integer</span>(), <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">add</span>(x, y) === <span class="title function_">add</span>(y, x);</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;加0不影响结果&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fc.<span class="title function_">assert</span>(fc.<span class="title function_">property</span>(fc.<span class="title function_">integer</span>(), <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">add</span>(x, <span class="number">0</span>) === x;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;正数加负数，结果小于原数&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fc.<span class="title function_">assert</span>(fc.<span class="title function_">property</span>(fc.<span class="title function_">integer</span>(<span class="number">1000</span>, <span class="number">1</span>), fc.<span class="title function_">integer</span>(-<span class="number">1</span>, -<span class="number">1000</span>), <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">add</span>(x, y) &lt; x;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;负数加正数，结果大于原数&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fc.<span class="title function_">assert</span>(fc.<span class="title function_">property</span>(fc.<span class="title function_">integer</span>(-<span class="number">1000</span>, -<span class="number">1</span>), fc.<span class="title function_">integer</span>(<span class="number">1</span>, <span class="number">1000</span>), <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">add</span>(x, y) &gt; x;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;负数加负数，结果小于原数&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fc.<span class="title function_">assert</span>(fc.<span class="title function_">property</span>(fc.<span class="title function_">integer</span>(-<span class="number">1000</span>, -<span class="number">1</span>), fc.<span class="title function_">integer</span>(-<span class="number">1000</span>, -<span class="number">1</span>), <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">add</span>(x, y) &lt; x;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;正数加正数，结果大于原数&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fc.<span class="title function_">assert</span>(fc.<span class="title function_">property</span>(fc.<span class="title function_">integer</span>(<span class="number">1</span>, <span class="number">1000</span>), fc.<span class="title function_">integer</span>(<span class="number">1</span>, <span class="number">1000</span>), <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">add</span>(x, y) &gt; x;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;任何数加自己，结果是两倍&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fc.<span class="title function_">assert</span>(fc.<span class="title function_">property</span>(fc.<span class="title function_">integer</span>(), <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">add</span>(x, x) === x * <span class="number">2</span>;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上代码中所使用的fast-check(fc)会帮助我们<span style="color:orange;">生成大量的</span>具有随机性的输入数据，但是我们并<span style="color:orange;">没有去assert add的返回值等于某个具体的数字</span>，而是去判断<span style="color:orange;">add这个函数在其输入值符合特定规则时其返回值符合我们通过fc定义的规律</span>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一份有意思的代码&quot;&gt;&lt;a href=&quot;#一份有意思的代码&quot; class=&quot;headerlink&quot; title=&quot;一份有意思的代码&quot;&gt;&lt;/a&gt;一份有意思的代码&lt;/h1&gt;&lt;p&gt;最近看到了一份&lt;span style=&quot;color:orange;&quot;&gt;使用随机生成的数据作为</summary>
      
    
    
    
    
    <category term="testing" scheme="https://cuipengfei.me/tags/testing/"/>
    
  </entry>
  
  <entry>
    <title>卢瑟经济学</title>
    <link href="https://cuipengfei.me/blog/2022/10/28/loser-economy/"/>
    <id>https://cuipengfei.me/blog/2022/10/28/loser-economy/</id>
    <published>2022-10-28T08:48:00.000Z</published>
    <updated>2022-10-28T08:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://img14.360buyimg.com//n0/jfs/t1/176451/22/10402/376750/60a37fb7E23ecc0e3/aa8754102dc19767.jpg"></p><h1 id="此书讲什么"><a href="#此书讲什么" class="headerlink" title="此书讲什么"></a>此书讲什么</h1><p>马克思《资本论》讲的三件事：</p><ul><li>原始积累靠暴力</li><li>贫富差距会扩大</li><li>最终自毁</li></ul><h1 id="经济与政治"><a href="#经济与政治" class="headerlink" title="经济与政治"></a>经济与政治</h1><p>经济学是有阶级属性的。</p><p>哪个阶级现在说了算，哪个阶级的经济学就流行。</p><p>反之亦然，可以通过观察哪个学说流行来倒推谁说了算。</p><ul><li>地主： 重农主义</li><li>商人： 重商主义</li><li>新兴资产阶级： 自由市场和劳动价值论</li><li>工人阶级： 劳动价值论</li><li>资产阶级卷土重来： 边际效用价值论</li></ul><p>不同的阶级有不同的价值理论，这就如同不同的宗教信仰对善行的定义是不一样的。<br>统治阶级的经济学，是为统治阶级寻找合法性的。被统治阶级的经济学，自然是为被统治阶级申诉的，顺便控诉对方。<br>市场是不是真的有效，到底什么创造价值，其实就看谁来解释。</p><p>按照卢瑟经济学，土地没有价值。土地的所有制，使土地所有者有权向在土地上生活工作的人要求贡赋。土地所有权越垄断，要求的地租就越高。土地垄断程度高的地方，绝对地租就高。<strong>所以房子的昂贵并不是土地的价值昂贵，而是土地的所有权高度垄断，导致地租昂贵。</strong></p><h1 id="危机的表征与对其的解释"><a href="#危机的表征与对其的解释" class="headerlink" title="危机的表征与对其的解释"></a>危机的表征与对其的解释</h1><ul><li>妈妈，天这么冷，我们家为什么不生火呢？</li><li>因为你爸爸失业了，我们没有钱去买煤。</li><li>小孩继续问：“妈妈，爸爸为什么失业呢？”</li><li>他妈妈说：“因为你爸爸的煤矿倒闭了。〞</li><li>小孩接着问：“妈妈，爸爸的煤矿为什么会倒闭呢？”</li><li>他妈妈说：“因为没有人买你爸爸的煤矿的煤，煤卖不出去，所以煤矿倒闭了。”</li></ul><p>与封建时期的危机不同，资本主义条件下的危机的特点：</p><ul><li>不是产品不足而是产品过剩</li><li>不是劳动力被透支而是劳动力被闲置</li><li>不是没稂食吃，而是产能过剩导致企业破产，然后大家下岗，没钱买粮食吃</li><li>产能有的是，就是没销路；粮食有的是，就是没钱买；劳动力有的是，就是没活干</li><li>这种危机有很强的周期性，按时袭击经济</li></ul><p>工业化的资本主义生产的特点是所有的人，都为别人生产商品，所有的人都消费别人生产的商品。</p><p>工人一旦失业就很难找到原有工资待遇水平类似的工作。因为全社会的资本家几乎在一夜之间觉得他们的劳动不值钱了。到处都是堆积的商品，老板做什么也不赚钱，索性停产，老板不生产，工人的劳动也就不值钱了，对老板就没有用了。</p><p>稳拿经济学假设工人工资水平下降，老板会增加劳动力的需求。问题是，老板的需求与产品的销售有关，当销售情况不改善的时候，工人工资再便宜，老板也没有兴趣多雇人。</p><p>社会金字塔的平级之间是可以自动调节的，但是上下级之间却不能自由调节。当社会需要的产品与资本家提供的产品不对称的时候，资本家能自行改变产品结构。当社会需要的劳动力与工人能提供的劳动力不对称的时候，工人能自动改行。<strong>但是当塔的上级不愿意投资和消费的时候，塔的下级却没有能力去代替上级投资或消费。这才是真正的困难。</strong></p><h2 id="凯恩斯"><a href="#凯恩斯" class="headerlink" title="凯恩斯"></a>凯恩斯</h2><p>1936年，凯恩斯在他的著作《就业、利息和货币通论》中提出在资本主义制度下不是产品做得出就卖得掉，有很大一部分产品注定无法消费，如此必然导致资本家压缩生产，工人失业。为了挽救资本主义，多余的产品需要政府帮助消费掉，甚至是浪费掉。无法消费的产品的量随着贫富差距的增大而增大，换句话说，贫富差距越大的经济体，失业问题越严重。</p><p>消费需求不足和投资需求不足将产生大量的失业，形成生产过剩的经济危机。</p><p>当投资的利润还不如利率的时候，资本家就都不投资，持币观望，转而存银行吃利息。如果这个时候利率高，那么投资就非常少了。<br>其实还是消费需求不足。因为投资需求归根到底完全仰仗消费品的销售情况。</p><p>觊恩斯主义是用通胀换就业：后遗症就是通货膨胀。</p><h2 id="弗里德曼"><a href="#弗里德曼" class="headerlink" title="弗里德曼"></a>弗里德曼</h2><p>在弗里德曼看来，政府</p><ul><li>第一要务是国防</li><li>第二要务是保证契约的实施</li><li>而财富分配则属于是一个人认为有益，另一个人认为是有害的</li></ul><p>但是如果我们换一个角度看弗里德曼的要求的话，就会发现三件事说起来冠冕堂皇：</p><ul><li>第一是不要外来势力干涉稳拿</li><li>第二是要求法律是保证契约的执行，不要插手稳拿利用契约合法地抢劫卢瑟 </li><li>第三是不要试图触碰，甚至返还抢来的赃物</li></ul><p>对弱者来说，与强者费厄泼赖就是最大的不公平。自愿和双方获利，只有在双方经济地位接近的时候才能存在。</p><p>关税保护了幼年时期的美国资本，避免被英国资本吞噬，避免成为英国的经济殖民地</p><p><strong>弗里德曼和凯恩斯的理论冲突，与李嘉图和马尔萨斯的冲突异曲同工。都是两个集团在争夺经济主导权。</strong></p><p>财产具有自我汇集的效应，古往今来小农经济就没有长期稳定存在过。小农如果不能进化为大地主，那么迟早会被地主吞并。</p><p>资本主义社会的矛盾的核心不是生产力的发展，而是资本主义分配制度。</p><p>自由市场加私有产权，只要一代人就能在社会上建立起人与人之间不可逾越的鸿沟。能力的竞争最多在一代人之同发挥作用，一代人之后资产确立统治地位。</p><p>其实，对大资本家来讲，周期性的经济危机未必是坏事。经济危机可以促进资本汇聚到强者也就是大资本家手中。</p><p>认识经济危机并不复杂，解决经济危机（至少从理论上）也不复杂，复杂的是后面纠葛的利益。经济危机袭扰人类将近 200 年了，解决的办法，无论是书面还是实战的都不少：</p><ul><li>希特勒的解决方式是寻求生存空间。从经济殖民地获得廉价的原材料，过剩的产品向经济殖民地倾销。</li><li>凯恩斯的解决方式，是政府印钱，由政府创造需求。多余的产能浪费掉，资本家不是没钱不生产，不雇用工人吗？用印钞机给他们钱就是了。政府有印钞机还愁没钱支付？后果是通货膨胀或者资产泡沫。</li><li>罗斯福的解决方案，是给工人更大的权利，支持他们与资本家斗争。增加财产税让稳拿出血，通过转移支付，给卢瑟更多的福利。</li></ul><p>这么多方法，多数效果都不好。这是因为稳拿处于塔尖的地位，直接调节总量而不触动分配模式的解决方案，不过是给稳拿更多的发财的机会，导致更严重的分配不公。如果触动分配模式，又难免遭到稳拿的强大阻碍，很可能半途而废。</p><h1 id="资产的属性"><a href="#资产的属性" class="headerlink" title="资产的属性"></a>资产的属性</h1><p>对产来说，具体选择哪种方式，取决于哪种方式来钱最容易，或者说风险更小，效率更高。产是否发展生产，并不确定，是否会改善多数人的生活则更不确定。我们没有任何理由认为，产权明晰加自由市场经济一定会发展生产力，提供更多物美价廉的产品。</p><p>对苏联这样的前社会主义国家来说，完全市场化和产权私有化（或者说产权明晰化）的结果，唯一能确定的就是私人产权迅速膨胀，出现一批人造寡头，其余的多数人则沦为这些寡头的奴隶。</p><p>稳拿经济学追求帕累托最优，认为在这种情况下各种资源得到最有效地利用，紧缺资源获得最大价值。稳拿经济学认为，自由的市场，最终会达到帕累托最优：就是不可能再改善某些人的境况，而不使任何其他人受损。在市场中，社会的各类人群在不断追求自身利益最大化的过程中，可以使整个社会的经济资源得到最合理的配置。</p><p>自由市场会导致帕累托最优，这是完全正确的。但是这种帕累托最优，却不是多数人之福—既不是卢瑟之福，也不是稳拿之福。自由的市场最终会造成财产的高度集中，拥有这些产的稳拿对社会总产品有极大的分配权。数量众多的卢瑟，却只有极其有限的分配权。所以，<strong>每次天下大乱以前，社会都处于或接近帕暴托最优的状态</strong>：不伤害地主的利益，农民就无法改着自己的生活，就要死于饥寒交迫，这时农民就不再尊重市场交易规则，采用暴力推翻产的权威。</p><h2 id="亚当斯密-科斯"><a href="#亚当斯密-科斯" class="headerlink" title="亚当斯密 &amp; 科斯"></a>亚当斯密 &amp; 科斯</h2><p>亚当.斯密提出，个人满足私欲的活动将促进社会福利，只要自由放任，市场的看不见的手发挥作用，最终就将实现全社会的富足。科斯提出只要产权明晰，把一切交给市场中看不见的手来发挥作用；然后就能建立安宁祥和的社会，一切都会万事大吉。<br>在斯密的时代，正是大饼迅猛变大的时代。那时资本主义刚刚登场不久，每一个资本家的资本量都很小，社会中还有大量封建残余。资本主义处于自由竟争时期，正在经历第一次产业革命，从手工作坊向大工厂过渡，劳动者还有当小老板或者当雇用工人的選擇。那时对产来说最有效率的自我增值的手段是发展生产力，资本主义相对封建残余来说极大地推动了生产力发展，所以这样说并不为过。经过200多年以后，到今天还这样说，那就是彻头彻尾的胡说了。</p><p>稳拿经济学提出只要交易就能改善全社会的福利。卢瑟经济学认为改善福利的过程复杂得多。价值来自生产劳动，市场并不创造价值。个人也许可以通过炒房子炒地皮获得极大的收益，但是社会总体生活不会改善，因为总消费品的量，无论是产量，还是销售量都并没增加。</p><p>可能存在大饼整体萎缩，大家吃得越来越少，某些个体却吃得越来越多的情况。</p><p>资本论想说明的事情之一：工人创造的剩余价值越多，资本家的资产越多，工人与资本家之间差距不断拉大，最终成为资本的奴隶：死劳动（工人以前创造的剩余价值）牢牢抓住活劳动（工人）。</p><p>产是什么：<strong>产是用于获得剩余价值依据的物化的媒介。人类社会总产品是块大饼，产是稳拿用来切大饼的刀。</strong></p><p>土地价格的攀升，不是土地自己产生价值，而是土地上产业资本不断壮大，地主要求其支付的贡税越来越多。如果土地上的产业萧条，土地价格必然暴跌。</p><p>依靠土地获得剩余价值，是对资本主义的阻力而不是动力。土地所有权高度集中，产业资本家获得的利润太薄，他们很难有足够的剩余价值扩大再生产。此外，土地垄断会造成土地利润高于社会平均利润，资本家的剩余资本必然会选择投机土地，而不是投资于原料或设备进行扩大再生产。引申一步，如果土地成为资本的主体，那么社会必然停滞不前，甚至倒退。历史上，土地所有权高度集中的地区很难诞生资本主义。</p><h1 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h1><p>绝大多数的交易，不过是从甲账户转移到乙账户。如果我们把金融机构看为一个整体的话，就会发现几乎所有的货币都在金融机构的手里。</p><p>资本主义世界的特点之一，就是<strong>强者恒强，这不仅仅表现在获得利润的时候强者有权先享用大饼，也表现在遇到危机的时候强者付出的代价更少</strong>。</p><p>国家是经济上占统治地位的阶级进行阶级统治的政治权力机构。是一个成长于社会之中而又凌驾于社会之上的、以暴力或合法性为基础的、带有相当抽象性的权力机构。国家有阶级性，国家由经济上占优势地位的阶级控制。国家有暴力性，而且是最终的暴力。国家的存在是为了维护统治阶级的经济利益。国家是一个阶级压迫另一个阶级的机器，是使一切被支配的阶级受一个阶级控制的机器。</p><p>由于暴力是唯一能对抗资本的要素，而代表国家行使暴力的官僚并不总是靠得住的。对资本来说，暴力的忠诚度是值得怀疑的。所以，<strong>资产阶级成为统治阶级以后，一直试图把国家的作用局限在最小的范围</strong>。对内保证社会治安，对外抵御外敌人侵，是资本主义国家的主要任务。至于维护社会的公平，扶助弱小，是资本家最忌讳的事情。</p><p>如果所有的劳动者都去大学深造，最终的结果将是大学深造对提高工资收入水平的作用目益下降。</p><h1 id="产销过程"><a href="#产销过程" class="headerlink" title="产销过程"></a>产销过程</h1><p>消费与生产是对立统一的，没有消费，就不会有生产。我们无法想象一个社会开采矿石，制造机器，最终的目的仅仅是为了开采更多的矿石和制造更多的机器。生产的各种产品最终都会被消费。</p><p>希望每当社会总需求不足的时候，就能出现新一轮技术革新导致投资高潮，进而消化掉多余产能，這是不现实的事情。</p><p>资本家投资的目的是获得更多的货币。如果社会1000万资本的平均利润率是10%，那么资本家如果投入1000万购买新设备、雇用新工人，那么他必然要求 100 万的利润。换句话说，原先社会存在1000 万的需求不足的缺口，在资本家投资以后，1000万的缺口消失了。但是，在1000万的投资实现产能以后，就将出现1100 万的需求缺口。所以，长期靠资本家投资替代工人需求是不现实的。</p><p>消费不足，并不见得是产业资本剥削得太严重，而是<strong>整个稳拿集团</strong>剥削得太严重。<strong>工人贡獻的剩余价值，在产业资本、土地，金融和暴力之间分配</strong>。</p><p>如果大批企业贷款偿还能力都发生了回题，那么银行会发现自己几乎在一夜之间成为最大的实业资本家，大批的货币资本收不回來，变成抵押物。更糟糕的是，这些抵押物没有人要，而且在不断贬值。</p><p>自从资本主义诞生起，尽管<strong>绝对消费水平不断上升，但是相对消费不足一直没有克服</strong>。</p><h1 id="垄断"><a href="#垄断" class="headerlink" title="垄断"></a>垄断</h1><p>每次经济危机都会成为大资本屠杀小资本的过程。年次危机结束后所有的幸存者都有机会廉价获得遇难者的一切生产资源，包括原料、生产设备、熟练工，当然也包括他们的市场。</p><p>自然界的进化，物种由多样归于多样，面人类社会资本的进化，最终归于“一”。这个过程是单向、清晰、不可逆的。</p><p>如果把社会总生产看成一个庞大的网络，那么我们可以看到一些最基本的生产、生活要素在极少数企业的控制之下，这些企业就是真正的帝王资本。他们控制交叉的行业，影响、操纵整体经济。在他们之下，则是一些诸候。他们垄断本行业，影响、操纵某一种或几种商品。在这些诸侯之下，则是一些中、小资本，他们为上面帝王和诸候资本服务，是“臣民资本”。再向下，则是一些零散的资本，他们数量很多，充满帝王和诸候触角不愿触及的“鸡肋”行业，彼此之间激烈竟争。至于劳动力，则处于完全不入流的状态。</p><p>垄断帝国则是在“暴力归公”的基础上，完全依靠财产的力量，在市场交易中逐步建立起来的。需要注意的是，这里的暴力的“归公”、是归资产阶级的“公”，而不是全民的“公”，这里的暴力，是资产阶级的暴力，这种暴力不在资产阶级内部使用，却不吝于镇压无产阶级。</p><p>暴力和资本走到一起，有两种方式：资本领导暴力；暴力领导资本。两种方式的起源与各个资本主义国家历史进程有关。不论哪种方式，最终殊途同归：最终都將建立资本与暴力结合的密严阶级专政，这个专政將处于官僚统治集团的统治之下，如果我们认为垄断大企业的管理层也是一种准官僚集团的话。</p><p>统治阶级争夺被统治阶级的时候，彼此是仇敌。一旦一方彻底认输，统治阶级内部的阶级感情又重新油然而生。</p><p>并不是衣食足不足的问题，而是达到一个社会阶层之后，对普通劳动者紧缺的生活必需品，对某个阶层中人已经不再是紧缺的，而是极大丰富的。对普通人来说很珍贵的东西，对这个层次上的人来说，已经不值得为此发生冲突了。为这些基本生活必需品发生冲突，对这个层面的人来说，是丢脸的事情。这个层次的稳拿，在彼此谦逊礼貌的气氛中，瓜分着社会总产品的大饼。底层之间争斗的越激烈，顶层吃到的大饼份额越多。</p><p>如果要维护人类社会系统的长期存在就必须从两个方面着手：第一，为领导阶层引入新鲜血液，避免小范围通婚造成的种群退化；第二，破解财富的单向流动过程，避免财富过度集中导致社会内部压力持续上升。</p><p>由于强者恒强，任何人类社会的终极形态，不论是官僚主动或者资本家主动，地主主导或者奴隶主主导，<strong>如果不干涉的话，都是通往奴役之路</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img14.360buyimg.com//n0/jfs/t1/176451/22/10402/376750/60a37fb7E23ecc0e3/aa8754102dc19767.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;此书讲什么&quot;&gt;</summary>
      
    
    
    
    
    <category term="读书" scheme="https://cuipengfei.me/tags/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="经济" scheme="https://cuipengfei.me/tags/%E7%BB%8F%E6%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>一些关于银行的散碎知识</title>
    <link href="https://cuipengfei.me/blog/2022/01/29/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E9%93%B6%E8%A1%8C%E7%9A%84%E6%95%A3%E7%A2%8E%E7%9F%A5%E8%AF%86/"/>
    <id>https://cuipengfei.me/blog/2022/01/29/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E9%93%B6%E8%A1%8C%E7%9A%84%E6%95%A3%E7%A2%8E%E7%9F%A5%E8%AF%86/</id>
    <published>2022-01-29T06:40:50.000Z</published>
    <updated>2022-01-29T06:40:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="金本位时期金融机构的层级结构"><a href="#金本位时期金融机构的层级结构" class="headerlink" title="金本位时期金融机构的层级结构"></a>金本位时期金融机构的层级结构</h2><p>19th century nation state financial institution hierarchy </p><p><img data-src="/images/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E9%93%B6%E8%A1%8C%E7%9A%84%E6%95%A3%E7%A2%8E%E7%9F%A5%E8%AF%86/Untitled.png" alt="Untitled"></p><p>央行的负债≈银行的资产≈货币</p><p>银行的负债≈私营部门的资产≈存款</p><h2 id="亏钱先亏哪儿？"><a href="#亏钱先亏哪儿？" class="headerlink" title="亏钱先亏哪儿？"></a>亏钱先亏哪儿？</h2><p><img data-src="/images/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E9%93%B6%E8%A1%8C%E7%9A%84%E6%95%A3%E7%A2%8E%E7%9F%A5%E8%AF%86/Untitled1.png" alt="Untitled"></p><p>假设左侧亏了5块钱，且左右必须平，则右侧也必须减少5。</p><p>不能先减liability，因为债权人优先级较高，只能先减equity。</p><h2 id="Liquidity和Solvency"><a href="#Liquidity和Solvency" class="headerlink" title="Liquidity和Solvency"></a>Liquidity和Solvency</h2><p><img data-src="/images/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E9%93%B6%E8%A1%8C%E7%9A%84%E6%95%A3%E7%A2%8E%E7%9F%A5%E8%AF%86/Untitled2.png" alt="Untitled"></p><p>cash reserve &gt; 0，则具有一定的流动性</p><p>net worth &gt; 0，则具有一定的偿付能力</p><p>流动性和偿付能力的高低则取决于到底比零大多少。</p><h2 id="资金来源"><a href="#资金来源" class="headerlink" title="资金来源"></a>资金来源</h2><p><img data-src="/images/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E9%93%B6%E8%A1%8C%E7%9A%84%E6%95%A3%E7%A2%8E%E7%9F%A5%E8%AF%86/Untitled3.png" alt="Untitled"></p><p>活期存款 (Demand deposit)</p><p>存款证书&#x2F;大额存单 (Certificate of deposit)</p><p>附买回协议（repurchase agreement、repo，也称为附买回协定、附买回交易，回购协议、卖出回购或正回购）</p><p>商业票据（Commercial Paper）</p><p><strong>负债业务</strong>是商业银行形成资金来源的业务</p><p><strong>存款</strong>是银行<strong>对存款人的负债</strong>，是银行最<strong>主要的资金来源</strong></p><h2 id="四种风险"><a href="#四种风险" class="headerlink" title="四种风险"></a>四种风险</h2><p>银行的风险种类较多，最主要的风险有四种：</p><p><strong>信用风险、市场风险、流动性风险和操作风险</strong> </p><p><strong>信用风险</strong>是指借款人因各种原因未能及时、足额偿还债务或银行贷款而违约的可能性。发生违约时，债权人或银行必将因为未能得到预期的收益而承担财务上的损失。 </p><p><strong>市场风险</strong>是指未来市场价格（利率、汇率、股票价格和商品价格）的不确定性对企业实现其既定目标的影响 </p><p><strong>流动性风险</strong>是指因市场成交量不足或缺乏愿意交易的对手，导致未能在理想的时点完成买卖的风险；或银行本身掌握的流动资产不能满足即时支付到期负债的需要，从而使银行丧失清偿能力和造成损失的可能性。 流动性风险，一方面是一种<strong>本原性</strong>风险，是由于流动性不足造成的；另一方面也是最常见的情况，是其他各类风险长期隐藏、积聚，最后以流动性风险的形式爆发出来。从这种意义上讲，流动性风险是一种<strong>派生性</strong>风险，即流动性不足，可能是由于利率风险、信用风险、经营风险、管理风险、法律风险、国家风险、汇率风险等风险源所造成的，银行最终陷入流动性风险中不能自拔。 </p><p><strong>操作风险</strong>的正式定义是：由于内部程序、人员和系统的不完备或失效，或由于外部事件造成损失的风险</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;金本位时期金融机构的层级结构&quot;&gt;&lt;a href=&quot;#金本位时期金融机构的层级结构&quot; class=&quot;headerlink&quot; title=&quot;金本位时期金融机构的层级结构&quot;&gt;&lt;/a&gt;金本位时期金融机构的层级结构&lt;/h2&gt;&lt;p&gt;19th century nation st</summary>
      
    
    
    
    
    <category term="银行" scheme="https://cuipengfei.me/tags/%E9%93%B6%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>TW十四载</title>
    <link href="https://cuipengfei.me/blog/2021/12/17/tw14years/"/>
    <id>https://cuipengfei.me/blog/2021/12/17/tw14years/</id>
    <published>2021-12-17T06:40:50.000Z</published>
    <updated>2021-12-17T06:40:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>2007年，我在读大二。</p><p>当时经常会去学校食堂对面的报刊亭买杂志，一本，是《大众软件》，另一本，是《程序员》。</p><img data-src="/images/14years/cxy-2007-06.png"/><p>印象中当时《程序员》上的多数文章充满了我没听过的各种缩写与稀奇古怪的名词，文风是老成持重，我看不懂，但很是佩服。</p><p>而这当中偶尔会夹杂着几篇文风犀利，睥睨天下的文章，加上作者头像很是非主流，我虽也看不懂，但印象深刻。<br>这些犀利文章的作者，便经常冠有TW的头衔。</p><p>2012年，我在一家小软件公司上了两年的班。<br>当时我们每半年发布一个版本，每到要发布前夕，程序员便都停止写代码，去做回归测试。</p><p>经常会发现半年前发布时还是ok的功能，在这六个月里被改错了，得修。<br>我隐隐觉得这不对劲，再六个月之后还是会出现类似的状况，老是靠大家停工去做回归测试不是个办法，我们总是会“狗熊掰棒子，掰一根丢一根”。</p><img data-src="/images/14years/gxbbz.png"/><p>恰在此时，邮箱收到了来自TW的面试邀请。<br>到了这会，我其实已经记不清楚大学时看的《程序员》杂志上有什么内容了，不过TW这个名字还是有些印象。<br>再去一查，这家公司还出过不少书，推崇做自动化测试，注重软件质量，而这些正是我当时所在的小公司所缺乏的。</p><p>于是便接受了面试邀请，做了Mars Rover的题目，去参加了办公室面试。<br>面试时还见到了《软件设计精要与模式》的作者。<br>之后便加入TW成为了一名21世纪的程序员。</p><p>从第一次看到《程序员》杂志上的文章到眼下的2021年，有14年了。<br>14年挺长的，从上小学到高中毕业，也才12年。</p><p>时间跨度长，变化也就多，不过当时持有的很朴素的观念不太容易变：<br>软件至少要做对，一旦做对了之后，要避免“狗熊掰棒子，掰一根丢一根”。</p><p>就好像一个木匠师傅，用了锛凿斧锯，费力做成了板凳，肯定是不希望这个凳子给人坐了两天之后就开始“嘎吱吱”。</p><p>码匠师傅，亦当如是。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2007年，我在读大二。&lt;/p&gt;
&lt;p&gt;当时经常会去学校食堂对面的报刊亭买杂志，一本，是《大众软件》，另一本，是《程序员》。&lt;/p&gt;
&lt;img data-src=&quot;/images/14years/cxy-2007-06.png&quot;/&gt;

&lt;p&gt;印象中当时《程序员》上的多数文章</summary>
      
    
    
    
    
    <category term="TW" scheme="https://cuipengfei.me/tags/TW/"/>
    
  </entry>
  
  <entry>
    <title>《大目标》一书中的有趣观点</title>
    <link href="https://cuipengfei.me/blog/2020/07/05/%E5%A4%A7%E7%9B%AE%E6%A0%87/"/>
    <id>https://cuipengfei.me/blog/2020/07/05/%E5%A4%A7%E7%9B%AE%E6%A0%87/</id>
    <published>2020-07-05T04:23:28.000Z</published>
    <updated>2020-07-05T04:23:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>工业化、现代化、城市化、民主化、自由化、市场化、全球化，不一定要姓“西、资、基”。</p><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><p>五常的否决权是对大国毁灭性力量的承认。核武器，氢弹，洲际导弹，核潜艇，多弹头分导。</p><p>退缩不会让狼群放弃供给，逃跑不会让狼群放弃追捕，倒下不会让狼群放弃杀戮。</p><p>大国没资格投降。</p><p>美国对日本可以援引《共同防卫协定》只会日本空军。韩国三军的最高指挥权本来就归美军。</p><p>冷战的本质是3.5亿的苏联东欧工业人口和欧美日6亿的工业人口抢全球的资源和市场。</p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><p>把人当人看是工业社会才能做到的事。医疗器具，消毒不再昂贵，简单高效。<br>当物质上的富足让社会不再需要合理合法地牺牲掉一些人而保证另一些人的生存时，才能进入文明。</p><p>1962年，中国粮食总产量1.6亿吨。1978年3亿吨。不是靠积极性。而是靠化肥。<br>化肥让农民有了余粮和闲暇，从农业中解放出来的生产力投入工业。</p><p>工业化：用机器造机器，然后用造出来的机器去造别的东西。</p><p>世界上勤俭的不止有中国人，勤俭了几千年也没有变的富裕。工业化才能让勤俭变成资本。</p><p>李鸿章去找“造器之器”，是找造火器的机器，而不是造机器的机器。</p><p>机器用钢铁造的，用的是煤炭或者煤炭生成的电能。欧盟来源于煤钢共同体。</p><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><p>美国“绿卡战士”的阵亡率比美籍士兵高出一倍。</p><p>钱并不是财富，说“有钱”其实意味着“有货”。</p><p>美元作为结算货币收全球铸币税。各国越小，产业链越分散，美元铸币税收的越开心。</p><p>经济活动的本质是物质生产。</p><p>枪杆子里面出石油。</p><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><p>工业与手工业的最大区别：工业可以升级。</p><p>西班牙，英国，美国，三个世界性的大帝国。<br>兴起的原因是先进的生产技术，发达的制造业能创造财富也支持了强大的军队。<br>然后不劳而获，停滞衰退。</p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><p>与之前的强国相比，苏联的工业化不依赖殖民地的市场和资源。</p><p>重工业是核心，轻工业释放重工业制造的生产能力。</p><p>苏联利用西方几次危机，抄底技术与设备。</p><p>工业化人口数量决定了工业经济的规模，也和工业体系的复杂程度和先进程度密切相关。<br>独立工业体系需要的工业化人口数量是基本配件数量的5到10倍。<br>欧洲走向一体化的原因就在于此。</p><p>苏联的崩溃说到底是因为美国用自己的人口优势率先完成了产业升级。</p><p>在战略对抗中，要掌握比对手更多的工业化人口，要向盟友输出工业化社会，通过输出工业化社会来制造盟友。否则早晚遇到工业升级的人口障碍。</p><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><p>一切强权、帝国在工业革命面前都是过眼云烟。</p><p>终结大英帝国的是第二次工业革命。</p><p>中国不能靠出口来长期支持我们的工业化进程了。</p><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><p>没有人会把太监叫做绅士。</p><p>保持不断的进步才能有道理可以讲。</p><p>输出工业化是个长久的买卖，比输出消费品要长久。</p><p>现在一个地市级的地勘力量比工业化之前全国合集还多。</p><p>买办是第一障碍。</p><p>要输出工业化，而不是像殖民主义那样打击当地工业发展。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h1&gt;&lt;p&gt;工业化、现代化、城市化、民主化、自由化、市场化、全球化，不一定要姓“西、资、基”。&lt;/p&gt;
&lt;h1 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第</summary>
      
    
    
    
    
    <category term="工业党" scheme="https://cuipengfei.me/tags/%E5%B7%A5%E4%B8%9A%E5%85%9A/"/>
    
  </entry>
  
  <entry>
    <title>软件需求膨胀系数</title>
    <link href="https://cuipengfei.me/blog/2020/05/22/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%86%A8%E8%83%80/"/>
    <id>https://cuipengfei.me/blog/2020/05/22/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%86%A8%E8%83%80/</id>
    <published>2020-05-22T04:32:38.000Z</published>
    <updated>2020-05-22T04:32:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="泡水膨胀球"><a href="#泡水膨胀球" class="headerlink" title="泡水膨胀球"></a>泡水膨胀球</h1><img data-src="/images/需求膨胀/膨胀球.jpg" alt="drawing" width="500"/><p>这是一种小玩具，干燥时拿在手里，小巧紧致。</p><p>泡在水里，一段时间之后，浑圆饱满，一只手都未必能捧的住。</p><p>放在干燥通风的地方晾晒，一段时间过后，又可以恢复原本的大小。</p><h1 id="软件需求"><a href="#软件需求" class="headerlink" title="软件需求"></a>软件需求</h1><p>软件需求与泡水膨胀球也有类似之处。</p><p>一开始时看似简单明了且完备正交，做起来发现<strong>越做越大，越做越多</strong>。</p><p>原本一只手能抓好几个的小球，后来变成两只手都抓不住一个。</p><p>然后的结果要么是超预算多花钱做完，要么是转嫁成本给乙方要求对方做完，要么是延期，要么是痛苦地去压缩需求。</p><p>无论哪种，都是<strong>不健康</strong>的。</p><h1 id="膨胀系数"><a href="#膨胀系数" class="headerlink" title="膨胀系数"></a>膨胀系数</h1><p>小球泡在水里会膨胀，暴露于干燥环境中会缩小。</p><p>这个过程可以用一个简化模型来表示：</p><p><em><strong>膨胀系数 ≈ 吸水力 - 斥水力</strong></em></p><p><em><strong>小球体积 ≈ 初始体积 + 膨胀系数 x 时间</strong></em></p><p>当吸水力大于斥水力时，膨胀系数为正数，在时间的作用下，球会膨胀。<br>当斥水力大于吸水力时，膨胀系数为负数，在时间的作用下，球会缩小。<br>当两个力接近相互<strong>平衡</strong>时，膨胀系数约等于零，在时间的作用下，小球体积趋于<strong>稳定</strong>。</p><h1 id="我们希望看到小球体积怎样变化？"><a href="#我们希望看到小球体积怎样变化？" class="headerlink" title="我们希望看到小球体积怎样变化？"></a>我们希望看到小球体积怎样变化？</h1><p>一直变肥？那不行。做软件是有成本的，时间人力都是成本。</p><p>持续变瘦？也不行。需求受到过分压抑也是不健康的。</p><p>健康的变化过程应该是：<br>先让小球丰满起来（充分收集需求，以免后面出现始料未及的“惊喜”）<br>然后削减多余的赘肉（使用奥卡姆剃刀）<br>之后长期维持健康范围内的波动</p><h1 id="力的阶段性施加策略"><a href="#力的阶段性施加策略" class="headerlink" title="力的阶段性施加策略"></a>力的阶段性施加策略</h1><p>时间的流逝是不受我们控制的，因而想要控制体积就要从膨胀系数下手。</p><p>而膨胀系数又与两个力相关，因而<strong>想要控制体积就要控制吸水力与斥水力</strong>。</p><img data-src="/images/需求膨胀/二力.png"/><p>首先让吸水力尽情释放，这时斥水力<strong>蛰伏</strong>着<strong>静待</strong>吸水力的<strong>衰减</strong>。<br>之后斥水力爬坡，达到与吸水力持平的水准，二者长期和平共处。</p><p>当我们如上使用这两种力的时候，小球体积的变化就会是这样的：</p><img data-src="/images/需求膨胀/体积变化.png"/><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>调研阶段积极创造<strong>环境</strong>来让吸水力得以<strong>释放</strong>，先允许小球变肥。然后施加一定的斥水力，让小球苗条下来。</p><p>到了研发阶段，由于吸水力在之前就已经得到了有效的<strong>释放</strong>，这时施加适量的斥水力来平衡<strong>所剩无几</strong>的吸水力就能让小球体积的波动维持在<strong>可控</strong>的范围内。</p><p>在不同的阶段有策略地利用这两种力，则可以趋近<strong>前期需求收集充分考虑各方诉求</strong>不留大的隐患，后续研发稳定<strong>不坐过山车</strong>的目的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;泡水膨胀球&quot;&gt;&lt;a href=&quot;#泡水膨胀球&quot; class=&quot;headerlink&quot; title=&quot;泡水膨胀球&quot;&gt;&lt;/a&gt;泡水膨胀球&lt;/h1&gt;&lt;img data-src=&quot;/images/需求膨胀/膨胀球.jpg&quot; alt=&quot;drawing&quot; width=&quot;500</summary>
      
    
    
    
    
    <category term="需求" scheme="https://cuipengfei.me/tags/%E9%9C%80%E6%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>分布式键值存储（Distributed Key-Value Store）</title>
    <link href="https://cuipengfei.me/blog/2020/02/21/distributed-key-value-store/"/>
    <id>https://cuipengfei.me/blog/2020/02/21/distributed-key-value-store/</id>
    <published>2020-02-21T12:54:15.000Z</published>
    <updated>2020-02-21T12:54:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>分布式键值存储（Distributed Key-Value Store）并不是一个新鲜的玩意。<br>常见的Redis，Memcache等等都有很多人在用。</p><p>不过如果要是说其中的细节，如replicate，读写，一致性，retry等等的话，又是经常会遇到把自己绕的混淆不清的情况。。<br>恰巧我最近在看的一门网课《Programming Reactive Systems》中有一道作业题就是要自己实现一个Distributed Key-Value Store，那就正好借此机会详细写下其中的关键点。</p><h1 id="组成系统的参与者"><a href="#组成系统的参与者" class="headerlink" title="组成系统的参与者"></a>组成系统的参与者</h1><p>既然是分布式键值存储，那么肯定会有主从节点，每个结点又会有自己的持久化，而主从之间也需要协调，于是就得出了如下关键参与者：</p><ul><li><strong>Primary</strong>： 主节点。接受来自client的更新（增&#x2F;删&#x2F;改）操作，并把更新后的数据扩散到其它节点。当然，也可以接受来自于client的读操作。</li><li><strong>Secondary</strong>： 从节点。接受来自主节点的更新操作。接受来自client的只读操作。</li><li><strong>Arbiter</strong>： 仲裁者。任何节点，无论主从，都要把自己注册到Arbiter上去。当有从节点加入或者离开集群的时候，Arbiter负责告知主节点。</li><li><strong>Persistence</strong>： 每个节点都拥有自己的独享的Persistence。用于把节点上的数据持久化。</li><li><strong>Clients</strong>： 客户端，可能与主或者从节点通信，进行各种读写操作。</li></ul><p>此外，还有另一个相对不那么关键的参与者：</p><ul><li><strong>Replicator</strong>： 复制器，负责扩散数据。主节点和从节点之间的桥梁。主节点扩散到从节点去的数据要经手Replicator。<br>之所以需要它是为了把一部分维护内部状态的职责从Primary身上解除出去，具体来说是一个sequence number序列号，后面会提到。</li></ul><h2 id="参与者之间的关系"><a href="#参与者之间的关系" class="headerlink" title="参与者之间的关系"></a>参与者之间的关系</h2><p><a href="https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoiZ3JhcGggVERcbiAgUHJpbWFyeS0tPnxhc2sgdG8gcmVwbGljYXRlfFJlcGxpY2F0b3IxXG4gIFByaW1hcnktLT58YXNrIHRvIHJlcGxpY2F0ZXxSZXBsaWNhdG9yMlxuICBSZXBsaWNhdG9yMS0tPnxzbmFwc2hvdCB0b3xTZWNvbmRhcnkxXG4gIFJlcGxpY2F0b3IyLS0-fHNuYXBzaG90IHRvfFNlY29uZGFyeTJcbiAgUHJpbWFyeS0tPnxKb2lufEFyYml0ZXJcbiAgU2Vjb25kYXJ5MS0tPnxKb2lufEFyYml0ZXJcbiAgU2Vjb25kYXJ5Mi0tPnxKb2lufEFyYml0ZXJcbiAgUHJpbWFyeS0tPnxQZXJzaXN0IHRvfFBlcnNpc3RlbmNlMFxuICBTZWNvbmRhcnkxLS0-fFBlcnNpc3QgdG98UGVyc2lzdGVuY2UxXG4gIFNlY29uZGFyeTItLT58UGVyc2lzdCB0b3xQZXJzaXN0ZW5jZTJcbiAgXG4gIENsaWVudC0tPnxyZWFkL3dyaXRlfFByaW1hcnlcbiAgQ2xpZW50LS0-fHJlYWR8U2Vjb25kYXJ5MVxuICBDbGllbnQtLT58cmVhZHxTZWNvbmRhcnkyXG5cbiAgQXJiaXRlci0tPnxOb3RpZnkgam9pbi9sZWF2ZSBvZiBzZWNvbmRhcmllc3xQcmltYXJ5IiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCIsImZsb3djaGFydCI6eyJjdXJ2ZSI6ImJhc2lzIn19LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ"><img data-src="https://mermaid.ink/img/eyJjb2RlIjoiZ3JhcGggVERcbiAgUHJpbWFyeS0tPnxhc2sgdG8gcmVwbGljYXRlfFJlcGxpY2F0b3IxXG4gIFByaW1hcnktLT58YXNrIHRvIHJlcGxpY2F0ZXxSZXBsaWNhdG9yMlxuICBSZXBsaWNhdG9yMS0tPnxzbmFwc2hvdCB0b3xTZWNvbmRhcnkxXG4gIFJlcGxpY2F0b3IyLS0-fHNuYXBzaG90IHRvfFNlY29uZGFyeTJcbiAgUHJpbWFyeS0tPnxKb2lufEFyYml0ZXJcbiAgU2Vjb25kYXJ5MS0tPnxKb2lufEFyYml0ZXJcbiAgU2Vjb25kYXJ5Mi0tPnxKb2lufEFyYml0ZXJcbiAgUHJpbWFyeS0tPnxQZXJzaXN0IHRvfFBlcnNpc3RlbmNlMFxuICBTZWNvbmRhcnkxLS0-fFBlcnNpc3QgdG98UGVyc2lzdGVuY2UxXG4gIFNlY29uZGFyeTItLT58UGVyc2lzdCB0b3xQZXJzaXN0ZW5jZTJcbiAgXG4gIENsaWVudC0tPnxyZWFkL3dyaXRlfFByaW1hcnlcbiAgQ2xpZW50LS0-fHJlYWR8U2Vjb25kYXJ5MVxuICBDbGllbnQtLT58cmVhZHxTZWNvbmRhcnkyXG5cbiAgQXJiaXRlci0tPnxOb3RpZnkgam9pbi9sZWF2ZSBvZiBzZWNvbmRhcmllc3xQcmltYXJ5IiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCIsImZsb3djaGFydCI6eyJjdXJ2ZSI6ImJhc2lzIn19LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ"></a></p><p>可以看出，系统中有一个Primary，多个Secondary（虽然图中只画了两个，但是理论上可以有任意N多个）。<br>Primary向Secondary扩散数据是通过Replicator进行的，并且是给每个Secondary配了一个单独的Replicator。<br>也就是说Replicator和Secondary是成双成对的。</p><p><strong>注：上图描述的是各个参与者之间的关系，上下左右位置并不代表先后顺序</strong></p><h1 id="一些限制"><a href="#一些限制" class="headerlink" title="一些限制"></a>一些限制</h1><p>我们并不是要做一个可以在Prod环境中使用的KV Store，而只是借助自己实现来厘清KV Store的一些知识点，所以做出了如下的限制来简化实现：</p><ul><li>只有主节点可以接受写操作，所有从节点都只能接受读操作</li><li>假设主节点是稳定可靠的，不会挂（不处理主节点身份转移）</li><li>假设Arbiter是可靠的，不会挂</li><li>不处理背压（back pressure）</li><li>客户端使用的请求id是不会重复的</li></ul><h1 id="各参与者的职责及相互之间的交互"><a href="#各参与者的职责及相互之间的交互" class="headerlink" title="各参与者的职责及相互之间的交互"></a>各参与者的职责及相互之间的交互</h1><p>以下的这些图，<strong>每一张都只关心系统中的一个局部</strong>。主要原因在于把整个系统的交互放到一张图里会导致<strong>要素太多而难以阅读</strong>。</p><h2 id="Arbiter"><a href="#Arbiter" class="headerlink" title="Arbiter"></a>Arbiter</h2><p><a href="https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgTm9kZSAxLT4-K0FyYml0ZXI6IEpvaW5cbiAgICBOb2RlIDItPj4rQXJiaXRlcjpKb2luXG4gICAgTm9kZSAzLT4-K0FyYml0ZXI6Sm9pblxuICAgIEFyYml0ZXItLT4-K05vZGUgMTogSm9pbmVkUHJpbWFyeVxuICAgIEFyYml0ZXItLT4-K05vZGUgMjogSm9pbmVkU2Vjb25kYXJ5XG4gICAgQXJiaXRlci0tPj4rTm9kZSAxOiBSZXBsaWNhcyhOb2RlIDIpXG4gICAgQXJiaXRlci0tPj4rTm9kZSAzOiBKb2luZWRTZWNvbmRhcnlcbiAgICBBcmJpdGVyLS0-PitOb2RlIDE6IFJlcGxpY2FzKE5vZGUgMylcblxuIiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCIsImZsb3djaGFydCI6eyJjdXJ2ZSI6ImJhc2lzIn19LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ"><img data-src="https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgTm9kZSAxLT4-K0FyYml0ZXI6IEpvaW5cbiAgICBOb2RlIDItPj4rQXJiaXRlcjpKb2luXG4gICAgTm9kZSAzLT4-K0FyYml0ZXI6Sm9pblxuICAgIEFyYml0ZXItLT4-K05vZGUgMTogSm9pbmVkUHJpbWFyeVxuICAgIEFyYml0ZXItLT4-K05vZGUgMjogSm9pbmVkU2Vjb25kYXJ5XG4gICAgQXJiaXRlci0tPj4rTm9kZSAxOiBSZXBsaWNhcyhOb2RlIDIpXG4gICAgQXJiaXRlci0tPj4rTm9kZSAzOiBKb2luZWRTZWNvbmRhcnlcbiAgICBBcmJpdGVyLS0-PitOb2RlIDE6IFJlcGxpY2FzKE5vZGUgMylcblxuIiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCIsImZsb3djaGFydCI6eyJjdXJ2ZSI6ImJhc2lzIn19LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ"></a></p><p>来的早的会被Arbiter当作Primary，来的晚的就是Secondary了。<br>并且，每一个来的晚的成为Secondary之后，Arbiter还会告知Primary说：来新节点了。以便Primary可以知道后续需要把数据扩散给谁。<br>如果有Secondary由于某种原因而离开了集群，Arbiter也会告知Primary，从而避免Primary继续给已经不在了的Secondary发消息。</p><h2 id="Persistence"><a href="#Persistence" class="headerlink" title="Persistence"></a>Persistence</h2><p><a href="https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgTm9kZSAtPj4rUGVyc2lzdGVuY2U6IFBlcnNpc3Qoa2V5LHZhbHVlLGlkKVxuICAgIFBlcnNpc3RlbmNlLS0-PitOb2RlOiBQZXJzaXN0ZWQoa2V5LGlkKSBvciBub3RoaW5nIiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCIsImZsb3djaGFydCI6eyJjdXJ2ZSI6ImJhc2lzIn19LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ"><img data-src="https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgTm9kZSAtPj4rUGVyc2lzdGVuY2U6IFBlcnNpc3Qoa2V5LHZhbHVlLGlkKVxuICAgIFBlcnNpc3RlbmNlLS0-PitOb2RlOiBQZXJzaXN0ZWQoa2V5LGlkKSBvciBub3RoaW5nIiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCIsImZsb3djaGFydCI6eyJjdXJ2ZSI6ImJhc2lzIn19LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ"></a></p><p>前面提到过，每个节点，无论主从，都有一个自己独享的persistence。所以上图中的Node兼指主或者从节点。<br>Persistence本身的职责很简单，把Node告诉它的数据持久化下来。<br>但是，此处我们并<strong>没有假设持久化总是可靠的</strong>，所以上图中的第二根线是<strong>未必总是能成功发生</strong>的。</p><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p><a href="https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgTm9kZSAtPj4rQXJiaXRlcjpKb2luXG4gICAgTm9kZSAtPj4rTm9kZTogUmV0cnkgUGVyc2lzdCBldmVyeSAxMDBtc1xuICAgIEFyYml0ZXItLT4-K05vZGU6Sm9pbmVkIFByaW1hcnkgb3IgU2Vjb25kYXJ5XG4gICAgIiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCIsImZsb3djaGFydCI6eyJjdXJ2ZSI6ImJhc2lzIn19LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ"><img data-src="https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgTm9kZSAtPj4rQXJiaXRlcjpKb2luXG4gICAgTm9kZSAtPj4rTm9kZTogUmV0cnkgUGVyc2lzdCBldmVyeSAxMDBtc1xuICAgIEFyYml0ZXItLT4-K05vZGU6Sm9pbmVkIFByaW1hcnkgb3IgU2Vjb25kYXJ5XG4gICAgIiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCIsImZsb3djaGFydCI6eyJjdXJ2ZSI6ImJhc2lzIn19LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ"></a></p><p>这里的Node兼指主或者从节点。也就是说上图中的事情是每个Node无论主从都要做的。<br>每一个Node，在它生命周期的最早开始作的第一件事就是告诉Arbiter：“我来了“。</p><p>上面提到过，Persistence未必总是可靠的。所以每个Node一旦开始存活，就会给自己启动一个定时任务，每隔100ms就去retry persist，直到Persitence回话说Persisted为止才停止retry。</p><h2 id="Secondary"><a href="#Secondary" class="headerlink" title="Secondary"></a>Secondary</h2><h3 id="Secondary-Snapshot"><a href="#Secondary-Snapshot" class="headerlink" title="Secondary - Snapshot"></a>Secondary - Snapshot</h3><p><a href="https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgUmVwbGljYXRvciAtPj4rU2Vjb25kYXJ5OlNuYXBzaG90KGtleSx2YWx1ZSxzZXEpXG4gICAgYWx0IHNlcT09ZXhwZWN0ZWRTZXFcbiAgICAgICAgU2Vjb25kYXJ5LT4-K1NlY29uZGFyeTogdXBkYXRlIGludGVybmFsIGt2IHN0b3JlXG4gICAgICAgIFNlY29uZGFyeS0-PitQZXJzaXN0ZW5jZTpQZXJzaXN0KGtleSx2YWx1ZSxzZXEpXG4gICAgICAgIFNlY29uZGFyeS0-PlNlY29uZGFyeTphZGQgb25lIGl0ZW0gdG8gaW50ZXJuYWwgcmV0cnkgcGVyc2lzdCBsaXN0XG4gICAgZWxzZSBzZXE8ZXhwZWN0ZWRTZXFcbiAgICAgICAgU2Vjb25kYXJ5LT4-K1JlcGxpY2F0b3I6U25hcHNob3RBY2soa2V5LHNlcSlcbiAgICBlbmRcbiAgICAiLCJtZXJtYWlkIjp7InRoZW1lIjoiZm9yZXN0IiwiZmxvd2NoYXJ0Ijp7ImN1cnZlIjoiYmFzaXMifX0sInVwZGF0ZUVkaXRvciI6ZmFsc2V9"><img data-src="https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgUmVwbGljYXRvciAtPj4rU2Vjb25kYXJ5OlNuYXBzaG90KGtleSx2YWx1ZSxzZXEpXG4gICAgYWx0IHNlcT09ZXhwZWN0ZWRTZXFcbiAgICAgICAgU2Vjb25kYXJ5LT4-K1NlY29uZGFyeTogdXBkYXRlIGludGVybmFsIGt2IHN0b3JlXG4gICAgICAgIFNlY29uZGFyeS0-PitQZXJzaXN0ZW5jZTpQZXJzaXN0KGtleSx2YWx1ZSxzZXEpXG4gICAgICAgIFNlY29uZGFyeS0-PlNlY29uZGFyeTphZGQgb25lIGl0ZW0gdG8gaW50ZXJuYWwgcmV0cnkgcGVyc2lzdCBsaXN0XG4gICAgZWxzZSBzZXE8ZXhwZWN0ZWRTZXFcbiAgICAgICAgU2Vjb25kYXJ5LT4-K1JlcGxpY2F0b3I6U25hcHNob3RBY2soa2V5LHNlcSlcbiAgICBlbmRcbiAgICAiLCJtZXJtYWlkIjp7InRoZW1lIjoiZm9yZXN0IiwiZmxvd2NoYXJ0Ijp7ImN1cnZlIjoiYmFzaXMifX0sInVwZGF0ZUVkaXRvciI6ZmFsc2V9"></a></p><p>上图描述的是当Replicator向Secondary扩散数据的时候，Secondary如何处理。<br>一旦一个Replicator告诉Secondary去更新数据（增&#x2F;删&#x2F;改），Secondary先去更新自己内部的kv，然后去告知Persistence去做持久化。</p><p>这里有一个细节，就是图中出现的seq（sequence number 序列号）。Replicator和Secondary之间就是靠这个seq来保证数据更新操作总是先来的先处理，后来的后处理。<br>据此来提供一定程度的consistency。避免老数据覆盖新数据（此处需要结合下文中replicator的retry snapshot来理解）。</p><h3 id="Secondary-Persisted"><a href="#Secondary-Persisted" class="headerlink" title="Secondary - Persisted"></a>Secondary - Persisted</h3><p><a href="https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgUGVyc2lzdGVuY2UtPj5TZWNvbmRhcnk6UGVyc2lzdGVkKGtleSxzZXEpXG4gICAgU2Vjb25kYXJ5LT4-UmVwbGljYXRvcjpTbmFwc2hvdEFjayhrZXksc2VxKVxuICAgIFNlY29uZGFyeS0-PlNlY29uZGFyeTppbmNyZWFzZSBleHBlY3RlZFNlcVxuICAgIFNlY29uZGFyeS0-PlNlY29uZGFyeTpyZW1vdmUgc2VxIGZyb20gcmV0cnkgcGVyc2lzdCBsaXN0IiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCIsImZsb3djaGFydCI6eyJjdXJ2ZSI6ImJhc2lzIn19LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ"><img data-src="https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgUGVyc2lzdGVuY2UtPj5TZWNvbmRhcnk6UGVyc2lzdGVkKGtleSxzZXEpXG4gICAgU2Vjb25kYXJ5LT4-UmVwbGljYXRvcjpTbmFwc2hvdEFjayhrZXksc2VxKVxuICAgIFNlY29uZGFyeS0-PlNlY29uZGFyeTppbmNyZWFzZSBleHBlY3RlZFNlcVxuICAgIFNlY29uZGFyeS0-PlNlY29uZGFyeTpyZW1vdmUgc2VxIGZyb20gcmV0cnkgcGVyc2lzdCBsaXN0IiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCIsImZsb3djaGFydCI6eyJjdXJ2ZSI6ImJhc2lzIn19LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ"></a></p><p>上图描述的是，当Persistence告诉Secondary：“持久化好了“的时候，Secondary如何处理。<br>可以看出来，只有确认持久化完成之后，Secondary才会告诉Replicator：“扩散数据完成了“，并且在Secondary自己内部取消掉这一条数据的retry persist。</p><h3 id="Secondary-Get"><a href="#Secondary-Get" class="headerlink" title="Secondary - Get"></a>Secondary - Get</h3><p><a href="https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgQ2xpZW50LT4-U2Vjb25kYXJ5OkdldChrZXksaWQpXG4gICAgU2Vjb25kYXJ5LT4-U2Vjb25kYXJ5OnF1ZXJ5IGludGVybmFsIGt2XG4gICAgU2Vjb25kYXJ5LS0-PkNsaWVudDpHZXRSZXN1bHQoa2V5LHZhbHVlLGlkKSAodmFsdWUgY291bGQgYmUgZW1wdHkpIiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCIsImZsb3djaGFydCI6eyJjdXJ2ZSI6ImJhc2lzIn19LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ"><img data-src="https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgQ2xpZW50LT4-U2Vjb25kYXJ5OkdldChrZXksaWQpXG4gICAgU2Vjb25kYXJ5LT4-U2Vjb25kYXJ5OnF1ZXJ5IGludGVybmFsIGt2XG4gICAgU2Vjb25kYXJ5LS0-PkNsaWVudDpHZXRSZXN1bHQoa2V5LHZhbHVlLGlkKSAodmFsdWUgY291bGQgYmUgZW1wdHkpIiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCIsImZsb3djaGFydCI6eyJjdXJ2ZSI6ImJhc2lzIn19LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ"></a></p><p>对于来自于Client的读取操作，Secondary总是心直口快，有就是有，没有就是没有。</p><h2 id="Replicator"><a href="#Replicator" class="headerlink" title="Replicator"></a>Replicator</h2><h3 id="Replicator-retry-snapshots"><a href="#Replicator-retry-snapshots" class="headerlink" title="Replicator - retry snapshots"></a>Replicator - retry snapshots</h3><p><a href="https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgUmVwbGljYXRvci0-PlJlcGxpY2F0b3I6cmV0cnkgc25hcHNob3QgZXZlcnkgMTAwbXNcbiAgICAiLCJtZXJtYWlkIjp7InRoZW1lIjoiZm9yZXN0IiwiZmxvd2NoYXJ0Ijp7ImN1cnZlIjoiYmFzaXMifX0sInVwZGF0ZUVkaXRvciI6ZmFsc2V9"><img data-src="https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgUmVwbGljYXRvci0-PlJlcGxpY2F0b3I6cmV0cnkgc25hcHNob3QgZXZlcnkgMTAwbXNcbiAgICAiLCJtZXJtYWlkIjp7InRoZW1lIjoiZm9yZXN0IiwiZmxvd2NoYXJ0Ijp7ImN1cnZlIjoiYmFzaXMifX0sInVwZGF0ZUVkaXRvciI6ZmFsc2V9"></a></p><p>上面提到过，Persistence未必总是可靠的，也就意味着数据扩散操作也未必总是成功，所以，Replicator一旦启动（被Primary创建出来），就要开始一个定时任务来不断retry尚未成功的数据扩散操作。</p><h3 id="Replicator-Replicate"><a href="#Replicator-Replicate" class="headerlink" title="Replicator - Replicate"></a>Replicator - Replicate</h3><p><a href="https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgUHJpbWFyeS0-PlJlcGxpY2F0b3I6UmVwbGljYXRlKGtleSx2YWx1ZSxpZClcbiAgICBSZXBsaWNhdG9yLT4-U2Vjb25kYXJ5OlNuYXBzaG90KGtleSx2YWx1ZSxzZXEpXG4gICAgUmVwbGljYXRvci0-PlJlcGxpY2F0b3I6YWRkIGl0ZW0gdG8gaW50ZXJuYWwgcGVuZGluZyBhY2sgbGlzdFxuICAgIFJlcGxpY2F0b3ItPj5SZXBsaWNhdG9yOmluY3JlYXNlIGludGVybmFsIHNlcVxuICAgICIsIm1lcm1haWQiOnsidGhlbWUiOiJmb3Jlc3QiLCJmbG93Y2hhcnQiOnsiY3VydmUiOiJiYXNpcyJ9fSwidXBkYXRlRWRpdG9yIjpmYWxzZX0"><img data-src="https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgUHJpbWFyeS0-PlJlcGxpY2F0b3I6UmVwbGljYXRlKGtleSx2YWx1ZSxpZClcbiAgICBSZXBsaWNhdG9yLT4-U2Vjb25kYXJ5OlNuYXBzaG90KGtleSx2YWx1ZSxzZXEpXG4gICAgUmVwbGljYXRvci0-PlJlcGxpY2F0b3I6YWRkIGl0ZW0gdG8gaW50ZXJuYWwgcGVuZGluZyBhY2sgbGlzdFxuICAgIFJlcGxpY2F0b3ItPj5SZXBsaWNhdG9yOmluY3JlYXNlIGludGVybmFsIHNlcVxuICAgICIsIm1lcm1haWQiOnsidGhlbWUiOiJmb3Jlc3QiLCJmbG93Y2hhcnQiOnsiY3VydmUiOiJiYXNpcyJ9fSwidXBkYXRlRWRpdG9yIjpmYWxzZX0"></a></p><p>上图描述的是当Primary要求Replicator去扩散数据到一个Secondary的时候Replicator如何处理。<br>那么Replicator首先告诉Secondary去更新数据，然后在自体内部把刚才的操作记下来，以便后续retry。并且把自己的seq加一，这里的seq就是Replicator和Secondary之间的信物，用来维持consistency。</p><h3 id="Replicator-SnapshotAck"><a href="#Replicator-SnapshotAck" class="headerlink" title="Replicator - SnapshotAck"></a>Replicator - SnapshotAck</h3><p><a href="https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgU2Vjb25kYXJ5LT4-UmVwbGljYXRvcjpTbmFwc2hvdEFjayhrZXksc2VxKVxuICAgIFJlcGxpY2F0b3ItPj5QcmltYXJ5OlJlcGxpY2F0ZWQoa2V5LGlkKVxuICAgIFJlcGxpY2F0b3ItPj5SZXBsaWNhdG9yOnJlbW92ZSBvbmUgaXRlbSBmcm9tIHBlbmRpbmcgYWNrIGxpc3QiLCJtZXJtYWlkIjp7InRoZW1lIjoiZm9yZXN0IiwiZmxvd2NoYXJ0Ijp7ImN1cnZlIjoiYmFzaXMifX0sInVwZGF0ZUVkaXRvciI6ZmFsc2V9"><img data-src="https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgU2Vjb25kYXJ5LT4-UmVwbGljYXRvcjpTbmFwc2hvdEFjayhrZXksc2VxKVxuICAgIFJlcGxpY2F0b3ItPj5QcmltYXJ5OlJlcGxpY2F0ZWQoa2V5LGlkKVxuICAgIFJlcGxpY2F0b3ItPj5SZXBsaWNhdG9yOnJlbW92ZSBvbmUgaXRlbSBmcm9tIHBlbmRpbmcgYWNrIGxpc3QiLCJtZXJtYWlkIjp7InRoZW1lIjoiZm9yZXN0IiwiZmxvd2NoYXJ0Ijp7ImN1cnZlIjoiYmFzaXMifX0sInVwZGF0ZUVkaXRvciI6ZmFsc2V9"></a></p><p>上图描述的是Replicator在被Secondary告知扩散数据成功后如何处理。<br>先把这个好消息告诉给Primary，然后在retry的列表里面去除掉刚刚成功的这次操作，这样后面就再也不会再去retry这次操作了。</p><h2 id="Primary"><a href="#Primary" class="headerlink" title="Primary"></a>Primary</h2><p>最后是Primary。作为主节点，它的职责是最多最辛劳的。</p><h3 id="Primary-Insert-Remove"><a href="#Primary-Insert-Remove" class="headerlink" title="Primary - Insert&#x2F;Remove"></a>Primary - Insert&#x2F;Remove</h3><p><a href="https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgQ2xpZW50LT4-UHJpbWFyeTpJbnNlcnQoa2V5LHZhbHVlLGlkKSBvciBSZW1vdmUoa2V5LGlkKVxuICAgIFByaW1hcnktPj5QcmltYXJ5OnVwZGF0ZSBpbnRlcm5hbCBrdlxuICAgIFByaW1hcnktPj5QZXJzaXN0ZW5jZTpQZXJzaXN0KGtleSx2YWx1ZSxpZClcbiAgICBQcmltYXJ5LT4-UHJpbWFyeTphZGQgb25lIGl0ZW0gdG8gaW50ZXJuYWwgcmV0cnkgcGVyc2lzdCBsaXN0XG4gICAgUHJpbWFyeS0-PlJlcGxpY2F0b3IgMTpSZXBsaWNhdGUoa2V5LHZhbHVlLGlkKVxuICAgIFByaW1hcnktPj5QcmltYXJ5OmFkZCBvbmUgaXRlbSB0byBwZW5kaW5nIHJlcGxpY2F0ZXMgbGlzdFxuICAgIFByaW1hcnktPj5SZXBsaWNhdG9yIDI6UmVwbGljYXRlKGtleSx2YWx1ZSxpZClcbiAgICBQcmltYXJ5LT4-UHJpbWFyeTphZGQgb25lIGl0ZW0gdG8gcGVuZGluZyByZXBsaWNhdGVzIGxpc3RcbiAgICBQcmltYXJ5LT4-UHJpbWFyeTpzY2hlZHVsZSBmYWlsdXJlIGZvciBhZnRlciAxcyIsIm1lcm1haWQiOnsidGhlbWUiOiJmb3Jlc3QiLCJmbG93Y2hhcnQiOnsiY3VydmUiOiJiYXNpcyJ9fSwidXBkYXRlRWRpdG9yIjpmYWxzZX0"><img data-src="https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgQ2xpZW50LT4-UHJpbWFyeTpJbnNlcnQoa2V5LHZhbHVlLGlkKSBvciBSZW1vdmUoa2V5LGlkKVxuICAgIFByaW1hcnktPj5QcmltYXJ5OnVwZGF0ZSBpbnRlcm5hbCBrdlxuICAgIFByaW1hcnktPj5QZXJzaXN0ZW5jZTpQZXJzaXN0KGtleSx2YWx1ZSxpZClcbiAgICBQcmltYXJ5LT4-UHJpbWFyeTphZGQgb25lIGl0ZW0gdG8gaW50ZXJuYWwgcmV0cnkgcGVyc2lzdCBsaXN0XG4gICAgUHJpbWFyeS0-PlJlcGxpY2F0b3IgMTpSZXBsaWNhdGUoa2V5LHZhbHVlLGlkKVxuICAgIFByaW1hcnktPj5QcmltYXJ5OmFkZCBvbmUgaXRlbSB0byBwZW5kaW5nIHJlcGxpY2F0ZXMgbGlzdFxuICAgIFByaW1hcnktPj5SZXBsaWNhdG9yIDI6UmVwbGljYXRlKGtleSx2YWx1ZSxpZClcbiAgICBQcmltYXJ5LT4-UHJpbWFyeTphZGQgb25lIGl0ZW0gdG8gcGVuZGluZyByZXBsaWNhdGVzIGxpc3RcbiAgICBQcmltYXJ5LT4-UHJpbWFyeTpzY2hlZHVsZSBmYWlsdXJlIGZvciBhZnRlciAxcyIsIm1lcm1haWQiOnsidGhlbWUiOiJmb3Jlc3QiLCJmbG93Y2hhcnQiOnsiY3VydmUiOiJiYXNpcyJ9fSwidXBkYXRlRWRpdG9yIjpmYWxzZX0"></a></p><p>上图是Primary处理来自Client的Insert或者Remove请求。<br>前面一半和Secondary处理Snapshot方式基本一致。</p><p>不同之处就在于：<br>Primary还要负责告诉所有现存的Replicator（图里只画了两个，理论上可以有任意N个）去扩散数据。并且把这个操作记在内部状态里。<br>以及设置一个定时任务，一秒钟之后，如果没有达成Primary自己persist成功并且每一个Replicator都扩散成功的状态，那就告诉Client这次操作是失败的。</p><h3 id="Primary-Get"><a href="#Primary-Get" class="headerlink" title="Primary - Get"></a>Primary - Get</h3><p>至于Primary处理来自于Client的Get请求的图就不画了，与Secondary完全一致。</p><h3 id="Primary-Persisted"><a href="#Primary-Persisted" class="headerlink" title="Primary - Persisted"></a>Primary - Persisted</h3><p><a href="https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgUGVyc2lzdGVuY2UtPj5QcmltYXJ5OlBlcnNpc3RlZChrZXksaWQpXG4gICAgUHJpbWFyeS0-PlByaW1hcnk6IHJlbW92ZSBvbmUgaXRlbSBmcm9tIHBlbmRpbmcgcGVyc2lzdCBsaXN0XG4gICAgYWx0IFJlcGxpY2F0aW9ucyBhbGwgZmluaXNoZWRcbiAgICBQcmltYXJ5LT4-Q2xpZW50Ok9wZXJhdGlvbkFjayhpZClcbiAgICBlbmQiLCJtZXJtYWlkIjp7InRoZW1lIjoiZm9yZXN0In0sInVwZGF0ZUVkaXRvciI6ZmFsc2V9"><img data-src="https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgUGVyc2lzdGVuY2UtPj5QcmltYXJ5OlBlcnNpc3RlZChrZXksaWQpXG4gICAgUHJpbWFyeS0-PlByaW1hcnk6IHJlbW92ZSBvbmUgaXRlbSBmcm9tIHBlbmRpbmcgcGVyc2lzdCBsaXN0XG4gICAgYWx0IFJlcGxpY2F0aW9ucyBhbGwgZmluaXNoZWRcbiAgICBQcmltYXJ5LT4-Q2xpZW50Ok9wZXJhdGlvbkFjayhpZClcbiAgICBlbmQiLCJtZXJtYWlkIjp7InRoZW1lIjoiZm9yZXN0In0sInVwZGF0ZUVkaXRvciI6ZmFsc2V9"></a></p><p>上图是Primary收到Persistence成功消息的时候要做的事情。<br>首先从pending persist列表中移除刚刚persist成功的一条。<br>然后检查下是不是所有Replications也都完成了，两个条件的都符合的话，就告诉Client说操作完成了。</p><h3 id="Primary-Replicated"><a href="#Primary-Replicated" class="headerlink" title="Primary - Replicated"></a>Primary - Replicated</h3><p><a href="https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgUmVwbGljYXRvci0-PlByaW1hcnk6UmVwbGljYXRlZChrZXksaWQpXG4gICAgUHJpbWFyeS0-PlByaW1hcnk6IHJlbW92ZSBvbmUgaXRlbSBmcm9tIHBlbmRpbmcgcmVwbGlhdGVzXG4gICAgYWx0IEFsbCBSZXBsaWNhdGlvbnMgRmluaXNoZWRcbiAgICBhbHQgUGVyc2lzdCBmaW5pc2hlZFxuICAgIFByaW1hcnktPj5DbGllbnQ6T3BlcmF0aW9uQWNrKGlkKVxuICAgIGVuZFxuICAgIGVuZFxuIiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCJ9LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ"><img data-src="https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgUmVwbGljYXRvci0-PlByaW1hcnk6UmVwbGljYXRlZChrZXksaWQpXG4gICAgUHJpbWFyeS0-PlByaW1hcnk6IHJlbW92ZSBvbmUgaXRlbSBmcm9tIHBlbmRpbmcgcmVwbGlhdGVzXG4gICAgYWx0IEFsbCBSZXBsaWNhdGlvbnMgRmluaXNoZWRcbiAgICBhbHQgUGVyc2lzdCBmaW5pc2hlZFxuICAgIFByaW1hcnktPj5DbGllbnQ6T3BlcmF0aW9uQWNrKGlkKVxuICAgIGVuZFxuICAgIGVuZFxuIiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCJ9LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ"></a></p><p>上图是Primary收到来自Replicator的扩散成功消息时候的处理。<br>首先把刚成功的这一条从pending replicates中移除。<br>然后检查下是不是所有的replications都完成了（毕竟这里只是收到了一个replicator的消息），并且persist也完成了，如果两条都符合，就告诉Client说操作完成了。</p><p>到这里就明显可以看出，pending replicates的作用就是primary用来记录尚未完成的replication。</p><h3 id="Primary-Replicas"><a href="#Primary-Replicas" class="headerlink" title="Primary - Replicas"></a>Primary - Replicas</h3><p><a href="https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgQXJiaXRlci0-PlByaW1hcnk6UmVwbGljYXMobm9kZXMpXG4gICAgbG9vcCBldmVyeSBuZXcgc2Vjb25kYXJ5XG4gICAgUHJpbWFyeS0-PlByaW1hcnk6Y3JlYXRlIG5ldyByZXBsaWNhdG9yIGZvciBuZXcgc2Vjb25kYXJ5XG4gICAgbG9vcCBldmVyeSBrdiBwYWlyXG4gICAgUHJpbWFyeS0-PlJlcGxpY2F0b3I6UmVwbGljYXRlKGtleSx2YWx1ZSxpZClcbiAgICBlbmRcbiAgICBlbmRcblxuICAgIGxvb3AgZXZlcnkgbGVmdCBzZWNvbmRhcnlcbiAgICBQcmltYXJ5LT4-UHJpbWFyeTpyZW1vdmUgaXRlbXMgZnJvbSBwZW5kaW5nIHJlcGxpY2F0ZXNcbiAgICBhbHQgYWxsIHJlcGxpY2F0aW9ucyBmaW5pc2hlZFxuICAgIGFsdCBwZXJzaXN0IGZpbmlzaGVkXG4gICAgUHJpbWFyeS0-PkNsaWVudDpPcGVyYXRpb25BY2soaWQpXG4gICAgZW5kXG4gICAgZW5kXG4gICAgUHJpbWFyeS0-PlByaW1hcnk6ZGVzdHJveSBpdHMgbWF0Y2hpbmcgcmVwbGljYXRvclxuICAgIFxuICAgIGVuZFxuIiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCJ9LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ"><img data-src="https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgQXJiaXRlci0-PlByaW1hcnk6UmVwbGljYXMobm9kZXMpXG4gICAgbG9vcCBldmVyeSBuZXcgc2Vjb25kYXJ5XG4gICAgUHJpbWFyeS0-PlByaW1hcnk6Y3JlYXRlIG5ldyByZXBsaWNhdG9yIGZvciBuZXcgc2Vjb25kYXJ5XG4gICAgbG9vcCBldmVyeSBrdiBwYWlyXG4gICAgUHJpbWFyeS0-PlJlcGxpY2F0b3I6UmVwbGljYXRlKGtleSx2YWx1ZSxpZClcbiAgICBlbmRcbiAgICBlbmRcblxuICAgIGxvb3AgZXZlcnkgbGVmdCBzZWNvbmRhcnlcbiAgICBQcmltYXJ5LT4-UHJpbWFyeTpyZW1vdmUgaXRlbXMgZnJvbSBwZW5kaW5nIHJlcGxpY2F0ZXNcbiAgICBhbHQgYWxsIHJlcGxpY2F0aW9ucyBmaW5pc2hlZFxuICAgIGFsdCBwZXJzaXN0IGZpbmlzaGVkXG4gICAgUHJpbWFyeS0-PkNsaWVudDpPcGVyYXRpb25BY2soaWQpXG4gICAgZW5kXG4gICAgZW5kXG4gICAgUHJpbWFyeS0-PlByaW1hcnk6ZGVzdHJveSBpdHMgbWF0Y2hpbmcgcmVwbGljYXRvclxuICAgIFxuICAgIGVuZFxuIiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCJ9LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ"></a></p><p>最后一张图，描述的是当Arbiter告知Primary集群中有变动时，Primary的处理方式。</p><p>对于新加入的Secondary，给它们每个都创建一个新的Replicator。然后通过Replicator把所有现存的kv数据都甩给新加入的Secondary。类似于给插班生<strong>补课</strong>。</p><p>对于离开集群的Secondary，把和它们相关的pending replicates都删掉，既然它离开了，那就没必要等它了。删除掉之后马上检查一下是不是replications和persist都完了（因为有可能当前等的就是这个离开的Secondary，它一离开，没有别的需要等的了），如果是的话，那就告诉Client更新成功了。<br>最后，销毁掉对应的replicator。这个Secondary的历史使命就算终结了。如果后续这个Secondary又加入回来了，那走的就是上面一段<strong>补课</strong>的处理。</p><h1 id="OK"><a href="#OK" class="headerlink" title="OK"></a>OK</h1><p>虽然讲的是一个加了若干限制的分布式键值存储，但是还是用了十四张图。</p><p>这些图里没能体现到的一点是关于异步的问题，在最后补充一句：<br>除了Client之外，以上所有提到的参与者，每一个都是严格单线程的，不会在任何时候同时做两件事。<br>实际的实现代码中，是用<strong>akka</strong>写的，这些参与者做的多数都是<strong>async message passing</strong>的工作。<br>由于这是一门课的作业题，所以具体实现代码就不提及了。</p><p>希望这些图表对于理解分布式键值存储（Distributed Key-Value Store）会有一些帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;分布式键值存储（Distributed Key-Value Store）并不是一个新鲜的玩意。&lt;br&gt;常见的Redis，Memcache等等</summary>
      
    
    
    
    
    <category term="Reactive" scheme="https://cuipengfei.me/tags/Reactive/"/>
    
    <category term="分布式" scheme="https://cuipengfei.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>[译] 类 vs 数据结构</title>
    <link href="https://cuipengfei.me/blog/2020/02/15/classes-vs-data-structures/"/>
    <id>https://cuipengfei.me/blog/2020/02/15/classes-vs-data-structures/</id>
    <published>2020-02-15T15:44:13.000Z</published>
    <updated>2020-02-15T15:44:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文作者：Robert C. Martin (Uncle Bob)<br>原文链接：<a href="https://blog.cleancoder.com/uncle-bob/2019/06/16/ObjectsAndDataStructures.html">https://blog.cleancoder.com/uncle-bob/2019/06/16/ObjectsAndDataStructures.html</a></p><blockquote><p>类是什么？</p></blockquote><p>类是一组相似对象的范本。</p><blockquote><p>对象又是什么呢？</p></blockquote><p>对象是对封装的数据进行操作的一组函数。</p><blockquote><p>不如这么说:对象是对隐含数据进行操作的一组函数。</p></blockquote><p>隐式数据？什么意思？</p><blockquote><p>对象的函数隐含意味着某些数据是存在的。但是该数据无法在对象外部直接访问或看到。</p></blockquote><p>数据不是对象内部的吗？</p><blockquote><p>可能是; 但没有规则说必须如此。从用户的角度来看，一个对象不过是一组函数。这些函数所需要的数据必须存在，但是用户不知道该数据的位置。</p></blockquote><p>嗯，好，我同意。</p><blockquote><p>好。现在说说，数据结构是什么？</p></blockquote><p>数据结构是一组内聚的数据。</p><blockquote><p>或者，换句话说，数据结构是由隐含函数操作的一组数据。</p></blockquote><p>好的，好的。我知道了。数据结构没有定义对数据结构进行操作的函数，但是数据结构的存在意味着某些函数必须存在。</p><blockquote><p>对。你有什么发现没有？</p></blockquote><p>对象和数据结构似乎是彼此相反的。</p><blockquote><p>确实。它们是彼此互补的。</p><ul><li>对象是对隐式数据进行操作的一组函数。</li><li>数据结构是被隐式函数操作的一组数据。</li></ul></blockquote><p>哇，所以对象不是数据结构了？</p><blockquote><p>说对了。对象与数据结构相反。</p></blockquote><p>那么DTO（Data Transfer Object）不是对象吗？</p><blockquote><p>DTO是数据结构。</p></blockquote><p>所以数据库表也不是对象吗？</p><blockquote><p>数据库包含数据结构，而不是对象。</p></blockquote><p>可是，等等。ORM(Object Relational Mapper)不是将数据库表映射到对象吗？</p><blockquote><p>当然不是。数据库表和对象之间没有映射。数据库表是数据结构，而不是对象。</p></blockquote><p>那么，ORM算是干嘛的呢？</p><blockquote><p>在数据结构之间传输数据。</p></blockquote><p>ORM与对象无关是吗？</p><blockquote><p>完全无关，ORM其实是不存在的。因为数据库表和对象之间没有映射。</p></blockquote><p>但是我还以为ORM为我们创建了业务对象呢。</p><blockquote><p>不对，ORM会提取业务对象所操作的数据。该数据包含在ORM加载的数据结构中。</p></blockquote><p>但是，业务对象是不是会包含该数据结构啊？</p><blockquote><p>它可能包含，也可能不包含。但是这不关ORM的事。</p></blockquote><p>这种说法似乎是咬文嚼字，不太重要。</p><blockquote><p>不，这具有重大意义。</p></blockquote><p>怎么讲？</p><blockquote><p>例如数据库schema的设计与业务对象的设计。业务对象定义业务行为的结构。数据库schema定义业务数据的结构。这两个结构受到非常不同的力的约束。业务数据的结构不一定是业务行为的最佳结构。</p></blockquote><p>嗯？令人困惑。</p><blockquote><p>这样想吧。数据库schema不仅为一个应用程序服务；它必须服务于整个企业。因此，该数据的结构是许多不同应用程序之间的折衷方案。</p></blockquote><p>好，我知道了。</p><blockquote><p>好。但是现在来说单独的应用程序。每个应用程序的对象模型描述了该应用程序的行为的构造方式。每个应用程序将具有不同的对象模型，并根据该应用程序的行为进行调整。</p></blockquote><p>哦，我懂了。由于数据库schema是各种应用程序的折衷方案，因此该schema将不符合任何特定应用程序的对象模型。</p><blockquote><p>对！对象和数据结构受到非常不同的作用力的约束。他们很少能对齐。人们习惯称其为对象&#x2F;关系阻抗失衡（Object&#x2F;Relational impedance mismatch）。</p></blockquote><p>我听说过，但是我认为阻抗失衡是由ORM解决的。</p><blockquote><p>现在你知道不是这样的了。因为对象和数据结构是互补的，而不是同构的，所以没有阻抗失配。</p></blockquote><p>什么？</p><blockquote><p>它们是对立的，不是相似的实体。</p></blockquote><p>相反吗?</p><blockquote><p>是的，以一种非常有趣的方式。你会看到，对象和数据结构意味着相反的控制结构。</p></blockquote><p>等一下，什么?</p><blockquote><p>考虑一组符合公共接口的类。例如，想象一下表示二维形状的类，这些类都具有计算area面积和perimeter周长的函数。</p></blockquote><p>为什么每个软件示例都总是提到形状？</p><blockquote><p>让我们只考虑两种不同的类型：Square和Circle。应该很容易看清楚的是，这两个类的area和permimeter函数在不同的隐式数据结构上运行。还应该清楚的是，调用这些函数的方式是通过动态多态性进行的。</p></blockquote><p>等下，慢一点，什么？</p><blockquote><p>有两种不同的area函数；一个是Square的，另一个是Circle的。当调用者在特定对象上调用area函数时，只有该对象才知道要调用哪个函数。我们称之为动态多态性。</p></blockquote><p>好。当然。该对象知道其方法的实现。当然。</p><blockquote><p>现在，让我们将这些对象换成数据结构。我们将使用标签联合（discriminated union）。</p></blockquote><p>标签联合是什么？</p><blockquote><p>标签联合。在我们当前讨论的情况下，这只是两个不同的数据结构。一个是Square另一个是Circle。Circle数据结构有一个圆心和半径。它还有一个将其标识为Circle的类型码。</p></blockquote><p>你是说像枚举？</p><blockquote><p>当然。Square数据结构有左顶点，和边长。它还有类型区分符(type discriminator)–枚举。</p></blockquote><p>好。具有类型码的两个数据结构。</p><blockquote><p>对。现在考虑area函数。它要有一个switch语句，不是吗？</p></blockquote><p>嗯，当然，对应两种不同的情况。一个用于Square另一个用于Circle。并且perimeter函数也需要类似的switch语句。</p><blockquote><p>对。现在考虑这两种场景的结构。在对象场景中，area函数的两个实现彼此独立，并且（在某种意义上）从属于类型。Square的area函数属于Square，Circle的area函数属于Circle。</p></blockquote><p>好的，我知道您的意思了。在数据结构场景中，area的两个实现在同一个函数中，它们并不“从属于”类型。</p><blockquote><p>接下来会更有趣。如果要将Triangle类型添加到对象方案中，必须更改哪些代码？</p></blockquote><p>无需更改代码。您只需创建新Triangle类。哦，我想必须更改实例的创建者。</p><blockquote><p>对。因此，当添加新类型时，几乎没有什么变化。现在，假设您要添加一个新函数-比如center函数。</p></blockquote><p>那么，你就必须在Circle，Square，和Triangle这三个类里面都去添加center函数。</p><blockquote><p>好。因此添加新函数很困难，必须更改每个类。</p></blockquote><p>但是在数据结构上却有所不同。为了添加Triangle，必须更改每个函数以将Triangle的case添加到switch语句里面去。</p><blockquote><p>对。添加新类型很困难，必须更改每个函数。</p></blockquote><p>但是，当您添加新center函数时，无需更改任何现存代码。</p><blockquote><p>对。添加新函数很容易。</p></blockquote><p>哇。恰恰相反。</p><blockquote><p>对。我们来复习：</p><ul><li>向一组类中添加新函数很困难，必须更改每个类。</li><li>向一组数据结构中添加新函数很容易，只需添加函数，无需其他改变。</li><li>向一组类中添加新类型很容易，只需添加新类即可。</li><li>向一组数据结构中添加新类型很困难，必须更改每个函数。</li></ul></blockquote><p>是的，相反。以一种有趣的方式对立。我的意思是，如果您知道要向一组类型中添加新函数，则应该使用数据结构。但是，如果您知道要添加新的类型，则可以使用类。</p><blockquote><p>说得好！但是，今天我们还有最后一件事要考虑。数据结构和类的对立还有另一种方式，与依赖关系有关。</p></blockquote><p>依赖关系？</p><blockquote><p>是的，源代码的依赖方向。</p></blockquote><p>具体来说呢？</p><blockquote><p>考虑数据结构的情况。每个函数都有一个switch语句，该语句根据类型码选择适当的实现。</p></blockquote><p>对，然后？</p><blockquote><p>考虑对area函数的调用。调用者依赖于area函数，而area函数依赖于每个特定的实现。</p></blockquote><p>您所说的“依赖”是什么意思？</p><blockquote><p>想象一下，area的每个实现都被写入了单独的函数中。所以有circleArea，squareArea和triangleArea。</p></blockquote><p>OK，switch语句会调用这几个函数。</p><blockquote><p>想象一下这几个函数在不同的源文件中。</p></blockquote><p>那么，包含有switch语句的源文件就必须import，use或include这些源文件。</p><blockquote><p>对。这就是源代码依赖性。一个源文件依赖于另一个源文件。这种依赖的方向是什么？</p></blockquote><p>带有switch语句的源文件依赖于包含实现的源文件。</p><blockquote><p>那area函数的调用者呢？</p></blockquote><p>area函数的调用者依赖于包含switch语句的源文件，该文件的switch语句依赖于各个实现。</p><blockquote><p>正确。从调用者到实现，所有源文件依赖性都指向调用的方向。因此，如果您对其中的一种实现进行了微小的更改……</p></blockquote><p>好的，我知道您的意思。对任何一种实现的更改将导致重新编译带有switch语句的源文件，从而导致每个调用switch语句的人重新编译。</p><blockquote><p>对。至少对于依赖于源文件的更改日期来确定应编译哪些模块的语言系统而言，这么说是正确的。</p></blockquote><p>几乎所有使用静态类型的语言，对吗？</p><blockquote><p>是的，有些非静态的也会。</p></blockquote><p>大量的重新编译。</p><blockquote><p>还有大量的重新部署。</p></blockquote><p>是的，但是在类的情况下这是相反的吗？</p><blockquote><p>是的，因为area函数的调用者依赖于接口，而函数实现也依赖于该接口。</p></blockquote><p>我明白你的意思了。Square类的源文件将import，use或include Shape接口的源文件。</p><blockquote><p>对。实现的源文件指向调用的相反方向。他们从实现指向调用者。至少对于静态类型的语言来说是这样。对于动态类型的语言，area函数的调用者完全不依赖任何内容。链接在运行时确定。</p></blockquote><p>对，因此，如果您更改其中一种实现方式…</p><blockquote><p>仅更改的文件需要重新编译或重新部署。</p></blockquote><p>那是因为源文件之间的依赖关系指向调用方向的反方向。</p><blockquote><p>对。我们称之为依赖倒置。</p></blockquote><p>好，让我看看我是否可以总结一下。类和数据结构在至少三种不同的方式上是相反的。</p><ul><li>类使函数可见，隐藏数据。数据结构使数据可见，隐藏函数。</li><li>类使添加类型变得容易，但是却难以添加函数。数据结构使添加函数变得容易，但难以添加类型。</li><li>数据结构导致调用者重新编译和重新部署。类将调用者与重新编译和重新部署隔离开。</li></ul><blockquote><p>你说对了。这些都是每个优秀的软件设计人员和架构师都需要牢记的问题。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原文作者：Robert C. Martin (Uncle Bob)&lt;br&gt;原文链接：&lt;a href=&quot;https://blog.cleancoder.com/uncle-bob/2019/06/16/ObjectsAndDataStructures.html&quot;&gt;https:</summary>
      
    
    
    
    
    <category term="Uncle Bob" scheme="https://cuipengfei.me/tags/Uncle-Bob/"/>
    
  </entry>
  
  <entry>
    <title>Desugar Scala 20 -- Self Type</title>
    <link href="https://cuipengfei.me/blog/2020/01/07/desugar-scala-20-self-type/"/>
    <id>https://cuipengfei.me/blog/2020/01/07/desugar-scala-20-self-type/</id>
    <published>2020-01-07T10:57:20.000Z</published>
    <updated>2020-01-07T10:57:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>Scala里有一个很有趣的语言特性叫做Self Type，可以用来限定一个trait可以被mixin到哪里去。</p><p>看个例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">username</span></span>: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Tweeter</span> </span>&#123;</span><br><span class="line">  self: <span class="type">User</span> =&gt;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tweet</span></span>(tweetText: <span class="type">String</span>) = println(<span class="string">s&quot;<span class="subst">$username</span>: <span class="subst">$tweetText</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VerifiedTweeter</span>(<span class="params">val username_ : <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">username</span> </span>= <span class="string">s&quot;real <span class="subst">$username_</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SelfTypeBlog</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> realBeyoncé = <span class="keyword">new</span> <span class="type">VerifiedTweeter</span>(<span class="string">&quot;Beyoncé&quot;</span>) <span class="keyword">with</span> <span class="type">User</span> <span class="keyword">with</span> <span class="type">Tweeter</span></span><br><span class="line">    realBeyoncé.tweet(<span class="string">&quot;Just spilled my glass of lemonade&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User就仅仅相当于一个Interface，定义一个username。</p><p>Tweeter内的第一行是重点 <code>self: User =&gt;</code> 就限定了Tweeter只能被mixin到实现了User的类里面去。<br>由于可以确定Tweeter只能被mixin到实现了User的类里面去，这样Tweeter的tweet方法内就可以放心大胆地用 <code>username</code> 了。</p><p>VerifiedTweeter是一个很普通的class，别人new它的时候给什么字符串，它的username就是啥。</p><p>最后，在main函数里new一个VerifiedTweeter，把User和Tweeter都mixin进去。<br>然后就可以调用tweet方法了。</p><p>而如果没有mixin User，直接试图mixin Tweeter，就会出一个编译错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Illegal inheritance, self-type VerifiedTweeter with Tweeter does not conform to User</span><br></pre></td></tr></table></figure><p>到这里，其实就可以猜到了：<br>由于Self Type是在编译时限定一个trait可以被mixin到哪里去的，并且我们知道在bytecode level上没有限定一个Interface可以被谁实现的机制。<br>由此可知，反编译这段Scala对应的class文件是看不到任何神奇的东西的。</p><p>不过，<strong>很久之前</strong>写过“Scala中的语言特性是如何实现的(3) – trait”：<br><a href="https://cuipengfei.me/blog/2013/10/13/scala-trait/">https://cuipengfei.me/blog/2013/10/13/scala-trait/</a></p><p>其中对于Scala如何编译trait做了逆向工程的分析，当时的trait是编译成了一个抽象类加一个接口。这个信息已经过时了。<br>现在更新版的Scala可以编译出bytecode version 52，这一版是有interface default method的。</p><p>所以，还是反编译一下吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">User</span></span><br><span class="line">&#123;</span><br><span class="line">    String <span class="title function_">username</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Tweeter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="comment">/* synthetic */</span> <span class="keyword">void</span> tweet$(<span class="keyword">final</span> Tweeter $<span class="built_in">this</span>, <span class="keyword">final</span> String tweetText) &#123;</span><br><span class="line">        $<span class="built_in">this</span>.tweet(tweetText);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">(<span class="keyword">final</span> String tweetText)</span> &#123;</span><br><span class="line">        Predef$.MODULE$.println((Object)<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">2</span>).append(((User)<span class="built_in">this</span>).username()).append(<span class="string">&quot;: &quot;</span>).append(tweetText).toString());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> $init$(<span class="keyword">final</span> Tweeter $<span class="built_in">this</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VerifiedTweeter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String username_;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">username_</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.username_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">username</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">5</span>).append(<span class="string">&quot;real &quot;</span>).append(<span class="built_in">this</span>.username_()).toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VerifiedTweeter</span><span class="params">(<span class="keyword">final</span> String username_)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username_ = username_;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是User Tweeter VerifiedTweeter他们三个的反编译结果，都比较单纯。<br>只是Tweeter这个含有一个实现方法的trait被编译成了有default method的Interface，而不像老版本的Scala要编译成一个抽象类加一个Interface。</p><p>然后看一下main函数反编译出来的样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> VerifiedTweeter realBeyonc\u00e9 = (VerifiedTweeter)<span class="keyword">new</span> <span class="title class_">SelfTypeBlog$$anon</span>.SelfTypeBlog$$anon$<span class="number">1</span>();</span><br><span class="line">    ((Tweeter)realBeyonc\u00e9).tweet(<span class="string">&quot;Just spilled my glass of lemonade&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里new的是一个叫做SelfTypeBlog$$anon$1的类。这个类反编译出来是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SelfTypeBlog$$anon$1</span> <span class="keyword">extends</span> <span class="title class_">VerifiedTweeter</span> <span class="keyword">implements</span> <span class="title class_">User</span>, Tweeter &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">(<span class="keyword">final</span> String tweetText)</span> &#123;</span><br><span class="line">        Tweeter.tweet$((Tweeter)<span class="built_in">this</span>, tweetText);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> SelfTypeBlog$$anon$<span class="number">1</span>() &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;Beyonc\u00e9&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        Tweeter.$init$((Tweeter)<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它继承了VerifiedTweeter，实现了User和Tweeter。<br>由此可见Scala中在对象创建时才with trait的写法，Scala编译器会产出一个类来表达。</p><p>如同前面推测的一样，在bytecode level上，没有神奇的东西，self type这个语言特性是仰赖于Scala compiler来做到的。</p><p>不过，既然是全靠Scala compiler来做到的，那就意味着如果我用别的compiler的话，这个限定就无法在<strong>编译时</strong>生效了。</p><p>来试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNotUser</span> <span class="keyword">implements</span> <span class="title class_">Tweeter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">abc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段Java代码编译起来完全没问题，没人强迫我去实现User，毕竟Tweeter对于Java来说就是个普通的Interface嘛。</p><p>然后跑一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">JNotUser</span>().tweet(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>会怎样呢？</p><p>结果是执行的时候出现一个类型转换异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException: class TraitSelfTypeBlog.JNotUser cannot be cast to class TraitSelfTypeBlog.User</span><br></pre></td></tr></table></figure><p>为啥会这样呢？仔细看下上面Tweeter反编译的结果中tweet方法的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">(<span class="keyword">final</span> String tweetText)</span> &#123;</span><br><span class="line">    Predef$.MODULE$.println((Object)<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">2</span>).append(((User)<span class="built_in">this</span>).username()).append(<span class="string">&quot;: &quot;</span>).append(tweetText).toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键就在这个 <code>(User)this</code> 了。</p><p>虽然编译时限制不住，运行时终归逃不过。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Scala里有一个很有趣的语言特性叫做Self Type，可以用来限定一个trait可以被mixin到哪里去。&lt;/p&gt;
&lt;p&gt;看个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p</summary>
      
    
    
    
    
    <category term="Desugar_Scala" scheme="https://cuipengfei.me/tags/Desugar-Scala/"/>
    
    <category term="Scala" scheme="https://cuipengfei.me/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Desugar Scala(19) -- Partial Function</title>
    <link href="https://cuipengfei.me/blog/2020/01/05/desugar-scala-19-partial-function/"/>
    <id>https://cuipengfei.me/blog/2020/01/05/desugar-scala-19-partial-function/</id>
    <published>2020-01-05T11:58:10.000Z</published>
    <updated>2020-01-05T11:58:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>先看这么一段Scala代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PFBlog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">usePF</span></span>(pf: <span class="type">PartialFunction</span>[<span class="type">Option</span>[<span class="type">Int</span>], <span class="type">Int</span>]) = &#123;</span><br><span class="line">    pf(<span class="type">Some</span>(<span class="number">11</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  usePF &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Some</span>(x) =&gt; x + <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个usePF方法，接受一个PartialFunction作为参数，它的实现就是传一个 <code>Some(11)</code> 给pf。<br>pf的具体类型是 <code>PartialFunction[Option[Int], Int]</code> 所以传递给它一个<code>Some(11)</code>可以期待它会返回一个Int。</p><p>然后调用usePF，传递给usePF的是一个pattern match表达式。给Some加一，给None返回0。</p><p>这时问题就来了，这个pattern match表达式是怎么能够符合usePF需要的参数类型的呢？<br>这么单纯的一个pattern match表达式怎么变成<code>PartialFunction[Option[Int], Int]</code>的呢？</p><p>为了探寻答案，先把这几行Scala代码编译成class文件，然后把byte code反编译成Java来一探究竟吧。</p><p>以上Scala代码会编译出3个class文件：</p><ul><li>PFBlog.class</li><li>PFBlog$.class</li><li>PFBlog$$anonfun$1.class</li></ul><p>逐个反编译出来看一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PFBlog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">usePF</span><span class="params">(<span class="keyword">final</span> PartialFunction&lt;Option&lt;Object&gt;, Object&gt; pf)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PFBlog$.MODULE$.usePF((PartialFunction)pf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是PFBlog，里面声明了一个usePF方法，它的实现完全代理给PFBlog$。那么它就只是对应Scala代码内的object PFBlog的对外声明。</p><p>接下来，那就看下PFBlog$吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PFBlog$</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PFBlog$ MODULE$;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        (MODULE$ = <span class="keyword">new</span> <span class="title class_">PFBlog$</span>()).usePF((PartialFunction&lt;Option&lt;Object&gt;, Object&gt;)<span class="keyword">new</span> <span class="title class_">PFBlog$$anonfun</span>.PFBlog$$anonfun$<span class="number">1</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">usePF</span><span class="params">(<span class="keyword">final</span> PartialFunction&lt;Option&lt;Object&gt;, Object&gt; pf)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BoxesRunTime.unboxToInt(pf.apply((Object)<span class="keyword">new</span> <span class="title class_">Some</span>((Object)BoxesRunTime.boxToInteger(<span class="number">11</span>))));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> PFBlog$() &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的usePF就有真的实现了，对应原Scala的usePF。调用pf.apply，并传递Some(11)。<br>并且，它的静态块里自己调用了usePF。这就对应了原Scala中对usePF的调用。<br>值得注意的调用usePF时传递的参数，是一个<code>new PFBlog$$anonfun.PFBlog$$anonfun$1()</code>，这就是第三个class文件的内容了。<br>那这个<code>new PFBlog$$anonfun.PFBlog$$anonfun$1()</code>就一定是对应原本的pattern match表达式了。</p><p>接下来看下<code>PFBlog$$anonfun$1.class</code> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PFBlog$$anonfun$1</span> <span class="keyword">extends</span> <span class="title class_">AbstractPartialFunction</span>&lt;Option&lt;Object&gt;, Object&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;A1 <span class="keyword">extends</span> <span class="title class_">Option</span>&lt;Object&gt;, B1&gt; B1 <span class="title function_">applyOrElse</span><span class="params">(<span class="keyword">final</span> A1 x1, <span class="keyword">final</span> Function1&lt;A1, B1&gt; <span class="keyword">default</span>)</span> &#123;</span><br><span class="line">        Object o;</span><br><span class="line">        <span class="keyword">if</span> (x1 <span class="keyword">instanceof</span> Some) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> BoxesRunTime.unboxToInt(((Some)x1).value());</span><br><span class="line">            o = BoxesRunTime.boxToInteger(x2 + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (None$.MODULE$.equals(x1)) &#123;</span><br><span class="line">            o = BoxesRunTime.boxToInteger(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            o = <span class="keyword">default</span>.apply((Object)x1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (B1)o;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isDefinedAt</span><span class="params">(<span class="keyword">final</span> Option&lt;Object&gt; x1)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x1 <span class="keyword">instanceof</span> Some || None$.MODULE$.equals(x1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> PFBlog$$anonfun$<span class="number">1</span>() &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，PFBlog$$anonfun$1继承了AbstractPartialFunction。<br>这个AbstractPartialFunction是在Scala标准库里定义了的，它mixin了PartialFunction。<br>所以，PFBlog$$anonfun$1自然就符合了usePF对参数要求的类型。</p><p>再看PFBlog$$anonfun$1内的具体实现，isDefinedAt对于Some或者None返回true。applyOrElse则做了原Scala中pattern match表达式给Some加一，给None返回零的逻辑。</p><p>由于AbstractPartialFunction中的apply方法是这样的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">T1</span>): <span class="type">R</span> = applyOrElse(x, <span class="type">PartialFunction</span>.empty)</span><br></pre></td></tr></table></figure><p>这就确保了当PFBlog$$anonfun$1的apply被调用到的时候，我们原Scala中的pattern match表达式的逻辑可以得到执行。</p><p>到这里就明白了，Scala编译器很勤劳，吭哧吭哧的给：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">Some</span>(x) =&gt; x + <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><p>产出了一个PFBlog$$anonfun$1并产出了isDefinedAt和applyOrElse方法。<br>从而让这个pattern match表达式可以符合usePF的参数类型。</p><p>最后，很久前写过一个关于partial application的博客： <a href="https://cuipengfei.me/blog/2013/12/25/desugar-scala-6/">https://cuipengfei.me/blog/2013/12/25/desugar-scala-6/</a><br>值得注意的是，虽然partial function和partial application名字里都有partial这个字，但是<strong>他俩其实没啥关系</strong>。<br>一个是关于把pattern match表达式编译成PartialFunction的实现类的。另一个是关于柯里化的。</p><p>这篇博客只关心Scala编译器是怎么支持Partial Function这个语言特性的。<br>关于Partial Function的更多信息，可以看看老人家的文章： <a href="https://www.jianshu.com/p/b0b4e3a349c3">https://www.jianshu.com/p/b0b4e3a349c3</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先看这么一段Scala代码：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2</summary>
      
    
    
    
    
    <category term="Desugar_Scala" scheme="https://cuipengfei.me/tags/Desugar-Scala/"/>
    
    <category term="Scala" scheme="https://cuipengfei.me/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Future-异步函数的两个视角</title>
    <link href="https://cuipengfei.me/blog/2019/12/29/future-from-two-perspectives/"/>
    <id>https://cuipengfei.me/blog/2019/12/29/future-from-two-perspectives/</id>
    <published>2019-12-29T13:02:39.000Z</published>
    <updated>2019-12-29T13:02:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们来一起看一下两个程序员之间的故事。</p><p>以下示例代码是用Scala写的，不过本文所讲的话题并不仅限于Scala，任何有Future&#x2F;Promise支持的语言都是适用的。<br>下面这个wiki页面罗列了各个有Future&#x2F;Promise支持的语言，已经涵盖了大多数的常用语言。<br><a href="https://zh.wikipedia.org/wiki/Future%E4%B8%8Epromise#%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8">Future与promise实现列表</a></p><h1 id="我是异步函数的编写者"><a href="#我是异步函数的编写者" class="headerlink" title="我是异步函数的编写者"></a>我是异步函数的编写者</h1><p>我写了两个异步函数,来提供给其他程序员同事使用。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">CallBack</span> </span>= <span class="type">Try</span>[<span class="type">String</span>] =&gt; <span class="type">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pretendCallAPI</span></span>(callBack: <span class="type">CallBack</span>, okMsg: <span class="type">String</span>, failedMsg: <span class="type">String</span>) = &#123;</span><br><span class="line">  <span class="keyword">val</span> task = <span class="keyword">new</span> <span class="type">TimerTask</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() = &#123;</span><br><span class="line">      <span class="keyword">val</span> percentage = <span class="type">Random</span>.between(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (percentage &gt;= <span class="number">50</span>)</span><br><span class="line">        callBack(<span class="type">Success</span>(okMsg))</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (percentage &lt;= <span class="number">30</span>)</span><br><span class="line">        callBack(<span class="type">Failure</span>(<span class="keyword">new</span> <span class="type">Exception</span>(failedMsg)))</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        callBack(<span class="type">Failure</span>(<span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">&quot;network problem&quot;</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> <span class="type">Timer</span>().schedule(task, <span class="type">Random</span>.between(<span class="number">200</span>, <span class="number">500</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> searchTB = pretendCallAPI(_, <span class="string">&quot;product price found&quot;</span>, <span class="string">&quot;product not listed&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> buyFromTB = pretendCallAPI(_, <span class="string">&quot;product bought&quot;</span>, <span class="string">&quot;can not buy, no money left&quot;</span>)</span><br></pre></td></tr></table></figure><p>这两个异步函数: <code>searchTB</code>用来从淘宝搜索物品,另一个<code>buyFromTB</code>用来购买搜到的物品。</p><p>由于仅仅是为了演示而写的,他们两个都是基于一个叫做<code>pretendCallAPI</code>的函数实现的。<br>顾名思义,<code>pretendCallAPI</code>并不会真的去调用淘宝的API,而只是模拟API的行为。</p><p>这个<code>pretendCallAPI</code>函数有几个行为特征:</p><ul><li>每次耗时200到500毫秒之间</li><li>每次执行有50%的几率成功</li><li>20%的几率遇到网络故障</li><li>另外30%的几率虽然网络没问题但是服务器会给你一个非正常的结果</li></ul><p>当然,由于我写的是异步算法,需要避免block caller thread。<br>所以当你调用<code>pretendCallAPI</code>的时候,这个函数是<strong>瞬间立即返回的</strong>。<br>那么当然我就<strong>无法在函数返回的时候return什么有用的东西</strong>给你了。</p><p>如果你想知道执行的结果到底是啥,你需要传给我一个<code>CallBack</code>,在我执行完后,通过<code>CallBack</code>来告知你执行的结果。<br>这个<code>CallBack</code>的完整签名表达式展开是<code>Try[String] =&gt; Unit</code></p><p>大家看<code>searchTB</code>和<code>buyFromTB</code>可能觉得他们长的有点奇怪,这是Scala里柯里化的写法。<br>也就是通过把<code>pretendCallAPI</code>包一层来构造新的函数,锁死两个参数,剩下的一个参数(也就是<code>CallBack</code>)就变成了新构造出来的函数的唯一参数了。<br>也就是说<code>searchTB</code>和<code>buyFromTB</code>的签名是<code>(Try[String] =&gt; Unit) =&gt; Unit</code>。</p><p>关于柯里化这个语言特性的更多信息:<br><a href="https://cuipengfei.me/blog/2013/12/25/desugar-scala-6/">https://cuipengfei.me/blog/2013/12/25/desugar-scala-6/</a></p><p>好了,现在这两个函数可以提供给大家使用了。</p><h1 id="我是异步函数的调用者"><a href="#我是异步函数的调用者" class="headerlink" title="我是异步函数的调用者"></a>我是异步函数的调用者</h1><p>听说异步函数已经写好了,我终于可以用他们来实现剁手业务了。</p><p>听函数作者讲了一下,用起来应该不会很难,那我来实现一下吧。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchPriceThenBuy</span></span>() = &#123;</span><br><span class="line">  searchTB &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Success</span>(searchMsg) =&gt;</span><br><span class="line">      println(searchMsg)</span><br><span class="line">      buyFromTB &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Success</span>(buyMsg) =&gt; println(buyMsg)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Failure</span>(err) =&gt; println(err.getMessage)</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Failure</span>(err) =&gt; println(err.getMessage)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>searchTB</code>和<code>buyFromTB</code>并不难. 他们两个都是接受<code>CallBack</code>作为参数的函数。<br><code>CallBack</code>本身是个函数,它的签名是<code>Try[String] =&gt; Unit</code>。<br>而<code>Try</code>有两种形式,分别是<code>Success</code>和<code>Failure</code>。</p><p>所以在调用<code>searchTB</code>和<code>buyFromTB</code>的时候,必须把两个分支都给到(以免pattern match不到)。<br>这样在异步函数有结果的时候(无论成败)才能call back过来到我的代码,以便我能够在合适的时机做后续的处理(无论是基于成功做后续业务,还是做error handling)。</p><p>关于pattern match,可以参考这里:<br><a href="https://cuipengfei.me/blog/2013/12/29/desugar-scala-8/">https://cuipengfei.me/blog/2013/12/29/desugar-scala-8/</a><br><a href="https://cuipengfei.me/blog/2015/06/16/visitor-pattern-pattern-match/">https://cuipengfei.me/blog/2015/06/16/visitor-pattern-pattern-match/</a></p><p>这段代码跑一下的话,会有这么几种结果:</p><ul><li>搜到了,也买到了</li><li>搜到了,购买时遇到了网络故障</li><li>搜到了,由于支付宝钱不够而没买到</li><li>没搜到,购买行为未触发</li><li>搜索遇到网络故障,购买行为未触发</li></ul><p>一共就这么几种可能,因为<code>pretendCallAPI</code>是跑概率的,多跑几次这些情况都能遇到。</p><p>虽然实现出来不难,执行结果也没问题,但是总有点<strong>隐忧</strong>。</p><p>这里只有<code>searchTB</code>和<code>buyFromTB</code>两个函数,如果其他场景下我需要把更多的异步函数组合起来使用呢?岂不是要缩进很多层?</p><p>当然,缩进只是个视觉审美问题,是个表象,不是特别要紧.关键是<strong>我的业务逻辑很容易被这样的代码给割裂的鸡零狗碎</strong>,那就不好了。<br>我要给上游编写异步函数的同事反馈一下，看是否有办法解决这个问题。</p><h1 id="镜头切回到异步函数编写者"><a href="#镜头切回到异步函数编写者" class="headerlink" title="镜头切回到异步函数编写者"></a>镜头切回到异步函数编写者</h1><p>之前写的两个函数反馈不太好，主要是因为同事们认为使用<code>CallBack</code>不是最优的方式。<br>这个反馈确实很中肯，如果只有一个异步函数单独使用，用<code>CallBack</code>也没什么太大的问题，如果是很多个异步函数组合使用确实会形成多层嵌套的问题。<br>我作为上游程序员，确实需要更多地为下游调用者考虑。</p><p>既然如此，那我改版一下，免除掉让下游使用<code>CallBack</code>的必要性。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">CallBackBasedFunction</span> </span>= (<span class="type">CallBack</span>) =&gt; <span class="type">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">futurize</span></span>(f: <span class="type">CallBackBasedFunction</span>) = () =&gt; &#123;</span><br><span class="line">  <span class="keyword">val</span> promise = <span class="type">Promise</span>[<span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line">  f &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Success</span>(msg) =&gt; promise.success(msg)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Failure</span>(err) =&gt; promise.failure(err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  promise.future</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> searchTBFutureVersion = futurize(searchTB)</span><br><span class="line"><span class="keyword">val</span> buyFromTBFutureVersion = futurize(buyFromTB)</span><br></pre></td></tr></table></figure><p>先定义一个<code>CallBackBasedFunction</code>，它代表一个接受<code>CallBack</code>为参数的函数的签名。</p><p>表达式展开后就是：　<code>(Try[String] =&gt; Unit) =&gt; Unit</code><br>这就符合了<code>searchTB</code>和<code>buyFromTB</code>两个函数的签名。</p><p><code>futurize</code>算是个higher order function,它接受一个<code>CallBackBasedFunction</code>作为参数，返回一个<code>() =&gt; Future[String]</code>。<br>(<code>Future</code>是Scala标准库的内容，可以认为和JS Promises&#x2F;A+是类似的概念)</p><p>也就是说<code>futurize</code>可以把<code>searchTB</code>和<code>buyFromTB</code>改造成返回<code>Future</code>的函数。上面代码最后两行就是改造的结果。</p><p>这样，原本接受<code>CallBack</code>做为参数且没有返回值的函数，就变成了不接受参数且返回<code>Future</code>的函数。</p><p>再看<code>futurize</code>的具体实现，它使用了Scala的<code>Promise</code>，让返回的<code>Future</code>在原版函数成功时成功，在原版函数失败时失败。</p><p>这样，我就得到了<code>searchTBFutureVersion</code>和<code>buyFromTBFutureVersion</code>这两个<strong>仍然是立即瞬间返回，不会block caller thread</strong>的函数。</p><p>关于Scala中Promise和Future的更多信息：<br><a href="https://docs.scala-lang.org/overviews/core/futures.html">https://docs.scala-lang.org/overviews/core/futures.html</a></p><h1 id="镜头再切到异步函数调用者"><a href="#镜头再切到异步函数调用者" class="headerlink" title="镜头再切到异步函数调用者"></a>镜头再切到异步函数调用者</h1><p>现在有了<code>searchTBFutureVersion</code>和<code>buyFromTBFutureVersion</code>，我来试着重新实现一次：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchPriceThenBuyFutureVersion</span></span>() = &#123;</span><br><span class="line">  <span class="keyword">val</span> eventualResult = <span class="keyword">for</span> &#123;</span><br><span class="line">    searchResult &lt;- searchTBFutureVersion().map(msg =&gt; println(msg))</span><br><span class="line">    buyResult &lt;- buyFromTBFutureVersion().map(msg =&gt; println(msg))</span><br><span class="line">  &#125; <span class="keyword">yield</span> (searchResult, buyResult)</span><br><span class="line"></span><br><span class="line">  eventualResult.onComplete &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Failure</span>(err) =&gt; println(err.getMessage)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了Scala的for comprehension，编译后会变成map，flatMap等等monadic operator。<br>而map,flatMap等操作符正是Scala中Future拿来做组合用的。</p><p>这样，用for把两个返回Future的异步函数组织起来，形成一个新的Future，然后在新的Future complete时统一处理异常。</p><p>关于for的更多信息：<br><a href="https://cuipengfei.me/blog/2014/08/30/options-for/">https://cuipengfei.me/blog/2014/08/30/options-for/</a></p><p>这次实现的代码与上次的行为是一致的,没什么两样。<br>不过我的<strong>业务代码从鸡零狗碎变成了平铺直叙平易近人</strong>。<br>(这种效果在这里表现的并不是特别突出，不过很容易想象如果需要组合使用的异步函数更多一些的话，这种效果的好处就显露出来了)</p><p>当然了，让业务代码易读易懂主要还是要靠<strong>个人奋斗</strong>，而有了Promise和Future这种<strong>历史进程</strong>的推力，则更有增益作用。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>最近在看Scala Reactive的一些内容<br>想起了很久之前写过一篇叫做<strong>自己动手实现Promises&#x2F;A+规范</strong>的博客，用JS实现了一个简版的Promise:<br><a href="https://cuipengfei.me/blog/2016/05/15/promise/">https://cuipengfei.me/blog/2016/05/15/promise/</a></p><p>我在当时的一段演示代码里面写了两句注释：</p><blockquote><p>Promise的作用在于</p><ol><li>给异步算法的编写者和使用者之间提供一种统一的交流手段</li><li>给异步算法的使用者提供一种组织代码的手段,以便于将一层又一层嵌套的业务主流程变成一次一次的对then的调用</li></ol></blockquote><p>不过当时的博客里只讲了实现Promise规范的事情,并没有详细解释过这两句话。<br>既然又遇到了这个话题，于是写点Scala来把当时没展开写到的内容补充了一下。</p><p>上文的四个镜头展现了两个角色的思考过程，通过这个过程其实也就解释了上面两句注释的含义。</p><blockquote><ol><li>给异步算法的编写者和使用者之间提供一种统一的交流手段</li></ol></blockquote><p>所谓统一的交流手段，其实就是异步函数的签名问题。<br>由于需要处理的业务五花八门，异步函数接受的参数列表没法统一，但是返回值是可以统一的。</p><p>一个异步函数，接受了外界给的参数，立即瞬间返回一个Js的Promise或者Scala的Future(<strong>或者是任何语言中类似概念的叫法</strong>)。<br>然后在异步任务执行完的时候把Promise resolve&#x2F;reject掉(让Future success或者failure),借此来让调用方的代码知道该到了它跑后续处理的时候了。</p><p>这样我们就获得了一个<strong>sensible default</strong>，无需在每次设计异步函数的时候都去商议该返回什么东西，该怎么获得异步执行的结果。</p><blockquote><ol start="2"><li>给异步算法的使用者提供一种组织代码的手段,以便于将一层又一层嵌套的业务主流程变成一次一次的对then的调用</li></ol></blockquote><p>所谓组织代码的手段，就是关于异步函数调用者的那两个镜头的内容了。<br>一开始<code>CallBack</code>套着<code>CallBack</code>，异步的味道很重，这体现出了代码的组织方式在向代码的技术实现低头。或者说是代码的<strong>技术实现干扰了我行文的风格</strong>。<br>后来变成了看起来很像是消费同步函数结果的写法。从而让我惯常的文风得以保持。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们来一起看一下两个程序员之间的故事。&lt;/p&gt;
&lt;p&gt;以下示例代码是用Scala写的，不过本文所讲的话题并不仅限于Scala，任何有Future&amp;#x2F;Promise支持的语言都是适用的。&lt;br&gt;下面这个wiki页面罗列了各个有Future&amp;#x2F;Promise支持</summary>
      
    
    
    
    
    <category term="Scala" scheme="https://cuipengfei.me/tags/Scala/"/>
    
    <category term="Reactive" scheme="https://cuipengfei.me/tags/Reactive/"/>
    
    <category term="🐸" scheme="https://cuipengfei.me/tags/%F0%9F%90%B8/"/>
    
    <category term="Future" scheme="https://cuipengfei.me/tags/Future/"/>
    
  </entry>
  
  <entry>
    <title>「译」大规模敏捷</title>
    <link href="https://cuipengfei.me/blog/2019/12/06/in-the-large/"/>
    <id>https://cuipengfei.me/blog/2019/12/06/in-the-large/</id>
    <published>2019-12-06T08:19:00.000Z</published>
    <updated>2019-12-06T08:19:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址： <a href="https://blog.cleancoder.com/uncle-bob/2018/04/02/InTheLarge.html">https://blog.cleancoder.com/uncle-bob/2018/04/02/InTheLarge.html</a></p><p>原作者：Robert C. Martin (Uncle Bob)</p><p>自敏捷之开端始，我们就思考大规模敏捷的问题。我们是否能够把轻量级，迭代，增量，快速反馈等软件开发的原理应用于规模巨大的项目呢？</p><p>最初我们想到的答案是Scrum of Scrums之类的东西。这个想法是在更高的层次上递归地应用敏捷开发的原理。如果一个项目需要超过5-12个开发人员，那么可以组织两个这样的团队，以及一个更高级别的团队来“监督？”他们。</p><p>请注意上面的问号。当我们开始考虑大型项目时，我们不可避免地要谈及层级化的组织。但是敏捷似乎是厌恶组织层级的。毕竟，敏捷就是关于平等主义的。敏捷是拒绝命令和控制的。敏捷是拒绝计划和时间表的，还有…</p><p><strong>无稽之谈！并不是这样的！</strong></p><p>敏捷其实是一场“风水轮流转”的革命。在软件行业的早期，我们原本就以敏捷的方式编写代码。我们写小块代码片段，对其进行了测试，将它们构建为更大的块，如此循环往复。如果您回到1960年代后期，并观察当时人们编写代码的方式，您会发现敏捷的小荷尖尖角正在显露出来。</p><p>当然，当时我们在硬件方面受到了很大的限制。编译要跑好几个小时。代码编辑要用电传打字机。那时，大多数程序员根本不会使用键盘。因此他们让按键操作员替他们输入代码。在这种环境下，很难实现快速反馈机制。</p><p>即便如此，我们仍竭尽所能去缩短反馈周期。我们使用汇编器编写程序，坐在控制台前通过用八进制或十六进制打补丁的方式来进行调试。我们可以通过在调试器中执行代码，甚至通过单步执行来测试代码。经年累月，熟能生巧。这是在合理的时间内完成工作的唯一方法。</p><p>但是“风水轮流转”了。我们开始使用在控制台上不容易调试的语言。我们开始编写越来越大的程序。为了在反馈周期如此长的环境中工作，我们需要制定计划。</p><p>瀑布就在这样的环境中诞生了出来。当编辑,编译,测试的循环周期需要一整天的时候，我们需要进行大量的计划和检查。在24小时的循环周期内做TDD和重构是不现实的！</p><p>但是“风水”一直在转动。今天的大多数程序员都没有深切体会到摩尔定律的指数发展。我们从1970年的24小时循环周期，到1980年的60分钟循环周期，到1990年的十分钟循环周期，再到2000年的10秒循环周期。到2005年，大多数程序员的循环周期不到1秒。</p><p>敏捷就在这样的环境中诞生了出来。敏捷是对1960年代快速周转，高频反馈开发策略的一种历史回归，不过这次我们有了更强大的机器，更强大的语言和工具以及更大规模的项目。</p><p>敏捷也可以说是从历史的灰烬中浴火重生而来的。瀑布虽然在70年代和80年代是很有必要的，但却令人非常痛苦。在那几十年中，我们学会了哪些事情是不该做的。因此，当敏捷在90年代末出现时，它也承载着之前那段黑暗时期所积累的教训。</p><p>敏捷却也不仅仅是对短反馈周期的历史回归。敏捷在短反馈周期的基础之上增强了纪律。诸如测试，重构，结对编程和高度自动化之类的实践。敏捷确实让我们从六十年代的策略中前进了。</p><p>不过前进的方向是什么？敏捷革命改进了什么？</p><p>敏捷革命关注的是相对较<em>小</em>的团队如何开发相对较<em>小</em>的软件项目。请注意，我强调了“<em>小</em>”这个字。</p><p>敏捷团队擅长于创建十万行左右的软件系统。十万行已经可以做很多事情了。对于许多公司而言，一两个敏捷团队足以满足他们。</p><p>另一方面，如果您需要创建一个千万行代码的系统，那么一个敏捷团队就不够了。您需要大约一百个团队来构建千万代码行级别的系统。</p><p>但是，您如何管理一百个敏捷团队？您如何给他们提供用户故事？您如何协调它们之间的接口？您如何在那千万行代码中创造边界而让团队可以彼此独立工作？</p><p>以及您如何以“敏捷”的方式做到这一点？ （这才是真正的问题）</p><p><strong>答案是：你不能！</strong></p><p>我们人类非常擅长于建设大型项目。长久以来我们就知道如何做这件事。</p><p><img data-src="https://blog.cleancoder.com/assets/pyramids.jpg" alt="alt img"></p><p>想想我们人类完成过的真正巨大的项目吧。</p><ul><li>阿波罗登月：我们把人送到月球上！</li><li>诺曼底战役：我们在50英里坚固的防线上，以156000名士兵入侵了诺曼底。</li><li>我们拥有支持80亿人口的世界经济。</li><li>全球各地都有庞大的网络，您可以在树林里徒步时在手机上读这篇文章！</li><li>你要买东西吗？按几下手机，明天甚至今天就会有人来送快递。</li><li>我们将红色跑车驶入了太阳轨道。</li></ul><p>应该不用说更多例子了。我们人类确实非常擅长做大事。</p><p>那为什么我们对大型软件会有所忧虑呢？我们已经知道如何构建大型软件了。我们已经这样做了50多年或更久了。“大”的部分实际上从来不是问题所在。我们用敏捷解决的问题是关于“<strong>小</strong>”的那部分。我们之前不知道如何搞定的，是做<strong>小</strong>型项目。</p><p>我们一直都知道如何做大型项目。那就是分而治之。敏捷解决了其中“<strong>小</strong>”的那一部分。敏捷与“<strong>大</strong>”的部分无关。</p><p>但是，但是，但是，但是……平等主义！拒绝计划和命令与控制！敏捷！</p><p><strong>无稽之谈！</strong></p><p>敏捷不是平等主义。敏捷不是拒绝计划，也不是拒绝命令和控制。事实上，敏捷是命令和控制体系中最小单元的体现：战术小队。</p><p>是的，在层级结构的末端，命令和控制不再有效。一小组人可以通过大量反馈和激烈的沟通在较短的周期内工作，以实现目标。这就是一支敏捷的团队。在这个级别上，严格的命令和控制是极为有害的。但是在此级别之上，命令和控制就变得有必要了。在层级上越往上走，这种效应就越明显。没有大量的命令和控制，就无法设计，建造，生产和销售数以亿部的iPhone。</p><p>市场上有很多种大规模敏捷的玩法。有关该主题的书籍和博客也有很多。也有人成立了咨询公司，专门为大公司做大规模敏捷的转型。这没有什么不好的。</p><p>这些大规模敏捷方法所讲的策略和技术都没有错。只不过，它们不是敏捷的。它们与敏捷无关。它们是在人类几千年来用于完成重大工作的策略和技术的基础上加了点敏捷的“味道”。</p><p>这点味道来自敏捷使用的词汇和概念。增添些口味没有错–没问题。如果您喜欢使用敏捷中的词语和概念，那就尽管去用。但是不要过分关注它的“敏捷性”。一旦你要做大规模的事情，就离开了敏捷的领域。希望您的各个开发小组正在使用敏捷；但是整个大规模项目并不是敏捷的。</p><p>因为敏捷是专注于做”<strong>小</strong>“事情的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原文地址： &lt;a href=&quot;https://blog.cleancoder.com/uncle-bob/2018/04/02/InTheLarge.html&quot;&gt;https://blog.cleancoder.com/uncle-bob/2018/04/02/InTheLa</summary>
      
    
    
    
    
    <category term="Uncle Bob" scheme="https://cuipengfei.me/tags/Uncle-Bob/"/>
    
  </entry>
  
</feed>

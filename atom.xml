<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>崔鹏飞的Blog</title>
  
  
  <link href="https://cuipengfei.is-a.dev/atom.xml" rel="self"/>
  
  <link href="https://cuipengfei.is-a.dev/"/>
  <updated>2025-09-14T12:30:00.000Z</updated>
  <id>https://cuipengfei.is-a.dev/</id>
  
  <author>
    <name>崔鹏飞</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>当泛型遇上现实：从表象到本质的技术思考</title>
    <link href="https://cuipengfei.is-a.dev/blog/2025/09/14/generic-type-erasure-deep-dive/"/>
    <id>https://cuipengfei.is-a.dev/blog/2025/09/14/generic-type-erasure-deep-dive/</id>
    <published>2025-09-14T12:30:00.000Z</published>
    <updated>2025-09-14T12:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="当泛型遇上现实：从表象到本质的技术思考"><a href="#当泛型遇上现实：从表象到本质的技术思考" class="headerlink" title="当泛型遇上现实：从表象到本质的技术思考"></a>当泛型遇上现实：从表象到本质的技术思考</h1><p>最近在优化一个序列化框架时，遇到了一些类型安全方面的意外行为。这让我重新审视了JVM泛型系统的底层机制。虽然类型擦除是个老话题，但当我深入分析Kotlin的reified实现时，发现了一些值得思考的细节。</p><h2 id="一个简单现象引发的思考"><a href="#一个简单现象引发的思考" class="headerlink" title="一个简单现象引发的思考"></a>一个简单现象引发的思考</h2><p>我们都知道Java的类型擦除，但最近在排查问题时，我又重新观察了这个现象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; intList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在运行时，它们的Class信息完全相同</span></span><br><span class="line">System.out.println(stringList.getClass() == intList.getClass()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这是类型擦除的基本表现：编译器将泛型参数替换为边界类型。不过这让我想到一个问题：既然编译器会进行严格的泛型类型检查，那反射是如何绕过这些检查机制的？</p><h2 id="反射揭示的真相"><a href="#反射揭示的真相" class="headerlink" title="反射揭示的真相"></a>反射揭示的真相</h2><p>为了理解这个机制，我做了个实验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射调用add方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> List.class.getMethod(<span class="string">&quot;add&quot;</span>, Object.class); <span class="comment">// 注意参数是Object</span></span><br><span class="line">add.invoke(list, <span class="number">42</span>); <span class="comment">// 成功添加Integer到String List</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历时才会出错</span></span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123; <span class="comment">// 这里会ClassCastException</span></span><br><span class="line">    System.out.println(<span class="string">&quot;String: &quot;</span> + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个结果其实很有启发性。关键在于<code>getMethod(&quot;add&quot;, Object.class)</code>——我们必须用<code>Object.class</code>，因为编译后的方法签名就是<code>add(Object obj)</code>。</p><p>通过字节码分析可以看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// List.add方法的实际签名</span><br><span class="line">11: invokeinterface #12,  2           // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span><br><span class="line"></span><br><span class="line">// 遍历时的类型转换</span><br><span class="line">138: invokeinterface #87,  1           // InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;</span><br><span class="line">143: checkcast     #62                 // class java/lang/String</span><br></pre></td></tr></table></figure><p>类型擦除的巧妙之处在于：编译器在需要类型转换的地方插入<code>checkcast</code>指令，将类型检查推迟到实际使用时。反射之所以能绕过编译期检查，是因为它直接操作字节码层面，而JVM运行时只验证原始类型，不验证泛型参数。</p><p>但这又让我思考另一个问题：如果反射能绕过类型检查，为什么反射API还能获取到一些泛型信息呢？</p><h2 id="反射API的能力边界"><a href="#反射API的能力边界" class="headerlink" title="反射API的能力边界"></a>反射API的能力边界</h2><p>为了深入理解类型擦除的补偿机制，我创建了一个具体的泛型类来测试反射API能获取哪些泛型信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个简单的泛型类，用于测试反射能力</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericClassDemo</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; items = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addItem</span><span class="params">(T item)</span> &#123;</span><br><span class="line">        items.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">getItems</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">processWithGenericMethod</span><span class="params">(E element, List&lt;? <span class="built_in">super</span> E&gt; sink)</span> &#123;</span><br><span class="line">        sink.add(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在让我们测试反射API在这个类上的表现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line">Class&lt;GenericClassDemo&gt; clazz = GenericClassDemo.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类级别的类型参数 - 可以获取！</span></span><br><span class="line">TypeVariable&lt;?&gt;[] typeParameters = clazz.getTypeParameters();</span><br><span class="line"><span class="keyword">for</span> (TypeVariable&lt;?&gt; typeParam : typeParameters) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Type Parameter: &quot;</span> + typeParam.getName());</span><br><span class="line">    Type[] bounds = typeParam.getBounds();</span><br><span class="line">    <span class="keyword">for</span> (Type bound : bounds) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;  Bound: &quot;</span> + bound.getTypeName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：Type Parameter: T</span></span><br><span class="line"><span class="comment">//       Bound: java.lang.Number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字段的泛型信息 - 可以获取！</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">itemsField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;items&quot;</span>);</span><br><span class="line"><span class="type">Type</span> <span class="variable">fieldType</span> <span class="operator">=</span> itemsField.getGenericType();</span><br><span class="line">System.out.println(<span class="string">&quot;Field type: &quot;</span> + fieldType);</span><br><span class="line"><span class="comment">// 输出：Field type: java.util.List&lt;T&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法的泛型信息 - 可以获取！</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">addMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;addItem&quot;</span>, Number.class);</span><br><span class="line">Type[] paramTypes = addMethod.getGenericParameterTypes();</span><br><span class="line">System.out.println(<span class="string">&quot;addItem parameter type: &quot;</span> + paramTypes[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 输出：addItem parameter type: T</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型方法的参数信息 - 也可以获取！</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">genericMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;processWithGenericMethod&quot;</span>, Object.class, List.class);</span><br><span class="line">Type[] genericParamTypes = genericMethod.getGenericParameterTypes();</span><br><span class="line">System.out.println(<span class="string">&quot;processWithGenericMethod parameter types: &quot;</span> + Arrays.toString(genericParamTypes));</span><br><span class="line"><span class="comment">// 输出：processWithGenericMethod parameter types: [E, java.util.List&lt;? super E&gt;]</span></span><br></pre></td></tr></table></figure><p>但是有一个关键的限制——当我们创建具体的实例时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GenericClassDemo&lt;Integer&gt; instance = <span class="keyword">new</span> <span class="title class_">GenericClassDemo</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 运行时实例的具体类型参数 - 无法获取！</span></span><br><span class="line">System.out.println(<span class="string">&quot;Instance class: &quot;</span> + instance.getClass());</span><br><span class="line">System.out.println(<span class="string">&quot;Instance type parameter: Cannot retrieve (type erasure)&quot;</span>);</span><br><span class="line"><span class="comment">// 输出：Instance class: class com.example.GenericClassDemo</span></span><br><span class="line"><span class="comment">//       Instance type parameter: Cannot retrieve (type erasure)</span></span><br></pre></td></tr></table></figure><p>这个对比很有启发性：<strong>泛型声明信息可以通过Signature属性保留</strong>，但<strong>运行时实例的具体类型参数确实被擦除</strong>。反射API的能力边界恰好体现了类型擦除的精确范围。</p><p>在字节码层面，编译器会保存完整的泛型签名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// GenericClassDemo类的签名</span><br><span class="line">Signature: #25  // &lt;T:Ljava/lang/Number;&gt;Ljava/lang/Object;</span><br><span class="line"></span><br><span class="line">// addItem方法的签名</span><br><span class="line">Signature: #18  // (TT;)V</span><br></pre></td></tr></table></figure><p>这就是为什么反射API能获取泛型信息——信息并未完全消失，而是以另一种形式保留在字节码中。</p><p>这里需要澄清一个重要概念：<strong>类型擦除</strong> ≠ <strong>类型信息完全消失</strong>。更准确地说，类型擦除是一个分层的过程——编译期的泛型类型检查被移除，但通过Signature属性等机制，足够的信息仍被保留以支持反射API。反射绕过类型检查的根本原因不是”信息丢失”，而是它<strong>直接操作字节码层面</strong>，跳过了编译器设置的类型安全护栏。</p><p>不过这又让我想到另一个问题：既然JVM在类型擦除后只保留原始类型信息，Kotlin的reified是怎么做到的？</p><h2 id="Kotlin-reified的巧思"><a href="#Kotlin-reified的巧思" class="headerlink" title="Kotlin reified的巧思"></a>Kotlin reified的巧思</h2><p>在使用Jackson的Kotlin扩展时，我注意到这样的API：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mapper = jacksonObjectMapper()</span><br><span class="line"><span class="keyword">val</span> person: Person = mapper.readValue&lt;Person&gt;(json) <span class="comment">// 看起来保留了类型信息</span></span><br></pre></td></tr></table></figure><p>这看起来超越了JVM类型擦除的限制。为了理解这个机制，我对比了普通泛型函数和reified函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通泛型函数 - 无法检查类型</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">checkNormal</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// return obj is T  // 编译错误！类型T被擦除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reified函数 - 可以检查类型</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">checkReified</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj <span class="keyword">is</span> T  <span class="comment">// 编译通过且工作正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reified的关键在于<code>inline</code>修饰符。当我们调用<code>checkReified&lt;String&gt;(&quot;hello&quot;)</code>时，<strong>Kotlin编译器</strong>会将函数体内联到调用点，并将类型参数<code>T</code>替换为具体的<code>String</code>。</p><p>这样，原本的<code>obj is T</code>在字节码中就变成了<code>obj is String</code>的直接类型检查。这里体现了<strong>Java编译器和Kotlin编译器的根本差异</strong>：</p><h3 id="Java编译器的处理方式"><a href="#Java编译器的处理方式" class="headerlink" title="Java编译器的处理方式"></a>Java编译器的处理方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java泛型方法</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj <span class="keyword">instanceof</span> T;  <span class="comment">// 编译错误！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java编译器<strong>直接拒绝编译</strong>这种写法，实际的错误信息为：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TestInstanceof.java:<span class="number">3</span>: error: Object cannot be safely cast <span class="keyword">to</span> T</span><br><span class="line">        return obj instanceof T<span class="punctuation">;</span></span><br><span class="line">               ^</span><br><span class="line">  <span class="keyword">where</span> T <span class="keyword">is</span> a <span class="keyword">type</span>-variable:</span><br><span class="line">    T extends Object declared <span class="keyword">in</span> <span class="keyword">method</span> &lt;<span class="title function_">T</span>&gt;<span class="title function_">check</span><span class="params">(Object)</span></span><br><span class="line">1 <span class="title function_">error</span></span><br></pre></td></tr></table></figure><p>这是因为类型擦除后，编译器无法在运行时获取<code>T</code>的具体类型信息。Java设计者选择了在编译期就阻止这种潜在错误的做法。</p><h3 id="Kotlin编译器的处理方式"><a href="#Kotlin编译器的处理方式" class="headerlink" title="Kotlin编译器的处理方式"></a>Kotlin编译器的处理方式</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">checkReified</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj <span class="keyword">is</span> T  <span class="comment">// 编译通过！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin编译器通过<strong>内联展开</strong>在编译时解决了这个问题：</p><p>我们可以通过字节码验证这一点。当调用<code>checkReified&lt;String&gt;(&quot;hello&quot;)</code>时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Kotlin内联展开后的实际字节码指令</span><br><span class="line">60: ldc           #87                 // class java/lang/String</span><br><span class="line">...</span><br><span class="line">134: instanceof    #87                 // class java/lang/String</span><br></pre></td></tr></table></figure><p>注意第134行的<code>instanceof #87</code>指令——<strong>Kotlin编译器直接引用具体的<code>java/lang/String</code>类</strong>，而不是擦除后的<code>Object</code>。这证明了编译器确实将类型参数<code>T</code>替换为了具体的<code>String</code>类型。</p><p>但这又引出了一个新的疑问：第三方库的reified函数是如何跨JAR边界工作的？</p><h2 id="编译器协作的精妙设计"><a href="#编译器协作的精妙设计" class="headerlink" title="编译器协作的精妙设计"></a>编译器协作的精妙设计</h2><p>Jackson Kotlin模块提供的reified函数让我很好奇——如果reified依赖于内联展开，那么如何跨JAR包边界工作？</p><p>这里需要理解”编译单元”的概念：<strong>编译单元是指一次编译操作处理的代码范围</strong>。比如Jackson Kotlin模块是一个独立的JAR包（一个编译单元），而我们的应用代码是另一个编译单元。当我们在应用代码中调用Jackson的<code>readValue&lt;Person&gt;(json)</code>时，就是在跨编译单元使用reified函数。</p><p>深入分析后发现，<strong>Kotlin编译器</strong>为第三方库reified函数设计了一个巧妙的<strong>四层协作机制</strong>：</p><h3 id="1-“一体两面”的架构设计"><a href="#1-“一体两面”的架构设计" class="headerlink" title="1. “一体两面”的架构设计"></a>1. “一体两面”的架构设计</h3><p>第三方库中的inline reified函数在编译后会产生两个不同的组件：</p><p><strong>方法存根（Method Stub）</strong>：为Java调用者准备的后备方案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字节码中实际存在的方法存根（Java方法签名）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> synthetic Object <span class="title function_">readValue</span><span class="params">(ObjectMapper, String)</span>;</span><br><span class="line"><span class="comment">// 调用时会立即抛出异常，提示需要内联</span></span><br></pre></td></tr></table></figure><p><strong>元数据函数体（Inlinable Body）</strong>：存储在<code>@kotlin.Metadata</code>中的完整逻辑</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储在元数据中的实际实现</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> ObjectMapper.<span class="title">readValue</span><span class="params">(content: <span class="type">String</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> readValue(content, T::<span class="keyword">class</span>.java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-四层协作机制"><a href="#2-四层协作机制" class="headerlink" title="2. 四层协作机制"></a>2. 四层协作机制</h3><p><strong>@Metadata注解</strong>：存储Kotlin特有信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java注解语法（在字节码中的表现）</span></span><br><span class="line"><span class="meta">@kotlin</span>.Metadata(</span><br><span class="line">  mv = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>&#125;,    <span class="comment">// Kotlin版本信息</span></span><br><span class="line">  bv = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>&#125;,    <span class="comment">// 二进制版本</span></span><br><span class="line">  k = <span class="number">2</span>,             <span class="comment">// 文件类型</span></span><br><span class="line">  <span class="comment">// 包含完整的内联函数体序列化数据</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>ACC_SYNTHETIC标记</strong>：标记编译器生成的特殊方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static final synthetic boolean needClassReification();</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL, ACC_SYNTHETIC</span><br></pre></td></tr></table></figure><p><strong>needClassReification()函数</strong>：编译器识别标记</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于标记需要类型具体化的函数</span></span><br><span class="line"><span class="meta">@PublishedApi</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">needClassReification</span><span class="params">()</span></span>: <span class="built_in">Nothing</span> =</span><br><span class="line">    <span class="keyword">throw</span> UnsupportedOperationException(<span class="string">&quot;Function with reified type parameter&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>reifiedOperationMarker()占位符</strong>：编译时替换点</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器占位符，运行时永不执行</span></span><br><span class="line"><span class="meta">@PublishedApi</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">reifiedOperationMarker</span><span class="params">()</span></span>: <span class="built_in">Nothing</span> =</span><br><span class="line">    <span class="keyword">throw</span> UnsupportedOperationException(<span class="string">&quot;This function should be called only during compilation&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="3-编译器协作流程"><a href="#3-编译器协作流程" class="headerlink" title="3. 编译器协作流程"></a>3. 编译器协作流程</h3><p>当我们调用<code>mapper.readValue&lt;Person&gt;(json)</code>时：</p><ol><li><strong>库扫描</strong>：Kotlin编译器发现<code>@kotlin.Metadata</code>注解</li><li><strong>方法分析</strong>：识别<code>ACC_SYNTHETIC</code>标记和特殊函数</li><li><strong>内联展开</strong>：从元数据中读取完整函数体</li><li><strong>类型替换</strong>：将<code>T::class.java</code>替换为<code>Person::class.java</code></li><li><strong>代码生成</strong>：生成最终调用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最终生成的Java字节码调用</span></span><br><span class="line">readValue(content, Person.class)</span><br></pre></td></tr></table></figure></li></ol><p>这个机制的精妙之处在于：完全使用JVM标准特性，无需定制JVM，但为Kotlin编译器提供了执行内联和类型具体化所需的所有信息。</p><h3 id="4-内联类生成的实际证据"><a href="#4-内联类生成的实际证据" class="headerlink" title="4. 内联类生成的实际证据"></a>4. 内联类生成的实际证据</h3><p>当我们实际编译调用第三方reified函数的代码时，可以观察到编译器确实生成了具体的TypeReference类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 为 Person 类型生成的内联类</span><br><span class="line">public final class com.example.ThirdPartyReifiedTestKt$testJacksonReifiedFunctions$$inlined$readValue$1</span><br><span class="line">extends com.fasterxml.jackson.core.type.TypeReference&lt;com.example.Person&gt;</span><br><span class="line"></span><br><span class="line">// 完整的泛型签名保留</span><br><span class="line">Signature: #3  // Lcom/fasterxml/jackson/core/type/TypeReference&lt;Lcom/example/Person;&gt;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 为 List&lt;Person&gt; 类型生成的内联类</span><br><span class="line">public final class com.example.ThirdPartyReifiedTestKt$testJacksonReifiedFunctions$$inlined$readValue$3</span><br><span class="line">extends com.fasterxml.jackson.core.type.TypeReference&lt;java.util.List&lt;? extends com.example.Person&gt;&gt;</span><br><span class="line"></span><br><span class="line">// 复杂泛型签名的完整保留</span><br><span class="line">Signature: #3  // Lcom/fasterxml/jackson/core/type/TypeReference&lt;Ljava/util/List&lt;+Lcom/example/Person;&gt;;&gt;;</span><br></pre></td></tr></table></figure><p>这些编译器生成的类名揭示了内联展开的命名规律：</p><ul><li><code>$$inlined$readValue$1</code>：表示第一个内联的readValue调用</li><li><code>$$inlined$readValue$3</code>：表示第三个内联的readValue调用，每个类型参数对应一个独立的TypeReference类</li></ul><h2 id="重新理解类型系统的层次"><a href="#重新理解类型系统的层次" class="headerlink" title="重新理解类型系统的层次"></a>重新理解类型系统的层次</h2><p>经过这一轮分析，我对JVM泛型系统有了更清晰的认识。类型擦除不是简单的”删除”，而是多层次类型系统的协调：</p><p><strong>源码层</strong>：我们编写强类型的泛型代码，享受IDE的类型检查</p><p><strong>编译期</strong>：编译器执行类型安全检查，同时通过多种机制保留泛型信息：</p><h3 id="Signature属性：完整泛型信息的保留"><a href="#Signature属性：完整泛型信息的保留" class="headerlink" title="Signature属性：完整泛型信息的保留"></a>Signature属性：完整泛型信息的保留</h3><p>Java编译器会在字节码中保存完整的泛型签名，这是类型擦除的重要补偿机制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 泛型类的签名（GenericClassDemo&lt;T extends Number&gt;）</span><br><span class="line">Signature: #25  // &lt;T:Ljava/lang/Number;&gt;Ljava/lang/Object;</span><br><span class="line"></span><br><span class="line">// 泛型方法的签名</span><br><span class="line">Signature: #18  // (TT;)V                           // addItem(T item)</span><br><span class="line">Signature: #21  // ()Ljava/util/List&lt;TT;&gt;;         // getItems()</span><br><span class="line">Signature: #24  // &lt;E:Ljava/lang/Object;&gt;(TE;Ljava/util/List&lt;-TE;&gt;;)V  // processWithGenericMethod</span><br></pre></td></tr></table></figure><h3 id="LocalVariableTypeTable：调试信息中的类型追踪"><a href="#LocalVariableTypeTable：调试信息中的类型追踪" class="headerlink" title="LocalVariableTypeTable：调试信息中的类型追踪"></a>LocalVariableTypeTable：调试信息中的类型追踪</h3><p>在启用调试信息编译时，还会生成额外的类型表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 普通变量表（总是存在）</span><br><span class="line">LocalVariableTable:</span><br><span class="line">  Start  Length  Slot  Name   Signature</span><br><span class="line">      8     227     1 stringList   Ljava/util/List;</span><br><span class="line"></span><br><span class="line">// 泛型变量表（仅调试模式）</span><br><span class="line">LocalVariableTypeTable:</span><br><span class="line">  Start  Length  Slot  Name   Signature</span><br><span class="line">      8     227     1 stringList   Ljava/util/List&lt;Ljava/lang/String;&gt;;</span><br></pre></td></tr></table></figure><p>注意两个表的关键差异：普通表显示擦除后的类型<code>List</code>，而泛型表保留完整信息<code>List&lt;String&gt;</code>。</p><p><strong>字节码层</strong>：不同的类型检查策略：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Java: 延迟类型检查</span><br><span class="line">143: checkcast     #62                 // class java/lang/String</span><br><span class="line"></span><br><span class="line">// Kotlin reified: 直接类型检查</span><br><span class="line">134: instanceof    #87                 // class java/lang/String</span><br></pre></td></tr></table></figure><p><strong>运行时</strong>：JVM执行擦除后的代码，但仍可通过Signature属性访问泛型信息</p><h3 id="设计权衡的思考"><a href="#设计权衡的思考" class="headerlink" title="设计权衡的思考"></a>设计权衡的思考</h3><p>通过对比分析，我们可以看到不同语言的设计权衡：</p><table><thead><tr><th>方面</th><th>Java 类型擦除</th><th>Kotlin Reified</th></tr></thead><tbody><tr><td><strong>字节码大小</strong></td><td>紧凑，共享字节码</td><td>内联展开，每个调用点独立</td></tr><tr><td><strong>运行时开销</strong></td><td>checkcast 指令检查</td><td>编译时优化，无运行时开销</td></tr><tr><td><strong>API 设计</strong></td><td>需要传递 Class 参数</td><td>直接使用类型参数</td></tr><tr><td><strong>互操作性</strong></td><td>完全兼容</td><td>Java 无法调用真正的 reified</td></tr></tbody></table><p>Kotlin的reified机制在编译期和运行时之间找到了巧妙的平衡点：通过内联函数在编译时恢复类型信息，同时通过编译器协作机制实现跨库调用。</p><p>这种设计思路反映了现代语言发展的趋势——不是对抗底层平台的限制，而是在编译器层面提供更好的抽象，通过巧妙的工程实现来突破技术约束。</p><p>你在项目中遇到过类似的类型系统边界问题吗？或者发现了其他语言处理这类问题的有趣方案？</p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;当泛型遇上现实：从表象到本质的技术思考&quot;&gt;&lt;a href=&quot;#当泛型遇上现实：从表象到本质的技术思考&quot; class=&quot;headerlink&quot; title=&quot;当泛型遇上现实：从表象到本质的技术思考&quot;&gt;&lt;/a&gt;当泛型遇上现实：从表象到本质的技术思考&lt;/h1&gt;&lt;p&gt;最近在优化一个序列化框架时，遇到了一些类型安全方面的意外行为。这让我重新审视了JVM泛型系统的底层机制。虽然类型擦除是个老话题，但当我深入分析Kotlin的reified实现时，发现了一些值得思考的细节。&lt;/p&gt;
&lt;h2 id=&quot;一个简单现象引发的思考&quot;&gt;&lt;a href=&quot;#一个简单现象引发的思考&quot; class=&quot;headerlink&quot; title=&quot;一个简单现象引发的思考&quot;&gt;&lt;/a&gt;一个简单现象引发的思考&lt;/h2&gt;&lt;p&gt;我们都知道Java的类型擦除，但最近在排查问题时，我又重新观察了这个现象：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;String&amp;gt; stringList = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;Integer&amp;gt; intList = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在运行时，它们的Class信息完全相同&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(stringList.getClass() == intList.getClass()); &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这是类型擦除的基本表现：编译器将泛型参数替换为边界类型。不过这让我想到一个问题：既然编译器会进行严格的泛型类型检查，那反射是如何绕过这些检查机制的？&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://cuipengfei.is-a.dev/tags/Java/"/>
    
    <category term="Kotlin" scheme="https://cuipengfei.is-a.dev/tags/Kotlin/"/>
    
    <category term="泛型" scheme="https://cuipengfei.is-a.dev/tags/%E6%B3%9B%E5%9E%8B/"/>
    
    <category term="JVM" scheme="https://cuipengfei.is-a.dev/tags/JVM/"/>
    
    <category term="类型擦除" scheme="https://cuipengfei.is-a.dev/tags/%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4/"/>
    
    <category term="反射" scheme="https://cuipengfei.is-a.dev/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Agent 构建中的三个诱人陷阱</title>
    <link href="https://cuipengfei.is-a.dev/blog/2025/08/27/agent-building-seductive-traps/"/>
    <id>https://cuipengfei.is-a.dev/blog/2025/08/27/agent-building-seductive-traps/</id>
    <published>2025-08-27T02:00:00.000Z</published>
    <updated>2025-08-27T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在构建 Cline AI agent 的过程中，我们发现最危险的不是那些一眼就能看出来的坏想法，而是那些理论上听起来完美、实践中却一败涂地的诱人陷阱。</p></blockquote><p><img data-src="https://cline.ghost.io/content/images/2025/08/u9318423161_tempting_trap_interpreted_in_nature_in_the_style__26705fd3-2f3e-430c-a10d-aae540aa1853_2-1.png" alt="诱人陷阱"></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在 Cline 构建 AI agent 的征程中，我们发现最危险的其实不是那些一眼就能识破的馊主意，而是那些理论上完美无缺、实践中却惨败收场的”陷阱”。这些思维病毒早已蔓延整个行业，吞噬了数百万工程师小时，把一个又一个团队拖进了架构死胡同。</p><p>以下是我们见过的三大最常见陷阱：</p><ol><li><strong>Multi-Agent Orchestration</strong>（多智能体编排）</li><li><strong>RAG (Retrieval Augmented Generation)</strong> 索引代码库</li><li><strong>指令越多 &#x3D; 效果越好</strong></li></ol><blockquote><p><strong>[译者注]</strong> 技术名词保持英文便于检索。RAG 在国内常被直译为”检索增强生成”，但工程实践中仍以英文为主。</p></blockquote><p>咱们一个个来看！</p><hr><h2 id="1-Multi-Agent-Orchestration"><a href="#1-Multi-Agent-Orchestration" class="headerlink" title="(1) Multi-Agent Orchestration"></a>(1) Multi-Agent Orchestration</h2><p>那种科幻电影般的 agent 愿景——‘rear agent、quarter agent、analyzer agent、orchestrator agent’——听起来确实很酷，派出一群子 agent 然后整合它们的结果。但现实是：大部分有用的 agent 工作其实都是单线程的。</p><p>目前多智能体系统的最大突破来自 Anthropic，但就连他们也坦言，构建和调教多个 agent 是<a href="https://www.anthropic.com/engineering/multi-agent-research-system">极其困难的</a>。他们的团队这样说：</p><p><em>“Agent 系统中的错误会叠加放大，传统软件里的小毛病到了这里可能让整个 agent 彻底偏轨。一步走错，agent 就可能走上完全不同的路径，结果变得完全不可预测。基于我们文章中提到的种种原因，从原型到生产的鸿沟往往比想象中要大得多。”</em></p><blockquote><p><strong>[译者注]</strong> 这段话点出了多 agent 系统的核心困境：错误放大效应。在分布式系统设计中，这被称为”故障级联”。</p></blockquote><p><img data-src="https://cline.ghost.io/content/images/2025/08/image-27.png" alt="多智能体微服务架构"></p><p><em>来源：<a href="https://seanfalconer.medium.com/ai-agents-are-microservices-with-brains-ccb42d1504d7">AI Agents are Microservices with Brains</a></em></p><p>当然，我们也不是完全否定多 agent 方案。对于一些小而具体的用例，用些功能有限的子 agent 还是挺合理的。</p><p>比如说，主 agent 线程创建几个子 agent 来并行读取文件。或者用子 agent 来处理从网络抓取数据这种简单任务。但说白了，这些跟并行调用工具没什么本质区别，我甚至怀疑这算不算得上”真正的”多智能体编排。</p><p><img data-src="https://cline.ghost.io/content/images/2025/08/image-33.png" alt="多智能体系统"></p><hr><h2 id="2-RAG-Retrieval-Augmented-Generation"><a href="#2-RAG-Retrieval-Augmented-Generation" class="headerlink" title="(2) RAG (Retrieval Augmented Generation)"></a>(2) RAG (Retrieval Augmented Generation)</h2><p>RAG 是另一个诱人的坑。这个概念延续自上下文窗口还很小的时代，那时候给 agent 提供查询”整个代码库”的能力确实很有吸引力。但 RAG 的炒作并没有转化为实际可用的编码 agent 工作流，因为它经常会产生零散的代码片段，完全无法为模型提供真正的”上下文理解”。纸面上看起来很强大，但实际上，就连 GREP 这样的简单工具都比它好用，特别是对 agent 来说。</p><p>让 agent 像人类一样工作——列出文件、用 grep 搜索、然后打开完整的文件来阅读——这样的效果几乎总是更好。Cline 从一开始就确立了这套方法的标准，后来 Amp Code 和 Cursor 都跟着采用了这种做法。</p><p><img data-src="https://cline.ghost.io/content/images/2025/08/image-32.png" alt="RAG介绍"></p><p><strong>RAG 及其复杂变种介绍</strong></p><p>大多数公司最初都选择了向量数据库，因为 2023 年那些”与代码聊天”的 VS Code 扩展刚出现时，模型只有 8,092 个 token 的上下文窗口，所以每一行进入模型的代码都必须精心挑选。那时候这样做确实说得通，这也解释了为什么那么多基础设施和热钱涌入了向量数据库公司，有些公司甚至筹集了数亿美元，比如 <a href="https://www.pinecone.io/">Pinecone</a>。但 Cline 于 2024 年 7 月发布时，当时领先的编码模型是拥有 200K token 上下文窗口的 Claude 3.5 Sonnet，所以它从来没有受到需要拼接无关上下文片段的限制。</p><blockquote><p><strong>[译者注]</strong> 从 8K 到 200K 的上下文窗口跨越是个分水岭。这个时间差导致了技术路径的根本性分歧。</p></blockquote><hr><h2 id="3-指令越多-效果越好"><a href="#3-指令越多-效果越好" class="headerlink" title="(3) 指令越多 &#x3D; 效果越好"></a>(3) 指令越多 &#x3D; 效果越好</h2><p>觉得在系统提示里堆砌越来越多”指令”就能让模型变聪明？这完全是个错误观念。过载的提示只会把模型搞糊涂，因为额外的指令经常会相互冲突，产生噪音。最后你只是在行为上打地鼠，而不是获得有用的输出。对今天的大多数前沿模型来说，最好是退一步让它们自己发挥，而不是通过提示不断对它们大吼大叫。措辞要仔细斟酌。</p><p><img data-src="https://cline.ghost.io/content/images/2025/08/image-31.png" alt="信号与噪声"></p><p><em>来源：<a href="https://nolongerset.com/signal-vs-noise/">Signal vs. Noise</a></em></p><p><strong>信号 vs. 噪声</strong></p><p>Cline 在 2024 年中期发布时，Sonnet 3.5 是当时的顶级模型，那个时候用大量示例和想法填充提示确实有意义。但当 Sonnet 4 系列出现时，这套方法彻底失效了，其他所有 agent 系统也跟着翻车。经过反复测试，我们意识到核心问题：指令太多会产生矛盾，矛盾会产生混乱。</p><p>新一代前沿模型——Claude 4、Gemini 2.5 和 GPT-5——在遵循简洁指令方面要强得多。它们不需要长篇大论，它们需要的是最精炼的内容。这就是新的现实。</p><blockquote><p><strong>[译者注]</strong> 这一观察与软件设计原则不谋而合：KISS (Keep It Simple, Stupid)。模型能力的提升反而要求我们做减法。</p></blockquote><hr><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>多智能体编排、RAG 和塞满内容的提示在纸面上看起来很诱人，但没有一个能在真正的开发工作流中存活下来。真正获胜的 agent 是那些拥抱简单性的：像开发者一样阅读代码，相信模型的能力，让路走得通畅。</p><p>虽然整个行业还在追逐架构上的复杂性，但基本面已经发生了根本转变。少即是多，清晰胜过聪明，最好的 AI agent 往往是最简单的。</p><blockquote><p><strong>[译者注]</strong> 复杂性往往是解决方案的敌人，而非朋友。在 AI 工程化的道路上，保持理性比追逐热点更重要。</p></blockquote><p><strong>— Ara</strong></p><p><em>让你的工程团队拥有一个完全协作的 AI 搭档。开源、完全可扩展，专为放大开发者影响力而设计。</em></p><hr><blockquote><p>原文链接：<a href="https://cline.bot/blog/3-seductive-traps-in-agent-building">3 Seductive Traps in Agent Building</a><br>作者：Ara Khan (@arafatkkatze)<br>发布日期：2025 年 8 月 26 日</p></blockquote><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在构建 Cline AI agent 的过程中，我们发现最危险的不是那些一眼就能看出来的坏想法，而是那些理论上听起来完美、实践中却一败涂地的诱人陷阱。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img data-src=&quot;https://cline.ghost.io/content/images/2025/08/u9318423161_tempting_trap_interpreted_in_nature_in_the_style__26705fd3-2f3e-430c-a10d-aae540aa1853_2-1.png&quot; alt=&quot;诱人陷阱&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在 Cline 构建 AI agent 的征程中，我们发现最危险的其实不是那些一眼就能识破的馊主意，而是那些理论上完美无缺、实践中却惨败收场的”陷阱”。这些思维病毒早已蔓延整个行业，吞噬了数百万工程师小时，把一个又一个团队拖进了架构死胡同。&lt;/p&gt;
&lt;p&gt;以下是我们见过的三大最常见陷阱：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Multi-Agent Orchestration&lt;/strong&gt;（多智能体编排）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RAG (Retrieval Augmented Generation)&lt;/strong&gt; 索引代码库&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;指令越多 &amp;#x3D; 效果越好&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="AI Agent" scheme="https://cuipengfei.is-a.dev/tags/AI-Agent/"/>
    
    <category term="Multi-Agent" scheme="https://cuipengfei.is-a.dev/tags/Multi-Agent/"/>
    
    <category term="RAG" scheme="https://cuipengfei.is-a.dev/tags/RAG/"/>
    
    <category term="Prompt Engineering" scheme="https://cuipengfei.is-a.dev/tags/Prompt-Engineering/"/>
    
    <category term="Cline" scheme="https://cuipengfei.is-a.dev/tags/Cline/"/>
    
  </entry>
  
  <entry>
    <title>把质量内建进设计：从“测试是负担”到“测试即设计”</title>
    <link href="https://cuipengfei.is-a.dev/blog/2025/08/10/build-quality-in-test-as-design/"/>
    <id>https://cuipengfei.is-a.dev/blog/2025/08/10/build-quality-in-test-as-design/</id>
    <published>2025-08-10T02:00:00.000Z</published>
    <updated>2025-08-10T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>业务复杂 ≠ 代码必然复杂。好代码常常看着普通，关键在于设计和可测试性平衡得好。</p></blockquote><h2 id="引言：为什么质量改进总是做不好？"><a href="#引言：为什么质量改进总是做不好？" class="headerlink" title="引言：为什么质量改进总是做不好？"></a>引言：为什么质量改进总是做不好？</h2><p>我们都见过这种情况：团队加了各种检查清单、覆盖率红线、扫描工具。</p><p>几个月后，流程更复杂了，质量却没怎么变好。</p><p>问题不在执行力度，而在于把质量活动放错了时间：设计定好了才让测试介入，只能事后补漏洞。</p><p><strong>核心思路：把质量从”事后检查”变成”设计时就考虑进去”，让测试帮助改进设计。</strong></p><hr><p>测试应该验证”设计是否合理”，而不是”代码是否正确”。</p><p>理解这一点，才解释得通：为什么很多“质量改进”看似动作频繁却收效甚微。</p><p>大量所谓失败的质量改进，其根源是<strong>诊断偏差</strong>：把“认知与方法”的缺口，误判为“态度与能力”的缺陷。</p><p>我们缺的往往不是意愿，而是对“质量必须被前置设计进去”的共识。</p><p>正因为测试目的被误读，我们才会不断叠加流程——模板、检查项、额外审批——却依旧缺乏演进信心。</p><p>把测试前置为设计反馈回路，才能释放团队在结构演化上的创造力。</p><p>Build Quality In（内建质量，指从设计、开发到交付各个环节，始终将可度量、可验证的质量目标固化为交付物的内在属性，不依赖于终极测试关卡。这一理念强调风险应前移并在流程中被分解，而不是留到最后集中暴露）</p><p>其真正含义是：每一环节交付的中间产物自带“可验证标准”，而不是把风险挤压到最后一轮集中测试。</p><p>换句话说：质量是过程属性，是<strong>设计</strong>出来的，而不是<strong>扫</strong>出来的。</p><p><img data-src="https://cuipengfei.github.io/picx-images-hosting/20250816/%E7%94%9F%E6%88%90%E8%9E%8D%E5%90%88%E5%9B%BE%E5%83%8F-(1).5xaykpra6p.png" alt="生成融合图像-(1)"></p><hr><h2 id="职责重塑：测试是谁的事？"><a href="#职责重塑：测试是谁的事？" class="headerlink" title="职责重塑：测试是谁的事？"></a>职责重塑：测试是谁的事？</h2><table><thead><tr><th>组织方式</th><th>测试责任认知</th><th>结果</th></tr></thead><tbody><tr><td>QA 负责</td><td>开发完扔给 QA 测试</td><td>被动、滞后</td></tr><tr><td>开发补测</td><td>写完代码再补测试</td><td>补救、慢反馈</td></tr><tr><td>测试驱动设计</td><td>测试推动设计</td><td>主动、预防</td></tr></tbody></table><p>测试是开发者的责任，不是 QA 的专属。</p><p>把测试外包出去，等于把系统演进的控制权也外包了。</p><p>团队对测试的认知通常经历三个阶段：</p><ol><li>测试是 QA 的事 → 代码能跑就行</li><li>测试是开发的事 → 写完代码补测试</li><li>测试是设计的事 → 用测试来驱动设计</li></ol><p>覆盖率不是质量，”改动后敢不敢部署”才是。</p><p>很多 90% 覆盖率的项目，改一行代码还是怕出事，因为测的是执行路径，不是业务行为。</p><hr><h2 id="设计原则：让复杂业务不制造复杂代码"><a href="#设计原则：让复杂业务不制造复杂代码" class="headerlink" title="设计原则：让复杂业务不制造复杂代码"></a>设计原则：让复杂业务不制造复杂代码</h2><p>以订单系统为例，如果把支付、库存、通知都耦合在一起，业务再简单代码也会变复杂。</p><p>两个关键点：</p><ul><li><strong>可组合性</strong>：组件能独立变化和复用</li><li><strong>解耦</strong>：模块边界清晰，依赖关系明确</li></ul><p>这两个直接决定了<strong>可测试性</strong>。</p><p>代码不好测，通常是设计问题，不是测试技术问题。</p><p><img data-src="https://cuipengfei.github.io/picx-images-hosting/20250816/%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90%E6%8F%90%E7%A4%BA%E8%AF%8D.4ub99tvgbv.png" alt="图像生成提示词"></p><h3 id="依赖倒置与构造注入"><a href="#依赖倒置与构造注入" class="headerlink" title="依赖倒置与构造注入"></a>依赖倒置与构造注入</h3><p>依赖倒置（DIP, Dependency Inversion Principle：让高层模块不依赖具体实现、仅依赖抽象接口，从而提升灵活性与可测试性）</p><p>构造注入（Constructor Injection，用显式传参而非内部直接实例化依赖，以便测试和扩展）</p><p>先看一个典型“隐式依赖”日常写法，随后用构造注入展示如何让依赖显式、可替换。</p><p>反例（内部直接创建依赖 → 紧耦合、难替换、难测）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">PaymentProcessor</span> <span class="variable">paymentProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaymentProcessor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">placeOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        paymentProcessor.process(order.getPaymentDetails());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>改进代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentGateway payment;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Inventory inventory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Notification notification;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentGateway payment, Inventory inventory, Notification notification)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.payment = payment;</span><br><span class="line">        <span class="built_in">this</span>.inventory = inventory;</span><br><span class="line">        <span class="built_in">this</span>.notification = notification;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        payment.charge(order.getAmount());</span><br><span class="line">        inventory.reserve(order.getItems());</span><br><span class="line">        notification.sendConfirmation(order.getEmail());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么这能降复杂？因为：</p><ul><li>可替换：测试中传入 Mock&#x2F;Fake，环境可控。</li><li>可演进：实现可变而接口不变，测试稳定。</li><li>可理解：依赖图显式化，认知负荷更低。</li></ul><p>这三点共同把变动半径压缩到装配层。</p><p>把对象创建权上移（构造注入）&#x3D; 将“变动点”推到最外围；业务核心越“纯”，测试越“薄”。</p><p><img data-src="https://cuipengfei.github.io/picx-images-hosting/20250816/%E4%B8%AD%E5%9B%BD%E9%A3%8E%E6%A6%82%E5%BF%B5%E6%8F%92%E7%94%BB.2a5ex6vhn1.png" alt="中国风概念插画"></p><h3 id="隔离框架：让业务逻辑保持纯粹"><a href="#隔离框架：让业务逻辑保持纯粹" class="headerlink" title="隔离框架：让业务逻辑保持纯粹"></a>隔离框架：让业务逻辑保持纯粹</h3><p>完成对象级依赖显式化后，第二类常见耦合源是“框架侵入业务”。策略：让 Controller 仅做“协议&#x2F;IO → 领域调用”转发，避免领域逻辑渗入框架层，使业务在纯 Java 环境下即可单测。</p><p>简例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderApplicationService app;</span><br><span class="line">    OrderController(OrderApplicationService app)&#123;<span class="built_in">this</span>.app = app;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/orders&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> OrderDTO <span class="title function_">place</span><span class="params">(<span class="meta">@RequestBody</span> OrderDTO dto)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> app.place(dto.toDomain()).toDTO();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯业务，可直接 new 来测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderApplicationService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderService domain;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderApplicationService</span><span class="params">(OrderService domain)</span>&#123;<span class="built_in">this</span>.domain = domain;&#125;</span><br><span class="line">    <span class="keyword">public</span> Order <span class="title function_">place</span><span class="params">(Order order)</span>&#123;<span class="keyword">return</span> domain.process(order);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试什么：结果而不是过程"><a href="#测试什么：结果而不是过程" class="headerlink" title="测试什么：结果而不是过程"></a>测试什么：结果而不是过程</h3><p>脆弱的测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verify(paymentClient, times(<span class="number">1</span>)).charge(any());</span><br></pre></td></tr></table></figure><p>稳定的测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">orderService.processOrder(order);</span><br><span class="line">assertThat(order.getStatus()).isEqualTo(PROCESSED);</span><br></pre></td></tr></table></figure><p>测试应该关注业务结果，而不是内部实现细节。</p><hr><h2 id="测试焦点：以对外行为契约取代内部调用序列"><a href="#测试焦点：以对外行为契约取代内部调用序列" class="headerlink" title="测试焦点：以对外行为契约取代内部调用序列"></a>测试焦点：以对外行为契约取代内部调用序列</h2><ul><li>测什么：组件对外的行为契约（状态、返回值、对外交互语义），而不是它“怎么做”。</li><li>好处：重构自由度大、测试稳定、设计抽象度更高。</li><li>经验法则：能用一个 Given-When-Then 讲清楚的场景，就不要写“调用序列监视”。</li></ul><p>经验：能用 Given-When-Then 说清楚的，就别用 verify。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Feature</span>: 订单处理</span><br><span class="line">  <span class="keyword">Scenario</span>: 成功处理有效订单</span><br><span class="line">    <span class="keyword">Given</span> 用户有一个包含商品的订单</span><br><span class="line">    <span class="keyword">When</span> 用户提交订单</span><br><span class="line">    <span class="keyword">Then</span> 订单状态为<span class="string">&quot;已处理&quot;</span></span><br><span class="line">    <span class="keyword">And</span> 用户收到确认邮件</span><br></pre></td></tr></table></figure><p>“行为测试”好比：下单后只看结果——订单状态改变、邮件发送完成；“实现细节测试”好比：盯内部是否“恰好调用 X 一次”，一旦内部重构（拆分、合并、缓存）测试就会挂。</p><p>列出该功能对外可观察的 1~3 个结果，测试只断言这些；仅当结果不可直接观察时，再退而使用 <code>verify</code>。</p><p>这是前文所称“语义覆盖”的具体化——验证承诺，而非执行路径。</p><p><img data-src="https://cuipengfei.github.io/picx-images-hosting/20250816/%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90%E6%8F%90%E7%A4%BA%E8%AF%8D-(1).1lc5d67ync.png" alt="图像生成提示词-(1)"></p><hr><h2 id="质量度量：用什么指标"><a href="#质量度量：用什么指标" class="headerlink" title="质量度量：用什么指标"></a>质量度量：用什么指标</h2><p>别只看覆盖率，看这些：</p><ul><li>改完代码敢不敢直接上线？</li><li>缺陷数在下降吗？</li><li>出问题多久能发现？</li></ul><p>测试金字塔：</p><ul><li>单元测试：测领域逻辑，最快定位问题</li><li>集成测试：测边界协作</li><li>端到端：测关键流程</li></ul><p>金字塔倒过来，通常是设计没做好。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们做了什么：</p><ul><li>测试从后置变前置</li><li>职责从外包变内聚</li><li>用依赖倒置 + 组合 + 薄层隔离框架</li><li>测行为契约，减少 verify</li><li>用真实指标衡量质量</li></ul><hr><h2 id="几个对照思考"><a href="#几个对照思考" class="headerlink" title="几个对照思考"></a>几个对照思考</h2><ol><li>业务复杂 ≠ 代码必须复杂：遇到”看不懂的实现”时，可以先问问”是否把业务决策隐藏在技术细节里”。</li><li>主要成本在修改：每次改动如果都需要”开启多人口头同步”才能放心发布，通常说明缺少可验证的自动化回归测试集。测试可以看作是摊平未来修改成本的”前置投资”。</li><li>设计是持续活动：每加入一个特性，都值得重新检视”依赖是否最小化””边界是否清晰”以及”关键行为是否能被直接测试”。</li><li>测试是一把尺：当你犹豫“是否需要抽象”时，可以问自己——这个抽象是否让关键行为的测试表达更短、更清晰？如果是，那么这个抽象通常是正确的方向。</li><li>认知惯性 ≠ 技术难点：很多开发者感觉”写测试浪费时间”，往往是对“前置投入换取未来自由”这一逆直觉收益模型的抗拒。识别到这只是惯性后，可用“小步演示削减回归&#x2F;调试时间”建立共识。</li></ol><p>这些对照共同指向：让测试成为持续设计校准机制，而非末端裁决。</p><hr><p><img data-src="https://cuipengfei.github.io/picx-images-hosting/20250816/%E7%94%9F%E6%88%90%E8%9E%8D%E5%90%88%E5%9B%BE%E5%83%8F.8adl1x53f7.png" alt="生成融合图像"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>把测试从“末端审判”变成“设计工具”，把质量从“外部检查”变成“内部属性”。</p><p>当我们用可组合设计、行为契约测试与清晰验收标准内建质量，复杂业务也能产出“平平无奇”且稳定可演进的代码。</p><blockquote><p>当前这次改动，如果我删掉所有 <code>verify</code> 调用，只保留对最终结果（状态&#x2F;返回值&#x2F;对外交互）的断言，测试是否仍清晰表达业务意图？若否，请回溯：依赖是否显式？行为是否可观察？测试是否覆盖契约而非路径？</p></blockquote><p>这三个对了，质量就在设计里了。</p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;业务复杂 ≠ 代码必然复杂。好代码常常看着普通，关键在于设计和可测试性平衡得好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;引言：为什么质量改进总是做不好？&quot;&gt;&lt;a href=&quot;#引言：为什么质量改进总是做不好？&quot; class=&quot;headerlink&quot; title=&quot;引言：为什么质量改进总是做不好？&quot;&gt;&lt;/a&gt;引言：为什么质量改进总是做不好？&lt;/h2&gt;&lt;p&gt;我们都见过这种情况：团队加了各种检查清单、覆盖率红线、扫描工具。&lt;/p&gt;
&lt;p&gt;几个月后，流程更复杂了，质量却没怎么变好。&lt;/p&gt;
&lt;p&gt;问题不在执行力度，而在于把质量活动放错了时间：设计定好了才让测试介入，只能事后补漏洞。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心思路：把质量从”事后检查”变成”设计时就考虑进去”，让测试帮助改进设计。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Build Quality In" scheme="https://cuipengfei.is-a.dev/tags/Build-Quality-In/"/>
    
    <category term="Testability" scheme="https://cuipengfei.is-a.dev/tags/Testability/"/>
    
    <category term="TDD" scheme="https://cuipengfei.is-a.dev/tags/TDD/"/>
    
    <category term="BDD" scheme="https://cuipengfei.is-a.dev/tags/BDD/"/>
    
    <category term="Dependency Inversion" scheme="https://cuipengfei.is-a.dev/tags/Dependency-Inversion/"/>
    
    <category term="Composition" scheme="https://cuipengfei.is-a.dev/tags/Composition/"/>
    
  </entry>
  
  <entry>
    <title>folo verify</title>
    <link href="https://cuipengfei.is-a.dev/blog/2025/07/30/verify/"/>
    <id>https://cuipengfei.is-a.dev/blog/2025/07/30/verify/</id>
    <published>2025-07-30T12:49:00.000Z</published>
    <updated>2025-07-30T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>This message is used to verify that this feed (feedId:97818615095497728) belongs to me (userId:97817750660390912). Join me in enjoying the next generation information browser <a href="https://folo.is/">https://folo.is</a>.</p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;This message is used to verify that this feed (feedId:97818615095497728) belongs to me (userId:97817750660390912). Join me in enjoying th</summary>
      
    
    
    
    
    <category term="Folo" scheme="https://cuipengfei.is-a.dev/tags/Folo/"/>
    
  </entry>
  
  <entry>
    <title>围墙花园里的阅读游击 - wewe-rss &amp; RSSHub，重夺信息控制权</title>
    <link href="https://cuipengfei.is-a.dev/blog/2025/07/21/folo-wewe-rss/"/>
    <id>https://cuipengfei.is-a.dev/blog/2025/07/21/folo-wewe-rss/</id>
    <published>2025-07-21T13:56:00.000Z</published>
    <updated>2025-07-21T13:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="控制权旁落"><a href="#控制权旁落" class="headerlink" title="控制权旁落"></a>控制权旁落</h2><p>RSS 并未消亡。</p><p>变化的不是协议，而是信息分发领域的权力结构。</p><p>用户在事实上让渡了选择看什么、何时看的权利。</p><p>微信公众号重塑了这种结构，通过两层约束：</p><ol><li><strong>技术约束</strong>：内容被封装于 App 内，无标准 API，无 RSS 输出通道。</li><li><strong>算法约束</strong>：信息流按商业目标而非时间或信息价值排序。</li></ol><p>其结果是一种<strong>注意力被动引导机制</strong>——用户的浏览行为，被用于优化平台的商业目标。</p><p><img data-src="https://cuipengfei.github.io/picx-images-hosting/20250721/%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90%E4%BB%BB%E5%8A%A1-(5).491kn3k47y.png" alt="图像生成任务-(5)"></p><h2 id="系统解剖"><a href="#系统解剖" class="headerlink" title="系统解剖"></a>系统解剖</h2><pre><code class="highlight mermaid">graph TD    subgraph 微信封闭生态        A[公众号文章] --&gt;|技术隔离| B(微信App)        B --&gt;|算法黑箱| C&#123;信息流&#125;        C --&gt;|注意力收割| D(用户)    end    subgraph RSS工具生态        A --&gt;|微信读书接口| E(wewe-rss)        F[其他平台内容] --&gt;|API/爬虫| G(RSSHub)        E --&gt;|RSS输出| H[统一RSS协议]        G --&gt;|RSS输出| H        H --&gt;|整合阅读| I(Folo)        I --&gt;|控制权归还| D    end</code></pre><p><strong>技术隔离层</strong></p><p>无 RSS，无 API，内容被封装在微信内。</p><p><strong>算法黑箱层</strong></p><p>算法根据用户停留时长、交互数据等指标对内容进行排序。用户的每一次点击，都在优化这个系统以更高效地实现其排序目标。</p><p><img data-src="https://cuipengfei.github.io/picx-images-hosting/20250721/%E7%94%9F%E6%88%90%E7%89%B9%E5%AE%9A%E5%9B%BE%E5%83%8F-(1).60uji03h4a.png" alt="生成特定图像-(1)"></p><h2 id="穿孔方案"><a href="#穿孔方案" class="headerlink" title="穿孔方案"></a>穿孔方案</h2><p>面对技术和算法的双重约束，开源社区提供了协同的解决工具：</p><h3 id="微信公众号的专用工具：wewe-rss"><a href="#微信公众号的专用工具：wewe-rss" class="headerlink" title="微信公众号的专用工具：wewe-rss"></a>微信公众号的专用工具：wewe-rss</h3><p><code>wewe-rss</code> 专门针对微信公众号这一特殊封闭系统。它不破坏系统，而是<strong>利用</strong>其现有接口。</p><p>通过调用微信读书的同步接口，将公众号内容转化为标准 RSS。这不是破解，是<strong>协议嫁接</strong>：</p><ul><li><strong>接口合法性</strong>：使用微信读书官方 API</li><li><strong>格式标准化</strong>：输出 RSS 2.0，兼容任意阅读器</li><li><strong>延迟容忍</strong>：以 15-30 分钟的延迟，换取系统稳定性</li></ul><h3 id="多平台的通用工具：RSSHub"><a href="#多平台的通用工具：RSSHub" class="headerlink" title="多平台的通用工具：RSSHub"></a>多平台的通用工具：RSSHub</h3><p><code>RSSHub</code> 覆盖微信之外的广阔信息源——微博、Twitter、知乎、GitHub 等 1000+平台。它采用企业级架构：</p><ul><li><strong>多源适配</strong>：每个平台都有专门的适配器</li><li><strong>反爬虫技术</strong>：浏览器自动化、代理轮换、签名验证</li><li><strong>社区驱动</strong>：标准化的贡献流程和质量保证体系</li></ul><h3 id="工具生态的协同价值"><a href="#工具生态的协同价值" class="headerlink" title="工具生态的协同价值"></a>工具生态的协同价值</h3><p>这两个工具在实际使用中形成<strong>互补覆盖</strong>：</p><ul><li><strong>wewe-rss</strong> 处理微信公众号这一中文互联网重要信息源</li><li><strong>RSSHub</strong> 覆盖其他所有主流平台和网站</li><li><strong>Folo</strong> 作为统一终端，整合所有 RSS 源的阅读体验</li></ul><p>它们共同指向同一目标：<strong>将分散的封闭内容重新导入开放协议</strong>。</p><p>局限依然存在：付费墙内容无法获取，接口可能关闭。但这是一种<strong>可接受的脆弱性</strong>——在绝对控制与完全开放之间，这个工具生态提供了可行的中间路径。</p><p><img data-src="https://cuipengfei.github.io/picx-images-hosting/20250721/%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90%E4%BB%BB%E5%8A%A1-(2).5q7pouo8yv.png" alt="图像生成任务-(2)"></p><h2 id="脆弱的平衡"><a href="#脆弱的平衡" class="headerlink" title="脆弱的平衡"></a>脆弱的平衡</h2><p>这套方案的生命周期，取决于微信读书的接口策略，存在不确定性。</p><p>但它证明了：<strong>中心化平台的控制并非绝对</strong>。</p><p>通过技术工具，个体可以重新取回部分信息控制权。</p><p>这不是颠覆，而是一种<strong>结构性再平衡</strong>。</p><p>RSS 这个 1999 年的协议，在 2025 年成为制衡平台中心化的有效工具。</p><p>这提示我们：<strong>开放协议通常比封闭应用拥有更长的生命周期</strong>。当用户需求与平台利益发生冲突时，基于开放标准的工具生态会自发涌现出解决方案。</p><p><img data-src="https://cuipengfei.github.io/picx-images-hosting/20250721/%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90%E4%BB%BB%E5%8A%A1-(3).7p3wf6trab.png" alt="图像生成任务-(3)"></p><h2 id="行动与思考"><a href="#行动与思考" class="headerlink" title="行动与思考"></a>行动与思考</h2><ol><li><strong>盘点</strong>：识别你真正需要关注的信源。</li><li><strong>部署</strong>：搭建<code>wewe-rss</code>处理微信公众号，部署<code>RSSHub</code>覆盖其他平台。</li><li><strong>整合</strong>：将所有 RSS 源导入<code>Folo</code>或你选择的 RSS 阅读器。</li><li><strong>重塑</strong>：用主动拉取替代被动投喂的阅读习惯。</li></ol><p>信息控制权的回归，是使用习惯的重塑。</p><p><img data-src="https://cuipengfei.github.io/picx-images-hosting/20250721/%E7%94%9F%E6%88%90%E7%89%B9%E5%AE%9A%E5%9B%BE%E5%83%8F.1sfc86d8bx.png" alt="生成特定图像"></p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;控制权旁落&quot;&gt;&lt;a href=&quot;#控制权旁落&quot; class=&quot;headerlink&quot; title=&quot;控制权旁落&quot;&gt;&lt;/a&gt;控制权旁落&lt;/h2&gt;&lt;p&gt;RSS 并未消亡。&lt;/p&gt;
&lt;p&gt;变化的不是协议，而是信息分发领域的权力结构。&lt;/p&gt;
&lt;p&gt;用户在事实上让渡了选择看什么、何时看的权利。&lt;/p&gt;
&lt;p&gt;微信公众号重塑了这种结构，通过两层约束：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;技术约束&lt;/strong&gt;：内容被封装于 App 内，无标准 API，无 RSS 输出通道。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;算法约束&lt;/strong&gt;：信息流按商业目标而非时间或信息价值排序。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="RSS" scheme="https://cuipengfei.is-a.dev/tags/RSS/"/>
    
    <category term="Folo" scheme="https://cuipengfei.is-a.dev/tags/Folo/"/>
    
    <category term="wewe-rss" scheme="https://cuipengfei.is-a.dev/tags/wewe-rss/"/>
    
    <category term="RSSHub" scheme="https://cuipengfei.is-a.dev/tags/RSSHub/"/>
    
  </entry>
  
  <entry>
    <title>AI 时代，我们是在写代码，还是在“写知识”？—— 极客时间 8x 课程笔记</title>
    <link href="https://cuipengfei.is-a.dev/blog/2025/06/28/geektime-8x-ai/"/>
    <id>https://cuipengfei.is-a.dev/blog/2025/06/28/geektime-8x-ai/</id>
    <published>2025-06-28T12:30:00.000Z</published>
    <updated>2025-06-28T12:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>本文是极客时间 8x 课程的读书笔记。我本想取名 G8 (Geekbang 8x)，但听起来不太对劲，所以就有了现在这个标题。</em></p></blockquote><blockquote><p>“软件的价值，最终由其承载的知识决定。代码，只是这些知识的可执行形态。”</p></blockquote><p><img data-src="https://github.com/cuipengfei/picx-images-hosting/raw/master/%E6%B0%B4%E5%A2%A8%E7%94%BB%E9%A3%8E%E6%A0%BC%E5%9B%BE%E7%89%87%E5%88%B6%E4%BD%9C-(1).witvkcf9b.webp" alt="x"></p><h2 id="引言：从“构建者”到“知识工程师”的身份转变"><a href="#引言：从“构建者”到“知识工程师”的身份转变" class="headerlink" title="引言：从“构建者”到“知识工程师”的身份转变"></a>引言：从“构建者”到“知识工程师”的身份转变</h2><p>我们习惯于将软件开发看作一种“建造”活动，谈论“构建”软件、“编写”代码。</p><p>但随着 AI 大语言模型（LLM）的普及，我们或许需要换个角度审视自己的工作。</p><p>如果说编码是软件开发的“最后一公里”，那在此之前的需求讨论、架构设计和技术选型，又是什么呢？</p><p>这些过程，更像是一种知识的传递、提炼与组织。</p><p>本文想探讨一个观点：在 AI 时代，软件工程的核心正从“构造软件”转向“管理知识”。</p><p>这一转变，对我们的日常工作意味着什么？</p><h2 id="一、软件：一种可执行的知识"><a href="#一、软件：一种可执行的知识" class="headerlink" title="一、软件：一种可执行的知识"></a>一、软件：一种可执行的知识</h2><p>让我们暂时抛开代码，思考软件的本质。</p><ul><li><strong>软件是知识的载体</strong>：真正的“产品”，是软件中蕴含的业务逻辑、领域规则和架构决策。代码只是这些知识的最终表现形式。</li><li><strong>软件是知识的“可执行”形态</strong>：它让抽象的知识能够在现实世界中产生具体影响。</li><li><strong>软件开发的核心，是知识的获取、学习与传递</strong>：编码只是这一漫长知识旅程的最终环节。</li></ul><p>代码是最终产物，但真正的价值在于其背后的业务逻辑、领域规则和架构决策。这些才是软件的核心“知识”。</p><h3 id="LLM：认知杠杆，而非认知替代"><a href="#LLM：认知杠杆，而非认知替代" class="headerlink" title="LLM：认知杠杆，而非认知替代"></a>LLM：认知杠杆，而非认知替代</h3><p>LLM 在这个新范式中扮演什么角色？它是一个强大的<strong>认知杠杆</strong>，极大地提升了知识转化为代码的效率，但它并未替代人类的认知过程。</p><ul><li><strong>人的认知水平是协作的上限</strong>：人与 LLM 协作的最终产出质量，取决于人对问题的理解深度和判断力。</li><li><strong>LLM 的核心能力是基于上下文的理解与生成</strong>：通过提供精准的上下文，我们可以将其“调教”为特定领域的辅助专家。</li><li><strong>LLM 存在固有技术限制</strong>：<ul><li><strong>上下文与 Token 限制</strong>，使其难以一次性处理庞杂的系统。</li><li><strong>“幻觉”现象</strong>，意味着其产出需要严格验证。</li></ul></li></ul><p>因此，将 LLM 视为无所不能的“代码生成器”是一种误解。</p><p>它的真正价值在于成为知识传递链条中的高效“处理器”，而我们则需要成为高效的“知识管理者”。</p><h2 id="二、知识工程：一种新的工作模式"><a href="#二、知识工程：一种新的工作模式" class="headerlink" title="二、知识工程：一种新的工作模式"></a>二、知识工程：一种新的工作模式</h2><p>如果软件开发是知识工作，我们该如何实践？</p><p><strong>知识工程</strong>，可以理解为：<strong>将软件开发视为一个“提取、组织知识，使其能被 LLM 理解，并最终通过 LLM 将这些知识转化为可工作软件”的完整过程。</strong></p><p>这里的<strong>关键瓶颈</strong>，不再是编码速度，而是<strong>知识传递的效率与保真度</strong>。</p><h3 id="1-知识与任务分离：与-LLM-精准对话"><a href="#1-知识与任务分离：与-LLM-精准对话" class="headerlink" title="1. 知识与任务分离：与 LLM 精准对话"></a>1. 知识与任务分离：与 LLM 精准对话</h3><p>与 LLM 交互时，清晰地分离**知识（背景信息）<strong>与</strong>任务（具体指令）**至关重要。这能帮助 LLM 建立正确的上下文，形成明确的关注点。</p><p>坦白说，我最初也尝试过一种不太明智的方法：将一份长达数页的需求文档直接丢给 LLM，期望它能“一口吃成个胖子”，直接生成整个模块。结果可想而知，它要么陷入逻辑混乱，要么给出一堆看似正确却无法组合的“代码碎片”。</p><p>这次失败让我意识到，与 LLM 协作，我们不能扮演“甩手掌柜”的角色，而必须成为一名**“知识主厨”**。我们需要亲手将大块的“需求原料”精心切分、预处理，才能让 LLM 这位“超级副厨”高效地烹饪出佳肴。</p><p>例如，与其直接说“写一个登录函数”，不如先提供知识：</p><ul><li><strong>知识（Context）</strong>：“系统使用 JWT 认证，密码采用 bcrypt 加密，用户信息存储在 <code>users</code> 表中。”</li><li><strong>任务（Task）</strong>：“基于以上信息，编写一个 <code>login(username, password)</code> 函数，验证成功后返回 JWT。”</li></ul><p>有趣的是，敏捷开发中的<strong>用户故事（User Story）</strong>，恰好是一种优秀的知识管理工具。它天然地侧重于<strong>定义问题（“我是谁”、“我想要什么”、“为什么”）</strong>，而非预设解决方案，这使其成为向 LLM 传递需求的理想形式。</p><h3 id="2-通过反馈迭代：提炼隐性知识"><a href="#2-通过反馈迭代：提炼隐性知识" class="headerlink" title="2. 通过反馈迭代：提炼隐性知识"></a>2. 通过反馈迭代：提炼隐性知识</h3><p>知识工程并非单向传递，而是一个双向的、迭代的探索过程。</p><blockquote><p>通过 LLM 的反馈来反思并修正我们对知识的描述，是知识工程的核心循环。</p></blockquote><p>我们可以将这个过程，比作<strong>请一位超级画师（LLM）为我们画一幅肖像画</strong>。我们与 LLM 的每一次交互，都是在向它描述自己的特征。当发现它画出的细节（生成的代码）有偏差时，问题往往不在于它的“画技”，而在于我们这位“模特”没有描述清楚自己的样貌。</p><p>LLM 的“误解”就像一面镜子，忠实地反射出我们自身知识表达的模糊与缺漏。因此，这个迭代过程，与其说是“调试机器”，不如说是**“校准自我”**。它的最终目标是得到一幅双方都认可的、纤毫毕现的“知识蓝图”，而非仅仅“修复代码”。当 LLM 对你的描述产生“误解”时，我们首先要反思的是，自己对知识的表达是否足够清晰、准确。</p><h3 id="3-驾驭不同类型的知识"><a href="#3-驾驭不同类型的知识" class="headerlink" title="3. 驾驭不同类型的知识"></a>3. 驾驭不同类型的知识</h3><p>软件开发涉及的知识远非单一类型，我们必须学会驾驭它们：</p><ul><li><strong>显式知识（Explicit Knowledge）</strong>：能够被清晰表达、记录和传播的”know-what”，如技术文档、业务规则。</li><li><strong>隐式知识（Implicit Knowledge）</strong>：尚未被记录，但可以通过交流和文档化转为显式知识。</li><li><strong>默会知识（Tacit Knowledge）</strong>：这是最宝贵也最难处理的部分。它是个人经验、直觉、技能的核心，是难以形式化的”know-how”。例如，一位资深架构师在众多方案中做出权衡的直觉，或是一位高级工程师对代码“坏味道”的敏锐嗅觉。<strong>定义问题通常比解决问题更难</strong>，而对问题的敏锐感知，正是默会知识的体现。</li></ul><p>为何同样的技术文档（显式知识）在不同人手中，会产生天壤之别的实现？</p><p>为何有经验的工程师能在看似平静的代码中，直觉性地感知到潜在的设计缺陷？</p><p>这些都体现了默会知识的核心价值。</p><h2 id="三、研发流程重塑：从代码管理到知识管理"><a href="#三、研发流程重塑：从代码管理到知识管理" class="headerlink" title="三、研发流程重塑：从代码管理到知识管理"></a>三、研发流程重塑：从代码管理到知识管理</h2><p>在新范式下，现有研发流程需要<strong>重构为以知识为中心的管理过程</strong>，其核心目标是从流程中捕获关键知识，并通过 LLM 有效沉淀。</p><p><strong>围绕“默会知识”的传递来构建流程，是实现知识工程的关键。</strong></p><h3 id="1-应用与提取“默会知识”"><a href="#1-应用与提取“默会知识”" class="headerlink" title="1. 应用与提取“默会知识”"></a>1. 应用与提取“默会知识”</h3><ul><li><strong>应用知识</strong>：对于成熟的、有明确解决方案的问题（例如，为新项目搭建 CI&#x2F;CD 流水线），我们可以通过<strong>提示词模板</strong>对成熟的任务流程进行建模，高效应用那些已被充分学习的默会知识。</li><li><strong>提取知识</strong>：默会知识的提取，本质上是**提炼“思维链”（Chain of Thought, CoT）**的过程。通过鼓励 LLM 解释其推理过程，我们可以反向形式化那些隐性的专家经验。RAG（检索增强生成）等模式，同样有助于新知识的学习与提取。</li></ul><h3 id="2-应对认知偏差：先对齐思路，再写代码"><a href="#2-应对认知偏差：先对齐思路，再写代码" class="headerlink" title="2. 应对认知偏差：先对齐思路，再写代码"></a>2. 应对认知偏差：先对齐思路，再写代码</h3><p><strong>认知偏差</strong>是团队协作中的巨大障碍：不同成员对同一问题可能持有完全不同的假设和理解，导致共识难以形成。</p><p>这种分歧的<strong>后果</strong>是：团队难以形成统一共识，讨论陷入循环，新人培养周期延长，系统设计出现不一致，引入大量隐蔽的质量缺陷。我们是否曾困惑，为何同样的技术讨论，有些团队能迅速聚焦并达成一致，而有些团队却在表面问题上争论不休？认知偏差往往是根源。</p><p>知识工程强调<strong>先对齐思路，再动手编码</strong>。</p><ul><li><strong>推行任务审查（Task Review）</strong>：将审查的重心从代码（Code Review）上移至任务本身，在编码前，就通过讨论、文档或图表，确保团队对“做什么”和“为什么做”达成一致。这看似增加了前期的沟通成本，但相较于修复因认知偏差导致的大量后期代码返工和隐蔽缺陷，这种“前期投入”的收益是巨大的。这是一种典型的“左移”（Shift-Left）思想在知识管理上的体现。</li><li><strong>建立认知行为基线</strong>：管理者应着力于建立团队统一的认知与行为基线，确保对问题的理解和处理方式有一致的标准。</li></ul><h3 id="3-混乱中的清醒：及时止损"><a href="#3-混乱中的清醒：及时止损" class="headerlink" title="3. 混乱中的清醒：及时止损"></a>3. 混乱中的清醒：及时止损</h3><p>当个体或团队对问题感到<strong>混乱（Chaotic）</strong>——即无法理解问题、被恐慌驱动而盲目行动时，任何试图“解决”问题的努力都可能加剧混乱。</p><p>此时，<strong>理性地及时止损</strong>，暂停行动，回归问题的澄清与理解，是避免大量返工的明智选择。</p><h2 id="四、任务划分与质量内建：新范式下的交付关键"><a href="#四、任务划分与质量内建：新范式下的交付关键" class="headerlink" title="四、任务划分与质量内建：新范式下的交付关键"></a>四、任务划分与质量内建：新范式下的交付关键</h2><h3 id="1-任务划分：与-LLM-协作的“接口”"><a href="#1-任务划分：与-LLM-协作的“接口”" class="headerlink" title="1. 任务划分：与 LLM 协作的“接口”"></a>1. 任务划分：与 LLM 协作的“接口”</h3><p>由于 LLM 的技术限制，需求必须被分解为<strong>足够小的、原子化的任务</strong>，才能转化为高质量的提示词。这个过程并非随意的拆分，而需同时兼顾<strong>软件架构与测试策略</strong>。</p><p><strong>可测试性（Testability）是进程内架构最重要的属性之一</strong>。一个好的任务划分，本身就应该导向一个易于测试的实现。</p><h3 id="2-质量控制优先于生成效率"><a href="#2-质量控制优先于生成效率" class="headerlink" title="2. 质量控制优先于生成效率"></a>2. 质量控制优先于生成效率</h3><p>在 LLM 辅助开发中，我们的精力分配需要发生根本转变：<strong>将更多精力投入质量控制，而非一味追求生成效率。</strong></p><p>反馈循环的瓶颈在于<strong>如何高效验证 LLM 生成结果的正确性与有效性</strong>。因此，我们必须大力倡导**内建质量（Build Quality In）**的理念，通过测试驱动（TDD&#x2F;BDD）来提炼需要给予 LLM 的精准反馈，而非仅仅依赖于编码后的手动调试。</p><p>我们应当转变思维，从”如何修复 LLM 生成的错误代码”到”如何设计流程，使 LLM 更容易生成正确代码”。</p><p>当我们过于关注生成速度时，往往因大量调试修复而降低总体效率；而当我们专注于质量时，整体进度反而可能加快。</p><p>这是否意味着，在 AI 时代，“慢即是快”可能成为新的工程法则？</p><h2 id="五、工程师的转型：从“编码者”到“知识工程师”"><a href="#五、工程师的转型：从“编码者”到“知识工程师”" class="headerlink" title="五、工程师的转型：从“编码者”到“知识工程师”"></a>五、工程师的转型：从“编码者”到“知识工程师”</h2><p>这场范式转型，最终将重塑工程师的核心价值。</p><ul><li><p><strong>角色转变</strong>：从专注于编码实现的**“编码者”（Coder）<strong>，转向侧重于知识管理、任务分解与验证的</strong>“知识工程师”（Knowledge Engineer）<strong>。对纯粹编码技能的要求或许会降低，但对</strong>知识提炼、系统思考、质量保障**等能力的要求将显著提升。</p><p>技能重组正在发生：</p><ul><li><strong>知识提炼能力</strong>：从复杂、模糊的业务需求中提取清晰、结构化的知识。</li><li><strong>系统性思考</strong>：在碎片化任务中保持整体视角，确保局部解决方案符合全局最优。</li><li><strong>元认知水平</strong>：对自身思考过程的觉察、监控与调整能力。</li><li><strong>跨学科整合</strong>：将技术、业务、用户体验等多维度知识有机融合。</li></ul></li><li><p><strong>核心价值</strong>：工程师的核心价值，在于为 LLM 提供<strong>足够丰富且精准的上下文信息</strong>——这包括功能需求、业务知识、架构决策、测试策略等一切关乎“生产正确代码”的关键信息。</p></li></ul><p>我们的关注点，正从“如何构造软件”，历史性地转向**“如何提取和组织知识，让知识变成 LLM 能够理解的形式”**。</p><p>从这个角度看，“提示词工程”的本质，是如何精准地组织与表达知识。</p><p>因此，<strong>“知识工程”</strong>，或许是一个更合理、也更深刻的名称。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>AI 时代的软件开发，核心挑战从编码转向了知识管理。掌握好知识提炼、任务分解和质量控制这些技能，将是工程师适应新环境的关键。</p><p><img data-src="https://github.com/cuipengfei/picx-images-hosting/raw/master/%E6%B0%B4%E5%A2%A8%E7%94%BB%E9%A3%8E%E6%A0%BC%E5%9B%BE%E7%89%87%E5%88%B6%E4%BD%9C.sz7xujcjv.webp" alt="x"></p><div class="markmap-wrap"                 >      <script type="application/json">{"content":"AI &#x65f6;&#x4ee3;&#xff1a;&#x8f6f;&#x4ef6;=&#x77e5;&#x8bc6;&#x5de5;&#x7a0b;","children":[{"content":"&#x5f15;&#x8a00;","children":[{"content":"&#x8f6f;&#x4ef6;&#x5f00;&#x53d1;&#x672c;&#x8d28;&#x662f;&#x77e5;&#x8bc6;&#x4f20;&#x9012;&#x4e0e;&#x7ec4;&#x7ec7;","children":[],"payload":{"tag":"li","lines":"9,10"}},{"content":"AI &#x4fc3;&#x4f7f;&#x5de5;&#x7a0b;&#x5e08;&#x4ece;&#x201c;&#x6784;&#x5efa;&#x8005;&#x201d;&#x8f6c;&#x5411;&#x201c;&#x77e5;&#x8bc6;&#x5de5;&#x7a0b;&#x5e08;&#x201d;","children":[],"payload":{"tag":"li","lines":"10,12"}}],"payload":{"tag":"h2","lines":"7,8"}},{"content":"&#x8f6f;&#x4ef6;&#x672c;&#x8d28;","children":[{"content":"&#x8f6f;&#x4ef6;&#x662f;&#x4e1a;&#x52a1;&#x4e0e;&#x67b6;&#x6784;&#x77e5;&#x8bc6;&#x7684;&#x53ef;&#x6267;&#x884c;&#x8f7d;&#x4f53;","children":[],"payload":{"tag":"li","lines":"14,15"}},{"content":"&#x4ee3;&#x7801;&#x53ea;&#x662f;&#x77e5;&#x8bc6;&#x7684;&#x6700;&#x7ec8;&#x8868;&#x73b0;","children":[],"payload":{"tag":"li","lines":"15,16"}},{"content":"&#x5f00;&#x53d1;&#x6838;&#x5fc3;&#x662f;&#x77e5;&#x8bc6;&#x7684;&#x83b7;&#x53d6;&#x3001;&#x5b66;&#x4e60;&#x4e0e;&#x4f20;&#x9012;","children":[],"payload":{"tag":"li","lines":"16,18"}}],"payload":{"tag":"h2","lines":"12,13"}},{"content":"&#x77e5;&#x8bc6;&#x5de5;&#x7a0b;","children":[{"content":"&#x5173;&#x952e;&#x74f6;&#x9888;&#x662f;&#x77e5;&#x8bc6;&#x4f20;&#x9012;&#x6548;&#x7387;&#x4e0e;&#x4fdd;&#x771f;&#x5ea6;","children":[],"payload":{"tag":"li","lines":"20,21"}},{"content":"&#x660e;&#x786e;&#x533a;&#x5206;&#x77e5;&#x8bc6;&#xff08;&#x80cc;&#x666f;&#xff09;&#x4e0e;&#x4efb;&#x52a1;&#xff08;&#x6307;&#x4ee4;&#xff09;","children":[],"payload":{"tag":"li","lines":"21,22"}},{"content":"&#x7528;&#x6237;&#x6545;&#x4e8b;&#x662f;&#x7406;&#x60f3;&#x7684;&#x77e5;&#x8bc6;&#x7ba1;&#x7406;&#x5de5;&#x5177;","children":[],"payload":{"tag":"li","lines":"22,23"}},{"content":"&#x901a;&#x8fc7;&#x53cd;&#x9988;&#x8fed;&#x4ee3;&#x63d0;&#x70bc;&#x9690;&#x6027;&#x77e5;&#x8bc6;","children":[],"payload":{"tag":"li","lines":"23,24"}},{"content":"&#x9a7e;&#x9a6d;&#x663e;&#x5f0f;&#x3001;&#x9690;&#x5f0f;&#x3001;&#x9ed8;&#x4f1a;&#x4e09;&#x7c7b;&#x77e5;&#x8bc6;","children":[],"payload":{"tag":"li","lines":"24,26"}}],"payload":{"tag":"h2","lines":"18,19"}},{"content":"&#x6d41;&#x7a0b;&#x91cd;&#x5851;","children":[{"content":"&#x4ee5;&#x77e5;&#x8bc6;&#x4e3a;&#x4e2d;&#x5fc3;&#x91cd;&#x6784;&#x7814;&#x53d1;&#x6d41;&#x7a0b;","children":[],"payload":{"tag":"li","lines":"28,29"}},{"content":"&#x6d41;&#x7a0b;&#x9700;&#x6355;&#x83b7;&#x5e76;&#x6c89;&#x6dc0;&#x5173;&#x952e;&#x77e5;&#x8bc6;","children":[],"payload":{"tag":"li","lines":"29,30"}},{"content":"&#x9ed8;&#x4f1a;&#x77e5;&#x8bc6;&#x4f20;&#x9012;&#x662f;&#x6d41;&#x7a0b;&#x8bbe;&#x8ba1;&#x5173;&#x952e;","children":[],"payload":{"tag":"li","lines":"30,31"}},{"content":"&#x5e94;&#x7528;&#xff1a;&#x7528;&#x6a21;&#x677f;&#x9ad8;&#x6548;&#x590d;&#x7528;&#x6210;&#x719f;&#x77e5;&#x8bc6;","children":[],"payload":{"tag":"li","lines":"31,32"}},{"content":"&#x63d0;&#x53d6;&#xff1a;&#x9f13;&#x52b1;&#x601d;&#x7ef4;&#x94fe;&#xff0c;&#x53cd;&#x5411;&#x5f62;&#x5f0f;&#x5316;&#x4e13;&#x5bb6;&#x7ecf;&#x9a8c;","children":[],"payload":{"tag":"li","lines":"32,33"}},{"content":"&#x5148;&#x5bf9;&#x9f50;&#x601d;&#x8def;&#xff0c;&#x518d;&#x5199;&#x4ee3;&#x7801;&#xff0c;&#x63a8;&#x884c;&#x4efb;&#x52a1;&#x5ba1;&#x67e5;","children":[],"payload":{"tag":"li","lines":"33,34"}},{"content":"&#x5efa;&#x7acb;&#x56e2;&#x961f;&#x8ba4;&#x77e5;&#x884c;&#x4e3a;&#x57fa;&#x7ebf;","children":[],"payload":{"tag":"li","lines":"34,35"}},{"content":"&#x6df7;&#x4e71;&#x65f6;&#x53ca;&#x65f6;&#x6b62;&#x635f;&#xff0c;&#x56de;&#x5f52;&#x6f84;&#x6e05;","children":[],"payload":{"tag":"li","lines":"35,37"}}],"payload":{"tag":"h2","lines":"26,27"}},{"content":"&#x4efb;&#x52a1;&#x4e0e;&#x8d28;&#x91cf;","children":[{"content":"&#x9700;&#x6c42;&#x9700;&#x539f;&#x5b50;&#x5316;&#xff0c;&#x4fbf;&#x4e8e; LLM &#x7406;&#x89e3;&#x4e0e;&#x751f;&#x6210;","children":[],"payload":{"tag":"li","lines":"39,40"}},{"content":"&#x4efb;&#x52a1;&#x5212;&#x5206;&#x9700;&#x517c;&#x987e;&#x67b6;&#x6784;&#x4e0e;&#x6d4b;&#x8bd5;","children":[],"payload":{"tag":"li","lines":"40,41"}},{"content":"&#x53ef;&#x6d4b;&#x8bd5;&#x6027;&#x662f;&#x67b6;&#x6784;&#x6838;&#x5fc3;&#x5c5e;&#x6027;","children":[],"payload":{"tag":"li","lines":"41,42"}},{"content":"&#x8d28;&#x91cf;&#x63a7;&#x5236;&#x4f18;&#x5148;&#x4e8e;&#x751f;&#x6210;&#x6548;&#x7387;","children":[],"payload":{"tag":"li","lines":"42,43"}},{"content":"&#x53cd;&#x9988;&#x5faa;&#x73af;&#x74f6;&#x9888;&#x5728;&#x4e8e;&#x9ad8;&#x6548;&#x9a8c;&#x8bc1;","children":[],"payload":{"tag":"li","lines":"43,44"}},{"content":"&#x63a8;&#x5d07;&#x5185;&#x5efa;&#x8d28;&#x91cf;&#xff08;TDD/BDD&#xff09;&#xff0c;&#x7cbe;&#x51c6;&#x53cd;&#x9988;","children":[],"payload":{"tag":"li","lines":"44,46"}}],"payload":{"tag":"h2","lines":"37,38"}},{"content":"&#x5de5;&#x7a0b;&#x5e08;&#x8f6c;&#x578b;","children":[{"content":"&#x89d2;&#x8272;&#xff1a;&#x4ece;&#x7f16;&#x7801;&#x8005;&#x5230;&#x77e5;&#x8bc6;&#x5de5;&#x7a0b;&#x5e08;","children":[],"payload":{"tag":"li","lines":"48,49"}},{"content":"&#x80fd;&#x529b;&#x91cd;&#x7ec4;&#xff1a;","children":[{"content":"&#x77e5;&#x8bc6;&#x63d0;&#x70bc;&#xff1a;&#x7ed3;&#x6784;&#x5316;&#x590d;&#x6742;&#x9700;&#x6c42;","children":[],"payload":{"tag":"li","lines":"50,51"}},{"content":"&#x7cfb;&#x7edf;&#x6027;&#x601d;&#x8003;&#xff1a;&#x5168;&#x5c40;&#x89c6;&#x89d2;","children":[],"payload":{"tag":"li","lines":"51,52"}},{"content":"&#x5143;&#x8ba4;&#x77e5;&#xff1a;&#x81ea;&#x6211;&#x89c9;&#x5bdf;&#x4e0e;&#x8c03;&#x6574;","children":[],"payload":{"tag":"li","lines":"52,53"}},{"content":"&#x8de8;&#x5b66;&#x79d1;&#x6574;&#x5408;&#xff1a;&#x878d;&#x5408;&#x6280;&#x672f;&#x3001;&#x4e1a;&#x52a1;&#x3001;&#x4f53;&#x9a8c;","children":[],"payload":{"tag":"li","lines":"53,54"}}],"payload":{"tag":"li","lines":"49,54"}},{"content":"&#x6838;&#x5fc3;&#x4ef7;&#x503c;&#xff1a;&#x4e3a; LLM &#x63d0;&#x4f9b;&#x4e30;&#x5bcc;&#x7cbe;&#x51c6;&#x4e0a;&#x4e0b;&#x6587;","children":[],"payload":{"tag":"li","lines":"54,55"}},{"content":"&#x5173;&#x6ce8;&#x70b9;&#x8f6c;&#x5411;&#x77e5;&#x8bc6;&#x7ec4;&#x7ec7;&#x4e0e;&#x8868;&#x8fbe;","children":[],"payload":{"tag":"li","lines":"55,57"}}],"payload":{"tag":"h2","lines":"46,47"}},{"content":"&#x7ed3;&#x8bed;","children":[{"content":"&#x77e5;&#x8bc6;&#x59cb;&#x7ec8;&#x662f;&#x8f6f;&#x4ef6;&#x6838;&#x5fc3;&#x4ef7;&#x503c;","children":[],"payload":{"tag":"li","lines":"59,60"}},{"content":"&#x6709;&#x6548;&#x4f20;&#x9012;&#x4e0e;&#x7ec4;&#x7ec7;&#x77e5;&#x8bc6;&#x51b3;&#x5b9a;&#x6210;&#x8d25;","children":[],"payload":{"tag":"li","lines":"60,61"}},{"content":"&#x8f6f;&#x4ef6;&#x5de5;&#x7a0b;&#x6b63;&#x8fc8;&#x5411;&#x8ba4;&#x77e5;&#x79d1;&#x5b66;&#x65b0;&#x8303;&#x5f0f;","children":[],"payload":{"tag":"li","lines":"61,62"}}],"payload":{"tag":"h2","lines":"57,58"}}],"payload":{"tag":"h1","lines":"5,6"}}</script>      <script type="application/json">{"colorFreezeLevel":2}</script>    </div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;本文是极客时间 8x 课程的读书笔记。我本想取名 G8 (Geekbang 8x)，但听起来不太对劲，所以就有了现在这个标题。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;“软件的价值，最终由其承载的知识决定。代码，只是这些知识的可执行形态。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img data-src=&quot;https://github.com/cuipengfei/picx-images-hosting/raw/master/%E6%B0%B4%E5%A2%A8%E7%94%BB%E9%A3%8E%E6%A0%BC%E5%9B%BE%E7%89%87%E5%88%B6%E4%BD%9C-(1).witvkcf9b.webp&quot; alt=&quot;x&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言：从“构建者”到“知识工程师”的身份转变&quot;&gt;&lt;a href=&quot;#引言：从“构建者”到“知识工程师”的身份转变&quot; class=&quot;headerlink&quot; title=&quot;引言：从“构建者”到“知识工程师”的身份转变&quot;&gt;&lt;/a&gt;引言：从“构建者”到“知识工程师”的身份转变&lt;/h2&gt;&lt;p&gt;我们习惯于将软件开发看作一种“建造”活动，谈论“构建”软件、“编写”代码。&lt;/p&gt;
&lt;p&gt;但随着 AI 大语言模型（LLM）的普及，我们或许需要换个角度审视自己的工作。&lt;/p&gt;</summary>
    
    
    
    <category term="技术思考" scheme="https://cuipengfei.is-a.dev/categories/%E6%8A%80%E6%9C%AF%E6%80%9D%E8%80%83/"/>
    
    <category term="AI" scheme="https://cuipengfei.is-a.dev/categories/%E6%8A%80%E6%9C%AF%E6%80%9D%E8%80%83/AI/"/>
    
    <category term="软件工程" scheme="https://cuipengfei.is-a.dev/categories/%E6%8A%80%E6%9C%AF%E6%80%9D%E8%80%83/AI/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
    <category term="知识工程" scheme="https://cuipengfei.is-a.dev/tags/%E7%9F%A5%E8%AF%86%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="LLM" scheme="https://cuipengfei.is-a.dev/tags/LLM/"/>
    
    <category term="认知模型" scheme="https://cuipengfei.is-a.dev/tags/%E8%AE%A4%E7%9F%A5%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="软件开发" scheme="https://cuipengfei.is-a.dev/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>如何给 GitHub Copilot &quot;洗脑”，让 AI 精准遵循指令产出高质量代码</title>
    <link href="https://cuipengfei.is-a.dev/blog/2025/06/17/how-to-brainwash-copilot-to-follow-orders/"/>
    <id>https://cuipengfei.is-a.dev/blog/2025/06/17/how-to-brainwash-copilot-to-follow-orders/</id>
    <published>2025-06-17T02:00:00.000Z</published>
    <updated>2025-06-17T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子：把-AI-新兵改造成精锐士兵"><a href="#引子：把-AI-新兵改造成精锐士兵" class="headerlink" title="引子：把 AI 新兵改造成精锐士兵"></a>引子：把 AI 新兵改造成精锐士兵</h2><p>GitHub Copilot 就像一个天赋异禀但野路子出身的“新兵”。它枪法精准（编码能力强），但缺乏战场纪律（工程规范）。</p><p>你让它冲锋，它能迅速拿下山头，但阵地上一片狼藉：没有构筑工事（错误处理），不关心侧翼安全（边界情况），弹药随意堆放（命名混乱）。</p><p>我们需要的不是一个只会冲锋的“莽夫”，而是一个懂得协同作战、遵守战场纪律的“精锐士兵”。因此，我决定为它编写一套严格的“作战条令”（Prompts），对它进行一次彻底的“军事化改造”，让它乖乖听话。</p><h2 id="不是魔法，是系统指令"><a href="#不是魔法，是系统指令" class="headerlink" title="不是魔法，是系统指令"></a>不是魔法，是系统指令</h2><p>经过一段时间的研究和实践，我发现 Copilot 这类 AI 工具实际上可以被深度”引导”，甚至达到一种”洗脑”的效果，让它们按照我们的意愿来行动。</p><p>它们并不是魔术盒子，而是遵循一套输入-输出原则的系统。如果我们能给它提供明确的指导和原则，它就能相应地调整自己的输出。</p><p>这个思路促使我整理了一个专门用来给 GitHub Copilot”洗脑”的指令集：<a href="https://github.com/cuipengfei/prompts">prompts</a>。</p><p>这个仓库里不是代码，而是一系列指导 AI 行为的 Markdown 文件。每个文件就像是给 AI 的一份规范或指南，告诉它应该怎样思考和行动。</p><h2 id="这套指令能解决什么问题？"><a href="#这套指令能解决什么问题？" class="headerlink" title="这套指令能解决什么问题？"></a>这套指令能解决什么问题？</h2><p>使用 AI 编程助手时，我们通常会遇到这些问题：</p><ul><li>生成的代码能运行，但结构混乱，难以维护</li><li>没有考虑边界情况和异常处理</li><li>代码风格不一致，命名随意</li><li>缺乏适当的测试覆盖</li><li>不遵循项目已有的架构模式</li></ul><p>这套指令集就是为了解决这些问题而设计的。它告诉 AI 该如何思考软件设计、如何编写清晰的代码、如何进行测试驱动开发，以及如何分解复杂问题。</p><h2 id="指令集的构成"><a href="#指令集的构成" class="headerlink" title="指令集的构成"></a>指令集的构成</h2><p>整个指令集分为几个主要部分：</p><ol><li><p><strong>核心行为定义</strong>：这部分告诉 AI 应该如何进行思考和工作，包括：</p><ul><li>如何保持项目知识的连贯性（memory-bank）</li><li>如何有条理地回应用户（response-and-prompt-guidelines）</li><li>如何遵循 TDD 工作流（programming-workflow）</li><li>如何分解复杂任务（workflow-and-task-splitting）</li></ul></li><li><p><strong>代码质量规范</strong>：这部分告诉 AI 什么是好代码，什么是坏代码：</p><ul><li>代码标准和最佳实践（code-standards）</li><li>代码异味和应避免的反模式（avoid-bad-smells）</li><li>如何编写有效的测试（testing-guidelines）</li></ul></li><li><p><strong>流程模板</strong>：这部分提供了从需求到实现的结构化方法：</p><ul><li>如何将模糊的想法转化为明确的计划（req）</li><li>如何协助业务分析师编写用户故事（ba）</li></ul></li><li><p><strong>工具使用指南</strong>：这部分包含了一些高级技巧：</p><ul><li>如何使用顺序思考解决问题（sequential-thinking）</li><li>快捷指令系统（shortcut-system-instruction）</li></ul></li></ol><h2 id="这些“作战条令”是如何生效的？"><a href="#这些“作战条令”是如何生效的？" class="headerlink" title="这些“作战条令”是如何生效的？"></a>这些“作战条令”是如何生效的？</h2><p>你可能会好奇，为什么几份 Markdown 文件就能驯服一个复杂的 AI？</p><p>其根本原因在于，我们利用了大型语言模型的一个核心特性：<strong>它是一个基于上下文的、概率性的序列生成器</strong>。它本身没有真正的“理解”或“意识”，它的所有行为都是在预测“在当前上下文中，下一个最可能的词是什么”。</p><p>因此，这套指令的本质，就是一场**“上下文污染”（Context Contamination）<strong>，或者说</strong>“概率空间操纵”（Probability Space Manipulation）**。</p><p>通过在它的工作环境中注入一套强有力的、结构化的规则（我们的“作战条令”），我们极大地改变了它进行概率计算的“初始条件”。当“编写单元测试”、“考虑异常”这些概念在上下文中被反复强调时，生成符合这些规范的代码的概率就被显著提高了。</p><p>我们不是在“教”它，而是在<strong>塑造一个让它“不得不”表现得更专业的环境</strong>。</p><p>这套“作战条令”的核心，就是用规则约束 AI 的“自由意志”：</p><ul><li><strong>“慢思考”条令</strong>，强制它在行动前必须进行“沙盘推演”（展示思考过程）。</li><li><strong>“自我批判”条令</strong>，要求它在每次“战斗”后必须提交“战后复盘报告”（自我评估）。</li><li><strong>结构化的模板</strong>，则像是规定了标准的“军事作业程序”（SOP），确保它在任何情况下都能做出标准、可靠的战术动作。</li></ul><p>说白了，这套指令的核心就是不让 AI “想当然”。它必须按照预设的流程来工作，该问的问题不能跳过，该考虑的边界情况不能遗漏。</p><h2 id="如何在实际工作中使用这套指令"><a href="#如何在实际工作中使用这套指令" class="headerlink" title="如何在实际工作中使用这套指令"></a>如何在实际工作中使用这套指令</h2><p>经过实践，我发现在 VS Code 中配置 Copilot 使用这些指令非常简单：</p><ol><li>打开 VS Code 设置（Ctrl+, 或 Cmd+,）</li><li>搜索 <code>github.copilot.chat.codeGeneration.instructions</code></li><li>添加指向指令文件的配置，例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;github.copilot.chat.codeGeneration.instructions&quot;: [</span><br><span class="line">    &#123; &quot;text&quot;: &quot;避免生成与公共代码完全匹配的代码&quot; &#125;,</span><br><span class="line">    &#123; &quot;file&quot;: &quot;../prompts/.github/instructions/req.md&quot; &#125;,</span><br><span class="line">    &#123; &quot;file&quot;: &quot;../prompts/.github/instructions/ba.md&quot; &#125;,</span><br><span class="line">    // 其它指令文件...</span><br><span class="line">    &#123; &quot;file&quot;: &quot;../prompts/.github/instructions/shortcut-system-instruction.md&quot; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>需要注意的是，文件路径要正确。这里的路径是相对于你的 workspace 的。如果你的 prompts 仓库和当前项目不在同一位置，可能需要调整路径。</p><p>设置完成后，你会发现 Copilot 生成的代码质量明显提升：更规范、更健壮、考虑更周全。</p><h2 id="一点思考：我们究竟在训练谁？"><a href="#一点思考：我们究竟在训练谁？" class="headerlink" title="一点思考：我们究竟在训练谁？"></a>一点思考：我们究竟在训练谁？</h2><p>为 AI 制定“作战条令”的过程，其实和带新人有些相似 —— 你需要清晰地表达期望，提供良好的指导和范例，然后持续进行纠正和反馈。</p><p>但更有趣的是，这个过程在某种程度上也是对我们自己的“训练”。为了能给 AI 写出清晰的指令，我们必须首先在自己脑中将“好的代码”、“好的设计”、“好的流程”这些模糊的概念给形式化、结构化。</p><p>我们究竟是在训练 AI，还是在通过训练 AI 的过程，强迫自己进行更深层次的思考，从而成为更好的工程师？</p><p>这套指令系统的价值，或许不仅在于提升了 AI 的输出质量，更在于它像一面镜子，照见了我们自身在软件工程实践中的知识盲区，并促使我们去填补它。</p><hr><p>如果你也在使用 AI 编程助手，不妨试试这套“作战条令”。如果有任何想法或改进建议，欢迎到 <a href="https://github.com/cuipengfei/prompts">prompts</a> 仓库提交 PR 或 Issue。</p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;引子：把-AI-新兵改造成精锐士兵&quot;&gt;&lt;a href=&quot;#引子：把-AI-新兵改造成精锐士兵&quot; class=&quot;headerlink&quot; title=&quot;引子：把 AI 新兵改造成精锐士兵&quot;&gt;&lt;/a&gt;引子：把 AI 新兵改造成精锐士兵&lt;/h2&gt;&lt;p&gt;GitHub Copilot 就像一个天赋异禀但野路子出身的“新兵”。它枪法精准（编码能力强），但缺乏战场纪律（工程规范）。&lt;/p&gt;
&lt;p&gt;你让它冲锋，它能迅速拿下山头，但阵地上一片狼藉：没有构筑工事（错误处理），不关心侧翼安全（边界情况），弹药随意堆放（命名混乱）。&lt;/p&gt;
&lt;p&gt;我们需要的不是一个只会冲锋的“莽夫”，而是一个懂得协同作战、遵守战场纪律的“精锐士兵”。因此，我决定为它编写一套严格的“作战条令”（Prompts），对它进行一次彻底的“军事化改造”，让它乖乖听话。&lt;/p&gt;
&lt;h2 id=&quot;不是魔法，是系统指令&quot;&gt;&lt;a href=&quot;#不是魔法，是系统指令&quot; class=&quot;headerlink&quot; title=&quot;不是魔法，是系统指令&quot;&gt;&lt;/a&gt;不是魔法，是系统指令&lt;/h2&gt;&lt;p&gt;经过一段时间的研究和实践，我发现 Copilot 这类 AI 工具实际上可以被深度”引导”，甚至达到一种”洗脑”的效果，让它们按照我们的意愿来行动。&lt;/p&gt;</summary>
    
    
    
    <category term="技术思考" scheme="https://cuipengfei.is-a.dev/categories/%E6%8A%80%E6%9C%AF%E6%80%9D%E8%80%83/"/>
    
    
    <category term="软件开发" scheme="https://cuipengfei.is-a.dev/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="AI" scheme="https://cuipengfei.is-a.dev/tags/AI/"/>
    
    <category term="GitHub Copilot" scheme="https://cuipengfei.is-a.dev/tags/GitHub-Copilot/"/>
    
    <category term="代码质量" scheme="https://cuipengfei.is-a.dev/tags/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"/>
    
    <category term="提示工程" scheme="https://cuipengfei.is-a.dev/tags/%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Reveal.js 高级特效演示</title>
    <link href="https://cuipengfei.is-a.dev/blog/2025/01/20/blog-slides-demo/"/>
    <id>https://cuipengfei.is-a.dev/blog/2025/01/20/blog-slides-demo/</id>
    <published>2025-01-19T16:00:00.000Z</published>
    <updated>2025-01-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<!--   纯 Markdown 演示文稿  使用 Reveal.js 的高级功能，但内容完全用 Markdown 编写  特效通过 Reveal.js 的注释语法实现--><h2 id="🚀-Reveal-js-高级特效演示"><a href="#🚀-Reveal-js-高级特效演示" class="headerlink" title="🚀 Reveal.js 高级特效演示"></a>🚀 Reveal.js 高级特效演示</h2><h3 id="极致的视觉体验"><a href="#极致的视觉体验" class="headerlink" title="极致的视觉体验"></a>极致的视觉体验</h3><ul><li>背景视频 · 动态效果 · 交互体验</li><li>使用纯 Markdown 语法编写</li><li>所有特效通过 Reveal.js 注释实现</li></ul><hr><h2 id="🎨-背景特效展示"><a href="#🎨-背景特效展示" class="headerlink" title="🎨 背景特效展示"></a>🎨 背景特效展示</h2><h3 id="渐变背景效果"><a href="#渐变背景效果" class="headerlink" title="渐变背景效果"></a>渐变背景效果</h3><p>支持多种背景效果：</p><ul><li>线性渐变</li><li>径向渐变  </li><li>图片背景</li><li>视频背景</li><li>纯色背景</li></ul><h3 id="图片背景-透明度"><a href="#图片背景-透明度" class="headerlink" title="图片背景 + 透明度"></a>图片背景 + 透明度</h3><p>支持透明度调节的图片背景：</p><ul><li>图片透明度</li><li>背景模糊</li><li>视觉效果</li></ul><h3 id="纯色背景"><a href="#纯色背景" class="headerlink" title="纯色背景"></a>纯色背景</h3><p>简洁的纯色背景设计：</p><ul><li>蓝色主题</li><li>红色主题</li><li>绿色主题</li><li>橙色主题</li></ul><hr><h2 id="💻-代码高亮演示"><a href="#💻-代码高亮演示" class="headerlink" title="💻 代码高亮演示"></a>💻 代码高亮演示</h2><h3 id="多语言代码展示"><a href="#多语言代码展示" class="headerlink" title="多语言代码展示"></a>多语言代码展示</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fibonacci</span>(n - <span class="number">1</span>) + <span class="title function_">fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化版本</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacciOptimized</span>(<span class="params">n, memo = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n <span class="keyword">in</span> memo) <span class="keyword">return</span> memo[n];</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    </span><br><span class="line">    memo[n] = <span class="title function_">fibonacciOptimized</span>(n - <span class="number">1</span>, memo) + </span><br><span class="line">               <span class="title function_">fibonacciOptimized</span>(n - <span class="number">2</span>, memo);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-代码示例"><a href="#Python-代码示例" class="headerlink" title="Python 代码示例"></a>Python 代码示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AdvancedCalculator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.history = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">self, operation, a, b</span>):</span><br><span class="line">        result = &#123;</span><br><span class="line">            <span class="string">&#x27;+&#x27;</span>: a + b,</span><br><span class="line">            <span class="string">&#x27;-&#x27;</span>: a - b,</span><br><span class="line">            <span class="string">&#x27;*&#x27;</span>: a * b,</span><br><span class="line">            <span class="string">&#x27;/&#x27;</span>: a / b</span><br><span class="line">        &#125;.get(operation, <span class="string">&quot;Invalid operation&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">self</span>.history.append(<span class="string">f&quot;<span class="subst">&#123;a&#125;</span> <span class="subst">&#123;operation&#125;</span> <span class="subst">&#123;b&#125;</span> = <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_history</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.history</span><br></pre></td></tr></table></figure><hr><h2 id="📊-图表与数据可视化"><a href="#📊-图表与数据可视化" class="headerlink" title="📊 图表与数据可视化"></a>📊 图表与数据可视化</h2><h3 id="Mermaid-图表支持"><a href="#Mermaid-图表支持" class="headerlink" title="Mermaid 图表支持"></a>Mermaid 图表支持</h3><pre><code class="highlight mermaid">graph TD    A[开始] --&gt; B&#123;数据输入&#125;    B --&gt;|有效数据| C[数据处理]    B --&gt;|无效数据| D[错误处理]    C --&gt; E[结果输出]    D --&gt; F[日志记录]    E --&gt; G[完成]    F --&gt; G</code></pre><h3 id="复杂流程图"><a href="#复杂流程图" class="headerlink" title="复杂流程图"></a>复杂流程图</h3><pre><code class="highlight mermaid">flowchart TB    subgraph 前端层        A[React App] --&gt; B[Redux Store]        B --&gt; C[Component Tree]    end    subgraph 后端层        D[Express API] --&gt; E[Database]        E --&gt; F[Cache Layer]    end    C -.-&gt;|HTTP Request| D    F -.-&gt;|Data Response| C</code></pre><h3 id="序列图演示"><a href="#序列图演示" class="headerlink" title="序列图演示"></a>序列图演示</h3><pre><code class="highlight mermaid">sequenceDiagram    participant 用户    participant 浏览器    participant 服务器    participant 数据库    用户-&gt;&gt;浏览器: 输入数据    浏览器-&gt;&gt;服务器: POST /api/data    服务器-&gt;&gt;数据库: INSERT INTO table    数据库--&gt;&gt;服务器: 返回 ID    服务器--&gt;&gt;浏览器: JSON 响应    浏览器--&gt;&gt;用户: 显示结果</code></pre><hr><h2 id="🎬-动画效果演示"><a href="#🎬-动画效果演示" class="headerlink" title="🎬 动画效果演示"></a>🎬 动画效果演示</h2><h3 id="列表动画效果"><a href="#列表动画效果" class="headerlink" title="列表动画效果"></a>列表动画效果</h3><ol><li>第一步 - 淡入上升效果</li><li>第二步 - 淡入下降效果</li><li>第三步 - 淡入左移效果</li><li>第四步 - 淡入右移效果</li><li>第五步 - 淡入效果</li></ol><h3 id="高级动画效果"><a href="#高级动画效果" class="headerlink" title="高级动画效果"></a>高级动画效果</h3><p><strong>高亮效果</strong></p><ul><li>红色高亮</li><li>蓝色高亮</li><li>绿色高亮</li></ul><p><strong>特殊效果</strong></p><ul><li>放大效果</li><li>缩小效果</li><li>删除线效果</li></ul><h3 id="堆叠动画"><a href="#堆叠动画" class="headerlink" title="堆叠动画"></a>堆叠动画</h3><p>通过 fragment 实现内容堆叠显示：</p><ul><li>第一层内容（淡入然后淡出）</li><li>第二层内容（同样淡入淡出）</li><li>第三层内容（最后显示）</li></ul><hr><h2 id="🎯-交互式元素"><a href="#🎯-交互式元素" class="headerlink" title="🎯 交互式元素"></a>🎯 交互式元素</h2><h3 id="点击触发动画"><a href="#点击触发动画" class="headerlink" title="点击触发动画"></a>点击触发动画</h3><p>使用 fragment 索引控制动画顺序：</p><ul><li>第一步（点击显示第一步）</li><li>第二步（点击显示第二步）</li><li>第三步（点击显示第三步）</li></ul><h3 id="自动动画演示"><a href="#自动动画演示" class="headerlink" title="自动动画演示"></a>自动动画演示</h3><p>使用 <code>data-auto-animate</code> 实现元素自动过渡：</p><ul><li>元素会自动过渡到下一个状态</li><li>新增的内容块</li></ul><hr><h2 id="🎵-多媒体支持"><a href="#🎵-多媒体支持" class="headerlink" title="🎵 多媒体支持"></a>🎵 多媒体支持</h2><h3 id="视频嵌入"><a href="#视频嵌入" class="headerlink" title="视频嵌入"></a>视频嵌入</h3><p>支持嵌入视频文件：</p><ul><li>HTML5 video 标签</li><li>多种格式支持</li><li>自定义控制界面</li></ul><h3 id="音频支持"><a href="#音频支持" class="headerlink" title="音频支持"></a>音频支持</h3><p>支持嵌入音频文件：</p><ul><li>HTML5 audio 标签</li><li>自动播放控制</li><li>音量调节</li></ul><h3 id="外部内容嵌入"><a href="#外部内容嵌入" class="headerlink" title="外部内容嵌入"></a>外部内容嵌入</h3><p>支持嵌入外部内容：</p><ul><li>YouTube 视频</li><li>iframe 内容</li><li>外部网页</li></ul><hr><h2 id="🎨-主题与样式"><a href="#🎨-主题与样式" class="headerlink" title="🎨 主题与样式"></a>🎨 主题与样式</h2><h3 id="内置主题展示"><a href="#内置主题展示" class="headerlink" title="内置主题展示"></a>内置主题展示</h3><ul><li><strong>Black</strong> - 经典黑色主题</li><li><strong>White</strong> - 纯净白色主题</li><li><strong>League</strong> - 深灰色主题</li><li><strong>Sky</strong> - 天蓝色主题</li><li><strong>Solarized</strong> - 护眼主题</li></ul><h3 id="自定义样式"><a href="#自定义样式" class="headerlink" title="自定义样式"></a>自定义样式</h3><p>支持 CSS 自定义样式：</p><ul><li>自定义渐变背景</li><li>半透明效果</li><li>动画效果</li></ul><hr><h2 id="📊-数据可视化"><a href="#📊-数据可视化" class="headerlink" title="📊 数据可视化"></a>📊 数据可视化</h2><h3 id="表格样式"><a href="#表格样式" class="headerlink" title="表格样式"></a>表格样式</h3><table><thead><tr><th>功能</th><th>支持程度</th><th>说明</th></tr></thead><tbody><tr><td>Markdown</td><td>✅ 完全支持</td><td>原生 Markdown 语法</td></tr><tr><td>HTML</td><td>✅ 完全支持</td><td>HTML 标签支持</td></tr><tr><td>LaTeX</td><td>✅ 支持</td><td>数学公式渲染</td></tr><tr><td>Mermaid</td><td>✅ 支持</td><td>图表支持</td></tr></tbody></table><h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><p>$$<br>E &#x3D; mc^2<br>$$</p><p>$$<br>\int_{-\infty}^{\infty} e^{-x^2} dx &#x3D; \sqrt{\pi}<br>$$</p><p>$$<br>\frac{d}{dx}\left( \int_{a}^{x} f(t) dt \right) &#x3D; f(x)<br>$$</p><hr><h2 id="🎮-演示控制"><a href="#🎮-演示控制" class="headerlink" title="🎮 演示控制"></a>🎮 演示控制</h2><h3 id="快捷键指南"><a href="#快捷键指南" class="headerlink" title="快捷键指南"></a>快捷键指南</h3><p><strong>基本控制</strong></p><ul><li><code>空格</code> &#x2F; <code>→</code> - 下一张</li><li><code>Shift</code> + <code>空格</code> &#x2F; <code>←</code> - 上一张</li><li><code>F</code> - 全屏模式</li><li><code>ESC</code> - 退出概览</li></ul><p><strong>高级功能</strong></p><ul><li><code>S</code> - 演讲者视图</li><li><code>O</code> - 幻灯片概览</li><li><code>Alt</code> + <code>点击</code> - 缩放</li><li><code>Ctrl</code> + <code>Shift</code> + <code>F</code> - 搜索</li></ul><h3 id="演讲者视图"><a href="#演讲者视图" class="headerlink" title="演讲者视图"></a>演讲者视图</h3><p>按 <code>S</code> 键打开演讲者视图，可以看到：</p><ul><li>当前幻灯片</li><li>下一张幻灯片预览</li><li>演讲者备注</li><li>时间显示</li><li>幻灯片计时</li></ul><hr><h2 id="🚀-高级特效"><a href="#🚀-高级特效" class="headerlink" title="🚀 高级特效"></a>🚀 高级特效</h2><h3 id="3D-转场效果"><a href="#3D-转场效果" class="headerlink" title="3D 转场效果"></a>3D 转场效果</h3><ul><li>3D 凸面转场（使用 3D 效果的转场动画）</li><li>3D 凹面转场（另一种 3D 转场效果）</li><li>缩放转场（背景图片的缩放转场效果）</li></ul><h3 id="背景动画"><a href="#背景动画" class="headerlink" title="背景动画"></a>背景动画</h3><ul><li>背景转场效果</li><li>缩放动画</li><li>淡入淡出效果</li></ul><hr><h2 id="🎯-实用功能"><a href="#🎯-实用功能" class="headerlink" title="🎯 实用功能"></a>🎯 实用功能</h2><h3 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h3><p>按 <code>Ctrl</code> + <code>Shift</code> + <code>F</code> 打开搜索框：</p><ul><li>支持全文搜索</li><li>快速定位内容</li></ul><h3 id="缩放功能"><a href="#缩放功能" class="headerlink" title="缩放功能"></a>缩放功能</h3><p>按住 <code>Alt</code> 键并点击任意位置：</p><ul><li>可以放大查看细节</li><li>再次点击恢复原大小</li></ul><h3 id="概览模式"><a href="#概览模式" class="headerlink" title="概览模式"></a>概览模式</h3><p>按 <code>ESC</code> 键进入概览模式：</p><ul><li>可以看到所有幻灯片的缩略图</li><li>点击任意幻灯片快速跳转</li></ul><hr><h2 id="🎨-创意布局"><a href="#🎨-创意布局" class="headerlink" title="🎨 创意布局"></a>🎨 创意布局</h2><h3 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h3><p>使用 CSS Grid 实现响应式布局：</p><table><thead><tr><th><strong>卡片 1</strong></th><th><strong>卡片 2</strong></th><th><strong>卡片 3</strong></th></tr></thead><tbody><tr><td>渐变背景</td><td>另一种渐变</td><td>蓝色渐变</td></tr><tr><td>卡片布局</td><td>卡片布局</td><td>卡片布局</td></tr></tbody></table><h3 id="弹性布局"><a href="#弹性布局" class="headerlink" title="弹性布局"></a>弹性布局</h3><p>使用 Flexbox 实现自适应布局：</p><table><thead><tr><th><strong>左侧内容</strong></th><th><strong>右侧内容</strong></th></tr></thead><tbody><tr><td>弹性布局</td><td>更宽的区域</td></tr><tr><td>自适应宽度</td><td>自适应宽度</td></tr></tbody></table><hr><h2 id="🎪-特殊效果"><a href="#🎪-特殊效果" class="headerlink" title="🎪 特殊效果"></a>🎪 特殊效果</h2><h3 id="打字机效果"><a href="#打字机效果" class="headerlink" title="打字机效果"></a>打字机效果</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是模拟的打字机效果...</span><br></pre></td></tr></table></figure><h3 id="闪烁效果"><a href="#闪烁效果" class="headerlink" title="闪烁效果"></a>闪烁效果</h3><p>使用 CSS 动画实现闪烁效果：</p><ul><li>闪烁效果</li><li>使用 CSS 动画</li></ul><h3 id="旋转效果"><a href="#旋转效果" class="headerlink" title="旋转效果"></a>旋转效果</h3><p>使用 CSS 动画实现旋转效果：</p><ul><li>旋转效果</li><li>持续旋转</li></ul><hr><h2 id="🎯-交互演示"><a href="#🎯-交互演示" class="headerlink" title="🎯 交互演示"></a>🎯 交互演示</h2><h3 id="点击计数器"><a href="#点击计数器" class="headerlink" title="点击计数器"></a>点击计数器</h3><p>交互式计数器演示：</p><ul><li>点击按钮增加计数</li><li>实时显示点击次数</li></ul><h3 id="颜色选择器"><a href="#颜色选择器" class="headerlink" title="颜色选择器"></a>颜色选择器</h3><p>动态背景颜色切换：</p><ul><li>选择不同的背景颜色</li><li>一键重置为默认颜色</li></ul><hr><h2 id="🎨-CSS-动画展示"><a href="#🎨-CSS-动画展示" class="headerlink" title="🎨 CSS 动画展示"></a>🎨 CSS 动画展示</h2><h3 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h3><ul><li><strong>滑入效果</strong> - 从左侧滑入</li><li><strong>弹跳效果</strong> - 持续弹跳</li><li><strong>脉冲效果</strong> - 缩放脉冲</li></ul><hr><h2 id="🎯-响应式设计"><a href="#🎯-响应式设计" class="headerlink" title="🎯 响应式设计"></a>🎯 响应式设计</h2><h3 id="适配各种设备"><a href="#适配各种设备" class="headerlink" title="适配各种设备"></a>适配各种设备</h3><p><strong>桌面端</strong> 💻</p><ul><li>完整功能</li><li>键盘快捷键</li><li>鼠标交互</li></ul><p><strong>移动端</strong> 📱</p><ul><li>触控优化</li><li>手势支持</li><li>响应式布局</li></ul><p><strong>投影仪</strong> 📟</p><ul><li>高清显示</li><li>大字体支持</li><li>对比度优化</li></ul><p><strong>打印</strong> 🖨️</p><ul><li>PDF 导出</li><li>纸张优化</li><li>无背景打印</li></ul><hr><h2 id="🎉-特效总结"><a href="#🎉-特效总结" class="headerlink" title="🎉 特效总结"></a>🎉 特效总结</h2><h3 id="展示的功能"><a href="#展示的功能" class="headerlink" title="展示的功能"></a>展示的功能</h3><p><strong>视觉效果</strong></p><ul><li>✅ 背景视频&#x2F;图片</li><li>✅ 渐变背景</li><li>✅ 动画效果</li><li>✅ 3D 转场</li></ul><p><strong>交互功能</strong></p><ul><li>✅ 点击动画</li><li>✅ 搜索缩放</li><li>✅ 概览模式</li><li>✅ 演讲者视图</li></ul><p><strong>内容支持</strong></p><ul><li>✅ 代码高亮</li><li>✅ 数学公式</li><li>✅ 图表支持</li><li>✅ 多媒体</li></ul><p><strong>高级特性</strong></p><ul><li>✅ 自定义动画</li><li>✅ 响应式设计</li><li>✅ 插件扩展</li><li>✅ 主题定制</li></ul><hr><h2 id="🎊-感谢观看！"><a href="#🎊-感谢观看！" class="headerlink" title="🎊 感谢观看！"></a>🎊 感谢观看！</h2><h3 id="Reveal-js-高级特效演示"><a href="#Reveal-js-高级特效演示" class="headerlink" title="Reveal.js 高级特效演示"></a>Reveal.js 高级特效演示</h3><ul><li>体验网页演示的无限可能</li><li>使用 Markdown 创建专业演示文稿</li><li>纯文本编写，丰富效果呈现</li></ul><p>🚀 现在开始使用</p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <summary type="html">&lt;!-- 
  纯 Markdown 演示文稿
  使用 Reveal.js 的高级功能，但内容完全用 Markdown 编写
  特效通过 Reveal.js 的注释语法实现
--&gt;

&lt;h2 id=&quot;🚀-Reveal-js-高级特效演示&quot;&gt;&lt;a href=&quot;#🚀-Reveal-js-高级特效演示&quot; class=&quot;headerlink&quot; title=&quot;🚀 Reveal.js 高级特效演示&quot;&gt;&lt;/a&gt;🚀 Reveal.js 高级特效演示&lt;/h2&gt;&lt;h3 id=&quot;极致的视觉体验&quot;&gt;&lt;a href=&quot;#极致的视觉体验&quot; class=&quot;headerlink&quot; title=&quot;极致的视觉体验&quot;&gt;&lt;/a&gt;极致的视觉体验&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;背景视频 · 动态效果 · 交互体验&lt;/li&gt;
&lt;li&gt;使用纯 Markdown 语法编写&lt;/li&gt;
&lt;li&gt;所有特效通过 Reveal.js 注释实现&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;🎨-背景特效展示&quot;&gt;&lt;a href=&quot;#🎨-背景特效展示&quot; class=&quot;headerlink&quot; title=&quot;🎨 背景特效展示&quot;&gt;&lt;/a&gt;🎨 背景特效展示&lt;/h2&gt;&lt;h3 id=&quot;渐变背景效果&quot;&gt;&lt;a href=&quot;#渐变背景效果&quot; class=&quot;headerlink&quot; title=&quot;渐变背景效果&quot;&gt;&lt;/a&gt;渐变背景效果&lt;/h3&gt;</summary>
    
    
    
    
    <category term="slides" scheme="https://cuipengfei.is-a.dev/tags/slides/"/>
    
    <category term="revealjs" scheme="https://cuipengfei.is-a.dev/tags/revealjs/"/>
    
    <category term="effects" scheme="https://cuipengfei.is-a.dev/tags/effects/"/>
    
    <category term="demo" scheme="https://cuipengfei.is-a.dev/tags/demo/"/>
    
  </entry>
  
  <entry>
    <title>Feedly硬广-回归RSS</title>
    <link href="https://cuipengfei.is-a.dev/blog/2025/01/05/go-back-to-rss/"/>
    <id>https://cuipengfei.is-a.dev/blog/2025/01/05/go-back-to-rss/</id>
    <published>2025-01-04T16:00:00.000Z</published>
    <updated>2025-01-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="highlight mermaid">flowchart TD  subgraph 被动信息接收    style 被动信息接收 fill:#f9d6c1,stroke:#000,stroke-width:2px;    A[被动接受信息] --&gt; B[算法过度控制]    B --&gt; C[信息茧房]    C --&gt; D[注意力消耗]  end  subgraph 信息主动消费    style 信息主动消费 fill:#c1e1f9,stroke:#000,stroke-width:2px;    E[回归RSS] --&gt; F[掌握信息主动权]    F --&gt; G[自主订阅]    G --&gt; H[控制信息摄入质量]    H --&gt; I[主动选择信息来源]    I --&gt; J[避免无用信息轰炸]    J --&gt; K[减少干扰]    K --&gt; L[专注高质量内容]    L --&gt; M[享受纯粹阅读乐趣]    M --&gt; N[高质量阅读体验]    N --&gt; O[注意力回归有价值内容]    O --&gt; F  end  D --&gt; E</code></pre><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code class=&quot;highlight mermaid&quot;&gt;flowchart TD
  subgraph 被动信息接收
    style 被动信息接收 fill:#f9d6c1,stroke:#000,stroke-width:2px;
    A[被动接受信息</summary>
      
    
    
    
    
    <category term="RSS" scheme="https://cuipengfei.is-a.dev/tags/RSS/"/>
    
    <category term="Feedly" scheme="https://cuipengfei.is-a.dev/tags/Feedly/"/>
    
  </entry>
  
  <entry>
    <title>解决 LibreOffice 导出Excel 到 PDF 超链接丢失问题</title>
    <link href="https://cuipengfei.is-a.dev/blog/2024/07/28/libre-jod-single-page-excel/"/>
    <id>https://cuipengfei.is-a.dev/blog/2024/07/28/libre-jod-single-page-excel/</id>
    <published>2024-07-27T16:00:00.000Z</published>
    <updated>2024-07-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在使用LibreOffice的Calc组件将电子表格导出为PDF文件时，如果启用了“Whole sheet export”（整页导出）选项，导出的PDF文件中的超链接将不会保留原始的URL，而是显示为本地文件路径。</p><p>这个问题在</p><ol><li><a href="https://ask.libreoffice.org/t/web-hyperlinks-not-preserved-after-export-to-pdf/96762">LibreOffice 官方论坛上的提问</a></li><li><a href="https://stackoverflow.com/questions/78799273/implementing-a-custom-whole-sheet-export-via-uno-api-to-preserve-hyperlinks-in">Stack Overflow 上的提问</a></li></ol><p>上都有讨论。</p><h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>为了解决这个问题，我们考虑使用LibreOffice的UNO API来实现一个自定义的解决方案。这个方案的核心思想是：</p><ul><li>遍历Calc文档中的每个工作表。</li><li>计算每个工作表内容适应一页所需的总宽度和高度。</li><li>根据这些尺寸为每个工作表生成自定义的纸张大小。</li><li>使用自定义纸张大小导出PDF，同时确保不使用“Whole sheet export”选项，以保留超链接。</li></ul><h1 id="ExcelSinglePageFilter解决方案"><a href="#ExcelSinglePageFilter解决方案" class="headerlink" title="ExcelSinglePageFilter解决方案"></a>ExcelSinglePageFilter解决方案</h1><p>针对上述问题，<code>ExcelSinglePageFilter</code>Java类实现了自定义的PDF导出过滤器。</p><p>以下是该过滤器如何解决问题的详细解析。</p><h1 id="过滤器初始化与文档检查"><a href="#过滤器初始化与文档检查" class="headerlink" title="过滤器初始化与文档检查"></a>过滤器初始化与文档检查</h1><p><code>ExcelSinglePageFilter</code>首先检查传入的文档是否为Excel文档。如果不是，它将直接调用链式调用<code>chain.doFilter</code>继续处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">XSpreadsheetDocument</span> <span class="variable">xSpreadsheetDocument</span> <span class="operator">=</span> queryInterface(XSpreadsheetDocument.class, document);</span><br><span class="line"><span class="keyword">if</span> (xSpreadsheetDocument == <span class="literal">null</span>) &#123;</span><br><span class="line">    chain.doFilter(context, document);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="工作表遍历与处理"><a href="#工作表遍历与处理" class="headerlink" title="工作表遍历与处理"></a>工作表遍历与处理</h1><p>接着，该过滤器遍历所有工作表，并为每个工作表异步执行调整操作。对于隐藏的工作表，它将跳过处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] sheetNames = xSpreadsheetDocument.getSheets().getElementNames();</span><br><span class="line">CompletableFuture[] futures = Arrays.stream(sheetNames).map(sheetName -&gt; CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ... 省略部分代码 ...</span></span><br><span class="line">    adjustOneSheet(sheetName, sheet, xPageStyles);</span><br><span class="line">&#125;)).toList().toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><h1 id="处理每个工作表"><a href="#处理每个工作表" class="headerlink" title="处理每个工作表"></a>处理每个工作表</h1><p>对于每个工作表，代码首先检查工作表是否可见，然后计算工作表的总宽度和高度，包括单元格和图形对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustOneSheet</span><span class="params">(String sheetName, XSpreadsheet sheet, XNameAccess xPageStyles)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算工作表的总宽度和高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">totalWidth</span> <span class="operator">=</span> getTotalWidth(getxColumnRowRange(sheet), getLastColumn(sheet));</span><br><span class="line">    <span class="type">int</span> <span class="variable">totalHeight</span> <span class="operator">=</span> getTotalHeight(getxColumnRowRange(sheet), getLastRow(sheet));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包括图形对象的尺寸</span></span><br><span class="line">    <span class="type">Size</span> <span class="variable">graphicalSize</span> <span class="operator">=</span> getGraphicalObjectsSize(sheet);</span><br><span class="line">    totalWidth = Math.max(totalWidth, graphicalSize.Width);</span><br><span class="line">    totalHeight = Math.max(totalHeight, graphicalSize.Height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置页面样式属性</span></span><br><span class="line">    <span class="type">XPropertySet</span> <span class="variable">xPageStyleProps</span> <span class="operator">=</span> getPageStyleProps(sheet, xPageStyles);</span><br><span class="line">    xPageStyleProps.setPropertyValue(<span class="string">&quot;Size&quot;</span>, <span class="keyword">new</span> <span class="title class_">Size</span>(totalWidth, totalHeight));</span><br><span class="line">    setMarginToZero(xPageStyleProps);</span><br><span class="line">    xPageStyleProps.setPropertyValue(<span class="string">&quot;ScaleToPages&quot;</span>, (<span class="type">short</span>) <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计算图形对象尺寸"><a href="#计算图形对象尺寸" class="headerlink" title="计算图形对象尺寸"></a>计算图形对象尺寸</h1><p>getGraphicalObjectsSize方法用于计算工作表中所有图形对象所占的最大宽度和高度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Size <span class="title function_">getGraphicalObjectsSize</span><span class="params">(XSpreadsheet sheet)</span> &#123;</span><br><span class="line">    <span class="type">XDrawPageSupplier</span> <span class="variable">drawPageSupplier</span> <span class="operator">=</span> queryInterface(XDrawPageSupplier.class, sheet);</span><br><span class="line">    <span class="type">XDrawPage</span> <span class="variable">drawPage</span> <span class="operator">=</span> drawPageSupplier.getDrawPage();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> drawPage.getCount();</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxWidth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxHeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="type">XShape</span> <span class="variable">shape</span> <span class="operator">=</span> queryInterface(XShape.class, drawPage.getByIndex(i));</span><br><span class="line">        <span class="type">Point</span> <span class="variable">position</span> <span class="operator">=</span> shape.getPosition();</span><br><span class="line">        <span class="type">Size</span> <span class="variable">size</span> <span class="operator">=</span> shape.getSize();</span><br><span class="line">        maxWidth = Math.max(maxWidth, position.X + size.Width);</span><br><span class="line">        maxHeight = Math.max(maxHeight, position.Y + size.Height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Size</span>(maxWidth, maxHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计算总宽度和总高度"><a href="#计算总宽度和总高度" class="headerlink" title="计算总宽度和总高度"></a>计算总宽度和总高度</h1><p>getTotalWidth和getTotalHeight方法分别用于计算工作表的总宽度和总高度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getTotalWidth</span><span class="params">(XColumnRowRange columnRowRange, <span class="type">int</span> endColumn)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">totalWidth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= endColumn; j++) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">column</span> <span class="operator">=</span> columnRowRange.getColumns().getByIndex(j);</span><br><span class="line">        <span class="type">XPropertySet</span> <span class="variable">columnProps</span> <span class="operator">=</span> queryInterface(XPropertySet.class, column);</span><br><span class="line">        totalWidth += (<span class="type">int</span>) columnProps.getPropertyValue(<span class="string">&quot;Width&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> totalWidth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getTotalHeight</span><span class="params">(XColumnRowRange columnRowRange, <span class="type">int</span> endRow)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">totalHeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= endRow; i++) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">row</span> <span class="operator">=</span> columnRowRange.getRows().getByIndex(i);</span><br><span class="line">        <span class="type">XPropertySet</span> <span class="variable">rowProps</span> <span class="operator">=</span> queryInterface(XPropertySet.class, row);</span><br><span class="line">        totalHeight += (<span class="type">int</span>) rowProps.getPropertyValue(<span class="string">&quot;Height&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> totalHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完成导出"><a href="#完成导出" class="headerlink" title="完成导出"></a>完成导出</h1><p>最后，等待所有异步任务完成后，调用链式调用chain.doFilter继续执行标准的PDF导出流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.allOf(futures).join();</span><br><span class="line">chain.doFilter(context, document);</span><br></pre></td></tr></table></figure><h1 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h1><p>上述解决方案的原始代码可以在GitHub上找到，链接为：</p><p><a href="https://github.com/cuipengfei/jodconverter-samples/blob/main/samples/spring-boot-rest/src/main/java/org/jodconverter/sample/rest/ExcelSinglePageFilter.java">https://github.com/cuipengfei/jodconverter-samples/blob/main/samples/spring-boot-rest/src/main/java/org/jodconverter/sample/rest/ExcelSinglePageFilter.java</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ExcelSinglePageFilter通过自定义的PDF导出逻辑，成功避免了使用“Whole sheet export”选项，从而解决了超链接在PDF中丢失的问题。这种方法不仅保留了超链接的完整性，而且还提供了一种灵活的方式来调整每个工作表的显示尺寸，确保它们在PDF中以单页的形式呈现。</p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;在使用LibreOffice的Calc组件将电子表格导出为PDF文件时，如果启用了“Whole sheet export”（整页导出）选项，导出的PDF文件中的超链接将不会保留原始的URL，而是显示为本地文件路径。&lt;/p&gt;
&lt;p&gt;这个问题在&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://ask.libreoffice.org/t/web-hyperlinks-not-preserved-after-export-to-pdf/96762&quot;&gt;LibreOffice 官方论坛上的提问&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/78799273/implementing-a-custom-whole-sheet-export-via-uno-api-to-preserve-hyperlinks-in&quot;&gt;Stack Overflow 上的提问&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上都有讨论。&lt;/p&gt;
&lt;h1 id=&quot;解决思路&quot;&gt;&lt;a href=&quot;#解决思路&quot; class=&quot;headerlink&quot; title=&quot;解决思路&quot;&gt;&lt;/a&gt;解决思路&lt;/h1&gt;</summary>
    
    
    
    
    <category term="LibreOffice" scheme="https://cuipengfei.is-a.dev/tags/LibreOffice/"/>
    
    <category term="PDF" scheme="https://cuipengfei.is-a.dev/tags/PDF/"/>
    
    <category term="JODConverter" scheme="https://cuipengfei.is-a.dev/tags/JODConverter/"/>
    
  </entry>
  
  <entry>
    <title>基于LibreOffice的MS Office文档格式转换</title>
    <link href="https://cuipengfei.is-a.dev/blog/2024/02/04/libre-jod/"/>
    <id>https://cuipengfei.is-a.dev/blog/2024/02/04/libre-jod/</id>
    <published>2024-02-04T07:21:24.000Z</published>
    <updated>2024-02-04T07:21:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="将Microsoft-Office文件转换为其他格式的场景"><a href="#将Microsoft-Office文件转换为其他格式的场景" class="headerlink" title="将Microsoft Office文件转换为其他格式的场景"></a>将Microsoft Office文件转换为其他格式的场景</h1><p>在一些情况下，可能需要将Microsoft Office文件转换为其他格式：</p><ul><li>兼容性问题：与不同的办公软件或操作系统进行交互，可能需要将MS Office文件转换为更通用的格式。例如，如果要与没有安装Microsoft Office的人分享文档，将其转换为PDF格式可能更合适。</li><li>归档和存档：将Office文件转换为更稳定、可持久保存的格式可以确保文件的长期保存和归档。某些文件格式（如PDF&#x2F;A）专门用于长期存档目的，以确保文件内容的完整性和可访问性。</li><li>数据提取：你可能只对文档中的特定数据或内容感兴趣。通过将Office文件转换为其他格式（如纯文本或CSV），可以更容易地提取所需的数据，并在其他应用程序中进行分析或处理。</li><li>网页发布：如果要将MS Office文件发布到网页上，可能需要将其转换为HTML或其他网页友好的格式，以确保文件在网页上正确显示。</li></ul><h1 id="LibreOffice-微软Office的开源替代"><a href="#LibreOffice-微软Office的开源替代" class="headerlink" title="LibreOffice - 微软Office的开源替代"></a>LibreOffice - 微软Office的开源替代</h1><p>LibreOffice是一个免费、开源的办公套件，在某种程度上可以被视为微软Office的开源替代品。</p><ul><li>LibreOffice Writer：对应于Microsoft Word。</li><li>LibreOffice Calc：对应于Microsoft Excel。</li><li>LibreOffice Impress：对应于Microsoft PowerPoint。</li></ul><p><img data-src="/images/libre/image.png" alt="alt text"></p><h1 id="LibreOffice支持的转换格式"><a href="#LibreOffice支持的转换格式" class="headerlink" title="LibreOffice支持的转换格式"></a>LibreOffice支持的转换格式</h1><p>LibreOffice支持广泛的转换格式。具体请参考如下的表格：</p><table aligh="center">    <tr><th align="left">Format Family</th><th align="left">From (any of)</th><th align="left">To (any of)</th></tr>    <tr valign="top">        <th align="left">Text</th>        <td>            <samp><b>*.odt</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Text<br>            <samp><b>*.ott</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Text Template<br>            <samp><b>*.sxw</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenOffice.org 1.0 Text<br>            <samp><b>*.rtf</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Rich Text Format<br>            <samp><b>*.doc</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Microsoft Word<br>            <samp><b>*.docx</b>&nbsp;&nbsp;&nbsp;</samp>Microsoft Word XML<br>            <samp><b>*.wpd</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>WordPerfect<br>            <samp><b>*.txt</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Plain Text<br>            <samp><b>*.html</b>&nbsp;&nbsp;&nbsp;</samp>HTML        </td>        <td>            <samp><b>*.pdf</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Portable Document Format<br>            <samp><b>*.odt</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Text<br>            <samp><b>*.ott</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Text Template<br>            <samp><b>*.sxw</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenOffice.org 1.0 Text<br>            <samp><b>*.rtf</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Rich Text Format<br>            <samp><b>*.doc</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Microsoft Word<br>            <samp><b>*.docx</b>&nbsp;&nbsp;&nbsp;</samp>Microsoft Word XML<br>            <samp><b>*.txt</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Plain Text<br>            <samp><b>*.html</b>&nbsp;&nbsp;&nbsp;</samp>HTML<br>            <samp><b>*.wiki</b>&nbsp;&nbsp;&nbsp;</samp>MediaWiki wikitext        </td>    </tr>    <tr valign="top">        <th align="left">Spreadsheet</th>        <td>            <samp><b>*.ods</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Spreadsheet<br>            <samp><b>*.ots</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Spreadsheet Template<br>            <samp><b>*.sxc</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenOffice.org 1.0 Spreadsheet<br>            <samp><b>*.xls</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Microsoft Excel<br>            <samp><b>*.xlsx</b>&nbsp;&nbsp;&nbsp;</samp>Microsoft Excel XML<br>            <samp><b>*.csv</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Comma-Separated Values<br>            <samp><b>*.tsv</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Tab-Separated Values        </td>        <td>            <samp><b>*.pdf</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Portable Document Format<br>            <samp><b>*.ods</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Spreadsheet<br>            <samp><b>*.ots</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Spreadsheet Template<br>            <samp><b>*.sxc</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenOffice.org 1.0 Spreadsheet<br>            <samp><b>*.xls</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Microsoft Excel<br>            <samp><b>*.xlsx</b>&nbsp;&nbsp;&nbsp;</samp>Microsoft Excel XML<br>            <samp><b>*.csv</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Comma-Separated Values<br>            <samp><b>*.tsv</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Tab-Separated Values<br>            <samp><b>*.html</b>&nbsp;&nbsp;&nbsp;</samp>HTML        </td>    </tr>    <tr valign="top">        <th align="left">Presentation</th>        <td>            <samp><b>*.odp</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Presentation<br>            <samp><b>*.otp</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Presentation Template<br>            <samp><b>*.sxi</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenOffice.org 1.0 Presentation<br>            <samp><b>*.ppt</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Microsoft PowerPoint<br>            <samp><b>*.pptx</b>&nbsp;&nbsp;&nbsp;</samp>Microsoft PowerPoint XML        </td>        <td>            <samp><b>*.pdf</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Portable Document Format<br>            <samp><b>*.swf</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Macromedia Flash<br>            <samp><b>*.odp</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Presentation<br>            <samp><b>*.otp</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Presentation Template<br>            <samp><b>*.sxi</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenOffice.org 1.0 Presentation<br>            <samp><b>*.ppt</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Microsoft PowerPoint<br>            <samp><b>*.pptx</b>&nbsp;&nbsp;&nbsp;</samp>Microsoft PowerPoint XML<br>            <samp><b>*.html</b>&nbsp;&nbsp;&nbsp;</samp>HTML        </td>    </tr>    <tr valign="top">        <th align="left">Drawing</th>        <td>            <samp><b>*.odg</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Drawing<br>            <samp><b>*.otg</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>OpenDocument Drawing Template        </td>        <td>            <samp><b>*.svg</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Scalable Vector Graphics<br>            <samp><b>*.swf</b>&nbsp;&nbsp;&nbsp;&nbsp;</samp>Macromedia Flash        </td>    </tr></table><h1 id="LibreOffice的headless模式"><a href="#LibreOffice的headless模式" class="headerlink" title="LibreOffice的headless模式"></a>LibreOffice的headless模式</h1><p>与常见的Chromium的headless模式类似，LibreOffice也提供headless模式。</p><ul><li>没有图形用户界面（GUI）：无论是LibreOffice的headless模式还是Chromium的headless模式，都在没有GUI的情况下运行，不会显示可见的窗口或用户界面。</li><li>命令行接口（CLI）控制：通过命令行接口进行控制和操作。可以在命令行中使用特定的命令和参数来执行相应的任务和操作。</li><li>自动化和批处理：LibreOffice的headless模式和Chromium的headless模式都适用于自动化和批处理任务。</li><li>服务器环境中的应用：适用于在服务器环境中使用。</li></ul><p>这就给在<strong>服务端自动化进行文档类型转换</strong>提供了很大的便利。</p><h1 id="资源池管理与容器化-JodConverter"><a href="#资源池管理与容器化-JodConverter" class="headerlink" title="资源池管理与容器化 - JodConverter"></a>资源池管理与容器化 - JodConverter</h1><p>JodConverter是一个用于将Office文档转换为其他格式的Java库。它支持与LibreOffice（也可以是OpenOffice）进行集成。</p><p>我们可以选择自己直接与headless的LibreOffice直接通信来完成文档格式转换，不过由JodConverter来代劳的好处是很明显的：</p><ul><li>资源池化</li><li>容器化</li></ul><p>JODConverter 的进程管理器（Process Manager）在资源池内维护 LibreOffice 进程。<br>将 LibreOffice 进程保持在资源池内，可以避免每次进行文档转换时都需要启动和终止 LibreOffice 进程的开销。<br>它可以检测到进程的健康状态，例如进程异常退出或崩溃，然后采取相应的措施，如重新启动进程。</p><p>JODConverter 还提供一个基于Debian的基础docker image，其中已经包含了LibreOffice。</p><p>我们的调用JODConverter的Java应用只需要基于该镜像build出来就好。</p><p><img data-src="/images/libre/libreoffice_logos_printed_on_dockers.png" alt="alt text"></p><h1 id="MS-Office存量文件的兼容性-字体的开源替代"><a href="#MS-Office存量文件的兼容性-字体的开源替代" class="headerlink" title="MS Office存量文件的兼容性 - 字体的开源替代"></a>MS Office存量文件的兼容性 - 字体的开源替代</h1><p><img data-src="/images/libre/compare.png" alt="alt text"></p><p>上面这张图左侧是原版的PPT，右侧是用JOD + LibreOffice转换出来的PDF。</p><p>可以看到右侧转换出PDF，文字之间出现了互相交叉重叠的现象，整个样式都乱掉了。<br>这其实并不是JOD或者是LibreOffice的bug。</p><p>而是由于左侧的PPT当中使用了一些微软的商用字体。<br>而LibreOffice运行在docker里面，它是拿不到这些微软的商用字体的，我们也不应该把有商用版权的字体置入docker image中。</p><p>这时我们可以使用一些<strong>开源的字体来代替微软的商用字体</strong>。</p><p>下图来自于LibreOffice的一篇博客： <a href="https://blog.documentfoundation.org/blog/2020/09/08/libreoffice-tt-replacing-microsoft-fonts/">https://blog.documentfoundation.org/blog/2020/09/08/libreoffice-tt-replacing-microsoft-fonts/</a></p><p><img data-src="https://blog.documentfoundation.org/wp-content/uploads/2020/09/Options-LibreOffice-Fonts.png" alt="font"></p><p>LibreOffice提供了一个Font Replacement Table的功能。</p><p>左侧Font列是商用字体，右侧Replace with列是开源字体。<br>例如：当LibreOffice见到一个ppt文件内的某段文字使用了Arial字体时，就会自动用Arimo字体去渲染这段文字。<br>这样，既能够尽量保持视觉效果的一致性，也避免使用商用字体。</p><p>下图是使用了开源字体替代后的转换效果，右侧的PDF和左侧的PPT视觉差异已经不太大了。<br><img data-src="/images/libre/compare2.png" alt="alt text"></p><p>作为一个LibreOffice<strong>桌面应用的使用者</strong>可以按照上述说明来做配置，从而最大程度的去兼容微软的商用字体。<br>而当我们使用headless模式时该如何做出等效的配置呢？</p><h1 id="LibreOffice-User-Profile"><a href="#LibreOffice-User-Profile" class="headerlink" title="LibreOffice - User Profile"></a>LibreOffice - User Profile</h1><p>上面提到的配置项，会被保存在LibreOffice User Profile内，在不同的OS内保存的路径为：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Windows</span><br><span class="line">%APPDATA%\libreoffice\<span class="number">4</span>\<span class="keyword">user</span> <span class="title">(LibreOffice</span> <span class="number">4</span> <span class="keyword">and</span> above)</span><br><span class="line"></span><br><span class="line">GNU/Linux</span><br><span class="line">/home/<span class="tag">&lt;user name&gt;</span>/.config/libreoffice/<span class="number">4</span>/<span class="keyword">user</span> <span class="title">(LibreOffice</span> <span class="number">4</span> <span class="keyword">and</span> above)</span><br></pre></td></tr></table></figure><p>我们可以把开源字体文件以及保存下来的配置文件内置入docker image内。<br>并通过JOD指定启动LibreOffice时的参数，让headless模式下运行的LibreOffice加载到正确的配置文件，进而也能达成上图所示一样转换的效果。</p><p><a href="https://github.com/cuipengfei/docker-image-jodconverter-examples/blob/909d9c62859b9c55b49afca0c7df7e04546042cc/Dockerfile#L38-L44">如下Dockerfile示例</a>中把开源字体和配置文件copy进Docker image</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># support more fonts</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> cjk-fonts/* /usr/share/fonts/cjk/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> condensed-fonts/* /usr/share/fonts/condensed/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ms-sub-fonts/* /usr/share/fonts/ms-sub-fonts/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add user profile config files</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./profile/LibreOffice/4/user /tmp/jodconverter/user</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/cuipengfei/jodconverter-samples/blob/98c2a6d73d3d9dfc88b0c7122b065dcd39e9ae61/samples/spring-boot-rest/src/main/resources/application.yml#L22-L26">如下示例</a>中指定template-profile-dir</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jodconverter:</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">port-numbers:</span> <span class="number">2002</span><span class="string">,2003</span></span><br><span class="line">    <span class="attr">template-profile-dir:</span> <span class="string">/tmp/jodconverter</span></span><br></pre></td></tr></table></figure><p>这样可以确保JODConverter在启动LibreOffice进程的时候可以明确地告诉LibreOffice去加载哪一份配置文件。</p><h1 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h1><p><a href="https://github.com/jodconverter/jodconverter/wiki/Getting-Started">JODConverter Wiki</a></p><p><a href="https://github.com/jodconverter/docker-image-jodconverter-runtime/pkgs/container/jodconverter-runtime">jodconverter-runtime docker基础镜像</a></p><p><a href="https://help.libreoffice.org/latest/en-US/text/shared/guide/pdf_params.html">LibreOffice PDF转换支持的命令行参数</a></p><p><a href="https://ask.libreoffice.org/t/libreoffice-xls-to-pdf-conversion-breaks-single-page-content-into-multiple-pages-on-ubuntu-18-04/49104/2">宽度过大的Excel转PDF的问题</a></p><p><a href="https://blog.documentfoundation.org/blog/2020/09/08/libreoffice-tt-replacing-microsoft-fonts/">微软字体兼容性问题</a></p><p><a href="https://wiki.documentfoundation.org/UserProfile#Default_locations">LibreOffice User Profile默认路径</a></p><p><a href="https://github.com/cuipengfei/docker-image-jodconverter-examples/blob/909d9c62859b9c55b49afca0c7df7e04546042cc/Dockerfile#L38-L44">把自定义的字体与User Profile加入Docker Image</a></p><p><a href="https://github.com/cuipengfei/jodconverter-samples/blob/98c2a6d73d3d9dfc88b0c7122b065dcd39e9ae61/samples/spring-boot-rest/src/main/resources/application.yml#L22-L26">给JODConverter指定User Profile路径</a></p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;将Microsoft-Office文件转换为其他格式的场景&quot;&gt;&lt;a href=&quot;#将Microsoft-Office文件转换为其他格式的场景&quot; class=&quot;headerlink&quot; title=&quot;将Microsoft Office文件转换为其他格式的场景&quot;&gt;&lt;/a&gt;将Microsoft Office文件转换为其他格式的场景&lt;/h1&gt;&lt;p&gt;在一些情况下，可能需要将Microsoft Office文件转换为其他格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;兼容性问题：与不同的办公软件或操作系统进行交互，可能需要将MS Office文件转换为更通用的格式。例如，如果要与没有安装Microsoft Office的人分享文档，将其转换为PDF格式可能更合适。&lt;/li&gt;
&lt;li&gt;归档和存档：将Office文件转换为更稳定、可持久保存的格式可以确保文件的长期保存和归档。某些文件格式（如PDF&amp;#x2F;A）专门用于长期存档目的，以确保文件内容的完整性和可访问性。&lt;/li&gt;
&lt;li&gt;数据提取：你可能只对文档中的特定数据或内容感兴趣。通过将Office文件转换为其他格式（如纯文本或CSV），可以更容易地提取所需的数据，并在其他应用程序中进行分析或处理。&lt;/li&gt;
&lt;li&gt;网页发布：如果要将MS Office文件发布到网页上，可能需要将其转换为HTML或其他网页友好的格式，以确保文件在网页上正确显示。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;LibreOffice-微软Office的开源替代&quot;&gt;&lt;a href=&quot;#LibreOffice-微软Office的开源替代&quot; class=&quot;headerlink&quot; title=&quot;LibreOffice - 微软Office的开源替代&quot;&gt;&lt;/a&gt;LibreOffice - 微软Office的开源替代&lt;/h1&gt;&lt;p&gt;LibreOffice是一个免费、开源的办公套件，在某种程度上可以被视为微软Office的开源替代品。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LibreOffice Writer：对应于Microsoft Word。&lt;/li&gt;
&lt;li&gt;LibreOffice Calc：对应于Microsoft Excel。&lt;/li&gt;
&lt;li&gt;LibreOffice Impress：对应于Microsoft PowerPoint。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="LibreOffice" scheme="https://cuipengfei.is-a.dev/tags/LibreOffice/"/>
    
    <category term="JOD" scheme="https://cuipengfei.is-a.dev/tags/JOD/"/>
    
  </entry>
  
  <entry>
    <title>Spring Integration JDBC分布式锁 - Transactions与Threads</title>
    <link href="https://cuipengfei.is-a.dev/blog/2023/12/25/spring-integration-jdbc-distributed-lock-with-transaction-and-threads/"/>
    <id>https://cuipengfei.is-a.dev/blog/2023/12/25/spring-integration-jdbc-distributed-lock-with-transaction-and-threads/</id>
    <published>2023-12-25T03:16:17.000Z</published>
    <updated>2023-12-25T03:16:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一个问题：在多个线程中同时运行隔离级别为serializable的事务而导致的无法重试获取锁的问题"><a href="#第一个问题：在多个线程中同时运行隔离级别为serializable的事务而导致的无法重试获取锁的问题" class="headerlink" title="第一个问题：在多个线程中同时运行隔离级别为serializable的事务而导致的无法重试获取锁的问题"></a>第一个问题：在多个线程中同时运行隔离级别为serializable的事务而导致的无法重试获取锁的问题</h1><p>Spring Integration JDBC分布式锁的实现会需要使用一个serializable级别的事务来<strong>获取锁</strong>。</p><p>如果多个线程同时尝试获取锁，这些事务之间可能会出现顺序问题。</p><p>具体而言，可能会遇到以下错误：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.postgresql.util.PSQLException: ERROR: could <span class="keyword">not</span> serialize access due <span class="built_in">to</span> <span class="built_in">read</span>/<span class="built_in">write</span> dependencies <span class="keyword">among</span> transactions</span><br></pre></td></tr></table></figure><p>发生这样的问题其实也不可怕，因为JDBC锁会进行重试。</p><p>然而，当使用JPA Transaction Manager时，由于某些异常类型的原因，JDBC锁无法在发生这种错误的情况下进行重试。</p><p>可以在以下GitHub Issue中查看详细信息：<br><a href="https://github.com/spring-projects/spring-integration/issues/3733">https://github.com/spring-projects/spring-integration/issues/3733</a></p><p>可以使用以下代码重现此问题：<br><a href="https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/service/Problem1Service.java">https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/service/Problem1Service.java</a></p><h1 id="使用Data-Source-Transaction-Manager来workaround第一个问题"><a href="#使用Data-Source-Transaction-Manager来workaround第一个问题" class="headerlink" title="使用Data Source Transaction Manager来workaround第一个问题"></a>使用Data Source Transaction Manager来workaround第一个问题</h1><p>可以明确指定让JDBC锁不使用JPA Transaction Manager，而是使用Data Source Transaction Manager来绕过此问题。</p><p>具体代码请参考：<br><a href="https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/configs/CustomJDBCLockConfigs.java">https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/configs/CustomJDBCLockConfigs.java</a></p><p>可以执行该代码以观察workaround的效果：<br><a href="https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/service/Problem1FixService.java">https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/service/Problem1FixService.java</a></p><h1 id="第二个问题：在同一个线程中先使用JpaTransactionManager启动一个事务，然后尝试用DataSourceTransactionManager获取JDBC锁所导致的事务隔离级别变化的问题"><a href="#第二个问题：在同一个线程中先使用JpaTransactionManager启动一个事务，然后尝试用DataSourceTransactionManager获取JDBC锁所导致的事务隔离级别变化的问题" class="headerlink" title="第二个问题：在同一个线程中先使用JpaTransactionManager启动一个事务，然后尝试用DataSourceTransactionManager获取JDBC锁所导致的事务隔离级别变化的问题"></a>第二个问题：在同一个线程中先使用JpaTransactionManager启动一个事务，然后尝试用DataSourceTransactionManager获取JDBC锁所导致的事务隔离级别变化的问题</h1><p>该问题的显著特征是：如果在一个方法上标注了@Transactional，然后在该方法内部先执行了一些JPA的SQL操作，然后再尝试获取JDBC分布式锁，就会出现无法更改事务隔离级别的问题。</p><p>问题的关键在于并行流（parallel stream）并不总是仅利用其自己线程池中的线程，它也会利用当前线程。<br>而恰好落在当前线程上的那一次尝试获取JDBC分布式锁的操作就会出现无法更改事务隔离级别的问题。</p><p>这是因为我们用来解决第一个问题而引入的DataSourceTransactionManager的文档中提及它具有如下行为：</p><blockquote><p>Note: The DataSource that this transaction manager operates on needs to return independent Connections. The Connections typically come from a connection pool but the DataSource must not return specifically scoped or constrained Connections. This transaction manager will associate Connections with thread-bound transactions, according to the specified propagation behavior. It assumes that a separate, independent Connection can be obtained even during an ongoing transaction.</p></blockquote><p>可以通过以下代码观察parallel stream的行为：<br><a href="https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/TestParallelStreamThreads.java">https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/TestParallelStreamThreads.java</a></p><p>可以使用以下代码重现该问题：<br><a href="https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/service/Problem2Service.java">https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/service/Problem2Service.java</a></p><h1 id="第二个问题的不完善解决方法：强制parallel-stream不使用当前线程"><a href="#第二个问题的不完善解决方法：强制parallel-stream不使用当前线程" class="headerlink" title="第二个问题的不完善解决方法：强制parallel stream不使用当前线程"></a>第二个问题的不完善解决方法：强制parallel stream不使用当前线程</h1><p>在解决该问题的过程中，我尝试了一种不太明智的方法，在这里也记录一下。</p><p>我最初的想法是，既然parallel stream会利用当前线程，从而导致落在当前线程上的那一次获取锁的操作失败，那么我干脆强制它不要使用当前线程。然而，这是一种非常简单粗暴的做法。</p><p>尽管这样做可以成功获取JDBC锁，但它也会导致一部分SQL游离在事务之外执行。<br>不仅仅是这个解决方法，<strong>上述的三份代码也都会有这个问题</strong>。</p><p>不太理想的解决方法的代码如下：<br><a href="https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/service/Problem2BadFixService.java">https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/service/Problem2BadFixService.java</a></p><h1 id="第二个问题的较优解决方法：缩小事务范围，避免将业务操作和获取JDBC锁的操作混合在同一个被-Transactional标注的方法内"><a href="#第二个问题的较优解决方法：缩小事务范围，避免将业务操作和获取JDBC锁的操作混合在同一个被-Transactional标注的方法内" class="headerlink" title="第二个问题的较优解决方法：缩小事务范围，避免将业务操作和获取JDBC锁的操作混合在同一个被@Transactional标注的方法内"></a>第二个问题的较优解决方法：缩小事务范围，避免将业务操作和获取JDBC锁的操作混合在同一个被@Transactional标注的方法内</h1><p><strong>上述四份代码都存在一个共同的缺点</strong>，即@Transactional注解的范围太广。</p><p>这容易导致JPA Transaction Manager的范畴以及用于获取JDBC分布式锁的Data Source Transaction Manager的范畴互相交叉。</p><p>当这两者混在一起时，很容易出现DataSourceTransactionManager试图去改变一个已经被open过的transaction的隔离级别的问题。</p><p>第二个问题的较优解决方法的代码请参考：<br><a href="https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/service/Problem2GoodFixService.java">https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/service/Problem2GoodFixService.java</a></p><h1 id="用图来总结一下"><a href="#用图来总结一下" class="headerlink" title="用图来总结一下"></a>用图来总结一下</h1><pre><code class="highlight mermaid">flowchart TD        style dstm fill:lightgreen,stroke:#333,stroke-width:4px    style nrt fill:#FFCCCB,stroke:#333,stroke-width:4px    jl[JDBC分布式锁]    str[Serializable级别的事务]    mt[多个线程]    jtm[JPA Transaction Manager]    dstm[❤️Data Source Transaction Manager❤️]    nrt[🪳无法重试获取锁🪳]    se[Serialization Error]    se2[Serialization Error]    subgraph 在多个线程中同时运行隔离级别为serializable的事务而导致的无法重试获取锁的问题    jl--&gt;|默认使用|str    mt--&gt;|同时获取|jl    jl--&gt;|恰好用了|jtm    str--&gt;|容易撞车而导致|se    jtm--&gt;|hold不住|se    se--&gt;|从而导致|nrt    jl--&gt;|替换成使用|dstm    dstm--&gt;|可以hold住|se2    se2--&gt;|从而解决|nrt    end</code></pre><pre><code class="highlight mermaid">flowchart TD        style nd fill:lightgreen,stroke:#333,stroke-width:4px    style ile fill:#FFCCCB,stroke:#333,stroke-width:4px    st[同一个线程中]    t[事务]    t2[事务]    tm[一个范围很宽的标注了@Transactional的方法]    js[JPA的SQL操作]    tl[获取JDBC分布式锁]    js2[JPA的SQL操作]    tl2[获取JDBC分布式锁]    ps[Parallel Stream]    op[其自己线程池中的线程]    ct[当前线程]    ile[🪳无法更改事务隔离级别的问题🪳]    nd[❤️正确做法应该是缩小@Transactional的范围❤️]    subgraph 在同一个线程中先使用JpaTransactionManager启动一个事务然后尝试用DataSourceTransactionManager获取JDBC锁所导致的事务隔离级别变化的问题    ps--&gt;|并不总是仅利用|op    ps--&gt;|也会利用|ct    ct--&gt;|那么就会在|st    st--&gt;|跑|tm    tm--&gt;|先执行了一些|js    tm--&gt;|然后再尝试|tl    js--&gt;|已经open了|t    tl--&gt;|再去试图更改其隔离等级|t    t--&gt;|从而导致|ile    nd--&gt;|可以及时关闭|t2    t2--&gt;|避免把二者混在一起|js2    t2--&gt;|避免把二者混在一起|tl2    js2--&gt;|从而避免|ile    tl2--&gt;|从而避免|ile    end</code></pre><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>上面的问题都是由于业务代码和获取锁的代码二者同时依赖于同一个数据库。</p><p>而Spring Integration的分布式锁除了可以使用JDBC，其实也可以使用Redis或其他底层技术。<br>如果把上述代码中的JdbcLockRegistry全部替换为RedisLockRegistry，而保持其它代码不变，所有错误都会消失，不会再重现。</p><p>因为无论用到了哪一个线程，哪一个DB Transaction，也无论@Transactional标记的宽或者窄，Redis总是不会和JDBC&#x2F;DB撞车的。</p><p>可以通过修改上述代码中的此处来试用Redis：<br><a href="https://github.com/cuipengfei/Spikes/blob/c887a6f802bbfffc45ee29cbb91dac731243b7cd/jpa/lock-transaction-threads/src/main/resources/application.properties#L17-L18">https://github.com/cuipengfei/Spikes/blob/c887a6f802bbfffc45ee29cbb91dac731243b7cd/jpa/lock-transaction-threads/src/main/resources/application.properties#L17-L18</a></p><h2 id="Spring-Boot-3"><a href="#Spring-Boot-3" class="headerlink" title="Spring Boot 3"></a>Spring Boot 3</h2><p>如果升级到Spring Boot 3.1.5 + JDK 17，则Spring Integration JDBC会升到6.1.4(上述代码用的是5.x)，甚至不用替换成Data Source Transaction Manager，上述问题也会消失。</p><p>因为这一版本的Spring Integration JDBC的分布式锁实现在acquire lock时不再使用serializable的事务，而是改成了read committed。</p><p>这样，自然就规避了第一个问题，不再有serializable事务撞车。</p><p>而由于不再需要给锁使用Data Source Transaction Manager，自然也就解决了第二个问题，不再有同一个线程上两个transaction managers打架的问题。<br>不过，即便如此，缩小@Transactional的范围仍然是值得建议的。</p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;第一个问题：在多个线程中同时运行隔离级别为serializable的事务而导致的无法重试获取锁的问题&quot;&gt;&lt;a href=&quot;#第一个问题：在多个线程中同时运行隔离级别为serializable的事务而导致的无法重试获取锁的问题&quot; class=&quot;headerlink&quot; title=&quot;第一个问题：在多个线程中同时运行隔离级别为serializable的事务而导致的无法重试获取锁的问题&quot;&gt;&lt;/a&gt;第一个问题：在多个线程中同时运行隔离级别为serializable的事务而导致的无法重试获取锁的问题&lt;/h1&gt;&lt;p&gt;Spring Integration JDBC分布式锁的实现会需要使用一个serializable级别的事务来&lt;strong&gt;获取锁&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果多个线程同时尝试获取锁，这些事务之间可能会出现顺序问题。&lt;/p&gt;
&lt;p&gt;具体而言，可能会遇到以下错误：&lt;/p&gt;
&lt;figure class=&quot;highlight livecodeserver&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;org.postgresql.util.PSQLException: ERROR: could &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; serialize access due &lt;span class=&quot;built_in&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;read&lt;/span&gt;/&lt;span class=&quot;built_in&quot;&gt;write&lt;/span&gt; dependencies &lt;span class=&quot;keyword&quot;&gt;among&lt;/span&gt; transactions&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;发生这样的问题其实也不可怕，因为JDBC锁会进行重试。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://cuipengfei.is-a.dev/tags/Java/"/>
    
    <category term="分布式" scheme="https://cuipengfei.is-a.dev/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="锁" scheme="https://cuipengfei.is-a.dev/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>内存涨上去不肯下来 - 未必是内存泄漏</title>
    <link href="https://cuipengfei.is-a.dev/blog/2023/08/26/not-mem-leak/"/>
    <id>https://cuipengfei.is-a.dev/blog/2023/08/26/not-mem-leak/</id>
    <published>2023-08-26T13:45:00.000Z</published>
    <updated>2023-08-26T13:45:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在一个Kubernetes（K8s）集群中，部署了Prometheus和Grafana用于监控集群本身和应用的状态。</p><p>在其中一个Java应用对应的Pod级别观察到了内存上升的现象。具体而言，当该应用刚启动时，内存占用并不高。如果不发送请求给应用，内存将保持在启动时的水平上。</p><p>如果大量发送请求给应用并在短时间内持续发送，内存会迅速增加。这在一定程度上是正常的。</p><p>一旦内存增加之后，即使停止发送请求和压力，内存使用也不会下降，一直保持在高峰水平。</p><p>上面的状况是由Grafana中观察到的。</p><p>观察到的现象看起来像是内存泄漏，但实际上并不一定是内存泄漏。</p><p>原因有以下两点：</p><h1 id="1-在K8s中运行的Prometheus默认只使用了Node-Exporter"><a href="#1-在K8s中运行的Prometheus默认只使用了Node-Exporter" class="headerlink" title="1 在K8s中运行的Prometheus默认只使用了Node Exporter"></a>1 在K8s中运行的Prometheus默认只使用了Node Exporter</h1><p>这意味着Prometheus收集的数据是从操作系统的角度来看进程的内存使用情况，而不是从Java虚拟机（JVM）进程内部观察。</p><p>如果想要从JVM内部的视角观察堆内存的使用情况，例如堆的大小和使用情况，就需要让应用容器内包含有Prometheus的jmx exporter。</p><h1 id="2-关键是要观察堆内存的使用情况"><a href="#2-关键是要观察堆内存的使用情况" class="headerlink" title="2 关键是要观察堆内存的使用情况"></a>2 关键是要观察堆内存的使用情况</h1><p>要检查和确诊Java应用的内存泄漏，不能仅仅从操作系统的角度观察整个进程的内存使用情况，认为内存没有释放就是泄漏。这种观察方式是不准确的。</p><p>应该从JVM内部观察堆内存的使用情况，即使进行了垃圾回收（GC），堆内存仍然无法下降是一个明确的征兆。</p><p>例如，堆使用量（heap usage）基本上接近堆大小（heap size），并且堆使用量出现了频繁的小锯齿波动，这基本上表明GC在尝试清理旧的内存，但无法成功清理，这就是比较明显的迹象了。</p><p>因为JVM有时候不愿意释放从操作系统那里要来的内存。因此，仅仅根据从操作系统的角度观察内存是否增加而不下降来诊断为Java的内存泄漏是不准确的。</p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在一个Kubernetes（K8s）集群中，部署了Prometheus和Grafana用于监控集群本身和应用的状态。&lt;/p&gt;
&lt;p&gt;在其中一个Java应用对应的Pod级别观察到了内存上升的现象。具体而言，当该应用刚启动时，内存占用并不高。如果不发送请求给应用，内存将保持在启动时的水平上。&lt;/p&gt;
&lt;p&gt;如果大量发送请求给应用并在短时间内持续发送，内存会迅速增加。这在一定程度上是正常的。&lt;/p&gt;
&lt;p&gt;一旦内存增加之后，即使停止发送请求和压力，内存使用也不会下降，一直保持在高峰水平。&lt;/p&gt;
&lt;p&gt;上面的状况是由Grafana中观察到的。&lt;/p&gt;
&lt;p&gt;观察到的现象看起来像是内存泄漏，但实际上并不一定是内存泄漏。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://cuipengfei.is-a.dev/tags/Java/"/>
    
    <category term="jvm" scheme="https://cuipengfei.is-a.dev/tags/jvm/"/>
    
    <category term="内存" scheme="https://cuipengfei.is-a.dev/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Spring Integration JDBC分布式锁 - TTL</title>
    <link href="https://cuipengfei.is-a.dev/blog/2023/07/29/spring%20integration%20jdbc%20distributed%20lock/"/>
    <id>https://cuipengfei.is-a.dev/blog/2023/07/29/spring%20integration%20jdbc%20distributed%20lock/</id>
    <published>2023-07-28T16:30:00.000Z</published>
    <updated>2023-07-28T16:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在项目中需要使用Spring Integration提供的基于JDBC实现的分布式锁。</p><p>在实践的过程中，我们遇到了一些有趣的问题，现在在此记录和总结一下。</p><p>一共遇到了两个问题，第一个和time to live有关，第二个还是和time to live有关。</p><h1 id="第一个问题：由于time-to-live默认值不够长而导致被动失去锁的问题"><a href="#第一个问题：由于time-to-live默认值不够长而导致被动失去锁的问题" class="headerlink" title="第一个问题：由于time to live默认值不够长而导致被动失去锁的问题"></a>第一个问题：由于time to live默认值不够长而导致被动失去锁的问题</h1><pre><code class="highlight mermaid">sequenceDiagramactor event_initiatorparticipant instance_1participant instance_2event_initiator-&gt;&gt;instance_1: do somethingnote over instance_1: instance 1 获得了 lockinstance_1-&gt;&gt;instance_1: start doing its thingevent_initiator-&gt;&gt;instance_2: do another thingnote over instance_2: instance 2 等待 locknote over instance_2: 等 ......note over instance_2: 等 ......note over instance_1: lock的超时时间TTL到，instance 1还没干完活，但是它失去了 lock&lt;br&gt;失去不同于主动release&lt;br&gt;失去lock后，instance 1还会继续干活&lt;br&gt;而这些活里面可能会有SQL写操作note over instance_2: instance 2 获得了 lockinstance_2-&gt;&gt;instance_2: start doing its thingnote over instance_1,instance_2: 此时二者同时干活，有撞车的风险，因为二者干活的先后顺序没有保证&lt;br&gt; instance 1尚未把它干完活后才能确定的状态写入DB，而instance 2已经开始干活了note over event_initiator,instance_2: 为了降低风险，可以： &lt;br&gt; ① 想办法尽量让instance 1能在超时前干完活 &lt;br&gt; ② 以防万一可以考虑在合适的时间节点延长锁的过期时间</code></pre><p>根据上图所示，我们有两个实例。</p><p>事件的触发者首先让第一个实例去处理一个事件。第一个实例获取了一个锁并开始执行相应的任务。</p><p>此时，事件的触发者又让第二个实例去处理另一个事件。第二个实例也想获取同一个锁，但由于第一个实例已经开始处理了，第二个实例无法获取锁，只能等待。</p><p>在理想情况下，第一个实例会在完成任务后释放锁，然后第二个实例就可以获取锁并开始执行相应的任务，这样就不会有任何问题。</p><p>但是，如果由于某种原因第一个实例处理任务的速度太慢，就会出现问题。</p><p>因为Spring Integration JDBC分布式锁会遵循Time to Live的参数，该参数确定了在获取锁后最长可持有锁的时间。</p><p>如果超出了这个时间，而另一个人想要获取该锁，则可以获取到锁。<strong>这是为了避免锁的持有者挂掉而导致其他人全部干等的防死锁机制。</strong></p><p>在这种情况下，就会有两个人同时运行。</p><p>我们本意是让锁保护资源以避免同时访问，但在这种情况下，资源会被同时访问。</p><p>如果这些访问中涉及到读取共享状态以决定后续行为以及写入其他人可能会读取的状态的操作，那么就会出现混乱。</p><p>在这种情况下，我们可以选择进行两个操作。</p><h2 id="给time-to-live一个合理的值"><a href="#给time-to-live一个合理的值" class="headerlink" title="给time to live一个合理的值"></a>给time to live一个合理的值</h2><p>实际上，相当于需要对运行时间进行合理的估算，然后尽量将time to live设置为能够覆盖该估算值的数值。</p><p>把这个估算出来的数字赋值给default lock repository的time to live就好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specify the time (in milliseconds) to expire deadlocks.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeToLive the time to expire deadlocks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTimeToLive</span><span class="params">(<span class="type">int</span> timeToLive)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.ttl = Duration.ofMillis(timeToLive);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/spring-projects/spring-integration/blob/7dcc0bb125eb5d72d9dc6cec0cc91bd4114336be/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/DefaultLockRepository.java#L190-L196">DefaultLockRepository</a></p><h2 id="选择在合适的时机renew"><a href="#选择在合适的时机renew" class="headerlink" title="选择在合适的时机renew"></a>选择在合适的时机renew</h2><p>即使我们进行了合理的估算，但这只是一个估计值，不是绝对精确的值。</p><p>换言之，在某些情况下，运行时间仍可能延续到time to live过期之后，从而面临两个人同时访问的风险。</p><p>为了避免这种情况，可以在适当的时候进行renew操作。</p><p>例如，在执行耗时较长的操作之前调用lock registry的renewLock方法，这样就相当于在执行耗时较长的操作之前重新获取了一次锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RenewableLockRegistry</span> <span class="keyword">extends</span> <span class="title class_">LockRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Renew the time to live of the lock is associated with the parameter object.</span></span><br><span class="line"><span class="comment"> * The lock must be held by the current thread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lockKey The object with which the lock is associated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">renewLock</span><span class="params">(Object lockKey)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/spring-projects/spring-integration/blob/7dcc0bb125eb5d72d9dc6cec0cc91bd4114336be/spring-integration-core/src/main/java/org/springframework/integration/support/locks/RenewableLockRegistry.java#L28-L37">RenewableLockRegistry</a></p><h1 id="第二个问题：time-to-live对于运行在同一个进程中的两个线程来说是不会自动生效的"><a href="#第二个问题：time-to-live对于运行在同一个进程中的两个线程来说是不会自动生效的" class="headerlink" title="第二个问题：time to live对于运行在同一个进程中的两个线程来说是不会自动生效的"></a>第二个问题：time to live对于运行在同一个进程中的两个线程来说是不会自动生效的</h1><pre><code class="highlight mermaid">sequenceDiagramactor event_initiatorparticipant instance_1participant instance_2event_initiator-&gt;&gt;instance_1: do somethingnote over instance_1: instance 1 获得了 lockinstance_1-&gt;&gt;instance_1: start doing its thingevent_initiator-&gt;&gt;instance_2: do another thingnote over instance_2: instance 2 等待 locknote over instance_2: 等 ......note over instance_2: 等 ......note over instance_1:instance 1的当前线程由于某种原因卡死了，没机会释放锁note over instance_1: lock的超时时间TTL到note over instance_2: instance 2 获得了 lockinstance_2-&gt;&gt;instance_2: start doing its thingnote over event_initiator,instance_2: instance 1的线程由于某种原因卡死而没机会释放锁&lt;br&gt;在TTL过后instance 2可以拿到锁并做事&lt;br&gt;这是我们希望看到的事情，因为这样可以避免由于一个线程卡死不释放锁而导致别人干等的局面</code></pre><p>在上述图中，我们描述了两个实例，即在不同机器（或容器）上运行的两个不同Java进程。这是跨进程协作的情况，这正是我们需要<strong>分布式</strong>锁的主要原因。</p><p>在这种场景下，time to live是有效的。它可以防止一个进程无法释放锁，从而导致其他进程一直等待锁而无法继续工作的局面的出现。</p><p>在跨进程协作中，time to live可以发挥作用，那对于同一个进程中的两个线程，<strong>是否同样有效呢？</strong></p><p>从概念上来说，如果能将其设计成同样有效的，则可以减轻使用者的认知负担。</p><p>但是，在Spring Integration JDBC的分布式锁实现中，time to live<strong>并不是这样的。它对于同一个Java进程中的两个线程来说是不会自动生效的。</strong></p><p>下面的图是一个它不会生效的具体例子。 </p><pre><code class="highlight mermaid">sequenceDiagramactor event_initiatorevent_initiator-&gt;&gt;instance_1: do somethinginstance_1-&gt;&gt;instance_1_thread_1: 分配工作给线程1note over instance_1_thread_1: instance 1 - thread 1 获得了 lockinstance_1_thread_1-&gt;&gt;instance_1_thread_1: start doing its thingevent_initiator-&gt;&gt;instance_1: do another thinginstance_1-&gt;&gt;instance_1_thread_2: 分配工作给线程2note over instance_1_thread_2: instance 1 - thread 2 等待 locknote over instance_1_thread_2: 等 ......note over instance_1_thread_2: 等 ......note over instance_1_thread_1: thread 1由于某种原因卡死了，没机会释放锁note over instance_1_thread_1: lock的超时时间TTL到note over instance_1_thread_2: thread 2 仍然获获取不到 locknote over instance_1_thread_2: 继续等也没用</code></pre><p>正如上图所示，第二个线程或同一个进程中的任何其他线程，即使继续等待锁，也无济于事。这也解释了time to live在这种情况下的无效性。</p><p><a href="https://github.com/cuipengfei/Spikes/blob/master/jpa/spring-jdbc-distributed-lock-issue/src/test/java/com/github/spring/example/LockTest.java">这份代码可以重现上面两幅图所描述的场景</a></p><p>要解决这种情况下的问题，则需要用到下面提到的这个expireUnusedOlderThan方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExpirableLockRegistry</span> <span class="keyword">extends</span> <span class="title class_">LockRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove locks last acquired more than &#x27;age&#x27; ago that are not currently locked.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> age the time since the lock was last obtained.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if the registry configuration does not support this feature.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">expireUnusedOlderThan</span><span class="params">(<span class="type">long</span> age)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/spring-projects/spring-integration/blob/7dcc0bb125eb5d72d9dc6cec0cc91bd4114336be/spring-integration-core/src/main/java/org/springframework/integration/support/locks/ExpirableLockRegistry.java#L27-L36">ExpirableLockRegistry </a></p><p>如果一个Java进程中的一个线程因为某种原因卡死了，从而无法释放锁。<br>在TTL过期之后，另一个线程在尝试获取同一个锁之前，可以调用expireUnusedOlderThan来强制释放该锁。<br>然后再尝试获取锁，就可以成功获取并继续工作。</p><h2 id="为什么不把time-to-live设计的更具有概念上的一致性？"><a href="#为什么不把time-to-live设计的更具有概念上的一致性？" class="headerlink" title="为什么不把time to live设计的更具有概念上的一致性？"></a>为什么不把time to live设计的更具有概念上的一致性？</h2><p>当涉及到跨越两个进程时，time to live会发挥作用。但是对于同一个进程中的两个线程来说，time to live就不再有效。这种同一个概念在不同的场景下表现出不同的行为，缺乏概念上的一致性，这可能会增加使用者的认知负担。</p><p>那Spring为什么要把它设计成这样呢？</p><p>以下是我的<strong>解读</strong>：</p><p>在分布式系统中，如果两个进程想要获得同一个锁，那么来得晚一些的进程实际上并不知道前一个进程目前处于什么状态，它是否已经死亡。在这种情况下，time to live成为了<strong>决策的唯一依据</strong>。如果time to live还没有过期，那么来得晚的进程认为它不应该获取该锁。一旦time to live过期，后续进程将把锁置于自己的控制之下，而不管前一个进程是否仍然活着。简而言之，由于<strong>缺少其他的决策依据</strong>，这种情况下只能选择依照time to live来简单粗暴的办事。</p><p>然而，对于同一个进程中的两个线程来说，情况就不同了。它们共享同一块内存空间(从实现层面来讲，同一个进程中的两个线程是共享<strong>同一份registry和repository</strong>的)。如果后续线程发现前一个线程在TTL过后还没有释放锁，则默认认为前一个线程仍然有继续工作的能力，因此它默认不会强制抢占锁。除非他在TTL之后等过一段时间之后觉得等不及了，这时候他<strong>可以选择</strong>强制把锁抢过来。</p><p>举个例子，就像在古代<strong>缺乏无线电通信</strong>的战争中。一支小队去执行任务，另一支小队待命。三个小时后，不论先前的小队是否成功，后续小队都必须出发参加战斗。因为除了这三个小时之外，你没有其他的决策依据。只要时间到了，我就开始行动。</p><p>但是，如果是同一支小队中的两个士兵，后面的士兵实际上可以在目视距离内看到前面的士兵是否仍然在执行任务。因此，<strong>即便是战友行动太慢</strong>了，他也可以选择多等待一会，让前面的士兵可以继续完成任务。当然，如果后面的士兵等不及了，想要立即行动，他也可以选择这样做。在这种情况下，后面的士兵<strong>具有更多的决策依据</strong>，因此他可以选择多等待一段时间或立即采取行动。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>第一个问题：由于time to live默认值不够长，而导致在还不该失去锁的时间点上过早地失去了锁（<strong>防死锁机制过早地介入了</strong>），解决方法是把TTL设置的足够大，以及在合适的时机做renew从而避免过早地失去锁。</p><p>第二个问题：time to live对于运行在同一个进程中的两个线程来说是<strong>不会默认生效</strong>的，从而导致应该失去锁的时间已经过了，但卡住的线程还没有释放锁，进而导致后续的线程拿不到锁的情况。解决方法是<strong>可以选择</strong>让同一个进程内的后来者线程使用expireUnusedOlderThan来强制剥夺锁(同一个进程中的两个线程，其中后来的那个具有更高的自由裁量权，不必只依据TTL一个指标来行事)。</p><pre><code class="highlight mermaid">mindmap  root(Spring Integration JDBC Distributed Lock)    默认TTL太短        设置长一些        renew    卡死了，没机会释放锁        其它进程可以在TTL过后拿到锁        同一个进程内的其它线程可以选择使用expireUnusedOlderThan</code></pre><p>锁的事，该失去就失去，不失去也强制失去。</p><p>锁的事，不该失去就不能失去，要失去也不许失去。</p><p><img data-src="/../images/spring-lock/LiuLuoGuo.jpg" alt="llg"></p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在项目中需要使用Spring Integration提供的基于JDBC实现的分布式锁。&lt;/p&gt;
&lt;p&gt;在实践的过程中，我们遇到了一些有趣的问题，现在在此记录和总结一下。&lt;/p&gt;
&lt;p&gt;一共遇到了两个问题，第一个和time to live有关，第二个还是和time to live有关。&lt;/p&gt;
&lt;h1 id=&quot;第一个问题：由于time-to-live默认值不够长而导致被动失去锁的问题&quot;&gt;&lt;a href=&quot;#第一个问题：由于time-to-live默认值不够长而导致被动失去锁的问题&quot; class=&quot;headerlink&quot; title=&quot;第一个问题：由于time to live默认值不够长而导致被动失去锁的问题&quot;&gt;&lt;/a&gt;第一个问题：由于time to live默认值不够长而导致被动失去锁的问题&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;highlight mermaid&quot;&gt;sequenceDiagram

actor event_initiator
participant instance_1
participant instance_2

event_initiator-&amp;gt;&amp;gt;instance_1: do something

note over instance_1: instance 1 获得了 lock

instance_1-&amp;gt;&amp;gt;instance_1: start doing its thing

event_initiator-&amp;gt;&amp;gt;instance_2: do another thing

note over instance_2: instance 2 等待 lock
note over instance_2: 等 ......
note over instance_2: 等 ......

note over instance_1: lock的超时时间TTL到，instance 1还没干完活，但是它失去了 lock&amp;lt;br&amp;gt;失去不同于主动release&amp;lt;br&amp;gt;失去lock后，instance 1还会继续干活&amp;lt;br&amp;gt;而这些活里面可能会有SQL写操作

note over instance_2: instance 2 获得了 lock

instance_2-&amp;gt;&amp;gt;instance_2: start doing its thing

note over instance_1,instance_2: 此时二者同时干活，有撞车的风险，因为二者干活的先后顺序没有保证&amp;lt;br&amp;gt; instance 1尚未把它干完活后才能确定的状态写入DB，而instance 2已经开始干活了

note over event_initiator,instance_2: 为了降低风险，可以： &amp;lt;br&amp;gt; ① 想办法尽量让instance 1能在超时前干完活 &amp;lt;br&amp;gt; ② 以防万一可以考虑在合适的时间节点延长锁的过期时间&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据上图所示，我们有两个实例。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://cuipengfei.is-a.dev/tags/Java/"/>
    
    <category term="分布式" scheme="https://cuipengfei.is-a.dev/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="锁" scheme="https://cuipengfei.is-a.dev/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>当测试代码使用随机生成的输入数据时，该如何去做出断言</title>
    <link href="https://cuipengfei.is-a.dev/blog/2023/03/18/generative-tests/"/>
    <id>https://cuipengfei.is-a.dev/blog/2023/03/18/generative-tests/</id>
    <published>2023-03-18T14:34:00.000Z</published>
    <updated>2023-03-18T14:34:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一份有意思的代码"><a href="#一份有意思的代码" class="headerlink" title="一份有意思的代码"></a>一份有意思的代码</h1><p>最近看到了一份<span style="color:orange;">使用随机生成的数据作为测试输入</span>的有趣代码，把其大致思路用伪代码描述如下 </p><h2 id="需要被测的实现代码"><a href="#需要被测的实现代码" class="headerlink" title="需要被测的实现代码"></a>需要被测的实现代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calculateSomething</span>(<span class="params">inputData</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用inputData来计算结果</span></span><br><span class="line">    <span class="comment">// 假装这里有一些很复杂的逻辑</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是被测的函数，在此不管它算的是什么，总之它接受input，返回result。</p><h2 id="测试代码的helpers"><a href="#测试代码的helpers" class="headerlink" title="测试代码的helpers"></a>测试代码的helpers</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">generateInputData</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 用来生成测试所需的input数据</span></span><br><span class="line">    <span class="comment">// 所生成的数据具有一定的随机性</span></span><br><span class="line">    <span class="keyword">return</span> randomlyGeneratedInputData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fuction <span class="title function_">calculateExpectedResult</span>(<span class="params">inputData</span>)&#123;</span><br><span class="line">    <span class="comment">// 用来计算assertion所需要的expected值</span></span><br><span class="line">    <span class="keyword">return</span> expectedResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是测试代码的helper函数，一个用来生成测试所需的input，一个用来计算expected的值。</p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> repeatTimes = <span class="number">100</span>; <span class="comment">//总之是一个较大的数字，不一定非得是100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;repeatTimes; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> randomInputData = <span class="title function_">generateInputData</span>(); <span class="comment">//生成具有一定随机性的输入</span></span><br><span class="line">    <span class="keyword">var</span> expected = <span class="title function_">calculatedExpectedResult</span>(randomInputData); <span class="comment">//用测试helper算出expected</span></span><br><span class="line">    <span class="keyword">var</span> actual = <span class="title function_">calculateSomething</span>(randomInputData); <span class="comment">//用被测方法算出actual</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">expect</span>(actual).<span class="title function_">toEqual</span>(expected); <span class="comment">//断言二者相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是测试代码，反复运行多次，每次都生成具有随机性的input，然后把input传递给<code>calculatedExpectedResult</code>和<code>calculateSomething</code>，最后断言二者返回值是一致的。</p><p>这份代码和常见的测试不同，<span style="color:orange;">它使用的input data不是预先设定好的</span>，而是运行时随机生成的。这也是它有趣的原因。</p><h1 id="如何解读测试结果"><a href="#如何解读测试结果" class="headerlink" title="如何解读测试结果"></a>如何解读测试结果</h1><p>通常来说，当测试通过时，它意味着针对给定的输入，程序给出了<strong>符合预期</strong>的输出。</p><p>但是对于这一份代码来说，却并非如此。因为<span style="color:orange;">它的expected值是由一个helper函数计算得来，而非是一个已经被验证过是正确的值</span>。</p><p>那么，<span style="color:orange;">如果上述的测试代码能够执行通过，它是在传递什么信息给开发者呢？</span></p><ul><li><p>它意味着<code>calculatedExpectedResult</code>这个helper函数和<code>calculateSomething</code>这个被测函数之间，具有<span style="color:orange;">较高的相似性</span>，二者针对<span style="color:orange;">多组</span>一样的输入，可以给出一样的输出</p></li><li><p>如果我们把<code>repeatTimes</code>的数值<span style="color:orange;">调到非常高</span>，测试还能通过的话，那就说明<code>calculatedExpectedResult</code>这个helper函数和<code>calculateSomething</code>这个被测函数之间的<span style="color:orange;">相似性非常高，简直可以达到同卵双胞胎甚至是克隆体这种以假乱真的程度</span></p></li></ul><p><span style="color:orange;"><strong>这是我们需要的吗？</strong></span></p><p><span style="color:orange;">我们<strong>需要去探寻世界上是否存在那么一个函数，它的行为可以做到和<code>calculateSomething</code>极其贴近吗？</strong></span></p><p>我认为我们是不需要的。</p><p>我们需要的是去验证<code>calculateSomething</code>的行为是符合预期的。而不是去验证我能写出另一个和它的行为很像的函数来。</p><p>这就如同是：如果我去测试洗衣机的话，我希望验证的是某款洗衣机可以把衣服洗涤干净，并且不会损伤衣物。</p><p>而不是希望验证存在另一台洗衣机和我手里这一台表现一样。</p><p>要不然的话，我说不定会得到两台洗不干净衣服，还会损伤布料的洗衣机😄</p><h1 id="当测试代码使用随机生成的输入数据时，该如何去做出断言"><a href="#当测试代码使用随机生成的输入数据时，该如何去做出断言" class="headerlink" title="当测试代码使用随机生成的输入数据时，该如何去做出断言"></a>当测试代码使用随机生成的输入数据时，该如何去做出断言</h1><p>上面的代码虽然做的并不妥当，但是想要用随机生成的input数据去做测试其实<strong>并不是一个不合理的想法</strong>。</p><p>当我们人工编制的测试数据对于整体样本空间来说显得太小时，用随机数据去作为input数据也是一个不错的补充。</p><p>其关键在于，<span style="color:orange;"><strong>当我们给input引入了随机性的时候，我们该如何去assert其output是符合预期的？</strong></span></p><p>如果我们还是想要和常规测试一样，严格地去assert输出的值和预期<strong>相等</strong>，那么就会陷入上述代码的误区里。</p><p>但是如果思路换一下，不一定非得强求能够严格地去assert输出的值和预期<strong>相等</strong>，而是去assert输出值符合一定的规则。<br>这样，就无需在测试代码里重复去实现一遍，而只需要描述我们预期输入和输出之间符合哪种规则。</p><h1 id="Property-Based-Testing"><a href="#Property-Based-Testing" class="headerlink" title="Property Based Testing"></a>Property Based Testing</h1><p>而这，恰好就是Property Based Testing。</p><p>Property Based Testing是一种基于属性规约的测试方法，通过使用随机输入数据来验证程序的行为是否符合预期的属性规约。</p><p>在 Property Based Testing 中，<span style="color:orange;">测试用例是基于属性规约自动生成的</span>。</p><p>Property Based Testing 的基本流程如下：</p><ul><li><p>定义属性规约：定义程序的行为应该满足的属性规约，这些规约通常是<span style="color:orange;"><strong>通用的、可重用的、抽象</strong>的，而<strong>不是特定的测试用例</strong></span>。</p></li><li><p>生成随机数据：通过随机数据生成器生成随机数据，并将随机数据输入到程序中。</p></li><li><p>检查属性规约：将实际输出与定义的属性规约进行比较，如果程序的输出符合属性规约，则测试通过，否则测试失败。</p></li><li><p>修复代码：如果测试失败，则需要对程序进行修复，直到程序能够符合所有属性规约。</p></li></ul><p>一些常用的 Property Based Testing 框架包括 QuickCheck、Hypothesis、ScalaCheck、fast-check 等。</p><p>下面是一段使用Property Based Testing的样例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fc = <span class="built_in">require</span>(<span class="string">&#x27;fast-check&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Property-Based Testing，测试加法函数</span></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;加法满足交换律&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fc.<span class="title function_">assert</span>(fc.<span class="title function_">property</span>(fc.<span class="title function_">integer</span>(), fc.<span class="title function_">integer</span>(), <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">add</span>(x, y) === <span class="title function_">add</span>(y, x);</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;加0不影响结果&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fc.<span class="title function_">assert</span>(fc.<span class="title function_">property</span>(fc.<span class="title function_">integer</span>(), <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">add</span>(x, <span class="number">0</span>) === x;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;正数加负数，结果小于原数&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fc.<span class="title function_">assert</span>(fc.<span class="title function_">property</span>(fc.<span class="title function_">integer</span>(<span class="number">1000</span>, <span class="number">1</span>), fc.<span class="title function_">integer</span>(-<span class="number">1</span>, -<span class="number">1000</span>), <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">add</span>(x, y) &lt; x;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;负数加正数，结果大于原数&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fc.<span class="title function_">assert</span>(fc.<span class="title function_">property</span>(fc.<span class="title function_">integer</span>(-<span class="number">1000</span>, -<span class="number">1</span>), fc.<span class="title function_">integer</span>(<span class="number">1</span>, <span class="number">1000</span>), <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">add</span>(x, y) &gt; x;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;负数加负数，结果小于原数&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fc.<span class="title function_">assert</span>(fc.<span class="title function_">property</span>(fc.<span class="title function_">integer</span>(-<span class="number">1000</span>, -<span class="number">1</span>), fc.<span class="title function_">integer</span>(-<span class="number">1000</span>, -<span class="number">1</span>), <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">add</span>(x, y) &lt; x;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;正数加正数，结果大于原数&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fc.<span class="title function_">assert</span>(fc.<span class="title function_">property</span>(fc.<span class="title function_">integer</span>(<span class="number">1</span>, <span class="number">1000</span>), fc.<span class="title function_">integer</span>(<span class="number">1</span>, <span class="number">1000</span>), <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">add</span>(x, y) &gt; x;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;任何数加自己，结果是两倍&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fc.<span class="title function_">assert</span>(fc.<span class="title function_">property</span>(fc.<span class="title function_">integer</span>(), <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">add</span>(x, x) === x * <span class="number">2</span>;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上代码中所使用的fast-check(fc)会帮助我们<span style="color:orange;">生成大量的</span>具有随机性的输入数据，但是我们并<span style="color:orange;">没有去assert add的返回值等于某个具体的数字</span>，而是去判断<span style="color:orange;">add这个函数在其输入值符合特定规则时其返回值符合我们通过fc定义的规律</span>。</p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一份有意思的代码&quot;&gt;&lt;a href=&quot;#一份有意思的代码&quot; class=&quot;headerlink&quot; title=&quot;一份有意思的代码&quot;&gt;&lt;/a&gt;一份有意思的代码&lt;/h1&gt;&lt;p&gt;最近看到了一份&lt;span style=&quot;color:orange;&quot;&gt;使用随机生成的数据作为测试输入&lt;/span&gt;的有趣代码，把其大致思路用伪代码描述如下 &lt;/p&gt;
&lt;h2 id=&quot;需要被测的实现代码&quot;&gt;&lt;a href=&quot;#需要被测的实现代码&quot; class=&quot;headerlink&quot; title=&quot;需要被测的实现代码&quot;&gt;&lt;/a&gt;需要被测的实现代码&lt;/h2&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;calculateSomething&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;inputData&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 使用inputData来计算结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 假装这里有一些很复杂的逻辑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这是被测的函数，在此不管它算的是什么，总之它接受input，返回result。&lt;/p&gt;
&lt;h2 id=&quot;测试代码的helpers&quot;&gt;&lt;a href=&quot;#测试代码的helpers&quot; class=&quot;headerlink&quot; title=&quot;测试代码的helpers&quot;&gt;&lt;/a&gt;测试代码的helpers&lt;/h2&gt;</summary>
    
    
    
    
    <category term="testing" scheme="https://cuipengfei.is-a.dev/tags/testing/"/>
    
  </entry>
  
  <entry>
    <title>卢瑟经济学</title>
    <link href="https://cuipengfei.is-a.dev/blog/2022/10/28/loser-economy/"/>
    <id>https://cuipengfei.is-a.dev/blog/2022/10/28/loser-economy/</id>
    <published>2022-10-28T08:48:00.000Z</published>
    <updated>2022-10-28T08:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://img14.360buyimg.com//n0/jfs/t1/176451/22/10402/376750/60a37fb7E23ecc0e3/aa8754102dc19767.jpg"></p><h1 id="此书讲什么"><a href="#此书讲什么" class="headerlink" title="此书讲什么"></a>此书讲什么</h1><p>马克思《资本论》讲的三件事：</p><ul><li>原始积累靠暴力</li><li>贫富差距会扩大</li><li>最终自毁</li></ul><h1 id="经济与政治"><a href="#经济与政治" class="headerlink" title="经济与政治"></a>经济与政治</h1><p>经济学是有阶级属性的。</p><p>哪个阶级现在说了算，哪个阶级的经济学就流行。</p><p>反之亦然，可以通过观察哪个学说流行来倒推谁说了算。</p><ul><li>地主： 重农主义</li><li>商人： 重商主义</li><li>新兴资产阶级： 自由市场和劳动价值论</li><li>工人阶级： 劳动价值论</li><li>资产阶级卷土重来： 边际效用价值论</li></ul><p>不同的阶级有不同的价值理论，这就如同不同的宗教信仰对善行的定义是不一样的。<br>统治阶级的经济学，是为统治阶级寻找合法性的。被统治阶级的经济学，自然是为被统治阶级申诉的，顺便控诉对方。<br>市场是不是真的有效，到底什么创造价值，其实就看谁来解释。</p><p>按照卢瑟经济学，土地没有价值。土地的所有制，使土地所有者有权向在土地上生活工作的人要求贡赋。土地所有权越垄断，要求的地租就越高。土地垄断程度高的地方，绝对地租就高。<strong>所以房子的昂贵并不是土地的价值昂贵，而是土地的所有权高度垄断，导致地租昂贵。</strong></p><h1 id="危机的表征与对其的解释"><a href="#危机的表征与对其的解释" class="headerlink" title="危机的表征与对其的解释"></a>危机的表征与对其的解释</h1><ul><li>妈妈，天这么冷，我们家为什么不生火呢？</li><li>因为你爸爸失业了，我们没有钱去买煤。</li><li>小孩继续问：“妈妈，爸爸为什么失业呢？”</li><li>他妈妈说：“因为你爸爸的煤矿倒闭了。〞</li><li>小孩接着问：“妈妈，爸爸的煤矿为什么会倒闭呢？”</li><li>他妈妈说：“因为没有人买你爸爸的煤矿的煤，煤卖不出去，所以煤矿倒闭了。”</li></ul><p>与封建时期的危机不同，资本主义条件下的危机的特点：</p><ul><li>不是产品不足而是产品过剩</li><li>不是劳动力被透支而是劳动力被闲置</li><li>不是没稂食吃，而是产能过剩导致企业破产，然后大家下岗，没钱买粮食吃</li><li>产能有的是，就是没销路；粮食有的是，就是没钱买；劳动力有的是，就是没活干</li><li>这种危机有很强的周期性，按时袭击经济</li></ul><p>工业化的资本主义生产的特点是所有的人，都为别人生产商品，所有的人都消费别人生产的商品。</p><p>工人一旦失业就很难找到原有工资待遇水平类似的工作。因为全社会的资本家几乎在一夜之间觉得他们的劳动不值钱了。到处都是堆积的商品，老板做什么也不赚钱，索性停产，老板不生产，工人的劳动也就不值钱了，对老板就没有用了。</p><p>稳拿经济学假设工人工资水平下降，老板会增加劳动力的需求。问题是，老板的需求与产品的销售有关，当销售情况不改善的时候，工人工资再便宜，老板也没有兴趣多雇人。</p><p>社会金字塔的平级之间是可以自动调节的，但是上下级之间却不能自由调节。当社会需要的产品与资本家提供的产品不对称的时候，资本家能自行改变产品结构。当社会需要的劳动力与工人能提供的劳动力不对称的时候，工人能自动改行。<strong>但是当塔的上级不愿意投资和消费的时候，塔的下级却没有能力去代替上级投资或消费。这才是真正的困难。</strong></p><h2 id="凯恩斯"><a href="#凯恩斯" class="headerlink" title="凯恩斯"></a>凯恩斯</h2><p>1936年，凯恩斯在他的著作《就业、利息和货币通论》中提出在资本主义制度下不是产品做得出就卖得掉，有很大一部分产品注定无法消费，如此必然导致资本家压缩生产，工人失业。为了挽救资本主义，多余的产品需要政府帮助消费掉，甚至是浪费掉。无法消费的产品的量随着贫富差距的增大而增大，换句话说，贫富差距越大的经济体，失业问题越严重。</p><p>消费需求不足和投资需求不足将产生大量的失业，形成生产过剩的经济危机。</p><p>当投资的利润还不如利率的时候，资本家就都不投资，持币观望，转而存银行吃利息。如果这个时候利率高，那么投资就非常少了。<br>其实还是消费需求不足。因为投资需求归根到底完全仰仗消费品的销售情况。</p><p>觊恩斯主义是用通胀换就业：后遗症就是通货膨胀。</p><h2 id="弗里德曼"><a href="#弗里德曼" class="headerlink" title="弗里德曼"></a>弗里德曼</h2><p>在弗里德曼看来，政府</p><ul><li>第一要务是国防</li><li>第二要务是保证契约的实施</li><li>而财富分配则属于是一个人认为有益，另一个人认为是有害的</li></ul><p>但是如果我们换一个角度看弗里德曼的要求的话，就会发现三件事说起来冠冕堂皇：</p><ul><li>第一是不要外来势力干涉稳拿</li><li>第二是要求法律是保证契约的执行，不要插手稳拿利用契约合法地抢劫卢瑟 </li><li>第三是不要试图触碰，甚至返还抢来的赃物</li></ul><p>对弱者来说，与强者费厄泼赖就是最大的不公平。自愿和双方获利，只有在双方经济地位接近的时候才能存在。</p><p>关税保护了幼年时期的美国资本，避免被英国资本吞噬，避免成为英国的经济殖民地</p><p><strong>弗里德曼和凯恩斯的理论冲突，与李嘉图和马尔萨斯的冲突异曲同工。都是两个集团在争夺经济主导权。</strong></p><p>财产具有自我汇集的效应，古往今来小农经济就没有长期稳定存在过。小农如果不能进化为大地主，那么迟早会被地主吞并。</p><p>资本主义社会的矛盾的核心不是生产力的发展，而是资本主义分配制度。</p><p>自由市场加私有产权，只要一代人就能在社会上建立起人与人之间不可逾越的鸿沟。能力的竞争最多在一代人之同发挥作用，一代人之后资产确立统治地位。</p><p>其实，对大资本家来讲，周期性的经济危机未必是坏事。经济危机可以促进资本汇聚到强者也就是大资本家手中。</p><p>认识经济危机并不复杂，解决经济危机（至少从理论上）也不复杂，复杂的是后面纠葛的利益。经济危机袭扰人类将近 200 年了，解决的办法，无论是书面还是实战的都不少：</p><ul><li>希特勒的解决方式是寻求生存空间。从经济殖民地获得廉价的原材料，过剩的产品向经济殖民地倾销。</li><li>凯恩斯的解决方式，是政府印钱，由政府创造需求。多余的产能浪费掉，资本家不是没钱不生产，不雇用工人吗？用印钞机给他们钱就是了。政府有印钞机还愁没钱支付？后果是通货膨胀或者资产泡沫。</li><li>罗斯福的解决方案，是给工人更大的权利，支持他们与资本家斗争。增加财产税让稳拿出血，通过转移支付，给卢瑟更多的福利。</li></ul><p>这么多方法，多数效果都不好。这是因为稳拿处于塔尖的地位，直接调节总量而不触动分配模式的解决方案，不过是给稳拿更多的发财的机会，导致更严重的分配不公。如果触动分配模式，又难免遭到稳拿的强大阻碍，很可能半途而废。</p><h1 id="资产的属性"><a href="#资产的属性" class="headerlink" title="资产的属性"></a>资产的属性</h1><p>对产来说，具体选择哪种方式，取决于哪种方式来钱最容易，或者说风险更小，效率更高。产是否发展生产，并不确定，是否会改善多数人的生活则更不确定。我们没有任何理由认为，产权明晰加自由市场经济一定会发展生产力，提供更多物美价廉的产品。</p><p>对苏联这样的前社会主义国家来说，完全市场化和产权私有化（或者说产权明晰化）的结果，唯一能确定的就是私人产权迅速膨胀，出现一批人造寡头，其余的多数人则沦为这些寡头的奴隶。</p><p>稳拿经济学追求帕累托最优，认为在这种情况下各种资源得到最有效地利用，紧缺资源获得最大价值。稳拿经济学认为，自由的市场，最终会达到帕累托最优：就是不可能再改善某些人的境况，而不使任何其他人受损。在市场中，社会的各类人群在不断追求自身利益最大化的过程中，可以使整个社会的经济资源得到最合理的配置。</p><p>自由市场会导致帕累托最优，这是完全正确的。但是这种帕累托最优，却不是多数人之福—既不是卢瑟之福，也不是稳拿之福。自由的市场最终会造成财产的高度集中，拥有这些产的稳拿对社会总产品有极大的分配权。数量众多的卢瑟，却只有极其有限的分配权。所以，<strong>每次天下大乱以前，社会都处于或接近帕暴托最优的状态</strong>：不伤害地主的利益，农民就无法改着自己的生活，就要死于饥寒交迫，这时农民就不再尊重市场交易规则，采用暴力推翻产的权威。</p><h2 id="亚当斯密-科斯"><a href="#亚当斯密-科斯" class="headerlink" title="亚当斯密 &amp; 科斯"></a>亚当斯密 &amp; 科斯</h2><p>亚当.斯密提出，个人满足私欲的活动将促进社会福利，只要自由放任，市场的看不见的手发挥作用，最终就将实现全社会的富足。科斯提出只要产权明晰，把一切交给市场中看不见的手来发挥作用；然后就能建立安宁祥和的社会，一切都会万事大吉。<br>在斯密的时代，正是大饼迅猛变大的时代。那时资本主义刚刚登场不久，每一个资本家的资本量都很小，社会中还有大量封建残余。资本主义处于自由竟争时期，正在经历第一次产业革命，从手工作坊向大工厂过渡，劳动者还有当小老板或者当雇用工人的選擇。那时对产来说最有效率的自我增值的手段是发展生产力，资本主义相对封建残余来说极大地推动了生产力发展，所以这样说并不为过。经过200多年以后，到今天还这样说，那就是彻头彻尾的胡说了。</p><p>稳拿经济学提出只要交易就能改善全社会的福利。卢瑟经济学认为改善福利的过程复杂得多。价值来自生产劳动，市场并不创造价值。个人也许可以通过炒房子炒地皮获得极大的收益，但是社会总体生活不会改善，因为总消费品的量，无论是产量，还是销售量都并没增加。</p><p>可能存在大饼整体萎缩，大家吃得越来越少，某些个体却吃得越来越多的情况。</p><p>资本论想说明的事情之一：工人创造的剩余价值越多，资本家的资产越多，工人与资本家之间差距不断拉大，最终成为资本的奴隶：死劳动（工人以前创造的剩余价值）牢牢抓住活劳动（工人）。</p><p>产是什么：<strong>产是用于获得剩余价值依据的物化的媒介。人类社会总产品是块大饼，产是稳拿用来切大饼的刀。</strong></p><p>土地价格的攀升，不是土地自己产生价值，而是土地上产业资本不断壮大，地主要求其支付的贡税越来越多。如果土地上的产业萧条，土地价格必然暴跌。</p><p>依靠土地获得剩余价值，是对资本主义的阻力而不是动力。土地所有权高度集中，产业资本家获得的利润太薄，他们很难有足够的剩余价值扩大再生产。此外，土地垄断会造成土地利润高于社会平均利润，资本家的剩余资本必然会选择投机土地，而不是投资于原料或设备进行扩大再生产。引申一步，如果土地成为资本的主体，那么社会必然停滞不前，甚至倒退。历史上，土地所有权高度集中的地区很难诞生资本主义。</p><h1 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h1><p>绝大多数的交易，不过是从甲账户转移到乙账户。如果我们把金融机构看为一个整体的话，就会发现几乎所有的货币都在金融机构的手里。</p><p>资本主义世界的特点之一，就是<strong>强者恒强，这不仅仅表现在获得利润的时候强者有权先享用大饼，也表现在遇到危机的时候强者付出的代价更少</strong>。</p><p>国家是经济上占统治地位的阶级进行阶级统治的政治权力机构。是一个成长于社会之中而又凌驾于社会之上的、以暴力或合法性为基础的、带有相当抽象性的权力机构。国家有阶级性，国家由经济上占优势地位的阶级控制。国家有暴力性，而且是最终的暴力。国家的存在是为了维护统治阶级的经济利益。国家是一个阶级压迫另一个阶级的机器，是使一切被支配的阶级受一个阶级控制的机器。</p><p>由于暴力是唯一能对抗资本的要素，而代表国家行使暴力的官僚并不总是靠得住的。对资本来说，暴力的忠诚度是值得怀疑的。所以，<strong>资产阶级成为统治阶级以后，一直试图把国家的作用局限在最小的范围</strong>。对内保证社会治安，对外抵御外敌人侵，是资本主义国家的主要任务。至于维护社会的公平，扶助弱小，是资本家最忌讳的事情。</p><p>如果所有的劳动者都去大学深造，最终的结果将是大学深造对提高工资收入水平的作用目益下降。</p><h1 id="产销过程"><a href="#产销过程" class="headerlink" title="产销过程"></a>产销过程</h1><p>消费与生产是对立统一的，没有消费，就不会有生产。我们无法想象一个社会开采矿石，制造机器，最终的目的仅仅是为了开采更多的矿石和制造更多的机器。生产的各种产品最终都会被消费。</p><p>希望每当社会总需求不足的时候，就能出现新一轮技术革新导致投资高潮，进而消化掉多余产能，這是不现实的事情。</p><p>资本家投资的目的是获得更多的货币。如果社会1000万资本的平均利润率是10%，那么资本家如果投入1000万购买新设备、雇用新工人，那么他必然要求 100 万的利润。换句话说，原先社会存在1000 万的需求不足的缺口，在资本家投资以后，1000万的缺口消失了。但是，在1000万的投资实现产能以后，就将出现1100 万的需求缺口。所以，长期靠资本家投资替代工人需求是不现实的。</p><p>消费不足，并不见得是产业资本剥削得太严重，而是<strong>整个稳拿集团</strong>剥削得太严重。<strong>工人贡獻的剩余价值，在产业资本、土地，金融和暴力之间分配</strong>。</p><p>如果大批企业贷款偿还能力都发生了回题，那么银行会发现自己几乎在一夜之间成为最大的实业资本家，大批的货币资本收不回來，变成抵押物。更糟糕的是，这些抵押物没有人要，而且在不断贬值。</p><p>自从资本主义诞生起，尽管<strong>绝对消费水平不断上升，但是相对消费不足一直没有克服</strong>。</p><h1 id="垄断"><a href="#垄断" class="headerlink" title="垄断"></a>垄断</h1><p>每次经济危机都会成为大资本屠杀小资本的过程。年次危机结束后所有的幸存者都有机会廉价获得遇难者的一切生产资源，包括原料、生产设备、熟练工，当然也包括他们的市场。</p><p>自然界的进化，物种由多样归于多样，面人类社会资本的进化，最终归于“一”。这个过程是单向、清晰、不可逆的。</p><p>如果把社会总生产看成一个庞大的网络，那么我们可以看到一些最基本的生产、生活要素在极少数企业的控制之下，这些企业就是真正的帝王资本。他们控制交叉的行业，影响、操纵整体经济。在他们之下，则是一些诸候。他们垄断本行业，影响、操纵某一种或几种商品。在这些诸侯之下，则是一些中、小资本，他们为上面帝王和诸候资本服务，是“臣民资本”。再向下，则是一些零散的资本，他们数量很多，充满帝王和诸候触角不愿触及的“鸡肋”行业，彼此之间激烈竟争。至于劳动力，则处于完全不入流的状态。</p><p>垄断帝国则是在“暴力归公”的基础上，完全依靠财产的力量，在市场交易中逐步建立起来的。需要注意的是，这里的暴力的“归公”、是归资产阶级的“公”，而不是全民的“公”，这里的暴力，是资产阶级的暴力，这种暴力不在资产阶级内部使用，却不吝于镇压无产阶级。</p><p>暴力和资本走到一起，有两种方式：资本领导暴力；暴力领导资本。两种方式的起源与各个资本主义国家历史进程有关。不论哪种方式，最终殊途同归：最终都將建立资本与暴力结合的密严阶级专政，这个专政將处于官僚统治集团的统治之下，如果我们认为垄断大企业的管理层也是一种准官僚集团的话。</p><p>统治阶级争夺被统治阶级的时候，彼此是仇敌。一旦一方彻底认输，统治阶级内部的阶级感情又重新油然而生。</p><p>并不是衣食足不足的问题，而是达到一个社会阶层之后，对普通劳动者紧缺的生活必需品，对某个阶层中人已经不再是紧缺的，而是极大丰富的。对普通人来说很珍贵的东西，对这个层次上的人来说，已经不值得为此发生冲突了。为这些基本生活必需品发生冲突，对这个层面的人来说，是丢脸的事情。这个层次的稳拿，在彼此谦逊礼貌的气氛中，瓜分着社会总产品的大饼。底层之间争斗的越激烈，顶层吃到的大饼份额越多。</p><p>如果要维护人类社会系统的长期存在就必须从两个方面着手：第一，为领导阶层引入新鲜血液，避免小范围通婚造成的种群退化；第二，破解财富的单向流动过程，避免财富过度集中导致社会内部压力持续上升。</p><p>由于强者恒强，任何人类社会的终极形态，不论是官僚主动或者资本家主动，地主主导或者奴隶主主导，<strong>如果不干涉的话，都是通往奴役之路</strong>。</p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://img14.360buyimg.com//n0/jfs/t1/176451/22/10402/376750/60a37fb7E23ecc0e3/aa8754102dc19767.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;此书讲什么&quot;&gt;&lt;a href=&quot;#此书讲什么&quot; class=&quot;headerlink&quot; title=&quot;此书讲什么&quot;&gt;&lt;/a&gt;此书讲什么&lt;/h1&gt;&lt;p&gt;马克思《资本论》讲的三件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原始积累靠暴力&lt;/li&gt;
&lt;li&gt;贫富差距会扩大&lt;/li&gt;
&lt;li&gt;最终自毁&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;经济与政治&quot;&gt;&lt;a href=&quot;#经济与政治&quot; class=&quot;headerlink&quot; title=&quot;经济与政治&quot;&gt;&lt;/a&gt;经济与政治&lt;/h1&gt;&lt;p&gt;经济学是有阶级属性的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="读书" scheme="https://cuipengfei.is-a.dev/tags/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="经济" scheme="https://cuipengfei.is-a.dev/tags/%E7%BB%8F%E6%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>一些关于银行的散碎知识</title>
    <link href="https://cuipengfei.is-a.dev/blog/2022/01/29/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E9%93%B6%E8%A1%8C%E7%9A%84%E6%95%A3%E7%A2%8E%E7%9F%A5%E8%AF%86/"/>
    <id>https://cuipengfei.is-a.dev/blog/2022/01/29/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E9%93%B6%E8%A1%8C%E7%9A%84%E6%95%A3%E7%A2%8E%E7%9F%A5%E8%AF%86/</id>
    <published>2022-01-29T06:40:50.000Z</published>
    <updated>2022-01-29T06:40:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="金本位时期金融机构的层级结构"><a href="#金本位时期金融机构的层级结构" class="headerlink" title="金本位时期金融机构的层级结构"></a>金本位时期金融机构的层级结构</h2><p>19th century nation state financial institution hierarchy </p><p><img data-src="/images/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E9%93%B6%E8%A1%8C%E7%9A%84%E6%95%A3%E7%A2%8E%E7%9F%A5%E8%AF%86/Untitled.png" alt="Untitled"></p><p>央行的负债≈银行的资产≈货币</p><p>银行的负债≈私营部门的资产≈存款</p><h2 id="亏钱先亏哪儿？"><a href="#亏钱先亏哪儿？" class="headerlink" title="亏钱先亏哪儿？"></a>亏钱先亏哪儿？</h2><p><img data-src="/images/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E9%93%B6%E8%A1%8C%E7%9A%84%E6%95%A3%E7%A2%8E%E7%9F%A5%E8%AF%86/Untitled1.png" alt="Untitled"></p><p>假设左侧亏了5块钱，且左右必须平，则右侧也必须减少5。</p><p>不能先减liability，因为债权人优先级较高，只能先减equity。</p><h2 id="Liquidity和Solvency"><a href="#Liquidity和Solvency" class="headerlink" title="Liquidity和Solvency"></a>Liquidity和Solvency</h2><p><img data-src="/images/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E9%93%B6%E8%A1%8C%E7%9A%84%E6%95%A3%E7%A2%8E%E7%9F%A5%E8%AF%86/Untitled2.png" alt="Untitled"></p><p>cash reserve &gt; 0，则具有一定的流动性</p><p>net worth &gt; 0，则具有一定的偿付能力</p><p>流动性和偿付能力的高低则取决于到底比零大多少。</p><h2 id="资金来源"><a href="#资金来源" class="headerlink" title="资金来源"></a>资金来源</h2><p><img data-src="/images/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E9%93%B6%E8%A1%8C%E7%9A%84%E6%95%A3%E7%A2%8E%E7%9F%A5%E8%AF%86/Untitled3.png" alt="Untitled"></p><p>活期存款 (Demand deposit)</p><p>存款证书&#x2F;大额存单 (Certificate of deposit)</p><p>附买回协议（repurchase agreement、repo，也称为附买回协定、附买回交易，回购协议、卖出回购或正回购）</p><p>商业票据（Commercial Paper）</p><p><strong>负债业务</strong>是商业银行形成资金来源的业务</p><p><strong>存款</strong>是银行<strong>对存款人的负债</strong>，是银行最<strong>主要的资金来源</strong></p><h2 id="四种风险"><a href="#四种风险" class="headerlink" title="四种风险"></a>四种风险</h2><p>银行的风险种类较多，最主要的风险有四种：</p><p><strong>信用风险、市场风险、流动性风险和操作风险</strong> </p><p><strong>信用风险</strong>是指借款人因各种原因未能及时、足额偿还债务或银行贷款而违约的可能性。发生违约时，债权人或银行必将因为未能得到预期的收益而承担财务上的损失。 </p><p><strong>市场风险</strong>是指未来市场价格（利率、汇率、股票价格和商品价格）的不确定性对企业实现其既定目标的影响 </p><p><strong>流动性风险</strong>是指因市场成交量不足或缺乏愿意交易的对手，导致未能在理想的时点完成买卖的风险；或银行本身掌握的流动资产不能满足即时支付到期负债的需要，从而使银行丧失清偿能力和造成损失的可能性。 流动性风险，一方面是一种<strong>本原性</strong>风险，是由于流动性不足造成的；另一方面也是最常见的情况，是其他各类风险长期隐藏、积聚，最后以流动性风险的形式爆发出来。从这种意义上讲，流动性风险是一种<strong>派生性</strong>风险，即流动性不足，可能是由于利率风险、信用风险、经营风险、管理风险、法律风险、国家风险、汇率风险等风险源所造成的，银行最终陷入流动性风险中不能自拔。 </p><p><strong>操作风险</strong>的正式定义是：由于内部程序、人员和系统的不完备或失效，或由于外部事件造成损失的风险</p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;金本位时期金融机构的层级结构&quot;&gt;&lt;a href=&quot;#金本位时期金融机构的层级结构&quot; class=&quot;headerlink&quot; title=&quot;金本位时期金融机构的层级结构&quot;&gt;&lt;/a&gt;金本位时期金融机构的层级结构&lt;/h2&gt;&lt;p&gt;19th century nation state financial institution hierarchy &lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;/images/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E9%93%B6%E8%A1%8C%E7%9A%84%E6%95%A3%E7%A2%8E%E7%9F%A5%E8%AF%86/Untitled.png&quot; alt=&quot;Untitled&quot;&gt;&lt;/p&gt;
&lt;p&gt;央行的负债≈银行的资产≈货币&lt;/p&gt;
&lt;p&gt;银行的负债≈私营部门的资产≈存款&lt;/p&gt;
&lt;h2 id=&quot;亏钱先亏哪儿？&quot;&gt;&lt;a href=&quot;#亏钱先亏哪儿？&quot; class=&quot;headerlink&quot; title=&quot;亏钱先亏哪儿？&quot;&gt;&lt;/a&gt;亏钱先亏哪儿？&lt;/h2&gt;</summary>
    
    
    
    
    <category term="银行" scheme="https://cuipengfei.is-a.dev/tags/%E9%93%B6%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>TW十四载</title>
    <link href="https://cuipengfei.is-a.dev/blog/2021/12/17/tw14years/"/>
    <id>https://cuipengfei.is-a.dev/blog/2021/12/17/tw14years/</id>
    <published>2021-12-17T06:40:50.000Z</published>
    <updated>2021-12-17T06:40:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>2007年，我在读大二。</p><p>当时经常会去学校食堂对面的报刊亭买杂志，一本，是《大众软件》，另一本，是《程序员》。</p><img data-src="/images/14years/cxy-2007-06.png"/><p>印象中当时《程序员》上的多数文章充满了我没听过的各种缩写与稀奇古怪的名词，文风是老成持重，我看不懂，但很是佩服。</p><p>而这当中偶尔会夹杂着几篇文风犀利，睥睨天下的文章，加上作者头像很是非主流，我虽也看不懂，但印象深刻。<br>这些犀利文章的作者，便经常冠有TW的头衔。</p><p>2012年，我在一家小软件公司上了两年的班。<br>当时我们每半年发布一个版本，每到要发布前夕，程序员便都停止写代码，去做回归测试。</p><p>经常会发现半年前发布时还是ok的功能，在这六个月里被改错了，得修。<br>我隐隐觉得这不对劲，再六个月之后还是会出现类似的状况，老是靠大家停工去做回归测试不是个办法，我们总是会“狗熊掰棒子，掰一根丢一根”。</p><img data-src="/images/14years/gxbbz.png"/><p>恰在此时，邮箱收到了来自TW的面试邀请。<br>到了这会，我其实已经记不清楚大学时看的《程序员》杂志上有什么内容了，不过TW这个名字还是有些印象。<br>再去一查，这家公司还出过不少书，推崇做自动化测试，注重软件质量，而这些正是我当时所在的小公司所缺乏的。</p><p>于是便接受了面试邀请，做了Mars Rover的题目，去参加了办公室面试。<br>面试时还见到了《软件设计精要与模式》的作者。<br>之后便加入TW成为了一名21世纪的程序员。</p><p>从第一次看到《程序员》杂志上的文章到眼下的2021年，有14年了。<br>14年挺长的，从上小学到高中毕业，也才12年。</p><p>时间跨度长，变化也就多，不过当时持有的很朴素的观念不太容易变：<br>软件至少要做对，一旦做对了之后，要避免“狗熊掰棒子，掰一根丢一根”。</p><p>就好像一个木匠师傅，用了锛凿斧锯，费力做成了板凳，肯定是不希望这个凳子给人坐了两天之后就开始“嘎吱吱”。</p><p>码匠师傅，亦当如是。</p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;2007年，我在读大二。&lt;/p&gt;
&lt;p&gt;当时经常会去学校食堂对面的报刊亭买杂志，一本，是《大众软件》，另一本，是《程序员》。&lt;/p&gt;
&lt;img data-src=&quot;/images/14years/cxy-2007-06.png&quot;&gt;

&lt;p&gt;印象中当时《程序员》上的多数文章充满了我没听过的各种缩写与稀奇古怪的名词，文风是老成持重，我看不懂，但很是佩服。&lt;/p&gt;
&lt;p&gt;而这当中偶尔会夹杂着几篇文风犀利，睥睨天下的文章，加上作者头像很是非主流，我虽也看不懂，但印象深刻。&lt;br&gt;这些犀利文章的作者，便经常冠有TW的头衔。&lt;/p&gt;
&lt;p&gt;2012年，我在一家小软件公司上了两年的班。&lt;br&gt;当时我们每半年发布一个版本，每到要发布前夕，程序员便都停止写代码，去做回归测试。&lt;/p&gt;</summary>
    
    
    
    
    <category term="TW" scheme="https://cuipengfei.is-a.dev/tags/TW/"/>
    
  </entry>
  
  <entry>
    <title>《大目标》一书中的有趣观点</title>
    <link href="https://cuipengfei.is-a.dev/blog/2020/07/05/%E5%A4%A7%E7%9B%AE%E6%A0%87/"/>
    <id>https://cuipengfei.is-a.dev/blog/2020/07/05/%E5%A4%A7%E7%9B%AE%E6%A0%87/</id>
    <published>2020-07-05T04:23:28.000Z</published>
    <updated>2020-07-05T04:23:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>工业化、现代化、城市化、民主化、自由化、市场化、全球化，不一定要姓“西、资、基”。</p><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><p>五常的否决权是对大国毁灭性力量的承认。核武器，氢弹，洲际导弹，核潜艇，多弹头分导。</p><p>退缩不会让狼群放弃供给，逃跑不会让狼群放弃追捕，倒下不会让狼群放弃杀戮。</p><p>大国没资格投降。</p><p>美国对日本可以援引《共同防卫协定》只会日本空军。韩国三军的最高指挥权本来就归美军。</p><p>冷战的本质是3.5亿的苏联东欧工业人口和欧美日6亿的工业人口抢全球的资源和市场。</p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><p>把人当人看是工业社会才能做到的事。医疗器具，消毒不再昂贵，简单高效。<br>当物质上的富足让社会不再需要合理合法地牺牲掉一些人而保证另一些人的生存时，才能进入文明。</p><p>1962年，中国粮食总产量1.6亿吨。1978年3亿吨。不是靠积极性。而是靠化肥。<br>化肥让农民有了余粮和闲暇，从农业中解放出来的生产力投入工业。</p><p>工业化：用机器造机器，然后用造出来的机器去造别的东西。</p><p>世界上勤俭的不止有中国人，勤俭了几千年也没有变的富裕。工业化才能让勤俭变成资本。</p><p>李鸿章去找“造器之器”，是找造火器的机器，而不是造机器的机器。</p><p>机器用钢铁造的，用的是煤炭或者煤炭生成的电能。欧盟来源于煤钢共同体。</p><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><p>美国“绿卡战士”的阵亡率比美籍士兵高出一倍。</p><p>钱并不是财富，说“有钱”其实意味着“有货”。</p><p>美元作为结算货币收全球铸币税。各国越小，产业链越分散，美元铸币税收的越开心。</p><p>经济活动的本质是物质生产。</p><p>枪杆子里面出石油。</p><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><p>工业与手工业的最大区别：工业可以升级。</p><p>西班牙，英国，美国，三个世界性的大帝国。<br>兴起的原因是先进的生产技术，发达的制造业能创造财富也支持了强大的军队。<br>然后不劳而获，停滞衰退。</p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><p>与之前的强国相比，苏联的工业化不依赖殖民地的市场和资源。</p><p>重工业是核心，轻工业释放重工业制造的生产能力。</p><p>苏联利用西方几次危机，抄底技术与设备。</p><p>工业化人口数量决定了工业经济的规模，也和工业体系的复杂程度和先进程度密切相关。<br>独立工业体系需要的工业化人口数量是基本配件数量的5到10倍。<br>欧洲走向一体化的原因就在于此。</p><p>苏联的崩溃说到底是因为美国用自己的人口优势率先完成了产业升级。</p><p>在战略对抗中，要掌握比对手更多的工业化人口，要向盟友输出工业化社会，通过输出工业化社会来制造盟友。否则早晚遇到工业升级的人口障碍。</p><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><p>一切强权、帝国在工业革命面前都是过眼云烟。</p><p>终结大英帝国的是第二次工业革命。</p><p>中国不能靠出口来长期支持我们的工业化进程了。</p><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><p>没有人会把太监叫做绅士。</p><p>保持不断的进步才能有道理可以讲。</p><p>输出工业化是个长久的买卖，比输出消费品要长久。</p><p>现在一个地市级的地勘力量比工业化之前全国合集还多。</p><p>买办是第一障碍。</p><p>要输出工业化，而不是像殖民主义那样打击当地工业发展。</p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h1&gt;&lt;p&gt;工业化、现代化、城市化、民主化、自由化、市场化、全球化，不一定要姓“西、资、基”。&lt;/p&gt;
&lt;h1 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h1&gt;&lt;p&gt;五常的否决权是对大国毁灭性力量的承认。核武器，氢弹，洲际导弹，核潜艇，多弹头分导。&lt;/p&gt;
&lt;p&gt;退缩不会让狼群放弃供给，逃跑不会让狼群放弃追捕，倒下不会让狼群放弃杀戮。&lt;/p&gt;
&lt;p&gt;大国没资格投降。&lt;/p&gt;</summary>
    
    
    
    
    <category term="工业党" scheme="https://cuipengfei.is-a.dev/tags/%E5%B7%A5%E4%B8%9A%E5%85%9A/"/>
    
  </entry>
  
  <entry>
    <title>软件需求膨胀系数</title>
    <link href="https://cuipengfei.is-a.dev/blog/2020/05/22/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%86%A8%E8%83%80/"/>
    <id>https://cuipengfei.is-a.dev/blog/2020/05/22/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%86%A8%E8%83%80/</id>
    <published>2020-05-22T04:32:38.000Z</published>
    <updated>2020-05-22T04:32:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="泡水膨胀球"><a href="#泡水膨胀球" class="headerlink" title="泡水膨胀球"></a>泡水膨胀球</h1><img data-src="/images/需求膨胀/膨胀球.jpg" alt="drawing" width="500"/><p>这是一种小玩具，干燥时拿在手里，小巧紧致。</p><p>泡在水里，一段时间之后，浑圆饱满，一只手都未必能捧的住。</p><p>放在干燥通风的地方晾晒，一段时间过后，又可以恢复原本的大小。</p><h1 id="软件需求"><a href="#软件需求" class="headerlink" title="软件需求"></a>软件需求</h1><p>软件需求与泡水膨胀球也有类似之处。</p><p>一开始时看似简单明了且完备正交，做起来发现<strong>越做越大，越做越多</strong>。</p><p>原本一只手能抓好几个的小球，后来变成两只手都抓不住一个。</p><p>然后的结果要么是超预算多花钱做完，要么是转嫁成本给乙方要求对方做完，要么是延期，要么是痛苦地去压缩需求。</p><p>无论哪种，都是<strong>不健康</strong>的。</p><h1 id="膨胀系数"><a href="#膨胀系数" class="headerlink" title="膨胀系数"></a>膨胀系数</h1><p>小球泡在水里会膨胀，暴露于干燥环境中会缩小。</p><p>这个过程可以用一个简化模型来表示：</p><p><em><strong>膨胀系数 ≈ 吸水力 - 斥水力</strong></em></p><p><em><strong>小球体积 ≈ 初始体积 + 膨胀系数 x 时间</strong></em></p><p>当吸水力大于斥水力时，膨胀系数为正数，在时间的作用下，球会膨胀。<br>当斥水力大于吸水力时，膨胀系数为负数，在时间的作用下，球会缩小。<br>当两个力接近相互<strong>平衡</strong>时，膨胀系数约等于零，在时间的作用下，小球体积趋于<strong>稳定</strong>。</p><h1 id="我们希望看到小球体积怎样变化？"><a href="#我们希望看到小球体积怎样变化？" class="headerlink" title="我们希望看到小球体积怎样变化？"></a>我们希望看到小球体积怎样变化？</h1><p>一直变肥？那不行。做软件是有成本的，时间人力都是成本。</p><p>持续变瘦？也不行。需求受到过分压抑也是不健康的。</p><p>健康的变化过程应该是：<br>先让小球丰满起来（充分收集需求，以免后面出现始料未及的“惊喜”）<br>然后削减多余的赘肉（使用奥卡姆剃刀）<br>之后长期维持健康范围内的波动</p><h1 id="力的阶段性施加策略"><a href="#力的阶段性施加策略" class="headerlink" title="力的阶段性施加策略"></a>力的阶段性施加策略</h1><p>时间的流逝是不受我们控制的，因而想要控制体积就要从膨胀系数下手。</p><p>而膨胀系数又与两个力相关，因而<strong>想要控制体积就要控制吸水力与斥水力</strong>。</p><img data-src="/images/需求膨胀/二力.png"/><p>首先让吸水力尽情释放，这时斥水力<strong>蛰伏</strong>着<strong>静待</strong>吸水力的<strong>衰减</strong>。<br>之后斥水力爬坡，达到与吸水力持平的水准，二者长期和平共处。</p><p>当我们如上使用这两种力的时候，小球体积的变化就会是这样的：</p><img data-src="/images/需求膨胀/体积变化.png"/><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>调研阶段积极创造<strong>环境</strong>来让吸水力得以<strong>释放</strong>，先允许小球变肥。然后施加一定的斥水力，让小球苗条下来。</p><p>到了研发阶段，由于吸水力在之前就已经得到了有效的<strong>释放</strong>，这时施加适量的斥水力来平衡<strong>所剩无几</strong>的吸水力就能让小球体积的波动维持在<strong>可控</strong>的范围内。</p><p>在不同的阶段有策略地利用这两种力，则可以趋近<strong>前期需求收集充分考虑各方诉求</strong>不留大的隐患，后续研发稳定<strong>不坐过山车</strong>的目的。</p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;泡水膨胀球&quot;&gt;&lt;a href=&quot;#泡水膨胀球&quot; class=&quot;headerlink&quot; title=&quot;泡水膨胀球&quot;&gt;&lt;/a&gt;泡水膨胀球&lt;/h1&gt;&lt;img data-src=&quot;/images/需求膨胀/膨胀球.jpg&quot; alt=&quot;drawing&quot; width=&quot;500&quot;&gt;

&lt;p&gt;这是一种小玩具，干燥时拿在手里，小巧紧致。&lt;/p&gt;
&lt;p&gt;泡在水里，一段时间之后，浑圆饱满，一只手都未必能捧的住。&lt;/p&gt;
&lt;p&gt;放在干燥通风的地方晾晒，一段时间过后，又可以恢复原本的大小。&lt;/p&gt;
&lt;h1 id=&quot;软件需求&quot;&gt;&lt;a href=&quot;#软件需求&quot; class=&quot;headerlink&quot; title=&quot;软件需求&quot;&gt;&lt;/a&gt;软件需求&lt;/h1&gt;</summary>
    
    
    
    
    <category term="需求" scheme="https://cuipengfei.is-a.dev/tags/%E9%9C%80%E6%B1%82/"/>
    
  </entry>
  
</feed>

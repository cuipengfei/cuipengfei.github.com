---
title: C#中的语言特性都是从何而来？
date: 2011-03-06 16:01:00
tags: 《你必须知道的.NET》
---

前几天推荐一个同事用“可选参数”，推荐完了我还画蛇添足的说这是.Net 4中的新特性。但是事后才发现这个新特性是C# 4.0的语言特性，与.Net
4无关。其实也不只这一次，我平时也经常把语言、框架、运行时，有时甚至还有开发工具混为一谈。于是今天就总结一下C#中我感兴趣的几个语言特性是从何而来的。

** 1.可选参数  **

可选参数是C# 4.0中的新特性，其作用在于在调用者不提供参数值时给参数一个默认值，用起来是这样的：

    static void Main(string[] args)


    {


        TestMethod();


        TestMethod(10);


     


        Console.ReadLine();


    }


     


    public static void TestMethod(int parameter = 5)


    {


        Console.WriteLine(parameter);


    }

以上的代码在第一次调用TestMethod时输出5，第二次输出10，也就是在没有给TestMethod提供参数值时，会自动以5作为参数值。

该特性的实现依赖于OptionalAttribute和DefaultParameterValueAttribute这两个attribute，也就是说Test
Method这个方法完全可以声明为这样：

    public static void TestMethod([Optional, DefaultParameterValue(5)] int parameter)
    {
        Console.WriteLine(parameter);
    }

而跑起来的结果是一样的。

OptionalAttribute和DefaultParameterValueAttribute这两个attribute分别是在.Net 1.1和.Net
2.0中引入的，也就是说N年前大家就可以写拥有“可选参数”的方法了，只是用起来没有现在这么爽。

只要您安装了.Net Framework 4.0（也就是说有了其中附带的新版的C#编译器），您就可以编写如上的代码而同时把target
framework指定为.Net Framework 2.0到.Net Framework 4之间的任何版本。

小总结：我在这个问题上犯的错误就在于将语言和框架混为一谈了。C#语言的第四版和.Net Framework的第四版一起发布，于是我就理所当然的认为C#
4.0中的新特性和.Net Framework 4有关系了。其实，只要微软的人愿意，他们完全可以在.Net Framework 2.0发布之后和.Net
Framework 4.0发布之前的任意时间发布一款CTP的编译器来实现这一语言性特性，正如他们前不久发布的Asyn CTP一样。

** 2.var关键字  **

var关键字是在C# 3.0中引入的，其作用在于在声明局部变量时无需指定具体类型，用起来是这样的：

    var str = "hello";
    Console.WriteLine(str);

其结果和把var替换为string完全一样。

这个语言特性看似鸡肋，实际上它的好处在于接收LinQ语句的返回值，比如说Enumerable.GroupBy的某几个重载的返回值是IEnumerable<I
Grouping<TKey, TElement>>，如果每次用到group by的时候都需要写这么长的一串代码的话，那玩儿LinQ的快感想必是要降低不少呀。

这个语言特性的实现要比可选参数简单一些，无需框架的支持，完全是语言规范和编译器的“合谋”。编译器在编译时根据赋值语句推断出真实的类型，编译出的IL中完全没有
var的身影。

** 3.泛型  **

泛型是C# 2.0中新增的特性，也是.Net 2.0中的新特性。没有错，这次终于可以说它是.Net的新特性了，但是也只是.Net而不是.Net
Framework。

在C#语言层面实现泛型需要CLR的支持，可以说它是.Net世界中的一等公民，IL甚至为它修改了语法。

比如说如下的类型声明：

    public class TestClass<T>

在编译为IL之后是这样的：

    .class public auto ansi beforefieldinit TestClass<T>
        extends [mscorlib]System.Object

可见IL中新增了尖括号的用法。

以上三个语言特性都比较典型。var关键字纯粹是语言层面的小甜头，只要有了能够理解var的编译器，使用哪个版本的CLR或者.Net
Framework完全无所谓。

可选参数需要编译器能理解参数名后面的赋值语句，同时也需要.Net Framework中提供的attribute的支持。

泛型同时需要CLR和编译器的支持。

如果列一张表的话，就是下面这样的：

语言特性

实现该特性需要的支持

var关键字

CLR（ ![red_cross_45.gif](http://vzochat.com/zh/images/icons/red_cross_45.gif)
） 框架（ ![red_cross_45.gif](http://vzochat.com/zh/images/icons/red_cross_45.gif)
） 编译器（ ![studio_check.gif](http://www.articulate.com/images/studio_check.gif)
）

可选参数

CLR（
![red_cross_45.gif](http://vzochat.com/zh/images/icons/red_cross_45.gif)

） 框架（
![studio_check.gif](http://www.articulate.com/images/studio_check.gif)
 ）
编译器（
![studio_check.gif](http://www.articulate.com/images/studio_check.gif)
 ）

泛型

CLR（
![studio_check.gif](http://www.articulate.com/images/studio_check.gif)
 ）
框架（
![red_cross_45.gif](http://vzochat.com/zh/images/icons/red_cross_45.gif)
 ）
编译器（
![studio_check.gif](http://www.articulate.com/images/studio_check.gif)
 ）

上表中每一项的编译器都打上了钩儿。很显然，每一项语法层面的特性都需要编译器的支持，要不然语言规范就只是一纸空文了。在这里还是把它列出来，仅求全面。

写完之后自己看一遍，觉得很是有考据癖的老学究味道。微软总是把开发工具、框架类库、运行时和编译器的新版本一起发布，所以我们总是被弄得很被动，总是搞不清这几者之
间区别。其实有时候把这些东西区分开来去观察，更有利于解释一些困惑。

当然，最后的表格中列出的东西还是太少了，希望各位补充啊。

PS：请问CSDN的工作人员一个问题，为什么用Live Writer发布的文章一开始排版，格式都是正确的，只要编辑时勾上推荐到首页的选项格式就全乱了呢

？

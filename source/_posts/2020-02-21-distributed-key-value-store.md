---
title: "分布式键值存储（Distributed Key-Value Store）"
date: 2020-02-21 20:54:15
tags:
- Reactive
---

# 前言

分布式键值存储（Distributed Key-Value Store）并不是一个新鲜的玩意。
常见的Redis，Memcache等等也有很多地方用到。

不过如果要是说其中的细节，如replicate，读写，一致性，retry等等的话，又是经常会遇到混淆不清。
恰巧我最近在看的一门网课《Programming Reactive Systems》中有一道作业题就是要自己实现一个Distributed Key-Value Store，那就正好借此机会详细写下其中的关键点。

# 关键参与者

既然是分布式键值存储，那么肯定会有主从节点，每个结点又会有自己的持久化，而主从之间也需要协调，于是就得出了如下关键参与者：

+ **Primary replica**： 主节点。接受来自client的更新（写/删）操作，并把更新后的数据扩散到其他节点。当然，也可以接受来自于client的读操作。
+ **Secondary replicas**： 从节点。接受来自主节点的更新操作。接受来自client的制度操作。
+ **Arbiter**： 仲裁者。任何节点，无论主从，都要把自己注册到arbiter上去。当有从节点加入或者离开集群的时候，arbiter负责告知主节点。
+ **Persistence**： 每个节点都拥有自己的独享的persistence。用于把节点上的数据持久化。
+ **Clients**： 客户端，可能与主或者从节点通信，进行各种读写操作。

## 参与者之间的粗略关系

[![](https://mermaid.ink/img/eyJjb2RlIjoiZ3JhcGggVERcbiAgUHJpbWFyeS0tPnzmianmlaPmlbDmja7liLB8U2Vjb25kYXJ5XG4gIFByaW1hcnktLT585rOo5YaM5YiwfEFyYml0ZXJcbiAgU2Vjb25kYXJ5LS0-fOazqOWGjOWIsHxBcmJpdGVyXG4gIFByaW1hcnktLT585oyB5LmF5YyW5Yiw54us5Lqr55qEfFBlcnNpc3RlbmNlXG4gIFNlY29uZGFyeS0tPnzmjIHkuYXljJbliLDni6zkuqvnmoR8UGVyc2lzdGVuY2VcbiAgQXJiaXRlci0tPnzpgJrnn6Xku47oioLngrnnmoTliqDlhaXmiJbnprvlvIB8UHJpbWFyeVxuICBDbGllbnQtLT585YaZL-ivu3xQcmltYXJ5XG4gIENsaWVudC0tPnzor7t8U2Vjb25kYXJ5IiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCIsImZsb3djaGFydCI6eyJjdXJ2ZSI6ImJhc2lzIn19fQ)](https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoiZ3JhcGggVERcbiAgUHJpbWFyeS0tPnzmianmlaPmlbDmja7liLB8U2Vjb25kYXJ5XG4gIFByaW1hcnktLT585rOo5YaM5YiwfEFyYml0ZXJcbiAgU2Vjb25kYXJ5LS0-fOazqOWGjOWIsHxBcmJpdGVyXG4gIFByaW1hcnktLT585oyB5LmF5YyW5Yiw54us5Lqr55qEfFBlcnNpc3RlbmNlXG4gIFNlY29uZGFyeS0tPnzmjIHkuYXljJbliLDni6zkuqvnmoR8UGVyc2lzdGVuY2VcbiAgQXJiaXRlci0tPnzpgJrnn6Xku47oioLngrnnmoTliqDlhaXmiJbnprvlvIB8UHJpbWFyeVxuICBDbGllbnQtLT585YaZL-ivu3xQcmltYXJ5XG4gIENsaWVudC0tPnzor7t8U2Vjb25kYXJ5IiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCIsImZsb3djaGFydCI6eyJjdXJ2ZSI6ImJhc2lzIn19fQ)

# 一些限制

我们并不是要做一个可以在Prod环境中使用的KV Store，而只是借助自己实现来厘清KV Store的一部分基础知识点，所以做出了如下的限制来简化实现：

+ 只有主节点可以写，所有从节点都只能读
+ 假设主节点是稳定可靠的，不会挂（不处理主节点身份转移）
+ 假设arbiter是可靠的，不会挂
+ 不处理背压（back pressure）
+ 更新操作有可能只是部分成功的，部分从节点有可能未成功拿到更新
+ 客户端使用的请求id（稍后会提到）是不会重复的

# 各参与者的职责及相互交互



## Arbiter

[![](https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgTm9kZSAxLT4-K0FyYml0ZXI6IEpvaW5cbiAgICBOb2RlIDItPj4rQXJiaXRlcjpKb2luXG4gICAgTm9kZSAzLT4-K0FyYml0ZXI6Sm9pblxuICAgIEFyYml0ZXItLT4-K05vZGUgMTogSm9pbmVkUHJpbWFyeVxuICAgIEFyYml0ZXItLT4-K05vZGUgMjogSm9pbmVkU2Vjb25kYXJ5XG4gICAgQXJiaXRlci0tPj4rTm9kZSAxOiBSZXBsaWNhcyhOb2RlIDIpXG4gICAgQXJiaXRlci0tPj4rTm9kZSAzOiBKb2luZWRTZWNvbmRhcnlcbiAgICBBcmJpdGVyLS0-PitOb2RlIDE6IFJlcGxpY2FzKE5vZGUgMylcblxuIiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCIsImZsb3djaGFydCI6eyJjdXJ2ZSI6ImJhc2lzIn19LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ)](https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgTm9kZSAxLT4-K0FyYml0ZXI6IEpvaW5cbiAgICBOb2RlIDItPj4rQXJiaXRlcjpKb2luXG4gICAgTm9kZSAzLT4-K0FyYml0ZXI6Sm9pblxuICAgIEFyYml0ZXItLT4-K05vZGUgMTogSm9pbmVkUHJpbWFyeVxuICAgIEFyYml0ZXItLT4-K05vZGUgMjogSm9pbmVkU2Vjb25kYXJ5XG4gICAgQXJiaXRlci0tPj4rTm9kZSAxOiBSZXBsaWNhcyhOb2RlIDIpXG4gICAgQXJiaXRlci0tPj4rTm9kZSAzOiBKb2luZWRTZWNvbmRhcnlcbiAgICBBcmJpdGVyLS0-PitOb2RlIDE6IFJlcGxpY2FzKE5vZGUgMylcblxuIiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCIsImZsb3djaGFydCI6eyJjdXJ2ZSI6ImJhc2lzIn19LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ)

来的早的会被arbiter当作primary，来的晚的就是secondary了。
并且，每一个来的晚的成为secondary之后，arbiter还会告知primary说：来新节点了。以便primary可以知道后续需要把数据扩散给谁。

## Persistence

[![](https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgTm9kZSAtPj4rUGVyc2lzdGVuY2U6IFBlcnNpc3Qoa2V5LHZhbHVlLGlkKVxuICAgIFBlcnNpc3RlbmNlLS0-PitOb2RlOiBQZXJzaXN0ZWQoa2V5LGlkKSBvciBub3RoaW5nIiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCIsImZsb3djaGFydCI6eyJjdXJ2ZSI6ImJhc2lzIn19LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ)](https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgTm9kZSAtPj4rUGVyc2lzdGVuY2U6IFBlcnNpc3Qoa2V5LHZhbHVlLGlkKVxuICAgIFBlcnNpc3RlbmNlLS0-PitOb2RlOiBQZXJzaXN0ZWQoa2V5LGlkKSBvciBub3RoaW5nIiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCIsImZsb3djaGFydCI6eyJjdXJ2ZSI6ImJhc2lzIn19LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ)

前面提到过，每个节点，无论主从，都有一个自己独享的persistence。所以上图中的Node兼指主或者从节点。
Persistence本身的职责很简单，把Node告诉它的数据持久化下来。
但是，此处我们并没有假设持久化总是可靠的，所以上图中的第二根线是有可能不会发生的。

## Node

[![](https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgTm9kZSAtPj4rQXJiaXRlcjpKb2luXG4gICAgTm9kZSAtPj4rTm9kZTogUmV0cnkgUGVyc2lzdCBldmVyeSAxMDBtc1xuICAgIEFyYml0ZXItLT4-K05vZGU6Sm9pbmVkIFByaW1hcnkgb3IgU2Vjb25kYXJ5XG4gICAgIiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCIsImZsb3djaGFydCI6eyJjdXJ2ZSI6ImJhc2lzIn19LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ)](https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgTm9kZSAtPj4rQXJiaXRlcjpKb2luXG4gICAgTm9kZSAtPj4rTm9kZTogUmV0cnkgUGVyc2lzdCBldmVyeSAxMDBtc1xuICAgIEFyYml0ZXItLT4-K05vZGU6Sm9pbmVkIFByaW1hcnkgb3IgU2Vjb25kYXJ5XG4gICAgIiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCIsImZsb3djaGFydCI6eyJjdXJ2ZSI6ImJhc2lzIn19LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ)

这里的Node兼指主或者从节点。也就是说上图中的事情是每个Node无论主从都要做的。
每一个Node，在它生命周期的最早开始作的第一件事就是告诉Arbiter：“我来了“。

上面提到过，Persistence未必总是可靠的。所以每个Node一旦开始存活，就会给自己启动一个定时任务，每隔100ms就去retry persist，直到Persitence回话说Persisted为止。

## Secondary

[![](https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgUHJpbWFyeSAtPj4rU2Vjb25kYXJ5OlNuYXBzaG90KGtleSx2YWx1ZSxzZXEpXG4gICAgYWx0IHNlcT09ZXhwZWN0ZWRTZXFcbiAgICAgICAgU2Vjb25kYXJ5LT4-K1NlY29uZGFyeTogdXBkYXRlIGludGVybmFsIGt2IHN0b3JlXG4gICAgICAgIFNlY29uZGFyeS0-PitQZXJzaXN0ZW5jZTpQZXJzaXN0KGtleSx2YWx1ZSxzZXEpXG4gICAgZWxzZSBzZXE8ZXhwZWN0ZWRTZXFcbiAgICAgICAgU2Vjb25kYXJ5LT4-K1ByaW1hcnk6U25hcHNob3RBY2soa2V5LHNlcSlcbiAgICBlbmRcbiAgICAiLCJtZXJtYWlkIjp7InRoZW1lIjoiZm9yZXN0IiwiZmxvd2NoYXJ0Ijp7ImN1cnZlIjoiYmFzaXMifX0sInVwZGF0ZUVkaXRvciI6ZmFsc2V9)](https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgUHJpbWFyeSAtPj4rU2Vjb25kYXJ5OlNuYXBzaG90KGtleSx2YWx1ZSxzZXEpXG4gICAgYWx0IHNlcT09ZXhwZWN0ZWRTZXFcbiAgICAgICAgU2Vjb25kYXJ5LT4-K1NlY29uZGFyeTogdXBkYXRlIGludGVybmFsIGt2IHN0b3JlXG4gICAgICAgIFNlY29uZGFyeS0-PitQZXJzaXN0ZW5jZTpQZXJzaXN0KGtleSx2YWx1ZSxzZXEpXG4gICAgZWxzZSBzZXE8ZXhwZWN0ZWRTZXFcbiAgICAgICAgU2Vjb25kYXJ5LT4-K1ByaW1hcnk6U25hcHNob3RBY2soa2V5LHNlcSlcbiAgICBlbmRcbiAgICAiLCJtZXJtYWlkIjp7InRoZW1lIjoiZm9yZXN0IiwiZmxvd2NoYXJ0Ijp7ImN1cnZlIjoiYmFzaXMifX0sInVwZGF0ZUVkaXRvciI6ZmFsc2V9)

这里描述的是当Primary向Secondary扩散数据的时候，Secondary如何处理。

[![](https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgUGVyc2lzdGVuY2UtPj5TZWNvbmRhcnk6UGVyc2lzdGVkKGtleSxzZXEpXG4gICAgU2Vjb25kYXJ5LT4-UHJpbWFyeTpTbmFwc2hvdEFjayhrZXksc2VxKVxuICAgIFNlY29uZGFyeS0-PlNlY29uZGFyeTppbmNyZWFzZSBleHBlY3RlZFNlcVxuICAgIFNlY29uZGFyeS0-PlNlY29uZGFyeTpyZW1vdmUgc2VxIGZyb20gcmV0cnkgcGVyc2lzdCBsaXN0IiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCIsImZsb3djaGFydCI6eyJjdXJ2ZSI6ImJhc2lzIn19LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ)](https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgUGVyc2lzdGVuY2UtPj5TZWNvbmRhcnk6UGVyc2lzdGVkKGtleSxzZXEpXG4gICAgU2Vjb25kYXJ5LT4-UHJpbWFyeTpTbmFwc2hvdEFjayhrZXksc2VxKVxuICAgIFNlY29uZGFyeS0-PlNlY29uZGFyeTppbmNyZWFzZSBleHBlY3RlZFNlcVxuICAgIFNlY29uZGFyeS0-PlNlY29uZGFyeTpyZW1vdmUgc2VxIGZyb20gcmV0cnkgcGVyc2lzdCBsaXN0IiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCIsImZsb3djaGFydCI6eyJjdXJ2ZSI6ImJhc2lzIn19LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ)

这里描述的是，当Persistence告诉Secondary：“持久化好了“的时候，Secondary如何处理。
可以看出来，只有确认持久化完成之后，Secondary才会告诉Primary：“扩散数据好了“，并且在Secondary自己内部取消掉retry。

[![](https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgQ2xpZW50LT4-U2Vjb25kYXJ5OkdldChrZXksaWQpXG4gICAgU2Vjb25kYXJ5LT4-U2Vjb25kYXJ5OnF1ZXJ5IGludGVybmFsIGt2XG4gICAgU2Vjb25kYXJ5LS0-PkNsaWVudDpHZXRSZXN1bHQoa2V5LHZhbHVlLGlkKSAodmFsdWXlj6_og73mmK_nqbopIiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCIsImZsb3djaGFydCI6eyJjdXJ2ZSI6ImJhc2lzIn19LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ)](https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgQ2xpZW50LT4-U2Vjb25kYXJ5OkdldChrZXksaWQpXG4gICAgU2Vjb25kYXJ5LT4-U2Vjb25kYXJ5OnF1ZXJ5IGludGVybmFsIGt2XG4gICAgU2Vjb25kYXJ5LS0-PkNsaWVudDpHZXRSZXN1bHQoa2V5LHZhbHVlLGlkKSAodmFsdWXlj6_og73mmK_nqbopIiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCIsImZsb3djaGFydCI6eyJjdXJ2ZSI6ImJhc2lzIn19LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ)

对于来自于Client的读取操作，Secondary总是心直口快，有就是有，没有就是没有。

## Primary

[![](https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgUHJpbWFyeS0-PlByaW1hcnk6cmV0cnkgc25hcHNob3QgZXZlcnkgMTAwbXNcbiAgICAiLCJtZXJtYWlkIjp7InRoZW1lIjoiZm9yZXN0IiwiZmxvd2NoYXJ0Ijp7ImN1cnZlIjoiYmFzaXMifX0sInVwZGF0ZUVkaXRvciI6ZmFsc2V9)](https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgUHJpbWFyeS0-PlByaW1hcnk6cmV0cnkgc25hcHNob3QgZXZlcnkgMTAwbXNcbiAgICAiLCJtZXJtYWlkIjp7InRoZW1lIjoiZm9yZXN0IiwiZmxvd2NoYXJ0Ijp7ImN1cnZlIjoiYmFzaXMifX0sInVwZGF0ZUVkaXRvciI6ZmFsc2V9)

上面提到过，Persistence未必总是可靠的，也就意味着数据扩散操作也未必总是成功，所以，Primary一旦确定了自己的身份，就要开始一个定时任务来不断retry数据扩散操作。
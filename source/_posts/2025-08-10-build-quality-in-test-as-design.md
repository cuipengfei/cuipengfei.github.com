---
title: "把质量内建进设计：从“测试是负担”到“测试即设计”"
date: 2025-08-10 10:00:00 +0800
tags:
  [Build Quality In, Testability, TDD, BDD, Dependency Inversion, Composition]
---

> 业务复杂 ≠ 代码必然复杂。优秀的代码往往“平平无奇”，真正平衡的是设计与可测试性。

## 引言：为何“质量改进”举步维艰？

我们或许都经历过类似的场景：团队引入详尽检查清单、严格覆盖率红线与各类扫描工具；数个月后，大家忙于应付流程，质量本身却没有与投入成正比的提升。

问题往往不在于“执行不力”，而在于我们把质量活动放在了错误的时间与空间：设计已定型之后，测试才被动介入，只能沦为缺陷拦截的末端闸门。

因此，若测试持续滞后，它只能事后缝补缺陷，而无法及早塑形结构。

**本文主线：把质量从“外部检验”迁移为“内部设计属性”。**

---

测试的核心目的，是验证“设计是否合理”，而不仅仅是“代码是否正确”。

理解这一点，才解释得通：为什么很多“质量改进”看似动作频繁却收效甚微。

大量所谓失败的质量改进，其根源是**诊断偏差**：把“认知与方法”的缺口，误判为“态度与能力”的缺陷。

我们缺的往往不是意愿，而是对“质量必须被前置设计进去”的共识。

正因为测试目的被误读，我们才会不断叠加流程——模板、检查项、额外审批——却依旧缺乏演进信心。

把测试前置为设计反馈回路，才能释放团队在结构演化上的创造力。

Build Quality In（内建质量，指从设计、开发到交付各个环节，始终将可度量、可验证的质量目标固化为交付物的内在属性，不依赖于终极测试关卡。这一理念强调风险应前移并在流程中被分解，而不是留到最后集中暴露）

其真正含义是：每一环节交付的中间产物自带“可验证标准”，而不是把风险挤压到最后一轮集中测试。

换句话说：质量是过程属性，是**设计**出来的，而不是**扫**出来的。

![生成融合图像-(1)](<https://cuipengfei.github.io/picx-images-hosting/20250816/生成融合图像-(1).5xaykpra6p.png>)

---

## 职责重塑：从外包测试到设计内聚

| 组织形态 | 测试责任认知模型 | 质量结果 |
|------------------|------------------------------|----------------------|
| QA 独立负责 | 测试滞后，开发交付后转 QA | 被动、滞后、缺陷拦截 |
| 开发负责补测试 | 先开发后补测，验收焦点分离 | 补救性、反馈慢 |
| 测试即设计 | 设计推动测试、测试反推接口 | 主动、预防、结构性改进 |

当质量转化为设计属性，首个需要重构的就是“职责”认知：测试是开发者的职责，不是 QA 的专属。

当我们把测试外包，就在事实层面放弃了对结构与演进风险的直接控制权。

团队心智模型常沿着如下梯度演进，决定是否能真正进入“测试即设计”：

1. 测试是 QA 的事 → 代码能跑就行
2. 测试是开发的事 → 写完代码补测试
3. 质量是设计的事 → 用测试驱动设计（Test drives design，即通过测试行为倒逼模块接口、抽象和职责划分，从而推动更优的设计方案形成）

在职责澄清之后，另一高频误区是度量：覆盖率不是质量，“变更信心、缺陷密度、反馈周期”才是更健康的指标。

所谓行覆盖率远低于“语义覆盖”（此处“语义覆盖”指：通过测试验证系统对外业务契约/承诺时的可观察行为，而非仅仅关注代码执行路径）。

许多 90% 覆盖率的项目仍“动一处怕全局”，因为它们测的是“执行路径”，而非“业务承诺”。

---

## 设计原则：让复杂业务不制造复杂代码

【示例补充】以金融支付平台的订单系统为例，若将支付、库存、通知等流程完全耦合在一起，即使业务本身不复杂，代码却会变得无法维护。如下「反例」与「改进」对比直观说明结构优化的效果。

为了避免业务复杂度直接沉积为代码复杂度，我们需要两个结构支点：**可组合性（Composition，指系统组件能够灵活组合、复用以适应业务变化）** 与 **解耦（Decoupling，使模块/职责边界清晰，依赖关系暴露且可替换）**。

它们直接决定**可测试性（Testability，指模块是否能被独立、快速地验证其行为正确性）**。

可测试性可以看作优秀设计的副产物——当某段代码“难以被孤立 + 快速断言”时，问题通常不是“不会写测试”，而是“边界模糊 / 依赖隐藏”。

![图像生成提示词](https://cuipengfei.github.io/picx-images-hosting/20250816/图像生成提示词.4ub99tvgbv.png)

### 依赖倒置与构造注入

依赖倒置（DIP, Dependency Inversion Principle：让高层模块不依赖具体实现、仅依赖抽象接口，从而提升灵活性与可测试性）

构造注入（Constructor Injection，用显式传参而非内部直接实例化依赖，以便测试和扩展）

先看一个典型“隐式依赖”日常写法，随后用构造注入展示如何让依赖显式、可替换。

反例（内部直接创建依赖 → 紧耦合、难替换、难测）：

```java
// Anti-pattern: 内部创建依赖，紧耦合
public class OrderService {
    private final PaymentProcessor paymentProcessor = new PaymentProcessor();
    public void placeOrder(Order order) {
        paymentProcessor.process(order.getPaymentDetails());
    }
}
```

改进思路：将依赖抽象（高层仅依赖接口）并交由外部装配（构造注入）。

```java
// Better: 构造注入 + 依赖倒置（DIP）
@Service
public class OrderService {
    private final PaymentGateway payment;
    private final Inventory inventory;
    private final Notification notification;

    public OrderService(PaymentGateway payment, Inventory inventory, Notification notification) {
        this.payment = payment;
        this.inventory = inventory;
        this.notification = notification;
    }

    public void processOrder(Order order) {
        payment.charge(order.getAmount());
        inventory.reserve(order.getItems());
        notification.sendConfirmation(order.getEmail());
    }
}
```

为什么这能降复杂？因为：

- 可替换：测试中传入 Mock/Fake，环境可控。
- 可演进：实现可变而接口不变，测试稳定。
- 可理解：依赖图显式化，认知负荷更低。

这三点共同把变动半径压缩到装配层。

把对象创建权上移（构造注入）= 将“变动点”推到最外围；业务核心越“纯”，测试越“薄”。

![中国风概念插画](https://cuipengfei.github.io/picx-images-hosting/20250816/中国风概念插画.2a5ex6vhn1.png)

### 薄回调层，隔离框架复杂度

完成对象级依赖显式化后，第二类常见耦合源是“框架侵入业务”。策略：让 Controller 仅做“协议/IO → 领域调用”转发，避免领域逻辑渗入框架层，使业务在纯 Java 环境下即可单测。

简例：

```java
// Spring Controller
@RestController
class OrderController {
  private final OrderApplicationService app; // 纯业务服务
  OrderController(OrderApplicationService app){this.app = app;}
  @PostMapping("/orders")
  public OrderDTO place(@RequestBody OrderDTO dto){return app.place(dto.toDomain()).toDTO();}
}

// 纯业务（无框架依赖，可直接 new + 单元测试）
public class OrderApplicationService {
  private final OrderService domain;
  public OrderApplicationService(OrderService domain){this.domain = domain;}
  public Order place(Order order){return domain.process(order);}
}
```

测试时只需 `new OrderApplicationService` + Fake 依赖，无需启动 Spring。框架适配用少量集成测试覆盖外围即可。

### 减少 verify 依赖，回到可观察结果

减少脆弱测试的关键，不是写更精巧的 `verify`，而是回到“可观察结果 / 状态改变”本身。

否则测试与内部调用序列耦合，将在正常重构时碎裂。

正确做法：基于公共接口的可观察结果或状态变化断言。

```java
// 错误聚焦：实现细节
verify(paymentClient, times(1)).charge(any());

// 正确聚焦：业务行为
orderService.processOrder(order);
assertThat(order.getStatus()).isEqualTo(PROCESSED);
```

---

## 测试焦点：以对外行为契约取代内部调用序列

- 测什么：组件对外的行为契约（状态、返回值、对外交互语义），而不是它“怎么做”。
- 好处：重构自由度大、测试稳定、设计抽象度更高。
- 经验法则：能用一个 Given-When-Then 讲清楚的场景，就不要写“调用序列监视”。

示例（BDD/SbE）：

```gherkin
Feature: 订单处理
  Scenario: 成功处理有效订单
    Given 用户有一个包含商品的订单
    When 用户提交订单
    Then 订单状态为“已处理”
    And 用户收到确认邮件
```

“行为测试”好比：下单后只看结果——订单状态改变、邮件发送完成；“实现细节测试”好比：盯内部是否“恰好调用 X 一次”，一旦内部重构（拆分、合并、缓存）测试就会挂。

列出该功能对外可观察的 1~3 个结果，测试只断言这些；仅当结果不可直接观察时，再退而使用 `verify`。

这是前文所称“语义覆盖”的具体化——验证承诺，而非执行路径。

![图像生成提示词-(1)](<https://cuipengfei.github.io/picx-images-hosting/20250816/图像生成提示词-(1).1lc5d67ync.png>)

---

## 质量度量：从数字走向信心

回到先前的覆盖率错觉，我们需要以“交付风险信号”替换单一数字崇拜：

- 变更信心：修改后能否立即部署？
- 缺陷密度：每千行缺陷数随时间下降？
- 反馈周期：提交到发现问题的时间足够短？

这些指标直接反映测试是否在“护航设计”（支撑演进信心），而不仅是堆数字。

层次补充（避免“一把梭”）：

- 单元测试：纯领域 / 规则（最快，失败定位最精确）。
- 组件 / 集成测试：跨边界协作假设验证（接口契约 + 配置）。
- 端到端冒烟：关键业务旅程“有没有坏”。

所谓“测试金字塔倒置”现象（即依赖端到端测试堆砌而缺乏单元/集成测试），通常反映的是可测试性设计的缺席，而非纯粹测试数量不足。

### 快速回顾（Recap）

我们改变了什么：测试位置（后置 → 前置反馈）、职责心智（外包 → 设计内聚）。

我们采用什么结构支点：依赖倒置 + 可组合边界 + 薄框架适配层。

我们设计什么测试：行为契约（即关注系统对外可观察的业务承诺，而非内部实现细节）/ 语义覆盖，减少 verify 依赖。

我们用什么信号验证：变更信心、缺陷密度、反馈周期。

这些拼合成“一条最小闭环”：结构可组合 → 行为可观察 → 度量可反馈。

---

## 延伸与反思

几点可内化的"对照思考"：

1. 业务复杂 ≠ 代码必须复杂：遇到"看不懂的实现"时，可以先问问"是否把业务决策隐藏在技术细节里"。
2. 主要成本在修改：每次改动如果都需要"开启多人口头同步"才能放心发布，通常说明缺少可验证的自动化回归测试集。测试可以看作是摊平未来修改成本的"前置投资"。
3. 设计是持续活动：每加入一个特性，都值得重新检视"依赖是否最小化""边界是否清晰"以及"关键行为是否能被直接测试"。
4. 测试是一把尺：当你犹豫“是否需要抽象”时，可以问自己——这个抽象是否让关键行为的测试表达更短、更清晰？如果是，那么这个抽象通常是正确的方向。
5. 认知惯性 ≠ 技术难点：很多开发者感觉"写测试浪费时间"，往往是对“前置投入换取未来自由”这一逆直觉收益模型的抗拒。识别到这只是惯性后，可用“小步演示削减回归/调试时间”建立共识。

这些对照共同指向：让测试成为持续设计校准机制，而非末端裁决。

---

![生成融合图像](https://cuipengfei.github.io/picx-images-hosting/20250816/生成融合图像.8adl1x53f7.png)

## 结语

把测试从“末端审判”变成“设计工具”，把质量从“外部检查”变成“内部属性”。当我们用可组合设计、行为契约测试与清晰验收标准内建质量，复杂业务也能产出“平平无奇”且稳定可演进的代码。

将全文抽象为一个快速自检:

> 当前这次改动，如果我删掉所有 `verify` 调用，只保留对最终结果（状态/返回值/对外交互）的断言，测试是否仍清晰表达业务意图？若否，请回溯：依赖是否显式？行为是否可观察？测试是否覆盖契约而非路径？

若三个答案逐一补齐，质量就已在设计层被“写进去”。

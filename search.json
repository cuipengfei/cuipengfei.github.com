[{"title":"《编程之美——微软技术面试心得》“中国象棋的将帅问题”C#实现","url":"/blog/2008/07/02/%E3%80%8A%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E2%80%94%E2%80%94%E5%BE%AE%E8%BD%AF%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E5%BF%83%E5%BE%97%E3%80%8B%E2%80%9C%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B%E7%9A%84%E5%B0%86%E5%B8%85%E9%97%AE%E9%A2%98%E2%80%9DCSharp%E5%AE%9E%E7%8E%B0/","content":"《编程之美——微软技术面试心得》“中国象棋的将帅问题”C#实现\nclass Class1 &#123;\t\tstatic byte counter = 81;\t\tstatic void Main(string[] a) &#123;\t\twhile (counter-- != 0) &#123;\t\t\tif (counter / 9 % 3 == counter % 9 % 3)\t\t\t\tcontinue;\t\t\telse &#123;\t\t\t\tSystem.Console.WriteLine(&quot;a=&quot; + (counter / 9 + 1).ToString() + &quot;b=&quot; + (counter % 9 + 1).ToString());\t\t\t&#125;\t\t&#125;\t\t\t\tSystem.Console.Read();\t&#125;\t&#125;\n\n\n\n\n\n\n","tags":["《编程之美——微软技术面试心得》的C#实现"]},{"title":"编程之美 C#实现 1","url":"/blog/2008/07/02/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%20CSharp%E5%AE%9E%E7%8E%B0%201/","content":"适用于1.8GHZ左右的CPU 50%占用率\nclass ManageCpu &#123;\tstaticvoid Main(string[] a) &#123;\t\tint st = 0;\t\twhile (true) &#123;\t\t\tst = System.Environment.TickCount;\t\t\t\t\t\twhile (System.Environment.TickCount - st &lt; 90) &#123;\t\t\t&#125;\t\t\t\t\t\tSystem.Threading.Thread.Sleep(90);\t\t&#125;\t&#125;&#125;\n\n\n\n\n\n\n","tags":["《编程之美——微软技术面试心得》的C#实现"]},{"title":"策略模式的简单应用（C#）","url":"/blog/2008/07/30/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8%EF%BC%88CSharp%EF%BC%89/","content":"using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace ConsoleApplication1&#123;    abstract class OperSuper    &#123;        public abstract double GetResult(double a, double b);    &#125;    class Add : OperSuper    &#123;        public override double GetResult(double a, double b)        &#123;            return a + b;        &#125;    &#125;    class Minus : OperSuper    &#123;        public override double GetResult(double a, double b)        &#123;            return a - b;        &#125;    &#125;    class Context    &#123;        OperSuper os = null;        double A, B;        public Context(OperSuper o, double a, double b)        &#123;            os = o;            A = a;            B = b;        &#125;        public double GetResult()        &#123;            return os.GetResult(A, B);        &#125;    &#125;    class client    &#123;        public static void Main()        &#123;            Context c = new Context(new Add(), 10, 20);            Console.WriteLine(c.GetResult());            c = new Context(new Minus(), 20, 10);            Console.WriteLine(c.GetResult());        &#125;    &#125;&#125;\n\n\n\n\n","tags":["设计模式读书笔记"]},{"title":"简单工厂的最最简单应用（C#）","url":"/blog/2008/07/29/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E7%9A%84%E6%9C%80%E6%9C%80%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8%EF%BC%88CSharp%EF%BC%89/","content":"简单工厂的最最简单应用\nusing System;using System.Collections.Generic;using System.Linq;using System.Text;namespace ConsoleApplication1&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Calculate cal = factory.CreateOper(&quot;-&quot;);            cal.A = 10;            cal.B = 20;            Console.WriteLine(cal.GetResult());            cal = factory.CreateOper(&quot;+&quot;);            cal.A = 10;            cal.B = 20;            Console.WriteLine(cal.GetResult());        &#125;    &#125;    abstract class Calculate    &#123;        double _NumA = 0;        double _B = 0;        public double A        &#123;            get &#123; return _NumA; &#125;            set &#123; _NumA = value; &#125;        &#125;        public double B        &#123;            get &#123; return _B; &#125;            set &#123; _B = value; &#125;        &#125;        public abstract double GetResult();    &#125;    class Add : Calculate    &#123;        public override double GetResult()        &#123;            return A + B;        &#125;    &#125;    class Minus : Calculate    &#123;        public override double GetResult()        &#123;            return A - B;        &#125;    &#125;    class factory    &#123;        public static Calculate            CreateOper(string oper)        &#123;            Calculate op = null;            switch (oper)            &#123;                case &quot;+&quot;:                    op = new Add();                    break;                case &quot;-&quot;:                    op = new Minus();                    break;            &#125;            return op;        &#125;    &#125;&#125;\n\n\n\n\n\n\n","tags":["设计模式读书笔记"]},{"title":"设计模式--代理模式的简单实现（C#）+类关系图","url":"/blog/2008/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%EF%BC%88CSharp%EF%BC%89+%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE/","content":"\nusing System;using System.Collections.Generic;using System.Linq;using System.Text;namespace ConsoleApplication1&#123;    class Class1    &#123;        public static void Main()        &#123;            Proxy p = new Proxy();            p.DoYourStuff();            Console.Read();        &#125;    &#125;    abstract class ProxyBase    &#123;        public abstract void DoYourStuff();    &#125;    class Subject : ProxyBase    &#123;        public override void DoYourStuff()        &#123;            Console.WriteLine(&quot;do my job&quot;);        &#125;    &#125;    class Proxy : ProxyBase    &#123;        Subject s;        public override void DoYourStuff()        &#123;            if (s == null)            &#123;                s = new Subject();            &#125;            s.DoYourStuff();//throw new NotImplementedException();        &#125;    &#125;&#125;\n\n\n\n","tags":["设计模式读书笔记"]},{"title":"装饰模式的简单实现（C#）内有图一张,嘿嘿.....","url":"/blog/2008/07/31/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%EF%BC%88CSharp%EF%BC%89%E5%86%85%E6%9C%89%E5%9B%BE%E4%B8%80%E5%BC%A0,%E5%98%BF%E5%98%BF...../","content":"\nusing System;using System.Collections.Generic;using System.Linq;using System.Text;namespace ConsoleApplication1&#123;    class Class1    &#123;        public static void Main()        &#123;            Person p = new Person(&quot;张三&quot;);            Ring r = new Ring();            EarRing er = new EarRing();            NeckLace nl = new NeckLace();            r.Decrate(p);            er.Decrate(r);            nl.Decrate(er);            nl.Show();            Console.Read();        &#125;    &#125;    class Person    &#123;        string name;        public Person(string name)        &#123;            this.name = name;        &#125;        public Person()        &#123;        &#125; //重载一个没有参数的构造函数，给其他子类用        public virtual void Show()        &#123;            Console.WriteLine(&quot;&#123;0&#125;拥有以上装饰物品&quot;, name);        &#125;    &#125;    class Decrator : Person    &#123;        Person p;        public override void Show()        &#123;            p.Show();        &#125;        public void Decrate(Person p)        &#123;            this.p = p;        &#125;    &#125;    class Ring : Decrator    &#123;        public override void Show()        &#123;            Console.WriteLine(&quot;戒指&quot;);            base.Show();        &#125;    &#125;    class EarRing : Decrator    &#123;        public override void Show()        &#123;            Console.WriteLine(&quot;耳环&quot;);            base.Show();        &#125;    &#125;    class NeckLace : Decrator    &#123;        public override void Show()        &#123;            Console.WriteLine(&quot;项链&quot;);            base.Show();        &#125;    &#125;&#125;\n\n\n\n","tags":["设计模式读书笔记"]},{"title":"《编程之美——微软技术面试心得》一摞烧饼的排序 （不会做，看不懂）","url":"/blog/2008/07/03/%E3%80%8A%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E2%80%94%E2%80%94%E5%BE%AE%E8%BD%AF%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E5%BF%83%E5%BE%97%E3%80%8B%E4%B8%80%E6%91%9E%E7%83%A7%E9%A5%BC%E7%9A%84%E6%8E%92%E5%BA%8F%20%EF%BC%88%E4%B8%8D%E4%BC%9A%E5%81%9A%EF%BC%8C%E7%9C%8B%E4%B8%8D%E6%87%82%EF%BC%89/","content":"《编程之美——微软技术面试心得》一摞烧饼的排序 （不会做，看不懂）\n留个位置\n\n\n\n\n","tags":["《编程之美——微软技术面试心得》的C#实现"]},{"title":"设计模式--工厂模式","url":"/blog/2008/08/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","content":"\nusing System;using System.Collections.Generic;using System.Linq;using System.Text;namespace ConsoleApplication1&#123;    class Client    &#123;        public static void Main()        &#123;            IFactory i = new AddFactory();            Math oper = i.CreateOperation();            oper.A = 5;            oper.B = 10;            Console.WriteLine(oper.DoTheMath());            i = new SubFactory();            oper = i.CreateOperation();            oper.A = 10;            oper.B = 3;            Console.WriteLine(oper.DoTheMath());            Console.Read();        &#125;    &#125;    class Math    &#123;        double _a;        double _b;        public double A        &#123;            set &#123; _a = value; &#125;            get &#123; return _a; &#125;        &#125;        public double B        &#123;            set &#123; _b = value; &#125;            get &#123; return _b; &#125;        &#125;        public virtual double DoTheMath()        &#123;            return 0;        &#125;    &#125;    class Add : Math    &#123;        public override double DoTheMath()        &#123;            return A + B;        &#125;    &#125;    class Sub : Math    &#123;        public override double DoTheMath()        &#123;            return A - B;        &#125;    &#125;    interface IFactory    &#123;        Math CreateOperation();    &#125;    class AddFactory : IFactory    &#123;        public Math CreateOperation()        &#123;            return new Add();        &#125;    &#125;    class SubFactory : IFactory    &#123;        public Math CreateOperation()        &#123;            return new Sub();        &#125;    &#125;&#125;\n\n\n\n","tags":["设计模式读书笔记"]},{"title":"设计模式--模板方法模式（照旧，有类关系图）","url":"/blog/2008/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%85%A7%E6%97%A7%EF%BC%8C%E6%9C%89%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE%EF%BC%89/","content":"\nusing System;using System.Collections.Generic;using System.Text;namespace ConsoleApplication1&#123;    public class TheFather    &#123;        public void BaseMethod1()        &#123;            Console.WriteLine(&quot;吃了吗？&quot;);            BaseMethod2();        &#125;        public virtual void BaseMethod2()        &#123;        &#125;    &#125;    public class Son1 : TheFather    &#123;        public override void BaseMethod2()        &#123;            Console.WriteLine(&quot;吃了&quot;);        &#125;    &#125;    public class Son2 : TheFather    &#123;        public override void BaseMethod2()        &#123;            Console.WriteLine(&quot;还没呢&quot;);        &#125;    &#125;    public class Client    &#123;        public static void Main()        &#123;            TheFather obj = new Son1();            obj.BaseMethod1();            obj = new Son2();            obj.BaseMethod1();            Console.Read();        &#125;    &#125;&#125;\n\n\n\n","tags":["设计模式读书笔记"]},{"title":"设计模式--原型模式（附带类关系图一张）","url":"/blog/2008/08/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E9%99%84%E5%B8%A6%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE%E4%B8%80%E5%BC%A0%EF%BC%89/","content":"\nusing System;using System.Collections.Generic;using System.Text;namespace ConsoleApplication1&#123;    public class Simple : ICloneable    &#123;        private int field1;        private int field2;        public int Property1        &#123;            get &#123; return field1; &#125;            set &#123; field1 = value; &#125;        &#125;        public int Property2        &#123;            get &#123; return field2; &#125;            set &#123; field2 = value; &#125;        &#125;        public object Clone()        &#123;            return this.MemberwiseClone();        &#125;    &#125;    public class Complecated : ICloneable    &#123;        private Simple simple;        public Complecated()        &#123;            simple = new Simple();        &#125;        private Complecated(Simple s)        &#123;            simple = (Simple) s.Clone();        &#125;        public object Clone()        &#123;            Complecated c = new Complecated(simple);            return c;        &#125;        public void SetMe(int a, int b)        &#123;            simple.Property1 = a;            simple.Property2 = b;        &#125;        public void Show()        &#123;            Console.WriteLine(simple.Property1);            Console.WriteLine(simple.Property2);        &#125;    &#125;    public class Client    &#123;        public static void Main()        &#123;            Complecated c = new Complecated();            c.SetMe(1, 2);            Complecated c2 = (Complecated) c.Clone();            c2.SetMe(3, 4);            c.Show();            c2.Show();            Console.Read();        &#125;    &#125;&#125;\n\n\n\n","tags":["设计模式读书笔记"]},{"title":"设计模式--外观模式","url":"/blog/2008/08/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/","content":"using System;using System.Collections.Generic;using System.Text;namespace ConsoleApplication1&#123;    class Facade    &#123;        private Func1 field1;        private Func2 field2;        public Facade()        &#123;            field1 = new Func1();            field2 = new Func2();        &#125;        public void Method()        &#123;            field1.Method();            field1.Method1();            field2.Method();        &#125;        public void Method1()        &#123;            field2.Method();            field2.Method1();            field1.Method();        &#125;    &#125;    class Func1    &#123;        public void Method()        &#123;            Console.WriteLine(&quot;功能类1的方法1&quot;);        &#125;        public void Method1()        &#123;            Console.WriteLine(&quot;功能类1的方法2&quot;);        &#125;    &#125;    internal class Func2    &#123;        public void Method()        &#123;            Console.WriteLine(&quot;功能类2的方法1&quot;);        &#125;        public void Method1()        &#123;            Console.WriteLine(&quot;功能类2的方法2&quot;);        &#125;    &#125;    class Client    &#123;        public static void Main()        &#123;            Facade f = new Facade();            f.Method();            f.Method1();            Console.Read();        &#125;    &#125;&#125;\n\n\n\n\n\n\n","tags":["设计模式读书笔记"]},{"title":"设计模式---建造者（Builder）模式，有关系图","url":"/blog/2008/08/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F---%E5%BB%BA%E9%80%A0%E8%80%85%EF%BC%88Builder%EF%BC%89%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%9C%89%E5%85%B3%E7%B3%BB%E5%9B%BE/","content":"using System;using System.Collections.Generic;using System.Text;namespace ConsoleApplication1&#123;    abstract class Builder    &#123;        public abstract void SetPrice();        public abstract void SetName();    &#125;    class TVBuilder : Builder    &#123;        private RawMateria rm;        public TVBuilder()        &#123;            rm = new RawMateria();        &#125;        public override void SetPrice()        &#123;            rm.Price = &quot;1500&quot;;        &#125;        public override void SetName()        &#123;            rm.Name = &quot;TV&quot;;        &#125;        public RawMateria GetTV()        &#123;            return rm;        &#125;    &#125;    class PCBuilder : Builder    &#123;        private RawMateria rm;        public PCBuilder()        &#123;            rm = new RawMateria();        &#125;        public override void SetName()        &#123;            rm.Name = &quot;PC&quot;;        &#125;        public override void SetPrice()        &#123;            rm.Price = &quot;2000&quot;;        &#125;        public RawMateria GetPC()        &#123;            return rm;        &#125;    &#125;    class RawMateria    &#123;        String _name;        String _price;        public String Name        &#123;            get &#123; return _name; &#125;            set &#123; _name = value; &#125;        &#125;        public String Price        &#123;            get &#123; return _price; &#125;            set &#123; _price = value; &#125;        &#125;        public void Show()        &#123;            Console.WriteLine(this.Name + &quot;    &quot; \\ + this.Price );        &#125;    &#125;    class Director    &#123;        private PCBuilder pcbuilder = new PCBuilder();        private TVBuilder tvbuilder = new TVBuilder();        public RawMateria GiveMeTV()        &#123;            tvbuilder.SetName();            tvbuilder.SetPrice();            return tvbuilder.GetTV();        &#125;        public RawMateria GiveMePC()        &#123;            pcbuilder.SetName();            pcbuilder.SetPrice();            return pcbuilder.GetPC();        &#125;    &#125;    class Client    &#123;        public static void Main()        &#123;            Director d = new Director();            d.GiveMePC().Show();            d.GiveMeTV().Show();            Console.Read();        &#125;    &#125;&#125;\n\n \n\n\n\n\n","tags":["设计模式读书笔记"]},{"title":"设计模式---观察者模式（恐怖袭击、地震的例子，有类关系图）","url":"/blog/2008/08/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F---%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%81%90%E6%80%96%E8%A2%AD%E5%87%BB%E3%80%81%E5%9C%B0%E9%9C%87%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%8C%E6%9C%89%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE%EF%BC%89/","content":"\nusing System;using System.Collections.Generic;using System.Text;namespace ConsoleApplication1&#123;    internal interface Warning    &#123;        String Situation &#123; get; set; &#125;        void Warn();        void Add(PeopleInSchool p);        void Sub(PeopleInSchool p);    &#125;    class PoliceStation : Warning    &#123;        private IList&lt;PeopleInSchool&gt; field = new List&lt;PeopleInSchool&gt;();        string situation;        public string Situation        &#123;            get &#123; return situation; &#125;            set &#123; situation = value; &#125;        &#125;        public void Warn()        &#123;            foreach (PeopleInSchool p in field)            &#123;                p.WarningReceived();            &#125;        &#125;        public void Add(PeopleInSchool p)        &#123;            field.Add(p);        &#125;        public void Sub(PeopleInSchool p)        &#123;            field.Remove(p);        &#125;    &#125;    class EarthquakeDepartment : Warning    &#123;        string situation;        private IList&lt;PeopleInSchool&gt; field = new List&lt;PeopleInSchool&gt;();        public string Situation        &#123;            get &#123; return situation; &#125;            set &#123; situation = value; &#125;        &#125;        public void Warn()        &#123;            foreach (PeopleInSchool p in field)            &#123;                p.WarningReceived();            &#125;        &#125;        public void Add(PeopleInSchool p)        &#123;            field.Add(p);        &#125;        public void Sub(PeopleInSchool p)        &#123;            field.Remove(p);        &#125;    &#125;    abstract class PeopleInSchool    &#123;        protected Warning field;        public PeopleInSchool(Warning w)        &#123;            field = w;        &#125;        public abstract void WarningReceived();    &#125;    class Teacher : PeopleInSchool    &#123;        public Teacher(Warning w)            : base(w)        &#123;        &#125;        public override void WarningReceived()        &#123;            Console.WriteLine(&quot;我是老师&quot; + field.Situation);        &#125;    &#125;    class Student : PeopleInSchool    &#123;        public Student(Warning w)            : base(w)        &#123;        &#125;        public override void WarningReceived()        &#123;            Console.WriteLine(&quot;我是学生&quot; + field.Situation);        &#125;    &#125;    class Client    &#123;        public static void Main()        &#123;            PoliceStation p = new PoliceStation();            Teacher t = new Teacher(p);            Student s = new Student(p);            p.Add(t);            p.Add(s);            p.Situation = &quot;有恐怖袭击！！！&quot;;            p.Warn();            p.Situation = &quot;注意防火防盗！！！&quot;;            p.Warn();            EarthquakeDepartment e = new EarthquakeDepartment();            t = new Teacher(e);            s = new Student(e);            e.Add(t);            e.Add(s);            e.Situation = &quot;要地震了！！！&quot;;            e.Warn();            Console.Read();        &#125;    &#125;&#125;\n\n\n\n\n","tags":["设计模式读书笔记"]},{"title":"设计模式---单例模式（singleton）","url":"/blog/2008/08/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F---%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88singleton%EF%BC%89/","content":"设计模式—单例模式（singleton）\n\nusing System;using System.Collections.Generic;using System.Text;namespace ConsoleApplication1&#123;    class Singleton    &#123;        private static Singleton s;        private Singleton()        &#123;        &#125;        public static Singleton GetInstance()        &#123;            if (s == null)            &#123;                s = new Singleton();            &#125;            return s;        &#125;    &#125;    class Client    &#123;        public static void Main()        &#123;            Singleton s1 = Singleton.GetInstance();            Singleton s2 = Singleton.GetInstance();            if (object.ReferenceEquals(s1, s2))            &#123;                Console.WriteLine(&quot;一样的&quot;);                Console.WriteLine(s1);            &#125;            Console.Read();        &#125;    &#125;&#125;\n\n\n\n\n\n\n","tags":["设计模式读书笔记"]},{"title":"设计模式---命令模式","url":"/blog/2008/08/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F---%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/","content":"设计模式—命令模式\n\nusing System;using System.Collections.Generic;using System.Text;namespace ConsoleApplication1&#123;    abstract class Order    &#123;        protected General general;        public Order(General g)        &#123;            this.general = g;        &#125;        public abstract void Excute();    &#125;    class Fire : Order    &#123;        public Fire(General g)            : base(g)        &#123;        &#125;        public override void Excute()        &#123;            general.ExcuteFire();        &#125;    &#125;    class Retreat : Order    &#123;        public Retreat(General g)            : base(g)        &#123;        &#125;        public override void Excute()        &#123;            general.ExcuteRetreat();        &#125;    &#125;    class Soldier    &#123;        private String name;        public Soldier(string n)        &#123;            this.name = n;        &#125;        public void ExcuteFire()        &#123;            Console.WriteLine(name + &quot;开火&quot;);        &#125;        public void ExcuteRetreat()        &#123;            Console.WriteLine(name + &quot;撤退&quot;);        &#125;    &#125;    class General    &#123;        private Soldier soldier;        public void ExcuteFire()        &#123;            soldier.ExcuteFire();        &#125;        public void SetSoldier(Soldier s)        &#123;            this.soldier = s;        &#125;        public void ExcuteRetreat()        &#123;            soldier.ExcuteRetreat();        &#125;    &#125;    class Client    &#123;        public static void Main()        &#123;            General g = new General();            Soldier s = new Soldier(&quot;张三&quot;);            g.SetSoldier(s);            Order o = new Fire(g);            o.Excute();            o = new Retreat(g);            o.Excute();            g.SetSoldier(new Soldier(&quot;李四&quot;));            o.Excute();            Console.Read();        &#125;    &#125;&#125;\n\n\n\n\n\n\n","tags":["设计模式读书笔记"]},{"title":"设计模式---抽象工厂模式+反射+配置文件","url":"/blog/2008/08/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F---%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F+%E5%8F%8D%E5%B0%84+%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","content":"using System;using System.Collections.Generic;using System.Text;using System.Reflection;using System.Configuration;namespace ConsoleApplication1&#123;    internal interface SportMan    &#123;        void Come();    &#125;    class ChineseSportMan : SportMan    &#123;        public void Come()        &#123;            Console.WriteLine(&quot;中国运动员来了~~~&quot;);        &#125;    &#125;    class RussianSportMan : SportMan    &#123;        public void Come()        &#123;            Console.WriteLine(&quot;俄罗斯运动员来了~~~&quot;);        &#125;    &#125;    class TheController    &#123;        public static SportMan CreateSportMan()        &#123;            //string s = (string)ConfigurationSettings.AppSettings[&quot;Nation&quot;];            return (SportMan) Assembly.Load(&quot;ConsoleApplication1&quot;)                .CreateInstance(&quot;ConsoleApplication1.&quot; + ConfigurationSettings.AppSettings[&quot;Nation&quot;].ToString());            //ConfigurationSettings.AppSettings[];            //return new ChineseSportMan();        &#125;    &#125;    class Client    &#123;        public static void Main()        &#123;            TheController.CreateSportMan().Come();            //s.Come();            //SportMan  c=(SportMan)Assembly.Load(&quot;ConsoleApplication1&quot;).CreateInstance(&quot;ConsoleApplication1.ChineseSportMan&quot;);            //c.Come();        &#125;    &#125;&#125;\n \n\n\n\n\n","tags":["设计模式读书笔记"]},{"title":"设计模式---中介者模式（打出来是“终结者.......”）","url":"/blog/2008/08/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F---%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%89%93%E5%87%BA%E6%9D%A5%E6%98%AF%E2%80%9C%E7%BB%88%E7%BB%93%E8%80%85.......%E2%80%9D%EF%BC%89/","content":"\nusing System;using System.Collections.Generic;using System.Text;namespace ConsoleApplication1&#123;    abstract class FBIAgent    &#123;        public abstract void SendMessage(string m);        public void ReadMessage(string m)        &#123;            Console.WriteLine(m);        &#125;    &#125;    class AgentInRussia : FBIAgent    &#123;        private FBICenter center;        public AgentInRussia(FBICenter f)        &#123;            center = f;        &#125;        public override void SendMessage(string m)        &#123;            center.Send(this, m);        &#125;    &#125;    class AgentInEngland : FBIAgent    &#123;        private FBICenter center;        public override void SendMessage(string m)        &#123;            center.Send(this, m);        &#125;        public AgentInEngland(FBICenter f)        &#123;            center = f;        &#125;    &#125;    abstract class FBICenter    &#123;        public abstract void Send(FBIAgent f, string m);    &#125;    class RealFBICenter : FBICenter    &#123;        private FBIAgent agentinrussia;        private FBIAgent agentinengland;        public FBIAgent russia        &#123;            set &#123; agentinrussia = value; &#125;        &#125;        public FBIAgent england        &#123;            set &#123; agentinengland = value; &#125;        &#125;        public override void Send(FBIAgent f, string m)        &#123;            if (f == agentinengland)            &#123;                agentinrussia.ReadMessage(m);            &#125;            else            &#123;                agentinengland.ReadMessage(m);            &#125;        &#125;    &#125;    class Client    &#123;        public static void Main()        &#123;            RealFBICenter fc = new RealFBICenter();            AgentInEngland eng = new AgentInEngland(fc);            AgentInRussia rus = new AgentInRussia(fc);            fc.england = eng;            fc.russia = rus;            eng.SendMessage(&quot;我在英国搞情报，hia~hia~&quot;);            rus.SendMessage(&quot;我在俄罗斯搞情报，xia~ixa~&quot;);            Console.Read();        &#125;    &#125;&#125;\n\n\n\n\n","tags":["设计模式读书笔记"]},{"title":"设计模式---备忘录模式（CSDN没有恢复迹象......）","url":"/blog/2008/08/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F---%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%EF%BC%88CSDN%E6%B2%A1%E6%9C%89%E6%81%A2%E5%A4%8D%E8%BF%B9%E8%B1%A1......%EF%BC%89/","content":"设计模式—备忘录模式（CSDN没有恢复迹象……）\n\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace ConsoleApplication1\n&#123;\n    class 人物状态\n    &#123;\n        private int _血;\n        private int _气;\n\n        public 人物状态()\n        &#123;\n            _气 = 100;\n            _血 = 100;\n        &#125;\n\n        public int 血\n        &#123;\n            get &#123; return _血; &#125;\n            set &#123; _血 = value; &#125;\n        &#125;\n\n        public int 气\n        &#123;\n            get &#123; return _气; &#125;\n            set &#123; _气 = value; &#125;\n        &#125;\n\n        public 存档 存档()\n        &#123;\n            return new 存档(_血, _气);\n        &#125;\n\n        public void 读档(存档 c)\n        &#123;\n            this.气 = c.气;\n            this.血 = c.血;\n        &#125;\n\n        public void 战斗()\n        &#123;\n            System.Random r = new System.Random();\n\n            this._血 = r.Next(100);\n            this._气 = r.Next(100);\n        &#125;\n\n        public void ShowState()\n        &#123;\n            Console.WriteLine(this.气 + &quot; &quot; + this.血);\n        &#125;\n    &#125;\n\n    class 存档\n    &#123;\n        private int _气;\n\n        private int _血;\n\n        public 存档(int x, int q)\n        &#123;\n            this._气 = q;\n            this._血 = x;\n        &#125;\n\n        public int 气\n        &#123;\n            get &#123; return _气; &#125;\n        &#125;\n\n        public int 血\n        &#123;\n            get &#123; return _血; &#125;\n        &#125;\n    &#125;\n\n    class 管理器\n    &#123;\n        private 存档 savedfile;\n\n        public 存档 SavedFile\n        &#123;\n            get &#123; return savedfile; &#125;\n            set &#123; savedfile = value; &#125;\n        &#125;\n    &#125;\n\n    class 调用者\n    &#123;\n        public static void Main()\n        &#123;\n            人物状态 r = new 人物状态();\n            r.ShowState();\n\n            管理器 g = new 管理器();\n            g.SavedFile = r.存档();\n            r.战斗();\n            r.ShowState();\n            r.读档(g.SavedFile);\n            r.ShowState();\n            Console.Read();\n        &#125;\n    &#125;\n&#125;\n``\n\n\n\n\n\n\n","tags":["设计模式读书笔记"]},{"title":"设计模式---桥接模式","url":"/blog/2008/08/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F---%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","content":"2008年08月15日 星期五 下午 05:23\n松耦合\n\nusing System;using System.Collections.Generic;using System.Text;namespace ConsoleApplication1&#123;    abstract class Vehicle    &#123;        protected Engine e;        public abstract void Show();        public abstract void InstallEngine(Engine e);    &#125;    class RacingCar : Vehicle    &#123;        public override void Show()        &#123;            Console.WriteLine(&quot;跑车&quot;);            e.Show();        &#125;        public override void InstallEngine(Engine e)        &#123;            this.e = e;        &#125;    &#125;    class Tractor : Vehicle    &#123;        public override void Show()        &#123;            Console.WriteLine(&quot;拖拉机&quot;);            e.Show();        &#125;        public override void InstallEngine(Engine e)        &#123;            this.e = e;        &#125;    &#125;    abstract class Engine    &#123;        public abstract void Show();    &#125;    class RacingCarEngine : Engine    &#123;        public override void Show()        &#123;            Console.WriteLine(&quot;跑车引擎&quot;);        &#125;    &#125;    class TractorEngine : Engine    &#123;        public override void Show()        &#123;            Console.WriteLine(&quot;拖拉机引擎&quot;);        &#125;    &#125;    class Client    &#123;        public static void Main()        &#123;            Vehicle v = new RacingCar();            v.InstallEngine(new RacingCarEngine());            v.Show();            v = new Tractor();            v.InstallEngine(new TractorEngine());            v.Show();            Console.Read();        &#125;    &#125;&#125;\n\n\n\n\n\n\n","tags":["设计模式读书笔记"]},{"title":"设计模式---状态模式（今天CSDN竟然上不去，暂时发在这里） (从百度空间转回来的)","url":"/blog/2008/08/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F---%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BB%8A%E5%A4%A9CSDN%E7%AB%9F%E7%84%B6%E4%B8%8A%E4%B8%8D%E5%8E%BB%EF%BC%8C%E6%9A%82%E6%97%B6%E5%8F%91%E5%9C%A8%E8%BF%99%E9%87%8C%EF%BC%89%20(%E4%BB%8E%E7%99%BE%E5%BA%A6%E7%A9%BA%E9%97%B4%E8%BD%AC%E5%9B%9E%E6%9D%A5%E7%9A%84)/","content":"设计模式—状态模式（今天CSDN竟然上不去，暂时发在这里）\n\nusing System;using System.Collections.Generic;using System.Text;namespace ConsoleApplication1&#123;    abstract class State    &#123;        public abstract void DoWhatIShouldDo(Worker w);    &#125;    class Young : State    &#123;        public override void DoWhatIShouldDo(Worker w)        &#123;            if (w.Age &lt;= 35)            &#123;                Console.WriteLine(&quot;我年轻，逍遥自在&quot;);            &#125;            else            &#123;                w.State = new MiddleAge();                w.DoWhatIShouldDo();            &#125;        &#125;    &#125;    class MiddleAge : State    &#123;        public override void DoWhatIShouldDo(Worker w)        &#123;            if (w.Age &lt;= 50)            &#123;                Console.WriteLine(&quot;人到中年&quot;);            &#125;            else            &#123;                w.State = new Old();                w.DoWhatIShouldDo();            &#125;        &#125;    &#125;    class Old : State    &#123;        public override void DoWhatIShouldDo(Worker w)        &#123;            Console.WriteLine(&quot;老年生活&quot;);        &#125;    &#125;    class Worker    &#123;        State state;        int age;        public Worker()        &#123;            age = 1;            state = new Young();        &#125;        public int Age        &#123;            get &#123; return age; &#125;            set &#123; age = value; &#125;        &#125;        public State State        &#123;            get &#123; return State; &#125;            set &#123; state = value; &#125;        &#125;        public void DoWhatIShouldDo()        &#123;            state.DoWhatIShouldDo(this);        &#125;    &#125;    class Client    &#123;        public static void Main()        &#123;            Worker w = new Worker();            w.Age = 5;            w.DoWhatIShouldDo();            w.Age = 45;            w.DoWhatIShouldDo();            w.Age = 80;            w.DoWhatIShouldDo();            Console.Read();        &#125;    &#125;&#125;\n\n\n\n\n\n\n","tags":["设计模式读书笔记"]},{"title":"设计模式---组合模式（CSDN依然没有恢复迹象......）","url":"/blog/2008/08/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F---%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%EF%BC%88CSDN%E4%BE%9D%E7%84%B6%E6%B2%A1%E6%9C%89%E6%81%A2%E5%A4%8D%E8%BF%B9%E8%B1%A1......%EF%BC%89/","content":"设计模式—组合模式（CSDN依然没有恢复迹象……）\n\nusing System;using System.Collections.Generic;using System.Text;namespace ConsoleApplication1&#123;    abstract class AbstractCompany    &#123;        protected String Name;        public AbstractCompany(string name)        &#123;            this.Name = name;        &#125;        public abstract void Add(AbstractCompany c);        public abstract void Remove(AbstractCompany c);        public abstract void Show(int len);        public abstract void DoJob();    &#125;    class RealCompany : AbstractCompany    &#123;        private IList&lt;AbstractCompany&gt; Son = new List&lt;AbstractCompany&gt;();        public RealCompany(string name) : base(name)        &#123;        &#125;        public override void Add(AbstractCompany c)        &#123;            Son.Add(c);        &#125;        public override void DoJob()        &#123;            Console.WriteLine(Name + &quot;公司正常运转&quot;);            foreach (AbstractCompany a in Son)            &#123;                a.DoJob();            &#125;        &#125;        public override void Remove(AbstractCompany c)        &#123;            Son.Remove(c);        &#125;        public override void Show(int len)        &#123;            Console.WriteLine(new String(&#x27;-&#x27;, len) + Name);            foreach (AbstractCompany a in Son)            &#123;                a.Show(len + 1);            &#125;        &#125;    &#125;    class HR : AbstractCompany    &#123;        public HR(string name) : base(name)        &#123;        &#125;        public override void Add(AbstractCompany c)        &#123;        &#125;        public override void DoJob()        &#123;            Console.WriteLine(Name + &quot;人事部正常运转&quot;);        &#125;        public override void Remove(AbstractCompany c)        &#123;        &#125;        public override void Show(int len)        &#123;            Console.WriteLine(new string(&#x27;-&#x27;, len) + Name);        &#125;    &#125;    class Client    &#123;        public static void Main()        &#123;            AbstractCompany root = new RealCompany(&quot;总公司&quot;);            root.Add(new HR(&quot;总公司人事部&quot;));            RealCompany r = new RealCompany(&quot;分公司&quot;);            r.Add(new HR(&quot;分公司人事部&quot;));            root.Add(r);            root.Show(1);            root.DoJob();            Console.Read();        &#125;    &#125;&#125;\n\n\n\n\n\n\n","tags":["设计模式读书笔记"]},{"title":"设计模式---迭代器模式（昨天停电了......）","url":"/blog/2008/08/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F---%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%98%A8%E5%A4%A9%E5%81%9C%E7%94%B5%E4%BA%86......%EF%BC%89/","content":"设计模式—迭代器模式（昨天停电了……）\n\n\n\n\n\n","tags":["设计模式读书笔记"]},{"title":"设计模式---职责链模式","url":"/blog/2008/08/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F---%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/","content":"2008年08月17日 星期日 下午 04:28\n\nusing System;using System.Collections.Generic;using System.Text;namespace ConsoleApplication1&#123;    abstract class Officer    &#123;        protected Officer myboss;        public Officer(Officer o)        &#123;            myboss = o;        &#125;        public abstract void Deal(Action a);    &#125;    class PoliceMan : Officer    &#123;        public PoliceMan(Officer o)            : base(o)        &#123;        &#125;        public override void Deal(Action a)        &#123;            if (a == Action.逮捕罪犯)            &#123;                Console.WriteLine(&quot;我是警察，我去逮捕罪犯&quot;);            &#125;            else if (myboss != null)            &#123;                myboss.Deal(a);            &#125;        &#125;    &#125;    class FBI : Officer    &#123;        public FBI(Officer o)            : base(o)        &#123;        &#125;        public override void Deal(Action a)        &#123;            if (a == Action.暗杀)            &#123;                Console.WriteLine(&quot;我是FBI，我去暗杀&quot;);            &#125;            else if (myboss != null)            &#123;                myboss.Deal(a);            &#125;        &#125;    &#125;    class Precident : Officer    &#123;        public Precident(Officer o)            : base(o)        &#123;        &#125;        public override void Deal(Action a)        &#123;            if (a == Action.干掉萨达姆)            &#123;                Console.WriteLine(&quot;我是总统，我去找人干掉萨达姆&quot;);            &#125;            else if (myboss != null)            &#123;                myboss.Deal(a);            &#125;        &#125;    &#125;    enum Action    &#123;        逮捕罪犯,        暗杀,        干掉萨达姆    &#125;    class Client    &#123;        public static void Main()        &#123;            Officer police = new PoliceMan(new FBI(new Precident(null)));            police.Deal(Action.逮捕罪犯);            police.Deal(Action.暗杀);            police.Deal(Action.干掉萨达姆);            Console.Read();        &#125;    &#125;&#125;\n\n\n\n\n\n\n","tags":["设计模式读书笔记"]},{"title":"设计模式---适配器模式（从百度转回来的）","url":"/blog/2008/08/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F---%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BB%8E%E7%99%BE%E5%BA%A6%E8%BD%AC%E5%9B%9E%E6%9D%A5%E7%9A%84%EF%BC%89/","content":"\nusing System;using System.Collections.Generic;using System.Text;namespace ConsoleApplication1&#123;    abstract class Birds    &#123;        public abstract void Fly();        public abstract void Shout();    &#125;    class Duck : Birds    &#123;        public override void Fly()        &#123;            Console.WriteLine(&quot;鸭子飞&quot;);        &#125;        public override void Shout()        &#123;            Console.WriteLine(&quot;鸭子叫唤&quot;);        &#125;    &#125;    class Chick : Birds    &#123;        public override void Fly()        &#123;            Console.WriteLine(&quot;小鸡飞&quot;);        &#125;        public override void Shout()        &#123;            Console.WriteLine(&quot;小鸡飞&quot;);        &#125;    &#125;    class Adapter : Birds    &#123;        private Eagle eagle = new Eagle();        public override void Fly()        &#123;            eagle.Fly();        &#125;        public override void Shout()        &#123;            eagle.Shout();        &#125;    &#125;    class Eagle    &#123;        public void Fly()        &#123;            Console.WriteLine(&quot;老鹰飞&quot;);        &#125;        public void Shout()        &#123;            Console.WriteLine(&quot;老鹰叫唤&quot;);        &#125;    &#125;    class Client    &#123;        public static void Main()        &#123;            Birds b = new Duck();            b.Fly();            b.Shout();            b = new Chick();            b.Fly();            b.Shout();            b = new Adapter();            b.Fly();            b.Shout();            Console.Read();        &#125;    &#125;&#125;\n\n\n\n\n\n\n","tags":["设计模式读书笔记"]},{"title":"设计模式---享元模式","url":"/blog/2008/08/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F---%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","content":"using System;using System.Collections.Generic;using System.Text;using System.Collections;namespace ConsoleApplication1&#123;    class MovieTheater    &#123;        private Hashtable movies = new Hashtable();        public void GiveMeAMovie(string name)        &#123;            Movie m;            if (movies.ContainsKey(name))            &#123;                m = (Movie) movies[name];            &#125;            else            &#123;                m = new ConcreteMovie(name);                movies.Add(name, m);            &#125;            m.ShowTheMovie();        &#125;        public void HowManyMoviesHaveWeOrdered()        &#123;            Console.WriteLine(movies.Count);        &#125;    &#125;    abstract class Movie    &#123;        protected string name;        public Movie(string n)        &#123;            this.name = n;        &#125;        public abstract void ShowTheMovie();    &#125;    class ConcreteMovie : Movie    &#123;        public ConcreteMovie(string n)            : base(n)        &#123;        &#125;        public override void ShowTheMovie()        &#123;            Console.WriteLine(name);        &#125;    &#125;    class Client    &#123;        public static void Main()        &#123;            MovieTheater mth = new MovieTheater();            mth.GiveMeAMovie(&quot;Hell Boy&quot;);            mth.GiveMeAMovie(&quot;Wanted&quot;);            mth.GiveMeAMovie(&quot;Wall-E&quot;);            mth.GiveMeAMovie(&quot;Hell Boy&quot;);            mth.GiveMeAMovie(&quot;Hell Boy&quot;);            mth.GiveMeAMovie(&quot;Wanted&quot;);            mth.GiveMeAMovie(&quot;Wall-E&quot;);            mth.GiveMeAMovie(&quot;Hell Boy&quot;);            mth.HowManyMoviesHaveWeOrdered();            Console.Read();        &#125;    &#125;&#125;\n\n\n\n\n\n","tags":["设计模式读书笔记"]},{"title":"CSDN被和谐期间的Blog都发到百度空间去了","url":"/blog/2008/08/19/CSDN%E8%A2%AB%E5%92%8C%E8%B0%90%E6%9C%9F%E9%97%B4%E7%9A%84Blog%E9%83%BD%E5%8F%91%E5%88%B0%E7%99%BE%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%8E%BB%E4%BA%86/","content":"粘贴回来格式一片混乱，百度似乎还有图床保护？干脆留个地址在这里\n http://hi.baidu.com/yansuochonglou/blog/calendar/200808\n\n\n\n\n\n","tags":["设计模式读书笔记"]},{"title":"设计模式---翻译器模式","url":"/blog/2008/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F---%E7%BF%BB%E8%AF%91%E5%99%A8%E6%A8%A1%E5%BC%8F/","content":"\nusing System;using System.Collections.Generic;using System.Text;namespace ConsoleApplication1&#123;    abstract class Expretion    &#123;        public void Translate(Words w)        &#123;            string s = w.MyWords.Substring(0, 1);            w.MyWords = w.MyWords.Substring(2);            Excute(s);        &#125;        public abstract void Excute(string s);    &#125;    class EnglishExpretion : Expretion    &#123;        public override void Excute(string s)        &#123;            switch (s)            &#123;                case &quot;e&quot;:                    Console.WriteLine(&quot;对方说的英语&quot;);                    break;            &#125;        &#125;    &#125;    class GermanExpretion : Expretion    &#123;        public override void Excute(string s)        &#123;            switch (s)            &#123;                case &quot;g&quot;:                    Console.WriteLine(&quot;对方说的德语&quot;);                    break;            &#125;        &#125;    &#125;    class Words    &#123;        private string words;        public string MyWords        &#123;            get &#123; return words; &#125;            set &#123; words = value; &#125;        &#125;    &#125;    class Client    &#123;        public static void Main()        &#123;            Words w = new Words();            w.MyWords = &quot;e g e e g &quot;;            Expretion e = null;            while (w.MyWords.Length &gt; 0)            &#123;                switch (w.MyWords.Substring(0, 1))                &#123;                    case &quot;e&quot;:                        e = new EnglishExpretion();                        break;                    case &quot;g&quot;:                        e = new GermanExpretion();                        break;                &#125;                e.Translate(w);            &#125;            Console.Read();        &#125;    &#125;&#125;\n\n\n\n\n","tags":["设计模式读书笔记"]},{"title":"关于显式接口实现","url":"/blog/2008/08/20/%E5%85%B3%E4%BA%8E%E6%98%BE%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0/","content":"第一个问题： http://topic.csdn.net/u/20080819/22/0bafb453-d03e-4d89-9a7a-1c087a13007a.html \n第二个问题： http://topic.csdn.net/u/20080819/22/0665f814-dddd-4cdd-a461-85620dca21b3.html \nMSDN的解释： http://msdn.microsoft.com/zh-cn/library/ms173157(VS.80).aspx\n留此存根\n\n\n\n\n","tags":["《你必须知道的.NET》"]},{"title":"设计模式---访问者模式（应该是最后一篇了）","url":"/blog/2008/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F---%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%BA%94%E8%AF%A5%E6%98%AF%E6%9C%80%E5%90%8E%E4%B8%80%E7%AF%87%E4%BA%86%EF%BC%89/","content":"\nusing System;using System.Collections.Generic;using System.Text;namespace ConsoleApplication1&#123;    abstract class Element    &#123;        public abstract void Accept(Visitor v);    &#125;    class Elem1 : Element    &#123;        public override void Accept(Visitor v)        &#123;            v.VisitElem1(this);        &#125;    &#125;    class Elem2 : Element    &#123;        public override void Accept(Visitor v)        &#123;            v.VisitElem2(this);        &#125;    &#125;    abstract class Visitor    &#123;        public abstract void VisitElem1(Elem1 e1);        public abstract void VisitElem2(Elem2 e2);    &#125;    class Visitor1 : Visitor    &#123;        public override void VisitElem1(Elem1 e1)        &#123;            Console.WriteLine(this.GetType().Name + &quot;  &quot; + e1.GetType().Name);        &#125;        public override void VisitElem2(Elem2 e2)        &#123;            Console.WriteLine(this.GetType().Name + &quot;  &quot; + e2.GetType().Name);        &#125;    &#125;    class Visitor2 : Visitor    &#123;        public override void VisitElem1(Elem1 e1)        &#123;            Console.WriteLine(this.GetType().Name + &quot;  &quot; + e1.GetType().Name);        &#125;        public override void VisitElem2(Elem2 e2)        &#123;            Console.WriteLine(this.GetType().Name + &quot;  &quot; + e2.GetType().Name);        &#125;    &#125;    class ObjStructure    &#123;        private List&lt;Element&gt; elems = new List&lt;Element&gt;();        public void add(Element e)        &#123;            elems.Add(e);        &#125;        public void visit(Visitor v)        &#123;            foreach (Element e in elems)            &#123;                e.Accept(v);            &#125;        &#125;    &#125;    class Client    &#123;        public static void Main()        &#123;            ObjStructure o = new ObjStructure();            o.add(new Elem1());            o.add(new Elem2());            o.visit(new Visitor1());            o.visit(new Visitor2());            Console.Read();        &#125;    &#125;&#125;\n\n\n\n\n\n","tags":["设计模式读书笔记"]},{"title":"MSIL的条件跳转（不知道正确与否）","url":"/blog/2008/08/24/MSIL%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%EF%BC%88%E4%B8%8D%E7%9F%A5%E9%81%93%E6%AD%A3%E7%A1%AE%E4%B8%8E%E5%90%A6%EF%BC%89/","content":"C# Code：\npublic static void Main3_3_3()&#123;    int x = 10;    int y = 6;    if (x &gt; y)    &#123;        Console.WriteLine(x);    &#125;    else    &#123;        Console.WriteLine(y);    &#125;    Console.Read();&#125;\n\n对应MSIL及其注释：\n.method  public  hidebysig  static  void  Main3_3_3() cil managed &#123; .maxstack 2 .locals init ( [0] int32 x, [1] int32 y, [2]  bool  CS$4$0000)  //定义三个变量L_0000: nop L_0001: ldc.i4.s 10  //把整型值10载入堆栈 L_0003: stloc.0  //把刚才载入堆栈的10赋值给第一个local变量，也就是int x=10; L_0004: ldc.i4.6  //把整型值6载入堆栈 L_0005: stloc.1  //把刚才载入堆栈的6赋值给第二个local变量，也就是int y=6; L_0006: ldloc.0 L_0007: ldloc.1  //这两句，把x,y两个local变量载入堆栈 L_0008: cgt  //比较x，y的大小，结果会保存在堆栈最上方（结果以0或1表示true ，false） L_000a: ldc.i4.0  //把0载入堆栈 L_000b: ceq  //比较0和cgt的运算结果是否相等，结果会保存在堆栈最上方（结果以0或1表示true ，false） L_000d: stloc.2  //ceq的运算结果保存入bool变量中 L_000e: ldloc.2  //再把ceq运算结果载入 L_000f: brtrue.s L_001a  //判断跳转，若跳转显式Y，不跳转显式X L_0011: ldloc.0 L_0012: callvoid  [mscorlib]System.Console::WriteLine(int32)L_0017: nop L_0018: br.s L_0021 L_001a: ldloc.1 L_001b: callvoid  [mscorlib]System.Console::WriteLine(int32)L_0020: nop L_0021: call int32 [mscorlib]System.Console::Read() L_0026: pop L_0027: ret &#125; \n\n\n\n\n\n","tags":["《你必须知道的.NET》"]},{"title":"new关键字用作修饰符","url":"/blog/2008/08/28/new%E5%85%B3%E9%94%AE%E5%AD%97%E7%94%A8%E4%BD%9C%E4%BF%AE%E9%A5%B0%E7%AC%A6/","content":"用new修饰的方法,在编译期按变量类型调用\n所以：\nNumber number &#x3D; new IntNumber();number.ShowInfo();\n会显示”base class—“\nclass Number&#123;    public static int i = 123;    public virtual void ShowInfo()    &#123;        Console.WriteLine(&quot;base class---&quot;);    &#125;    public virtual void ShowNumber()    &#123;        Console.WriteLine(i.ToString());    &#125;&#125;class IntNumber : Number&#123;    new public static int i = 456;    public new virtual void ShowInfo()    &#123;        Console.WriteLine(&quot;Derived class---&quot;);    &#125;    public override void ShowNumber()    &#123;        Console.WriteLine(&quot;Base number is &#123;0&#125;&quot;, Number.i.ToString());        Console.WriteLine(&quot;New number is &#123;0&#125;&quot;, i.ToString());    &#125;&#125;class Test_Number&#123;    public static void Main() //Main_6_1_1    &#123;        Number num = new Number();        num.ShowNumber();        IntNumber intNum = new IntNumber();        intNum.ShowNumber();        intNum.ShowInfo();        Number number = new IntNumber();        //究竟调用了谁？        number.ShowInfo();        //究竟调用了谁？        number.ShowNumber();        Console.Read();    &#125;&#125;\n\n\n\n\n\n\n","tags":["《你必须知道的.NET》"]},{"title":"引用类型参数的按值传递","url":"/blog/2008/08/28/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/","content":"一个小问题：  http://topic.csdn.net/u/20080826/21/1b29e906-4ebb-49ab-98e3-982b7f2249f5.html \n\n\n\n\n","tags":["《你必须知道的.NET》"]},{"title":"一个关于深层拷贝的问题（迷惑在私有构造函数）","url":"/blog/2008/09/04/%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8E%E6%B7%B1%E5%B1%82%E6%8B%B7%E8%B4%9D%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E8%BF%B7%E6%83%91%E5%9C%A8%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%89/","content":"一个关于深层拷贝的问题（迷惑在私有构造函数）\n地址： http://topic.csdn.net/u/20080903/16/0f89b388-0c33-4c0f-931c-0520c907fdad.html \n\n\n\n\n","tags":["《你必须知道的.NET》"]},{"title":"可以为null的值类型","url":"/blog/2008/09/09/%E5%8F%AF%E4%BB%A5%E4%B8%BAnull%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B/","content":"可以为null的值类型\n地址：  http://topic.csdn.net/u/20080909/11/ad46c1db-327d-4c23-a78a-d65deebd9d1d.html \n\n\n\n\n","tags":["《你必须知道的.NET》"]},{"title":"cpu占用率为正弦曲线（C#实现）基本照抄书上的C++","url":"/blog/2008/09/17/cpu%E5%8D%A0%E7%94%A8%E7%8E%87%E4%B8%BA%E6%AD%A3%E5%BC%A6%E6%9B%B2%E7%BA%BF%EF%BC%88CSharp%E5%AE%9E%E7%8E%B0%EF%BC%89%E5%9F%BA%E6%9C%AC%E7%85%A7%E6%8A%84%E4%B9%A6%E4%B8%8A%E7%9A%84C++/","content":"internal值根据配置调整\nusing System;using System.Collections.Generic;using System.Linq;using System.Text;namespace ConsoleApplication1&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            const double SPLIT = 0.01;            const int COUNT = 200;            const double PI = 3.14159265;            const int INTERVAL = 100;            double[] busySpan = new double [COUNT]; //array of busy times            double[] idleSpan = new double [COUNT]; //array of idle times            int half = INTERVAL / 2;            double radian = 0.0;            for (int i = 0; i &lt; COUNT; i++)            &#123;                busySpan[i] = (double) (half + (Math.Sin(PI * radian) * half));                idleSpan[i] = INTERVAL - busySpan[i];                radian += SPLIT;            &#125;            double startTime = 0;            int j = 0;            while (true)            &#123;                j = j % COUNT;                startTime = Environment.TickCount;                while ((Environment.TickCount - startTime) &lt;= busySpan[j]) ;                System.Threading.Thread.Sleep((int) idleSpan[j]);                j++;            &#125;        &#125;    &#125;&#125;\n\n\n\n\n\n","tags":["《编程之美——微软技术面试心得》的C#实现"]},{"title":"编译不可通过?short s1 = 1;short s2 = 2;short s3 = s1 + s2; why??","url":"/blog/2008/08/28/%E7%BC%96%E8%AF%91%E4%B8%8D%E5%8F%AF%E9%80%9A%E8%BF%87%20why/","content":"连接：  http://topic.csdn.net/u/20080826/00/092e304d-b342-4e75-b62d-801142b556ca.html \n\n\n\n\n","tags":["疑难"]},{"title":"编程之美---阶乘末尾有几个\"零\"?(C#实现)","url":"/blog/2008/09/18/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E---%E9%98%B6%E4%B9%98%E6%9C%AB%E5%B0%BE%E6%9C%89%E5%87%A0%E4%B8%AA0(CSharp%E5%AE%9E%E7%8E%B0)/","content":"using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace ConsoleApplication1&#123;    class Program    &#123;        delegate long DoMath(long num);        static void Main(string[] args)        &#123;            Program p = new Program();            p.GetFactorial(26);            DoMath d = new DoMath(p.HowManyZero);            d += p.HowManyZero2;            d(26);            Console.Read();        &#125;        public long HowManyZero(long num) //第一种解法        &#123;            long result = 0;            for (long i = 1; i &lt;= num; i++)            &#123;                long j = i;                while (j % 5 == 0)                &#123;                    result++; //检查每一个数可以分解因式出多少个5                    j /= 5;                &#125;            &#125;            Console.WriteLine(result);            return result;        &#125;        public long HowManyZero2(long num) //第二种        &#123;            long ret = 0;            while (num != 0)            &#123;                ret += num / 5; //可以被5整除，然后是25、125、625......                num /= 5;            &#125;            Console.WriteLine(ret);            return ret;        &#125;        public decimal GetFactorial(long num) //获得阶乘        &#123;            decimal ret = 1;            for (long i = 1; i &lt;= num; i++)            &#123;                ret *= i;            &#125;            Console.WriteLine(ret);            return ret;        &#125;    &#125;&#125;\n\n 书上只标了2颗星，我怎么觉得这么费劲….PS：decimal都算不到30的阶乘啊……\n具体讲解书上有\n顺便复习一下delegate~~~~~~~\n\n\n\n\n","tags":["《编程之美——微软技术面试心得》的C#实现"]},{"title":"《编程之美——微软技术面试心得》的C#实现---电梯调度问题解法一","url":"/blog/2008/09/11/%E3%80%8A%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E2%80%94%E2%80%94%E5%BE%AE%E8%BD%AF%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E5%BF%83%E5%BE%97%E3%80%8B%E7%9A%84CSharp%E5%AE%9E%E7%8E%B0---%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98%E8%A7%A3%E6%B3%95%E4%B8%80/","content":"class Program&#123;    static void Main(string[] args)    &#123;        int[] person = &#123;0, 1, 1, 1, 1, 1, 15&#125;; //总共六层楼，没有0层        int needed = 0;        int min = 0;        int target = 0;        for (int i = 1; i &lt;= 6; i++)        &#123;            needed = 0;            for (int j = 1; j &lt; i; j++)            &#123;                //目的在i层以下的                needed += person[j] * (i - j);            &#125;            for (int j = i + 1; j &lt;= 6; j++)            &#123;                //目的在i层上面的                needed += person[j] * (j - i);            &#125;            if (min == 0 || min &gt;= needed)            &#123;                min = needed;                target = i;            &#125;        &#125;        Console.WriteLine(target);        Console.Read();    &#125;\n\n\n\n\n\n\n","tags":["《编程之美——微软技术面试心得》的C#实现"]},{"title":"编程之美---1的个数C#笨（效率低）方法实现","url":"/blog/2008/09/18/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E---1%E7%9A%84%E4%B8%AA%E6%95%B0CSharp%E7%AC%A8%EF%BC%88%E6%95%88%E7%8E%87%E4%BD%8E%EF%BC%89%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0/","content":"编程之美—1的个数C#笨（效率低）的方法实现\nclass Program&#123;    static void Main(string[] args)    &#123;        Program p = new Program();        Console.WriteLine(p.count_1_in_a_bounch_of_nums(13));        Console.Read();    &#125;    public int count_1_in_a_num(int num)    &#123;        int count = 0;        while (num != 0)        &#123;            count += (num % 10) == 1 ? 1 : 0;            num /= 10;        &#125;        return count;    &#125;    public int count_1_in_a_bounch_of_nums(int end)    &#123;        int count = 0;        for (int i = 1; i &lt;= end; i++)        &#123;            count += count_1_in_a_num(i);        &#125;        return count;    &#125;&#125;\n\n\n\n\n\n\n","tags":["《编程之美——微软技术面试心得》的C#实现"]},{"title":"对Graphic的应用，实现类似九宫格的绘制字符串、制定圆心，半径绘制圆形、用火柴棍拼字[Java ME]","url":"/blog/2008/10/03/%E5%AF%B9Graphic%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BC%E4%B9%9D%E5%AE%AB%E6%A0%BC%E7%9A%84%E7%BB%98%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%88%B6%E5%AE%9A%E5%9C%86%E5%BF%83%EF%BC%8C%E5%8D%8A%E5%BE%84%E7%BB%98%E5%88%B6%E5%9C%86%E5%BD%A2%E3%80%81%E7%94%A8%E7%81%AB%E6%9F%B4%E6%A3%8D%E6%8B%BC%E5%AD%97%5BJava%20ME%5D/","content":"\n\n\n\nimport  javax.microedition.midlet.*;import  javax.microedition.lcdui.*;public class HomeWork extends MIDlet implements CommandListener &#123;\tDisplay d = Display.getDisplay(this);\tFormattedFloatingDecimal.Form f = new Form(&quot;主窗口&quot;);\tCommand back = new Command(&quot;返回&quot;, Command.BACK, 1);\tCommand exit = new Command(&quot;退出&quot;, Command.EXIT, 1);\tCommand drs = new Command(&quot;绘制字符串&quot;, Command.OK, 1);\tCommand drc = new Command(&quot;画圆&quot;, Command.OK, 1);\tCommand drn = new Command(&quot;火柴棍拼字&quot;, Command.OK, 1);\t//用于画圆的\tpublic class CircleCanvas extends Canvas &#123;\t\tint pointX, pointY, len;\t\tpublic void paint(Graphics g) &#123;\t\t\tg.setColor(255, 0, 0);\t\t\tg.fillArc(pointX, pointY, len, len, 0, 360);\t\t\tg.drawRect(pointX, pointY, len, len);  //框住了就代表对了\t\t&#125;\t\tpublic void drawCircle(int x, int y, int r) &#123;\t\t\tpointX = x - r;\t\t\tpointY = y - r;\t\t\tlen = 2 * r;\t\t&#125;\t&#125;\t//用于在指定位置绘制字符串\tpublic class MyCanvas extends Canvas &#123;\t\tString printword = &quot;&quot;;\t\tint[] myenum = &#123;\t\t\t0, 0, Graphics.LEFT | Graphics.TOP,\t\t\tgetWidth() / 2, 0, Graphics.HCENTER | Graphics.TOP,\t\t\tgetWidth(), 0, Graphics.RIGHT | Graphics.TOP,\t\t\t0, getHeight() / 2, Graphics.LEFT | Graphics.TOP, getWidth() / 2,\t\t\tgetHeight() / 2, Graphics.HCENTER | Graphics.TOP,\t\t\tgetWidth(), getHeight() / 2, Graphics.RIGHT | Graphics.TOP, 0,\t\t\tgetHeight(), Graphics.LEFT | Graphics.BOTTOM,\t\t\tgetWidth() / 2,\t\t\tgetHeight(), Graphics.HCENTER | Graphics.BOTTOM,\t\t\tgetWidth(), getHeight(), Graphics.RIGHT | Graphics.BOTTOM\t\t&#125;;\t\tint[] position = new int[3];\t\tpublic void paint(Graphics g) &#123;\t\t\tg.setColor(255, 0, 0);\t\t\tg.drawString(printword, position[0], position[1], position[2]);\t\t&#125;\t\tpublic void DrawMyStrin(String s, int pos) &#123;\t\t\tprintword = s;\t\t\tposition[0] = myenum[pos * 3 - 3];\t\t\tposition[1] = myenum[pos * 3 - 2];\t\t\tposition[2] = myenum[pos * 3 - 1];\t\t&#125;\t&#125;\t//用火柴棍拼字\tpublic class MatchNum extends Canvas &#123;\t\tint[][] lines =\t\t\t&#123;\t\t\t\t&#123;\t\t\t\t\t100, 100, 120, 100\t\t\t\t&#125;,  //0\t\t\t\t&#123;\t\t\t\t\t100, 120, 120, 120\t\t\t\t&#125;,  //1\t\t\t\t&#123;\t\t\t\t\t100, 140, 120, 140\t\t\t\t&#125;,  //2 //三个横\t\t\t\t&#123;\t\t\t\t\t100, 100, 100, 120\t\t\t\t&#125;,  //3\t\t\t\t&#123;\t\t\t\t\t100, 120, 100, 140\t\t\t\t&#125;,  //4//左边的两竖\t\t\t\t&#123;\t\t\t\t\t120, 100, 120, 120\t\t\t\t&#125;,  //5\t\t\t\t&#123;\t\t\t\t\t120, 120, 120, 140\t\t\t\t&#125;\t\t\t&#125;;  //6//右边的两竖\t\tint[][] nums =\t\t\t&#123;\t\t\t\t&#123;\t\t\t\t\t0, 2, 3, 4, 5, 6\t\t\t\t&#125;,  //0\t\t\t\t&#123;\t\t\t\t\t5, 6\t\t\t\t&#125;,  //1\t\t\t\t&#123;\t\t\t\t\t0, 1, 2, 5, 4\t\t\t\t&#125;,  //2\t\t\t\t&#123;\t\t\t\t\t0, 1, 2, 5, 6\t\t\t\t&#125;,  //3\t\t\t\t&#123;\t\t\t\t\t5, 6, 1, 3\t\t\t\t&#125;,  //4\t\t\t\t&#123;\t\t\t\t\t0, 1, 2, 3, 6\t\t\t\t&#125;,  //5\t\t\t\t&#123;\t\t\t\t\t3, 4, 0, 1, 2, 6\t\t\t\t&#125;,  //6\t\t\t\t&#123;\t\t\t\t\t0, 5, 6\t\t\t\t&#125;,  //7\t\t\t\t&#123;\t\t\t\t\t0, 1, 2, 3, 4, 5, 6\t\t\t\t&#125;,  //8\t\t\t\t&#123;\t\t\t\t\t0, 1, 3, 5, 6, 2\t\t\t\t&#125;,  //9\t\t\t&#125;;\t\tint[] temp;\t\tpublic void drawMyNum(int n) &#123;\t\t\ttemp = nums[n];\t\t&#125;\t\tpublic void paint(Graphics g) &#123;\t\t\tg.setColor(255, 0, 0);\t\t\tint i = temp.length;\t\t\tfor (int j = 0; j &lt;= i - 1; j++) &#123;\t\t\t\tint[] a = lines[temp[j]];\t\t\t\tg.drawLine(a[0], a[1], a[2], a[3]);\t\t\t&#125;\t\t&#125;\t&#125;\tpublic void startApp() &#123;\t\tf.addCommand(exit);\t\tf.addCommand(drs);\t\tf.addCommand(drc);\t\tf.addCommand(drn);\t\tf.setCommandListener(this);\t\td.setCurrent(f);\t&#125;\tpublic void commandAction(Command c, Displayable dis) &#123;\t\tif (c == exit)\t\t\tdestroyApp(false);\t\telse if (c == drs) &#123;\t\t\tMyCanvas m = new MyCanvas();\t\t\tm.addCommand(back);\t\t\tm.setCommandListener(this);\t\t\tm.DrawMyStrin(&quot;字符串&quot;, new java.util.Random().nextInt(8) + 1);\t\t\td.setCurrent(m);\t\t&#125; else if (c == drc) &#123;\t\t\tCircleCanvas cc = new CircleCanvas();\t\t\tcc.addCommand(back);\t\t\tcc.setCommandListener(this);\t\t\tcc.drawCircle(60, 60, 40);\t\t\td.setCurrent(cc);\t\t&#125; else if (c == drn) &#123;\t\t\tMatchNum mn = new MatchNum();\t\t\tmn.addCommand(back);\t\t\tmn.setCommandListener(this);\t\t\tmn.drawMyNum(new java.util.Random().nextInt(9));\t\t\td.setCurrent(mn);\t\t&#125; else if (c == back) &#123;\t\t\td.setCurrent(f);\t\t&#125;\t&#125;\tpublic void pauseApp() &#123;\t&#125;\tpublic void destroyApp(boolean unconditional) &#123;\t\tnotifyDestroyed();\t&#125;&#125;\n\n\n\n\n","tags":["graphics"]},{"title":"文字竖排工具BY烟锁重楼","url":"/blog/2008/10/09/%E6%96%87%E5%AD%97%E7%AB%96%E6%8E%92%E5%B7%A5%E5%85%B7BY%E7%83%9F%E9%94%81%E9%87%8D%E6%A5%BC/","content":"运行库：.net 2.0\n下载地址： http://pickup.mofile.com/7286535210268103\n备用地址： http://ishare.iask.sina.com.cn/cgi-bin/fileid.cgi?fileid=4452071\n\nps:烟锁重楼是我原来的网名  \n\n\n\n\n","tags":["utils"]},{"title":"文字竖排工具 By 崔鹏飞 没有混淆，可以用reflector看代码","url":"/blog/2008/10/12/%E6%96%87%E5%AD%97%E7%AB%96%E6%8E%92%E5%B7%A5%E5%85%B7%20By%20%E5%B4%94%E9%B9%8F%E9%A3%9E%20%E6%B2%A1%E6%9C%89%E6%B7%B7%E6%B7%86%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%94%A8reflector%E7%9C%8B%E4%BB%A3%E7%A0%81/","content":"功能全面的文字竖排工具。\n实现功能：截图、设置字体、繁体转换、文字竖排、设置行列数实现分页、输入原文的时候同步显示竖排文字、一键复制到剪切板等。\n注意：C#编写，需要.net framework 2.0\n下载地址： http://download.csdn.net/source/686787\n发现缺陷、不足、bug，请告知我，我会尽快修改\nps：没有混淆，可以用reflector看代码\n图片：\n\n\n\n\n\n","tags":["utils"]},{"title":"Good news from O'Reilly's Chinese website","url":"/blog/2008/10/30/Good%20news%20from%20O'Reilly's%20Chinese%20website/","content":"官方即将出版中文版，看图：\n\n本系列预计将在官方中文版available之后停止翻译\n以后大家可以看质量有保证的了~~\n但在正版出现之前，我将继续更新，希望大家继续关注，谢谢~~~~~~~~~\n\n\n\n\n","tags":["我翻译的Head First C#（习作）"]},{"title":"数据结构:二叉树的建立和遍历(C#实现)","url":"/blog/2008/12/12/data-structure-binary-tree/","content":"遍历只做了先序,递归实现的,中序和后序都类似.代码比较简单,就不写注释,直接贴出来了\n代码:\nTreeNode:结点类\nusing System;using System.Collections.Generic;using System.Text;namespace 二叉树的建立和遍历&#123;    class TreeNode    &#123;        public char data;        public TreeNode left, right;        public TreeNode(char c, TreeNode l, TreeNode r)        &#123;            data = c;            left = l;            right = r;        &#125;        public TreeNode()        &#123;            left = right = null;        &#125;    &#125;&#125;\n\n Tree:树类 \nusing System;using System.Collections.Generic;using System.Text;namespace 二叉树的建立和遍历&#123;    class Tree    &#123;        public TreeNode root;        Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();        public void CreateTree(String description)        &#123;            bool left = true;            char[] descriptionarray = description.ToCharArray();            root = new TreeNode();            root.data = descriptionarray[0];            TreeNode temp = root;            for (int i = 1; i &lt;= descriptionarray.Length - 1; i++)            &#123;                if (descriptionarray[i] == &#x27;(&#x27;)                &#123;                    left = true;                    stack.Push(temp);                &#125;                else if (descriptionarray[i] == &#x27;,&#x27;)                &#123;                    left = false;                &#125;                else if (descriptionarray[i] == &#x27;)&#x27;)                &#123;                    stack.Pop();                &#125;                else                &#123;                    temp = new TreeNode();                    temp.data = descriptionarray[i];                    if (left == true)                    &#123;                        stack.Peek().left = temp;                    &#125;                    else                    &#123;                        stack.Peek().right = temp;                    &#125;                &#125;            &#125;        &#125;        public void PreOrder(TreeNode t, String sign)        &#123;            if (t != null)            &#123;                Console.WriteLine(sign + t.data);                sign += sign;                if (t.left != null)                &#123;                    PreOrder(t.left, sign);                &#125;                if (t.right != null)                &#123;                    PreOrder(t.right, sign);                &#125;            &#125;        &#125;    &#125;&#125;\n\n Program:调用者 \nusing System;using System.Collections.Generic;using System.Text;namespace 二叉树的建立和遍历&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            //TreeNode t=null;            Tree tree = new Tree();            Console.WriteLine(&quot;请输入用字符串表示的二叉树&quot;);            string input = Console.ReadLine();            tree.CreateTree(input);            Console.WriteLine(&quot;遍历&quot;);            tree.PreOrder(tree.root, &quot;--&quot;);            Console.Read();        &#125;    &#125;&#125;\n\n\n\n\n\n","tags":["Data Structrue"]},{"title":"数据结构：用队列模拟理发店的排队情况（C#）","url":"/blog/2008/11/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%94%A8%E9%98%9F%E5%88%97%E6%A8%A1%E6%8B%9F%E7%90%86%E5%8F%91%E5%BA%97%E7%9A%84%E6%8E%92%E9%98%9F%E6%83%85%E5%86%B5%EF%BC%88CSharp%EF%BC%89/","content":"题目内容：使用的排队现象，通过仿真手法评估其营业状况。*基本要求：设某理发馆有N把理发椅，可同时为N位顾客进行理发。*当顾客进门时，若有空椅，则可以立即坐下理发，否则需要依次排队等候。*一旦有顾客理完发离去时，排在队头的顾客便可开始理发。*若理发馆每天连续营业T小时，求一天内顾客在理发馆内的平均逗留时间*顾客排队等候的队列平均长度 \nN和T在运行的时候输入\n用C#写的，有注释，很混乱，请高人指教~~\nusing System;using System.Collections.Generic;using System.Text;using System.Collections;namespace 队列应用&#123;    class Seat    &#123;        public bool IsFree;        public Customer cus = null;        public Seat(bool b)        &#123;            IsFree = b;        &#125;    &#125;    class Customer    &#123;        public int cometime;        public int timetogo;        public int cost = 30 - new Random().Next(10); //理发需要20~30分钟        public Customer()        &#123;        &#125;    &#125;    class Program    &#123;        static void Main(string[] args)        &#123;            System.Console.WriteLine(&quot;每天营业多少小时？&quot;);            int workinghours = int.Parse(Console.ReadLine());            System.Console.WriteLine(&quot;有多少个椅子？&quot;);            int seats = int.Parse(Console.ReadLine());            Process(seats, workinghours);            Console.ReadLine();        &#125;        static void Process(int num, int time)        &#123;            //------------准备变量------------------------            Queue q = new Queue(); //队列            Seat[] S = new Seat[num]; //所有的椅子            for (int i = 0; i &lt; num; i++) //初始化椅子            &#123;                S[i] = new Seat(true);                S[i].cus = null;            &#125;            int somebodycome = 1; //第一个顾客来的时间            //int count = 0;//顾客计数器            List&lt;Customer&gt; cuslist = new List&lt;Customer&gt;();            int st = num; //椅子数            int Qlen = 0; //队列长度            int Qchangetime = 0; //队列长度改变次数            //------------准备变量--------------------------            for (int t = 1; t &lt;= time * 60; t++) //时间从第一分钟开始流逝，每分钟检查状态            &#123;                //--------检查现在有没有人需要离开--------------                CheckLeave(S, t);                //--------检查现在有没有人需要离开--------------                //-------检查排队的人是否可以找到座位---------                CheckSeat(q, S, ref Qlen, ref Qchangetime, t);                //-------检查排队的人是否可以找到座位---------                //-------------如果来人了，有座位就坐下，没座位就排队-------------------                if (t == somebodycome)                &#123;                    bool IsSitted = false; //当前刚来的顾客是否找到了座位                    Customer c = new Customer();                    c.cometime = t;                    cuslist.Add(c);                    foreach (Seat s in S)                    &#123;                        if (s.IsFree == true)                        &#123;                            s.IsFree = false;                            s.cus = c;                            s.cus.timetogo = t + s.cus.cost;                            IsSitted = true;                            break;                        &#125;                    &#125;                    if (IsSitted == false)                    &#123;                        q.Enqueue(c);                        Qlen += q.Count;                        Qchangetime++;                    &#125;                    else                    &#123;                        IsSitted = false;                    &#125;                    somebodycome += 10 - new Random().Next(5); //下一个顾客来的时间,假设5~10分钟之内会有一个                &#125;                //------如果来人了，有座位就坐下，没座位就排队---------            &#125;            //---------加班----------            bool Inseat = true;            //bool InQ = true;            bool KeepWorking = true;            int curtime = time * 60 + 1;            while (KeepWorking)            &#123;                CheckLeave(S, curtime);                CheckSeat(q, S, ref Qlen, ref Qchangetime, curtime);                foreach (Seat s in S)                &#123;                    if (s.IsFree == false)                    &#123;                        Inseat = true;                        break;                    &#125;                    else                    &#123;                        Inseat = false;                    &#125;                &#125;                KeepWorking = Inseat;                curtime++;            &#125;            //---------加班----------            //--------------            int no = 1;            foreach (Customer c in cuslist)            &#123;                Console.Write(&quot;第&#123;0&#125;个顾客  &quot;, no);                Console.Write(&quot;来的时间：&quot; + c.cometime);                Console.WriteLine(&quot;  走的时间:&quot; + c.timetogo);                no++;            &#125; //------------------            //--------打印结果-------------            int totalstaytime = 0;            foreach (Customer c in cuslist)            &#123;                int staytime = c.timetogo - c.cometime;                totalstaytime += staytime;            &#125;            int averragestay = totalstaytime / cuslist.Count;            System.Console.WriteLine(&quot;平均逗留时间:&quot; + averragestay);            System.Console.WriteLine(&quot;顾客数量:&quot; + cuslist.Count);            if (Qchangetime != 0)            &#123;                int averagelen = Qlen / Qchangetime;                Console.WriteLine(&quot;队列平均长度：&quot; + averagelen);            &#125;            else            &#123;                Console.WriteLine(&quot;椅子充足，不用排队&quot;);            &#125;            Console.WriteLine(&quot;加班时间：&quot; + (curtime - time * 60) + &quot;分钟&quot;);            //--------打印结果------------        &#125;        private static void CheckSeat(Queue q, Seat[] S, ref int Qlen, ref int Qchangetime, int t)        &#123;            if (q.Count != 0) //如果有人排队            &#123;                foreach (Seat s in S)                &#123;                    if (s.IsFree == true)                    &#123;                        s.IsFree = false;                        s.cus = (Customer) q.Dequeue();                        Qlen += q.Count;                        Qchangetime++;                        s.cus.timetogo = t + s.cus.cost; //                    &#125;                &#125;            &#125;        &#125;        private static void CheckLeave(Seat[] S, int t)        &#123;            foreach (Seat s in S)            &#123;                if (s.cus != null)                &#123;                    if (s.cus.timetogo == t)                    &#123;                        s.IsFree = true;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;\n\n\n\n\n\n","tags":["Data Structrue"]},{"title":"迅雷账号升级到24了，全球70000名。Oh~~Yeah~~~~","url":"/blog/2009/01/14/%E8%BF%85%E9%9B%B7%E8%B4%A6%E5%8F%B7%E5%8D%87%E7%BA%A7%E5%88%B024%E4%BA%86%EF%BC%8C%E5%85%A8%E7%90%8370000%E5%90%8D/","content":"\n也不知道会不会快一些……\n\n\n\n\n","tags":["杂7杂8"]},{"title":"SWPU学分绩点计算器女生版","url":"/blog/2009/02/06/SWPU%E5%AD%A6%E5%88%86%E7%BB%A9%E7%82%B9%E8%AE%A1%E7%AE%97%E5%99%A8%E5%A5%B3%E7%94%9F%E7%89%88/","content":"所谓女生版就是指的GUI稍微美化了一点点，我承认是标题党….\n\n注意：需要有.net Framework 2.0才可以运行\n.net Framework 2.0下载地址（如果你的电脑没有请在这儿下载）：http://www.gougou.com/search?search=.net%20Framework%202.0&amp;id=0\n学分绩点计算器下载地址： http://download.csdn.net/source/993661（要有CSDN账号才可以下载）\n没有CSDN账号请向  397649079@QQ.com  索取\n代码在压缩包里面有。\n\n\n\n\n","tags":["utils"]},{"title":"西南石油大学--学分绩点计算器（用C#编写，需要有.NET 2.0）","url":"/blog/2009/01/16/%E8%A5%BF%E5%8D%97%E7%9F%B3%E6%B2%B9%E5%A4%A7%E5%AD%A6--%E5%AD%A6%E5%88%86%E7%BB%A9%E7%82%B9%E8%AE%A1%E7%AE%97%E5%99%A8%EF%BC%88%E7%94%A8CSharp%E7%BC%96%E5%86%99%EF%BC%8C%E9%9C%80%E8%A6%81%E6%9C%89.NET%202.0%EF%BC%89/","content":"注意：需要有.net Framework 2.0才可以运行\n.net Framework 2.0下载地址（如果你的电脑没有请在这儿下载）：http://www.gougou.com/search?search=.net%20Framework%202.0&amp;id=0\n学分绩点计算器下载地址： http://download.csdn.net/source/973619（要有CSDN账号才可以下载）\n运行效果（示例而已）：\n\n——————————————分割线下面是类关系图、代码———————-这是类关系图：\n\n下面是代码：\nusing System;using System.Collections.Generic;using System.Text;namespace 西南石油大学_学分绩点计算器&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;西南石油大学--学分绩点计算器&quot;);            Console.WriteLine();            Term thisTerm = new Term();            int NumOfCourses = GetInput.CourseNum(); //本学期课程数 for(int            for (i = 1; i &lt;= NumOfCourses; i++)            &#123;                Console.WriteLine();                Console.WriteLine(&quot;--------------开始录入第&#123;0&#125;门课程--------------&quot;, i);                Console.WriteLine(&quot;第&#123;0&#125;门课程有几个学分？&quot;, i);                double credit = GetInput.GetCredit();                Console.WriteLine(&quot;第&#123;0&#125;门课程考了多少分？&quot;, i);                double score = GetInput.GetCredit();                Course OneCourse = new Course(credit, score);                thisTerm.AddOneCourse(OneCourse);                Console.WriteLine(&quot;--------------第&#123;0&#125;门课程录入完毕--------------&quot;, i);                Console.WriteLine();            &#125;            Console.WriteLine(&quot;最后学分绩点是：&quot; + thisTerm.GetFinalJIDIAN());            Console.WriteLine(&quot;欢迎访问我的博客：http://blog.csdn.net/cuipengfei1&quot;);            Console.Read();            System.Diagnostics.Process.Start(&quot;http://blog.csdn.net/cuipengfei1&quot;);        &#125;    &#125;    class GetInput    &#123;        public static int CourseNum()        &#123;            Console.WriteLine(&quot;本学期一共有几门必修课程？（注意，是必修课程哦）&quot;);            string num = Console.ReadLine();            int NUM;            int.TryParse(num, out NUM);            return NUM;        &#125;        public static double            GetCredit()        &#123;            string credit = Console.ReadLine();            double CREDIT;            double.TryParse(credit, out CREDIT);            return CREDIT;        &#125;    &#125;    class Course //一门课程    &#123;        private double credit; //学分 private double score;//分数 public double Credit//学分        &#123;            get            &#123;                return credit;            &#125;            set            &#123;                credit = value;            &#125;        &#125;        public double Score //分数        &#123;            get &#123; return score; &#125;            set &#123; score = value; &#125;        &#125;        public Course(double            _credit, double _score) //构造        &#123;            credit = _credit;            score = _score;        &#125;        public double            GetJIDIAN() //本门绩点        &#123;            double jidian;            jidian = ((score - 60) / 10) + 1;            return jidian;        &#125;    &#125;    class Term //本学期    &#123;        List&lt;Course&gt; AllCourse = new List&lt;Course&gt;();        public void AddOneCourse(Course course)        &#123;            AllCourse.Add(course);        &#125;        public            double GetFinalJIDIAN()        &#123;            double totalCredit = 0;            double totalJIDIAN = 0;            foreach                (Course oneCourse in AllCourse)            &#123;                totalCredit += oneCourse.Credit;                totalJIDIAN                    += oneCourse.GetJIDIAN() * oneCourse.Credit;            &#125;            return totalJIDIAN / totalCredit;        &#125;    &#125;&#125;\n\nPS：什么时候可以查分啊？\n\n\n\n\n","tags":["utils"]},{"title":"《计算机图形技术》练习--用GDI+模拟DDA算法","url":"/blog/2009/03/02/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E6%8A%80%E6%9C%AF%E3%80%8B%E7%BB%83%E4%B9%A0--%E7%94%A8GDI+%E6%A8%A1%E6%8B%9FDDA%E7%AE%97%E6%B3%95/","content":"刘义军老师留的作业\n代码简单，一看就懂\n\nusing System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Windows.Forms;namespace GDI_DDA&#123;    public partial class Form1 : Form    &#123;        int pointSize = 22;        int width = Screen.PrimaryScreen.WorkingArea.Width;        int height = Screen.PrimaryScreen.WorkingArea.Height;        public Form1()        &#123;            InitializeComponent();        &#125;        void DrawGrid(Graphics gra)        &#123;            for (int i = 0; i &lt;= Width; i += pointSize)            &#123;                gra.DrawLine(Pens.Black, i, 0, i, height);            &#125;            for (int i = 0; i &lt;= height; i += pointSize)            &#123;                gra.DrawLine(Pens.Black, 0, i, Width, i);            &#125;        &#125;        void MyDrawLine(Graphics gra, float startX, float startY, float endX, float endY)        &#123;            float dx = endX - startX;            float dy = endY - startY;            float delta = dy / dx;            float                y = startY;            for (int x = (int) startX; x &lt;= endX; x++, y += delta)            &#123;                DrawEllipseByCenter(gra, Pens.Red, x * pointSize, y * pointSize, pointSize * 0.5f);            &#125;        &#125;        void DrawEllipseByCenter(Graphics g, Pen p, float centerX, float centerY, float r)        &#123;            g.FillEllipse(Brushes.Red, centerX - r * 0.5f, centerY - 0.5f, 2 * r, 2 * r);        &#125;        private void Form1_Paint(object sender, PaintEventArgs e)        &#123;            Graphics myGra = e.Graphics;            DrawGrid(myGra);            MyDrawLine(myGra, 3, 5, 47, 25);            myGra.DrawLine(Pens.Red, 3 * pointSize, 5 * pointSize, 47 * pointSize, 25 * pointSize);            myGra.Dispose();        &#125;    &#125;&#125;\n\n\n\n\n\n\n","tags":["graphics"]},{"title":"A double blessing has descended upon the house","url":"/blog/2009/03/10/A%20double%20blessing%20has%20descended%20upon%20the%20house/","content":"今天公布了CET-SET（口语）的成绩，在去上课的路上用手机查询。得了一个A。\n\n到教室，没过几分钟收到一封邮包。是O‘reilly寄来的笔记本（是真的笔记本，不是laptop……）\n封面是这样的\n\nO(∩_∩)O哈哈~\n双喜临门啊~~~\n\n\n\n\n","tags":["杂7杂8"]},{"title":"今天又被门卫大爷小小的雷了一下","url":"/blog/2009/03/26/%E4%BB%8A%E5%A4%A9%E5%8F%88%E8%A2%AB%E9%97%A8%E5%8D%AB%E5%A4%A7%E7%88%B7%E5%B0%8F%E5%B0%8F%E7%9A%84%E9%9B%B7%E4%BA%86%E4%B8%80%E4%B8%8B/","content":"今天成都血液中心来采血。我去献了300CC的血，今天才知道自己是O型血~~\n手里拿着送我的一把天堂伞和《无偿献血证》回寝室。门口大爷（大概60岁）正在择菜，看到我，说：“你们去献血了？好同学！为社会主义献血！”\nO(∩_∩)O 年代的烙印啊\n\n\n\n\n","tags":["625"]},{"title":"格物致知 《Effective C#》读书笔记--验证二进制兼容性","url":"/blog/2009/02/18/%E6%A0%BC%E7%89%A9%E8%87%B4%E7%9F%A5%20%E3%80%8AEffective%20CSharp%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E9%AA%8C%E8%AF%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%BC%E5%AE%B9%E6%80%A7/","content":"昨天读了《Effective C#》的第一个条款“使用属性代替可访问的数据成员”，讲到要把公有字段修改为私有字段，并用公有属性把它封装起来。这一点不难理解，不过里面提到了一个关于二进制兼容性的问题，很是有趣，今天来验证一下。\n验证思路：创建一个类库内有一个public的类，该类内有一个public的字段。另外创建一个WinForm程序去读区该字段并显示。然后修改类库中的字段为属性。再去运行WinForm，就应该会出错了。出错具体原因请参看《Effective C#》讲解。\n开始吧！\n创建一个ClassLibrary，叫做TheDLL。代码如下：\npublic class DataHolder&#123;    public String Data = &quot;Hey! Hey!You!You!&quot;;&#125;\n\n\n用它生成一个dll。\n然后创建一个WindowsFormsApplication，叫做TheForm，上有一个按钮，点击按钮就去读取dll中的数据，把它显示在按钮上。具体代码如下：\npublic partial class TheForm : Form&#123;    public TheForm()    &#123;        InitializeComponent();    &#125;    private void button1_Click(object sender, EventArgs e)    &#123;        TheDLL.DataHolder DH = new TheDLL.DataHolder();        button1.Text = DH.Data;    &#125;&#125;\n\n\n运行，点击按钮，效果如下：\n\n然后修改  TheDll的代码为如下：\npublic class DataHolder&#123;    private String data = &quot;Hey! Hey!You!You!&quot;;    public String Data    &#123;        get &#123; return data; &#125;        set &#123; data = value; &#125;    &#125;&#125;\n\n\n重新生成dll，把新生成的dll复制到TheForm的debug文件夹下去覆盖原来的dll文件。然后双击运行TheForm.exe。结果如下：\n\n提示找不到TheDLL.DataHolder.Data。没错!这就是因为访问字段和访问属性的C#代码虽然一样，都是\nTheDLL.DataHolder DH = new TheDLL.DataHolder();button1.Text = DH.Data;\n\n但是生成的MSIL是不一样的，这就造成了二进制不兼容。\n注意，不要去IDE中运行TheForm，因为那样会重编译TheForm，就会看不到二进制不兼容造成的结果了。\n另外，即使在TheForm中用try -catch来把访问dll的代码包含起来，如下：\npublic partial class TheForm : Form&#123;    public TheForm()    &#123;        InitializeComponent();    &#125;    private void button1_Click(object sender, EventArgs e)    &#123;        try        &#123;            TheDLL.DataHolder DH = new TheDLL.DataHolder();            button1.Text = DH.Data;        &#125;        catch (Exception)        &#123;        &#125;    &#125;&#125;\n\n还是会发生上图报错的结果。\n\n\n\n\n","tags":["格物致知 《Effective C#》读书笔记"]},{"title":"三种方式统计string中出现次数最多的char（还是LinQ最简便）","url":"/blog/2009/04/26/%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%BB%9F%E8%AE%A1string%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84char%EF%BC%88%E8%BF%98%E6%98%AFLinQ%E6%9C%80%E7%AE%80%E4%BE%BF%EF%BC%89/","content":"using System;using System.Collections.Generic;using System.Text;using System.Linq;using System.Collections;namespace ConsoleApplication1&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            string str = &quot;aaeaabbebbccececddeddd&quot;;            List&lt;char&gt; charList = new List&lt;char&gt;(str.ToCharArray());            int len = charList.Count;            Dictionary&lt;char, int&gt; charD = new Dictionary&lt;char, int&gt;();            int lastTime = 0;            while (charList.Count != 0)            &#123;                int count = CountAChar(charList);                if (count &gt; lastTime)                &#123;                    charD.Clear();                    charD.Add(charList[0], count);                    lastTime = count;                &#125;                else if (count == lastTime)                &#123;                    charD.Add(charList[0], count);                    lastTime = count;                &#125;                DeleteAChar(count, charList);            &#125;            foreach (KeyValuePair&lt;char, int&gt; kv in charD)            &#123;                Console.WriteLine(&quot;&#123;1&#125;有&#123;0&#125;个&quot;, kv.Value.ToString(), kv.Key.ToString());            &#125;            Console.WriteLine(&quot;----------------------------------------&quot;);            SecondProgram.SecondWay(str);            Console.WriteLine(&quot;----------------------------------------&quot;);            ThirdClass.ThirdWay(str);            Console.Read();        &#125;        static void DeleteAChar(int num, List&lt;char&gt; cl)        &#123;            char c = cl[0];            for (int i = 0; i &lt; num; i++)            &#123;                cl.Remove(c);            &#125;        &#125;        static int CountAChar(List&lt;char&gt; cl)        &#123;            int ret = 0;            foreach (char c in cl)            &#123;                if (c == cl[0])                &#123;                    ret++;                &#125;            &#125;            return ret;        &#125;    &#125;//-----------------------------------------------------------------    class SecondProgram    &#123;        public static void SecondWay(string str)        &#123;            int len = str.Length;            char[] strArray = str.ToCharArray();            int[] count = new int[len];            for (int y = 0; y &lt; len; y++) //将count数组的每个单元初始为0                count[y] = 0;            for (int y = 0; y &lt; len; y++) //将当前字符与之后的字符进行比较，相同count数组中对应索引处++            &#123;                for (int yy = y; yy &lt; len; yy++)                &#123;                    if (strArray[y].Equals(strArray[yy]))                    &#123;                        count[y]++;                    &#125;                &#125;            &#125;            ArrayList maxCountArr = new ArrayList();            int maxCount = count[0];            for (int y = 0; y &lt; len; y++) //获得出现次数的最大值            &#123;                if (count[y] &gt; maxCount)                &#123;                    maxCount = count[y];                &#125;            &#125;            for (int y = 0; y &lt; len; y++)//最大值与count数组中的每个数进行比较，相同则出现次数相同，把索引加入到maxCountArr            &#123;                if (count[y] == maxCount)                &#123;                    maxCountArr.Add(y);                &#125;            &#125;            for (int y = 0; y &lt; maxCountArr.Count; y++) //输出            &#123;                Console.Write(&quot;Str&quot; + (y + 1) + &quot;:&quot; + strArray[(int) maxCountArr[y]] + &quot;/n&quot;);            &#125;        &#125;    &#125;    /// &lt;summary&gt;    /// 第三种方式    /// &lt;/summary&gt;    class ThirdClass    &#123;        /// &lt;summary&gt;        /// 还是LinQ最简便        /// &lt;/summary&gt;        /// &lt;param name=&quot;str&quot;&gt;&lt;/param&gt;        public static void ThirdWay(string str)        &#123;            var resultGroup = from aChar in str.ToCharArray()                group aChar by aChar;            int max = 0;            foreach (var one in resultGroup)            &#123;                if (one.Count() &gt; 0)                &#123;                    max = one.Count();                &#125;            &#125;            foreach (var one in resultGroup)            &#123;                if (one.Count() == max)                &#123;                    Console.WriteLine(&quot;&#123;0&#125;字符出现了&#123;1&#125;次&quot;, one.Key, max);                &#125;            &#125;        &#125;    &#125;&#125;\n\n\n\n\n\n\n\n","tags":["Linq"]},{"title":"CET口语证书，呕嘢~~~~~~~~~~~~","url":"/blog/2009/05/15/CET%E5%8F%A3%E8%AF%AD%E8%AF%81%E4%B9%A6%EF%BC%8C%E5%91%95%E5%98%A2/","content":"\n\n 点赞  1  \n 收藏  \n 分享 \n\n\n\n\n\n","tags":["杂7杂8"]},{"title":"格物致知--《Effective C#》读书笔记--验证四种判等方式","url":"/blog/2009/07/19/%E6%A0%BC%E7%89%A9%E8%87%B4%E7%9F%A5--%E3%80%8AEffective%20CSharp%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E9%AA%8C%E8%AF%81%E5%9B%9B%E7%A7%8D%E5%88%A4%E7%AD%89%E6%96%B9%E5%BC%8F/","content":"原地址在我的CSDNBlog：http://blog.csdn.net/cuipengfei1/archive/2009/07/19/4362245.aspx\n①  Object  的静态方法  ReferenceEquals  ：\n只适用于判断两个引用是否指向同一个实例，不适用于值类型（或者说用于值类型是没意义的，因为永远返回  false  ）。如下：\nTestEqual  te =  new  TestEqual  ();bool  b1=  object  .ReferenceEquals(te,te);bool  b2 =  object  .ReferenceEquals(1, 1);\nb1  为  true  ，  b2  为  false  。  b2  为  false  的原因是两个整型值  1  装箱之后是两个不同的Object  实例。\n②  Object  中定义的实例级虚方法  Equals  ：\n其  默认  行为是判断引用是否相等，引用类型从  Object  中继承了这一行为，如下：\nTestEqual  te1=  new  TestEqual  ();TestEqual  te2 =  new  TestEqual  ();bool  b4= te1.Equals(te2);bool  b5 = te1.Equals(te1);Console  .WriteLine(b4);Console  .WriteLine(b5)  ;\n\n输出结果很明显第一个假，第二个真。\n但是对于值类型来说，由于  ValueType  重写了这个方法，所以其行为不同，可以判断值是否相同，而不是引用。\n如下：\nint  num1 = 15;int  num2 = 15;bool  b3 = num1.Equals(num2);Console  .WriteLine(b3);\n\n虽然  num1  和  num2  是两个变量，但是只要它们的值一样，  b3  结果就为  true  。\n③  &#x3D; &#x3D;  运算符：\n应用于值类型的时候其行为是判断值是否相等。应用于引用类型的时候判断引用是否相同。\n④  Object  中的静态方法  Equals  ：\n它接受两个  Object  类型的参数，它会调用第一个参数的实例级  Equals方法，以第二个参数作为该方法的参数来进行判等。所以其行为表现出来和实例级的  Equals方法一样。只是其内部添加了对于两个参加判等的参数是否本身已经是同一个引用的判断，还有两个参数是否为  null的判断。\n2009  年  7  月  19  日  22:35:15  于  SWPU 19#625\n\n\n\n\n","tags":["格物致知 《Effective C#》读书笔记"]},{"title":"格物致知 《Effective C#》读书笔记--验证类型转换","url":"/blog/2009/05/31/%E6%A0%BC%E7%89%A9%E8%87%B4%E7%9F%A5%20%E3%80%8AEffective%20CSharp%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E9%AA%8C%E8%AF%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","content":"as  看起来很好用的样子，不会抛出异常，只要根据返回值是否为  null来做不同的处理就可以了。但是它也不是万金油，以下的情况  as  就不适用：\n①值类型\n比如：\ndouble  d = 100.0;int  valueType = d  as  int  ;\n\n这两句代码就直接通不过编译，给出的原因是：  as  运算符必须用于引用类型或可以为  null类型  (“int”  是一种不可以为  null值的类型  )\n想一下也合理，  as  在失败时会返回  null，而值类型是不可以为  null的（  INullable  除外）。\n由上面的出错信息也可以看出来，  as  只可以作用于引用类型。\n但是也并非所有值类型都适用，存在于一条继承链上的自不必说。但是自定义类型转换呢？\n②自定义类型转换\n假设有两个类定义如下：\nclass ClassOne&#123;    private int filedOne;    public int FiledOne    &#123;        get &#123; return filedOne; &#125;        set &#123; filedOne = value; &#125;    &#125;    public static explicit operator ClassTwo(ClassOne co)    &#123;        return new ClassTwo &#123;FiledTwo = co.FiledOne&#125;;    &#125;&#125;class ClassTwo&#123;    private int filedtwo;    public int FiledTwo    &#123;        get &#123; return filedtwo; &#125;        set &#123; filedtwo = value; &#125;    &#125;&#125;\n\nClassOne  中定义了向  ClassTwo  的转换。\n试用一下：\nClassOne  co =  new  ClassOne  &#123; FiledOne=10&#125;;ClassTwo  ct = (  ClassTwo  )co;\n\n这样是没问题的，但是再写下面一句：\nct = co  as  ClassTwo  ;\n\n就会报告：  无法通过引用转换、装箱转换、取消装箱转换、包装转换或  Null类型转换将类型  “CastAsIs.ClassOne”  转换为“CastAsIs.ClassTwo”\n由此可见  as  对于自定义类型转换不感冒。\n实际上，  foreach  内部也是使用的强制类型转换的，看下面：\nClassOne[] arr =&#123;    new ClassOne &#123;FiledOne = 1&#125;,    new ClassOne &#123;FiledOne = 2&#125;&#125;;foreach (ClassTwo item in arr)&#123;    Console.WriteLine(item.FiledTwo.ToString());&#125;\n\n这段代码编译和运行都没问题（把  arr  中的  ClassOne  强制转换为  ClassTwo  自然没问题），但是如果改写成下面这样：\nforeach (ClassTwo item in arr as IEnumerable)&#123;    Console.WriteLine(item.FiledTwo.ToString());&#125;\n\n就会报告一个  InvalidCastException  ，原因就是  IEnumerator.Current  （）返回的是  Object类型，而在  foreach  中试图将  Object  转化为  ClassTwo  就会出错。\n\n\n\n\n","tags":["格物致知 《Effective C#》读书笔记"]},{"title":"被学校的广播大大地雷了一把","url":"/blog/2009/03/25/%E8%A2%AB%E5%AD%A6%E6%A0%A1%E7%9A%84%E5%B9%BF%E6%92%AD%E5%A4%A7%E5%A4%A7%E5%9C%B0%E9%9B%B7%E4%BA%86%E4%B8%80%E6%8A%8A/","content":"刚才在食堂吃完午饭回寝室的路上听广播，大意是：学校组织全校党员、领导、干部，本着实践科学发展观的精神进行了深入的调查研究，仅专题座谈会就召开了192场。终于得出一个重要结论：就业率对于我们学校是很重要的。\nTMD……彻底被雷了一把…\n\n\n\n\n","tags":["嗷"]},{"title":"《Head First C#》将停止翻译和更新","url":"/blog/2009/08/07/%E3%80%8AHead%20First%20CSharp%E3%80%8B%E5%B0%86%E5%81%9C%E6%AD%A2%E7%BF%BB%E8%AF%91%E5%92%8C%E6%9B%B4%E6%96%B0/","content":"近日闻悉国内某出版社即将出版《  Head First C#  》的中文版，为避免版权纠纷，本“山寨”系列将停止翻译和更新。\n从去年  10  月开始利用课余时间翻译这本书，到现在翻译完了将近  13  章，总计  12  万余字。\n\n剩余的正文内容已不足百页，无法做到有始有终，颇为遗憾。\n感谢  CSDN  和  VeryCD  各位朋友一直以来的关注、支持、鼓励和批评。\n2009  年  8  月  7  日\n\n 点赞  2  \n 收藏  \n 分享 \n\n\n\n\n\n","tags":["我翻译的Head First C#（习作）"]},{"title":"电驴（easyMule）自动关机工具","url":"/blog/2009/08/21/%E7%94%B5%E9%A9%B4%EF%BC%88easyMule%EF%BC%89%E8%87%AA%E5%8A%A8%E5%85%B3%E6%9C%BA%E5%B7%A5%E5%85%B7/","content":"由于电驴官方鼓励尽量多的上传，所以不提供下载完关机的功能。于是我自己写了个小工具来实现这个功能。\n使用方法：\n运行  EasyMulePowerOff.exe\n\n会提示您设置电驴的安装路径，设置好之后会检查到有没有未完成的任务：\n\n显示我有一个未完的任务，看一下电驴中\n\n确实只有一个任务\n然后可以点击隐藏按钮让程序隐藏，等下完之后，会出现\n\n这时可以点击取消按钮取消关机并关闭本程序，如果您在睡觉的话，倒计时  60  秒之后就自动关机了。\n下载： http://download.csdn.net/source/1595128\nPS  ：会生成一个easyMulePath.cpf文件，请不要删除。\n此程序只适用于  easyMule  并需要  .NET 2.0\n\n\n\n\n","tags":["utils"]},{"title":"格物致知--《Effective C#》读书笔记--验证接口引用指向装箱后的值类型时无需拆箱","url":"/blog/2009/07/29/%E6%A0%BC%E7%89%A9%E8%87%B4%E7%9F%A5--Effective%20C%20Sharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E9%AA%8C%E8%AF%81%E6%8E%A5%E5%8F%A3%E5%BC%95%E7%94%A8%E6%8C%87%E5%90%91%E8%A3%85%E7%AE%B1%E5%90%8E%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%97%B6%E6%97%A0%E9%9C%80%E6%8B%86%E7%AE%B1/","content":"欲验证的结论：  接口引用指向装箱后的值类型时无需拆箱  。\n代码如下：\ninterface SomeInterface&#123;    void MethodInInterface();&#125;struct OneValueType : SomeInterface&#123;    public void MethodInInterface()    &#123;        Console.WriteLine(&quot;get called&quot;);    &#125;&#125;class TestUnBox&#123;    public static void Main()    &#123;    &#125;    private static void CastStruct()    &#123;        OneValueType ovt = new OneValueType();        object o = ovt; //Box        ((OneValueType) o).MethodInInterface();    &#125;    private static void CastInterface()    &#123;        OneValueType ovt = new OneValueType();        object o = ovt; //Box        ((SomeInterface) o).MethodInInterface();    &#125;&#125;\n\n其中  OneValueType  是值类型，它实现了  SomeInterface  。\n两个方法  CastStruct  和  CastInterface  分别把装箱之后的值类型转型为  OneValueType  和SomeInterface  。预计的结果是第二个方法无需拆箱，查看  IL  来验证：\n这是  CastStruct  （）：\n\n这是  CastInterface  （）：\n\n可见，第二个方法中没有  unbox  指令，结论得证。\n2009  年  7  月  29  日\n\n\n\n\n","tags":["格物致知 《Effective C#》读书笔记"]},{"title":"Words Via Subtitle的两点改进","url":"/blog/2009/09/10/Words%20Via%20Subtitle%E7%9A%84%E4%B8%A4%E7%82%B9%E6%94%B9%E8%BF%9B/","content":"上周写了一个 通过英文剧集、电影学单词的小工具，这几天又做了一点小的改进。主要是下面这两点：\n\n显示单词解释的同时显示其在剧中出现的语境，关键单词红色显示。效果如下：\n\n\n\n导出文档。可以把列表中的单词，其简明解释和在剧中出现的语境保存到文档中。关键词开头绿色显示，例句中红色显示。效果如下：\n\n\n为什么要写这个功能呢？因为九月中下旬有很多美剧要回归，包括  TBBT  ，  Lie to me  ，  Heroes  ，  Fringe  。到时候每一集出来之后可以用这个程序迅速的把一集中出现的生词，其音标及解释还有语境总结出来。可以把它发到博客里，或者发到美剧对应的社区或者贴吧里去，会比一般的影迷手工总结的快很多。\n做这个功能的时候费了很多力气，倒不是它有多难，而是因为对于  WPS  文档对象模型不够了解。请各位注意：  这个功能只有安装了  WPS  才可以用。（之所以这样是因为我这儿没装  Office……  ）\n下载在： http://download.csdn.net/source/1649482\n以上就是  Words  Via  Subtitle  今天更新的内容，基本功能和使用方法和原来一样，需要了解的话请看这儿：http://blog.csdn.net/cuipengfei1/archive/2009/09/03/4516588.aspx\n\n\n\n\n","tags":["Words Via Subtitle"]},{"title":"Words Via Subtitle改进：视频播放例句、加快生成WPS文档的速度","url":"/blog/2009/09/17/Words%20Via%20Subtitle%E6%94%B9%E8%BF%9B%EF%BC%9A%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E4%BE%8B%E5%8F%A5%E3%80%81%E5%8A%A0%E5%BF%AB%E7%94%9F%E6%88%90WPS%E6%96%87%E6%A1%A3%E7%9A%84%E9%80%9F%E5%BA%A6/","content":"Words Via Subtitle  改进：视频播放例句、加快生成  WPS  文档的速度\n关于  Words Via Subtitle  的介绍：\n1 http://blog.csdn.net/cuipengfei1/archive/2009/09/03/4516588.aspx\n2 http://blog.csdn.net/cuipengfei1/archive/2009/09/10/4539180.aspx\n最近给这个小程序添加了视频播放例句的功能，使用方法如下：\n载入字幕文件并指定了与之对应的视频文件之后，选中某个感觉生疏的单词，然后点击播放例句按钮，该单词所在句子就会以视频的方式开始播放，播完该句子视频暂停。其实这个功能写起来也挺简单的，就是在字幕中找到一个单词所在句子对应的时间信息，然后依照该时间段播放视频。\n\n加快生成  WPS  文档的速度：\n原 来是在生成文档的时候才去获取单词的网络解释及其语境。又要访问网络又要读文件然后才可以生成文档，速度就会很慢。现在改变了方式，载入字幕之后就用一个线程去把单词的解释从网上获取来，把语境从文件中读取来，这样生成文档这个操作所耗的时间就主要在于在文档中找到关键字并把关键字变色了（这个过程还是耗时不少，不过比原来快多了）。\n程序下载地址： http://cuipengfei1.download.csdn.net/\n\n\n\n\n","tags":["Words Via Subtitle"]},{"title":"通过英文剧集、电影学单词的小工具","url":"/blog/2009/09/03/%E9%80%9A%E8%BF%87%E8%8B%B1%E6%96%87%E5%89%A7%E9%9B%86%E3%80%81%E7%94%B5%E5%BD%B1%E5%AD%A6%E5%8D%95%E8%AF%8D%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/","content":"我平时很喜欢看美剧和电影。而如果看中文字幕（看英文字幕也是一样）的话，注意力就会集中于阅读文字、理解剧情，练习听力的目的就落空了。而如果不看字幕的话，对话中的很多生词就会随着对句子的大致理解而溜过去了，所以最好的办法就是看之前把对白中会出现的单词预览一次以为预习，看的过程中再熟悉一次，看完之后还可以针对用得到的单词再记一次。为了实现这个目的，我写了一个小程序。\n使用方式如下：\n运行  WordsViaSubtitle.exe\n\n可以通过程序中的搜索框搜索字幕文件（是射手网提供的，赞美射手  O(∩_∩)O哈！！）\n\n通过弹出的链接去射手网把字幕下载到本地，然后通过“打开字幕”按钮载入字幕文件，程序会解析其中出现的单词并给出其中文解释和例句（赞美海词在线  O(∩_∩)O  哈！）。效果如下：\n\n然后可以用“认识当前单词”按钮把某个认识的单词过滤掉，这样认识的单词下次就不会再蹦出来干扰你了。可以用“当前单词加入生词本”按钮把一个单词加入生词本，也可以在使用“认识当前单词”按钮和“单词拼写错误”（字幕中难免会有错）按钮把已知词汇和拼错的词去掉之后再使用“全部单词加入生词本”按钮把列表中余下的单词全部加入生词本。以后可以用“打开生词本”按钮来学习这些生词。“搜索字幕文件”按钮用来打开最初的搜索页面。\n最近我自己使用这个程序已经积累了  10000  多的词汇了（当然部分是之前就认识的单词）。\n下载：   http://download.csdn.net/source/1630439\n\n下载的文件解压之后会有一个  KnownWords.cpf文本文件，里面的单词是用于过滤已知单词的，可以用任意的文本编辑器把它清空，然后积累您自己的过滤词库。\n本程序需要  .NET 2.0\n\n\n\n\n","tags":["utils"]},{"title":"easyMule自动关机工具(可用于1.X和2.0版本)","url":"/blog/2009/09/01/easyMule%E8%87%AA%E5%8A%A8%E5%85%B3%E6%9C%BA%E5%B7%A5%E5%85%B7(%E5%8F%AF%E7%94%A8%E4%BA%8E1.X%E5%92%8C2.0%E7%89%88%E6%9C%AC)/","content":"前几天发的程序只可以用于easyMule1.X版本，今天改写了一下，可以适用于2.0\n使用方法：\n运行  EasyMulePowerOff.exe\n会提示您设置电驴的安装路径，设置好之后会检查到有没有未完成的任务：\n\n显示我有一个未完的任务，看一下电驴中\n\n确实只有一个任务\n然后可以点击隐藏按钮让程序隐藏，等下完之后，会出现\n\n这时可以点击取消按钮取消关机并关闭本程序，如果您在睡觉的话，倒计时  60  秒之后就自动关机了。\n下载：http://download.csdn.net/source/1623330\nPS  ：此程序只适用于  VeryCD的  easyMule  并需要  .NET 2.0\n\n\n\n\n","tags":["utils"]},{"title":"使用AvalonDock制作WPF多标签浏览器（一）","url":"/blog/2010/03/15/%E4%BD%BF%E7%94%A8AvalonDock%E5%88%B6%E4%BD%9CWPF%E5%A4%9A%E6%A0%87%E7%AD%BE%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/","content":"AvalonDock  是  CodePlex  上的一个开源项目，利用它可以很容易的做出类似于  VS  的  UI  效果。\n下图是  AvalonDock  源码中自带的一个  Demo  ：\n我们可以用这款第三方控件为基础来制作多标签浏览器。\n下面是最终效果图：\n\n甚至可以把其中一个标签拖出主窗体成为一个独立的窗口：\n\n是不是很像  VS2010  中新的  TextEditor  啊，呵呵。\n但是观察一下常用的浏览器，比如  IE  ：\n\nChrome  ：\n\nFireFox  ：\n\n它们都有一个添加新标签的按钮，但是  AvalonDock  的  DocumentPane  默认并没有新建一个  DocumentContent的按钮。\nDocumentPane  和  DocumentContent  是  AvalonDock  中众多类型中的两个，  DocumentPane  是DocumentContent  的父级容器，  DocumentContent  中则可以置入任何  UI  元素，比如说一个  WebBrowser。\n所以我们的第一步就从给  AvalonDock  的  DocumentPane  写一个添加新  DocumentContent  的按钮开始吧。\n首先  ReStyle  ，从  AvalonDock  的源码中找到  DocumentPaneStyles.xaml  这个文件，定位到\n&lt;Button x:Name=&quot;PART_ShowContextMenuButton&quot; DockPanel.Dock=&quot;Right&quot; Width=&quot;18&quot;        Height=&quot;18&quot; Style=&quot;&#123;StaticResource PaneHeaderCommandStyle&#125;&quot;        mce_Style=&quot;&#123;StaticResource PaneHeaderCommandStyle&#125;&quot;        Command=&quot;ad:DocumentPane.ShowDocumentsListMenuCommand&quot;&gt;    &lt;ad:AlignedImage&gt;        &lt;Image x:Name=&quot;ShowContextMenuIcon&quot; Source=&quot;Images/PinMenu.png&quot; Width=&quot;13&quot;               Height=&quot;13&quot; Stretch=&quot;Uniform&quot;/&gt;    &lt;/ad:AlignedImage&gt;&lt;/Button&gt;\n\n这段代码\n紧接着这段代码添加如下代码：\n&lt;Button DockPanel.Dock=&quot;Right&quot; Width=&quot;18&quot; Height=&quot;18&quot; Style=&quot;&#123;StaticResourcePaneHeaderCommandStyle&#125;&quot; mce_Style=&quot;&#123;StaticResource PaneHeaderCommandStyle&#125;&quot;        Command=&quot;ad:DocumentPane.AddNewCommand&quot;&gt;    &lt;ad:AlignedImage&gt;        &lt;Image                Source=&quot;Images/add.png&quot; Width=&quot;13&quot; Height=&quot;13&quot; Stretch=&quot;Uniform&quot;/&gt;    &lt;/ad:AlignedImage&gt;&lt;/Button&gt;\n\n其中的  add.png  是我从网上随便找的一个加号的图片；\n其中的  ad:DocumentPane.AddNewCommand  是紧接下来我们要给  DocumentPane  添加的一个  Command  。\n找到  DocumentPane.cs  文件并添加代码：\npublic static RoutedCommand AddNewCommand = new RoutedCommand();private void    ExecutedAddNewCommand(object sender, ExecutedRoutedEventArgs e)&#123;    AddNew();&#125;private void AddNew()&#123;    DocumentContent newContent = new DocumentContent();    newContent.Title = &quot;new content&quot;;    newContent.IsFloatingAllowed = true;    Items.Add(newContent);&#125;private void CanExecuteAddNewCommand(object sender,    CanExecuteRoutedEventArgs e)&#123;    e.CanExecute = true;&#125;\n\n然后再在其  OnInitialized  方法中添加如下一句：\nthis  .CommandBindings.Add(  new  CommandBinding(AddNewCommand,ExecutedAddNewCommand, CanExecuteAddNewCommand));\n\n这样我们就给  DocumentPane  添加了一个加号按钮并把它和  AddNewCommand  这个命令联系了起来，点击按钮时我们添加的AddNew  方法就会执行。由于  DocumentPane  是  WPF  中  Selector  的子类，而  Selector  又继承自ItemsControl  ，所以  DocumentPane  会有一个  Items  属性，我们在  AddNew  方法中做的就是给其  Items中塞进一个新的  DocumentContent  。\n这时再次运行  AvalonDock  自带的  Demo  ，可以看见右侧有一个小加号按钮，点击按钮则可以新建标签页：\n\nOK  ！第一步搞定了。\n但是每一个标签都是空的，下一步要给每个标签中添加一个  WebBrowser  。\n是不是修改一下前面添加的  AddNew  方法，在里面  new up  一个  WebBrowser  呢，不太好，这样感觉不是在修改而是在破坏AvalonDock  的源码，毕竟  AvalonDock  是一个控件库，添加一个新标签时，其默认行为就应该是让标签为空。\n给每个新添加的空标签中置入一个  WebBrowser  应该是在客户代码中做的事儿。\n这部分明天再写吧，洗洗去看  10-4 show  了。（挺好看的视频，讲  VS2010  和  .Net 4 new features  的：http://channel9.msdn.com/shows/10-4/  \nOver and out  ！  Ciao  ！\n\n\n\n\n","tags":["WPF"]},{"title":"使用AvalonDock制作WPF多标签浏览器（二）","url":"/blog/2010/03/16/%E4%BD%BF%E7%94%A8AvalonDock%E5%88%B6%E4%BD%9CWPF%E5%A4%9A%E6%A0%87%E7%AD%BE%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"闲话少叙，书接上文。\n现在我们已经通过  ReStyle  给  DocumentPane  加上了一个加号的按钮，并且可以通过点击该按钮给  DocumentPane  的Items  添加一个  DocumentContent  了。\n不过每个新添加进来的  DocumentContent  内部都是空的，而我们需要的是每个新标签中都有一个  WebBrowser，要实现这一点很简单，只要给  DocumentContent  的  Content  （  DocumentContent  是ContentControl  的子类）属性赋值为一个  WebBrowser  的实例就  OK  了。\n但是这不应该是  AvalonDock  的默认行为，所以我们要把这部分写到客户端  –  也就是引用  AvalonDock.dll文件或者直接引用  AvalonDock  工程的  Solution  中去。\n如何可以在客户端得知有一个新的  DocumentContent  被添加进  DocumentPane  中去了呢？自然是用事件了。\n首先来写一个自定义的  EventArgs  吧：\npublic class NewContentAddedEventArgs : EventArgs&#123;    public        NewContentAddedEventArgs(DocumentContent addedContent)    &#123;        AddedContent =            addedContent;    &#125;    public DocumentContent AddedContent &#123; get; private set; &#125;&#125;\n\n这个名为  NewContentAddedEventArgs  的事件参数的构造方法会要求一个  DocumentContent，其实也就是被添加的那个新标签了。\n这样订阅其对应事件的客户代码就可以得到一个指向新添加的标签的引用，当然就可以将其  Content  设置为一个新的  WebBrowser  的实例了。\n接下来在  DocumentPane  中定义一个使用刚写好的事件参数的事件：\npublic event EventHandler&lt;NewContentAddedEventArgs&gt; NewContentAdded;\n\n接下来，遵照规范写一个  OnNewContentAdded  方法，以免在没人订阅事件的时候试图触发事件而抛异常：\nprivate void OnNewContentAdded(NewContentAddedEventArgs args)&#123;    if        (NewContentAdded != null)    &#123;        NewContentAdded(this, args);    &#125;&#125;\n\n再然后在我们之前写的  AddNew  方法中调用  OnNewContentAdded  方法就  OK  了，修改后的  AddNew  方法是这样的：\nprivate void AddNew()&#123;    DocumentContent newContent = new DocumentContent();    newContent.Title = &quot;new content&quot;;    newContent.IsFloatingAllowed = true;    Items.Add(newContent);    OnNewContentAdded(new        NewContentAddedEventArgs(newContent));&#125;\n\n然后就可以开始着手写客户代码了。\n首先在  XAML  中添加对  AvalonDock  的引用：\nxmlns:Avalon=&quot;clr-namespace:AvalonDock;assembly=AvalonDock&quot;\n\n然后再在主体中添加如下代码：\n&lt;Avalon:DockingManager&gt;    &lt;Avalon:DocumentPane Name=&quot;mainPane&quot;                         NewContentAdded=&quot;DocumentPane_NewContentAdded&quot;&gt;        &lt;Avalon:DocumentContent                Title=&quot;Default Tab&quot; GotFocus=&quot;DocumentContent_GotFocus&quot; IsCloseable=&quot;False&quot;                IsFloatingAllowed=&quot;True&quot;&gt;            &lt;WebBrowser Name=&quot;defaultBrowser&quot;                        Source=&quot;http://www.google.cn/webhp?hl=zh-CN&quot;&gt;&lt;/WebBrowser&gt;        &lt;/Avalon:DocumentContent&gt;    &lt;/Avalon:DocumentPane&gt;&lt;/Avalon:DockingManager&gt;\n\n其中的  DockingManager  是  AvalonDock  中的“总管”，其详细使用方法请看：http://avalondock.codeplex.com/  \n上面的代码中可以看到，我们给  DocumentPane  新加的  NewContentAdded  事件已经挂到了一个叫做DocumentPane_NewContentAdded  的方法上。该方法的定义很简单：\nprivate void DocumentPane_NewContentAdded(object sender,    NewContentAddedEventArgs e)&#123;    DocumentContent newContent = e.AddedContent;    newContent.Title = &quot;New Tab&quot;;    newContent.GotFocus += DocumentContent_GotFocus;    newContent.Content = new WebBrowser    &#123;        Source = new            Uri(@&quot;http://www.google.cn&quot;)    &#125;;&#125;\n\n就是把一个打开  Google  首页的  WebBrowser  实例赋值给新添加的标签页的  Content  属性。\n里面还有一句：\nnewContent.GotFocus += DocumentContent_GotFocus;\n\n其中的  DocumentContent_GotFocus  定义如下：\nprivate void DocumentContent_GotFocus(object sender, RoutedEventArgs e)&#123;    DocumentContent selectedOne = s as DocumentContent;    if (selectedOne != null)    &#123;        WebBrowser browser = selectedOne.Content as WebBrowser;        if (browser != null &amp;&amp;            browser.Source != null)        &#123;            currentBrowser = browser;            url.Text =                browser.Source.ToString();        &#125;    &#125;&#125;\n\n这是做什么用的呢？\n我们用浏览器打开多个标签页的时候程序中就会存在多个  WebBrowser  的实例，这时如果在地址栏中输入一个地址并回车的话，怎么知道到底应该把哪个WebBrowser  重定向到输入的地址呢？\n所以程序中应该有一个  WebBrowser  的引用，假设叫做  currentBrowser  吧，它始终指向当前选中标签中的  WebBrowser实例。\n上面的代码做的就是这个工作，当一个标签页得到焦点的时候，就让  currentBrowser  指向该标签页中的  WebBrowser实例，并把一个叫做  url  的  TextBox  （也就是地址栏了）的  Text  属性设置为当前  Browser  打开的地址  。\n当然，这个叫做  url  的地址栏的  KeyDown  事件的处理方法中应该把  currentBrowser重定向到输入的网址，这段代码很简单，就不贴了。\n现在运行一下，似乎  OK  了，真的完事儿了吗？\n呵呵，没有。\n试一下打开两个标签，把其中的第二个拖拽到主区域的右侧去，从而将主区域一分为二：\n\n在右侧新分化出来的区域中点击加号小按钮新建另一个标签，切换到新标签。\n啊哦  ~~~~~\n\n新标签是空的，不是明明已经在每个新标签被添加时给其中加上一个  WebBrowser  了吗？咋没有捏？这究竟是哪儿来的  Bug  呢？\n再注意观察一下，这个新标签的标题是  new content  而不是  New Tab  ，呵呵，是不是已经猜到了呢？\n其实这是和  AvalonDock  中的另一个类  –  DocumentFloatingWindow  有关的问题。\n怎么解决这个问题明天再说吧。\nOver and out  ！\n\n\n\n\n","tags":["WPF"]},{"title":"用AvalonDock制作WPF多标签浏览器（三）","url":"/blog/2010/03/17/%E7%94%A8AvalonDock%E5%88%B6%E4%BD%9CWPF%E5%A4%9A%E6%A0%87%E7%AD%BE%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%88%E4%B8%89%EF%BC%89/","content":" 昨天遇到了一个  Bug  ，如果在浏览器中打开多个标签，并把其中一个标签拖拽到主窗口的一侧来划分出独立的一个区域，然后在新区域中通过点击加号键添加的新标签内不会被添加上  WebBrowser  。  \n 说得好绕嘴啊，截张图吧：  \n \n 而且没有加上  WebBrowser  的标签的标题是  new content  （我们在  AvalonDock  中给新标签的默认标题）而不是  New Tab  （客户代码中重新赋的值）。  \n OK  ，问题明了了，是不是新添加的标签的  Got_Focus  没能够挂到客户代码中的方法上去呢？  \n 的确是这样，当我们把一个标签（  DocumentContent  ）拖拽到一侧从而划分出一个新区域的时候，  AvalonDock  会创建一个新的  DocumentPane  来代表这个新区域。  \n 我们浏览器中默认的  DocumentPane  是在  XAML  中声明的，声明时其  NewContentAdded\n 事件就挂到了事件响应方法DocumentPane_NewContentAdded上。  \n 而这个新区域中的  DocumentPane  是在  AvalonDock  内部的  DocumentFloatingWindow类中创建的，其事件自然没有挂上来。  \n 知道了这些，解决方案自然就有了。  \n 在DocumentFloatingWindow中添加如下事件：  \n public static event EventHandler NewDocumentPaneAddedByMouse;\n 其中用到的事件参数定义如下：  \npublic class NewDocumentPaneAddedByMouseEventArgs : EventArgs &#123;   public NewDocumentPaneAddedByMouseEventArgs(DocumentPane addedPane) &#123; AddedPane = addedPane; &#125;   public DocumentPane AddedPane &#123; get; private set; &#125; &#125;\n\n 依然尊规范在DocumentFloatingWindow中定义如下方法来触发事件：  \nprivate void OnNewDocumentPaneAddedByMouse(NewDocumentPaneAddedByMouseEventArgs args) &#123;   if (NewDocumentPaneAddedByMouse != null) &#123;       NewDocumentPaneAddedByMouse(this, args);   &#125;&#125;\n\n 并在DocumentFloatingWindow中的ClonePane方法（鼠标拖拽时创建新  DocumentPane  的工作就是在这个方法中做的）中调用该方法来触发事件，修改后的  ClonePane方法是这样的：  \npublic override Pane ClonePane() &#123; DocumentPane paneToAnchor = new DocumentPane(); OnNewDocumentPaneAddedByMouse(new NewDocumentPaneAddedByMouseEventArgs(paneToAnchor)); ResizingPanel.SetEffectiveSize(paneToAnchor, new Size(Width, Height)); while (HostedPane.Items.Count &gt; 0) &#123;  paneToAnchor.Items.Add(HostedPane.RemoveContent(0)); &#125; return paneToAnchor;&#125;\n 我们只关心其中的OnNewDocumentPaneAddedByMouse(new NewDocumentPaneAddedByMouseEventArgs(paneToAnchor));  这一句就OK了。  \n 好了，现在每当因鼠标拖拽而创建出一个新的  DocumentPane  时，都有一个事件会被触发，而且其传递的事件参数中还含有对新添加的  DocumentPane  实例的引用。这样订阅事件的地方（比如说我们的客户代码中）就可以通过该引用来把新添加的  DocumentPane  的  NewContentAdded事件挂到某个方法上了（当然就是我们的DocumentPane_NewContentAdded方法了）。  \n 接下来修改客户代码吧：  \n 在浏览器窗口的构造方法中添加下面一句：  \nDocumentFloatingWindow.NewDocumentPaneAddedByMouse += (object sender, NewDocumentPaneAddedByMouseEventArgs e) =&gt; &#123; e.AddedPane.NewContentAdded += DocumentPane_NewContentAdded;&#125;;\n\n 用了  lambda  表达式，有点长，不过的确还只是一句啊。  \n 这样每个通过鼠标拖拽出来的  DocumentPane  就和我们在  XAML  中声明的  DocumentPane  没什么两样了，它们的  NewContentAdded 事件都挂到了DocumentPane_NewContentAdded方法上，这个方法做什么的来着？它做的就是给每一个新标签中置入一个新的  WebBrowser  。\n 好了，现在再运行一下，之前的问题不见了。  \n 另外，如果你在使用  Win7  的话，把某个新标签拖拽出窗口，右击，选择  Floating  \n \n 然后就可以把这个拖拽出来的标签  Dock  到屏幕的一侧了  \n \n 那个玻璃化的框框好漂亮啊，呵呵。  \n 好了，到现在为止我们的多标签浏览器基本就运转起来了。如果您发现其中隐含的  Bug  或者不妥之处请不吝赐教哈！  \n 另外，  AvalonDock  有两套  Theme  ，我们之前的  Restyle  只修改了  DocumentPaneStyles.xaml  ，要在  Win7  下看到想要的效果还要对  aero.normalcolor.xaml  做同样的修改。\n 好了，  Over and out  ！  \n代码下载：  http://download.csdn.net/source/2137819\n\n\n\n\n","tags":["WPF"]},{"title":".NET 4.0 FAQ 第一部分—DLR","url":"/blog/2010/05/22/NET40FAQ%20%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86DLR/","content":".NET 4.0 FAQ 第一部分—DLR\n简介\n本篇文章中我们将讨论.NET FrameWork 4.0提供了哪些新特性。然后再探讨DLR特性  中的动态对象和Expando对象。我们也将会创建一个Expando对象来看我们可以从中获得哪些益处。很多的开发人员误以为动态对象是用来替代反射和object类型的，我们也将会纠正这种错误的概念。\n.NET 4.0中有哪些重要的新特性？\n与其去浏览.NET 4.0冗长的新特性列表，我们还是专注于我们认为最重要的三项新特性上吧。\n•  WF和WCF 4.0：这是.NET\n4.0中的一个重大改变。WCF中引入了简化的配置、发现和路由服务。WF的核心编程模型也得到了改变，变得更加简易和健壮。最重大事件的就是WCF和WF的整合。\n•  动态语言运行时：DLR给.NET 4.0的CLR赋予了动态编程的能力。我们将会在文章接下来的部分探讨这一点。\n•  并行扩展：这有助于多核系统中的并行计算。.NET 4.0的LinQ中添加了PLinQ来支持并行执行。.NET 4.0引入了TPL（Taskparallel library），其中暴露了像并行的“For”和“ForEach”等并行构造，它们可以调用普通方法或者委托。\n接下来我们将详细讲述以上提到新特性。\nDLR在.NET 4.0中扮演何种角色呢？\nDLR（Dynamic language runtime）是一组服务，它给CLR赋予了动态编程的能力。DLR使得像LISP、JavaScript、PHP、Ruby一样的动态语言可以运行在.NETFrameWork上。\n\n编程语言分为动态类型语言和静态类型语言。在静态类型语言中，你需要在编译时或者说是设计时指明对象的类型。而动态类型语言可以在运行时识别对象的类型。DLR使得CLR能够作为动态语言代码运行的宿主环境。\n\n有了DLR，Ruby、Python、JavaScript等动态语言就可以无缝的运行在CLR之上了。DLR还有助于为你最喜欢的动态语言来构建最佳体验。这样，你的与动态语言交互的代码就会变得更加简洁。\n\nDLR并不仅限于动态语言。你也可以通过使用COM Interop Binder来以一种更加简洁的方式去调用MS Office组件。\nDLR的一大优势就是它为动态语言提供了一个子系统。\n可以讲讲DLR子系统的细节吗？\nDLR有三个基本子系统：\n•  表达式树：我们可以用它来以AST（抽象语法树）的方式表达语义。DLR会动态生成使用AST的代码，这些代码可以在CLR之上执行。JavaScript和Ruby等动态语言可以运行在CLR之上很大程度上得是益于表达式树的助力。\n•  调用栈缓存：当你调用动态对象的方法时，DLR会把那些方法调用的信息都缓存起来。在后续的调用中，DLR就会使用这些缓存起来的信息来完成快速调度。\n•  动态对象互操作性（DOI）：DOI系统中包含一组用来创建动态对象的类。开发人员可以使用这些类来创建可以在动态语言或者静态语言中使用的动态对象。\n接下来我们会对上述的新特性做详细讲解。\n\n我们该如何使用动态语言的对象，又该如何向动态语言暴露一个类呢？\n要使用一个DLR支持的语言创建的对象，我们可以使用dynamic关键字。而要向动态语言暴露一个类，我们可以使用Expando类。\n所以如果你想要使用一个诸如由Python、Ruby或者JavaScript等动态语言创建的对象的话，你就可以使用dynamic的引用来指向该对象。如果你想要让你的类可以被动态语言使用，你的类就需要继承自Expando类。我们稍后就会看到这两种例子。\n\n（上图中文字：Dynamic对象有助于使用动态语言创建的对象。Expando对象有助于向动态语言暴露一个类。）\n有什么Dynamic对象的例子吗？\n我们已经讲过Dynamic对象有助于去访问由受DLR支持的动态语言创建的对象。dynamic关键字是DOI子系统的一部分。\n如果你把一个对象赋值给一个dynamic类型的变量的话（dynamic x &#x3D; newSomeClass（）），所有对x的方法的调用，对x的属性的访问，以及对x的运算符操作都会被延迟到运行时去，而且编译器在编译时不会对x做任何的类型检查。\n考虑下面的代码片段，我们在其中试着去调用excel的方法。\n// Get the running object of the excel applicationobject objApp = System.Runtime.InteropServices.Marshal.GetActiveObject(&quot;Excel.Application&quot;);// Invoke the member dynamicallyobject x = objApp.GetType().InvokeMember(&quot;Name&quot;, System.Reflection.BindingFlags.GetProperty, null, objApp, null);// Finally get the value by type castingMessageBox.Show(x.ToString());\n\n使用dynamic关键字来完成相同功能的代码。\n// Get the object using dynamic objApp1 =System.Runtime.InteropServices.Marshal.GetActiveObject(&quot;Excel.Application&quot;);// Call the MessageBox.Show(objApp1.Name);\n\n你可以很清楚地发现访问属性的语法的简化。InvokeMember这个方法含义模糊而且容易出错。使用dynamic关键字，我们可以看到代码得到了简化。\n\n如果你试着在Visual Studio中查看x的属性，你将会得到提示说此表达式的值只有在运行时才可以被断定。\n\nDynamic、Object和反射这三者之间有何关系？\n很多的开发人员认为引入Dynamic的目的就是要替换掉反射或者Object这种类型。其实dynamic的主要目的是在静态类型的语言中去无缝的访问动态语言创建的对象。也正是由于这一点，它的部分目的与反射和object类型重合了。\n由于dynamic可以简化代码并具有缓存的优势，它最终会替换掉反射和object类型。但是引入dynamic的初衷绝对不是要去代替反射和object类型，只是它们的目的重合了而已。\nDynamic\nObject &#x2F;  反射\nDynamic对象是DLR引擎提供的一个小特性，我们可以通过使用它来访问动态语言创建的对象。而DLR不仅使得动态语言创建的对象可以被访问，它还使得你的类可以被暴露给动态语言。\n反射和object类型只是用来引用未知类型。反射和object类型无法帮你把你的类暴露给其他语言。它们只是用来访问那些直到运行时才得知具体类型的对象的。\n语法相当简单。\n语法有点难。\n因为有了方法访问的缓存，性能得以提升。\n目前还没有对访问方法的缓存。\ndynamic关键字有什么优缺点？\n差的程序员即使使用最好的语言也会写出很差的代码，而好的程序员即使使用最差的编程语言也可以健步如飞。Dynamic关键字是一个减少复杂性的好工具，但是如果使用不当的话，它就是个诅咒。\nDynamic关键字的优势有：\n•  帮你与动态语言相交互。\n•  消除混乱的反射代码并可以简化代码复杂度。\n•  有方法访问的缓存，可以提升性能。\n缺点：\n•  当与强类型的类一起使用的时候可能会损害性能。\nExpando对象是什么呢？\nExpando对象是为交互性的另一端服务的，比如说它使得你的自定义类型可以在动态语言中被访问。所以你可以创建一个Expando类的实例并把它传递给像Ruby、JavaScript、Python之类的动态语言。Expando对象有助于在运行时添加属性。它是动态属性包的一种高效实现。要想使用Expando对象，我们首先要引入System.Dynamic命名空间。然后创建一个ExpandoObject的对象并把它赋值给一个用dynamic声明的引用。\ndynamic obj = new ExpandoObject();\n\n要创建动态属性，我们只需要写出属性名并给它赋值。\nobj.Customername = &quot;Some Customer Name&quot;;\n\n最后我们显示该值。\nMessageBox.Show(obj.Customername);\n\n我们可以实现自己的Expando对象吗？\nExpando对象在内部只是向一个集合中添加属性。所以你可以创建自己的Expando对象。\n我们首先需要继承DynamicObject类。\npublic class clsMyExpando : DynamicObject&#123;&#125;\n\n如前所述，我们需要定义一个集合来存储属性。所以第二步我们就要创建一个字典对象来维护集合中的属性。\npublic class clsMyExpando : DynamicObject&#123;    Dictionary items= new Dictionary();&#125;\n\n我们现在可以使用TryGetMember和SetGetMember来定义我们的属性访问器。\npublic class clsMyExpando: DynamicObject &#123; Dictionary items = new Dictionary(); public override bool TryGetMember(GetMemberBinder binder, out object result) &#123;  return items.TryGetValue(binder.Name, out result); &#125; public override bool TrySetMember(SetMemberBinder binder, object value) &#123;  items[binder.Name] = value;  return true; &#125;&#125;\n\n现在我们可以创建我们自己的Expando类的对象并把它赋值给dynamic类的引用。下面的代码片断中我们给一个叫做Name的动态属性赋了值。\ndynamic obj = new clsMyExpando();obj.Name = &quot;Dynamic Property&quot;;\n\n使用自定义Expando对象有什么益处呢？\n使用Expando对象可以提升性能。如果你的类有静态属性也有动态属性的话，你可以像如下代码一样的在自定义Expando类中创建静态属性。当该对象的静态属性被访问的时候，它不会去调用字典的成员方法，这样也就增进了性能。DLR引擎会首先试着去访问属性名而不是去调用TryGetMember和SetGetMember。\n如果你不需要动态属性也不需要和动态语言交互的话，就要避免使用自定义Expando类型。而如果你需要使用动态属性的话，一定要确保你是继承了DynamicObject类的。\npublic class clsMyExpando: DynamicObject &#123; Dictionary items = new Dictionary(); private string _Name; public string Name &#123;  get &#123;   return _Name;  &#125;  set &#123;   _Name = value;  &#125; &#125; public override bool TryGetMember(GetMemberBinder binder, out object result) &#123;  return items.TryGetValue(binder.Name, out result); &#125; public override bool TrySetMember(SetMemberBinder binder, object value) &#123;  items[binder.Name] = value;  return true; &#125;&#125;\n\nIDynamicMetaObjectProvider和DynamicMetaObject是什么呢？\n动态对象实现IDynamicMetaObjectProvider并返回DynamicMetaObject。这两个类型都是实现动态语言之间交互性的核心部分。\n\n\n\n\n","tags":["C#"]},{"title":"MEF编程指南（前两节）","url":"/blog/2010/05/22/MEF%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E5%89%8D%E4%B8%A4%E8%8A%82%EF%BC%89/","content":"MEF编程指南（前两节）\n在应用程序中使用MEF\n在应用程序中使用MEF需要创建一个CompositionContainer的实例，向其中添加可组合的部件，将宿主应用包含进去然后组合。\n以下是使用MEF需要用到的步骤：\n1、  创建一个宿主类。在接下来的示例中，我们将会使用一个控制台应用，所以宿主也就是Program类了。\n2、  引用System.ComponentModel.Composition程序集\n3、  添加如下using语句：using System.ComponentModel.Composition;\n4、  添加一个Compose（）方法，它创建容器的实例并做组合的工作\n5、  添加一个Run（）方法，它会调用Compose（）  方法\n6、  在Main（）方法中实例化宿主类\n注意：在ASP.NET和WPF中无需这一步，因为宿主类是由运行时初始化的。\n下面的代码演示了代码的样式。\nusing System.ComponentModel.Composition;using System.ComponentModel.Composition.Hosting;using System.Reflection;using System;public class Program &#123; public static void Main(string[] args) &#123;  Program p = new Program();  p.Run(); &#125; public void Run() &#123;  Compose(); &#125; private void Compose() &#123;  var container = new CompositionContainer();  container.ComposeParts(this); &#125;&#125;\n\n7、  定义一个或多个宿主可以导入（import）的导出（exports）。下面的代码中我们将会创建一个叫做IMessageSender的接口。我么还会定义一个可组合组件–EmailSender类，它通过使用[System.ComponentModel.Composition.Export]特性来导出了一个IMessageSender。\npublic interface IMessageSender &#123; void Send(string message);&#125;[Export(typeof(IMessageSender))]public class EmailSender: IMessageSender &#123; public void Send(string message) &#123;  Console.WriteLine(message); &#125;&#125;\n\n8、  给宿主类添加属性，每个属性都被[  System.ComponentModel.Composition.Import]修饰。如下就是给Program类添加的一个IMessegeSender类型的导入。\n[Import]public IMessageSender MessageSender &#123; get; set; &#125;\n\n9、  向容器中添加可组合部件。在MEF中有多种方式可以向容器中添加可组合部件。其中一种就是直接添加可组合部件的实例，还有一种更常用的方式是通过使用目录（catalog），我们稍后将会讲解这一点。\n向容器中直接添加组件\n在Compose（）方法中通过使用ComposeParts（）方法来手动添加可组合组件。下面的例子中，一个EmailSender的实例和需要导入它的Program类的实例被添加进了容器中去了。\nprivate void Compose() &#123; var container = new CompositionContainer(); container.ComposeParts(this, new EmailSender());&#125;\n\n使用AssemblyCatalog来向容器中添加可组合组件\n通过使用catalog，容器可以自动创建组件的实例而不需要我们显式的去添加它们。在Compose（）方法中创建一个catalog。然后把它传入到容器的构造方法中去。\n下面的例子中，我们通过把当前程序集传入其构造方法中去来创建了一个AssemblyCatalog。我们没有手动添加EmailSender的实例，它将会被自动发现。\nprivate void Compose() &#123; var catalog = new AssemblyCatalog(System.Reflection.Assembly.GetExecutingAssembly()); var container = new CompositionContainer(catalog); container.ComposeParts(this);&#125;\n\n完成上面各个步骤之后，现在代码应该是如下的样式。\nusing System.ComponentModel.Composition;using System.ComponentModel.Composition.Hosting;using System.Reflection;using System;public class Program &#123; [Import] public IMessageSender MessageSender &#123;  get;  set; &#125; public static void Main(string[] args) &#123;  Program p = new Program();  p.Run(); &#125; public void Run() &#123;  Compose();  MessageSender.Send(&quot;Message Sent&quot;); &#125; private void Compose() &#123;  AssemblyCatalog catalog = new AssemblyCatalog(Assembly.GetExecutingAssembly());  var container = new CompositionContainer(catalog);  container.ComposeParts(this); &#125;&#125;public interface IMessageSender &#123; void Send(string message);&#125;[Export(typeof(IMessageSender))]public class EmailSender: IMessageSender &#123; public void Send(string message) &#123;  Console.WriteLine(message); &#125;&#125;\n\n上面的代码编译并运行时，应用程序和它需要的导入将会被组合起来。Send（）方法将会被调用，从而在控制台输出“Message Sent”。\n定义可组合部件和契约\n可组合部件\n可组合部件可以导出其他部件需要的服务，也可以导入其他部件提供的服务。在MEF中可组合部件需要使用System.ComponentModel.Composition.Import和System.ComponentModel.Composition.Export来定义其导入和导出。一个可组合部件应该至少包含一个导出。可组合部件可能会是被显式的添加进容器中去，也可能是通过使用catalog被创建的。MEF发布时带有的默认catalog可以通过Export特性来识别可组合部件。\n契约\n可组合部件并非是直接依赖于彼此，它们都依赖于一个契约，也就是一个标示字符串。每个导出都会有一个契约，而导入需要声明它需要哪个契约。容器通过使用契约信息来匹配导入和导出。如果没有指明契约，MEF将会默认使用类型的全限定名作为契约。如果导出中传入了一个类型，MEF也将会使用全限定名。\n下面的代码中出现的所有导出契约都是等价的。\nnamespace MEFSample &#123; [Export] public class Exporter &#123;  ... &#125; [Export(typeof(Exporter))] public class Exporter1 &#123;  ... &#125; [Export(&quot;MEFSample.Exporter&quot;)] public class Exporter2 &#123;  ... &#125;&#125;\n\n接口&#x2F;抽象契约\n通常一个可组合部件导出的都是接口或者抽象类型，而不是具体类型。比如如下的代码中，有两个类都导出了IMessageSender。Notifier类导入一组IMessageSender，并调用其中每一项的Send（）方法。现在新的信息发送器可以很容易的被添加到系统中去。\n[Export(typeof(IMessageSender))]public class EmailSender: IMessageSender &#123; ...&#125;[Export(typeof(IMessageSender))]public class TCPSender: IMessageSender &#123; ...&#125;public class Notifier &#123; [ImportMany] public IEnumerable &lt; IMessageSender &gt; Senders &#123;  get;  set; &#125; public void Notify(string message) &#123;  foreach(IMessageSender sender in Senders) sender.Send(message); &#125;&#125;\n\n\n\n","tags":["C#"]},{"title":"在.NET 4中调用GDAL库时遇到的问题及解决方法","url":"/blog/2010/07/31/%E5%9C%A8.NET%204%E4%B8%AD%E8%B0%83%E7%94%A8GDAL%E5%BA%93%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","content":"最近需要在  .NET 4  的环境中调用  GDAL  库。  GDAL  本身是一套非托管类库，不过还好提供了托管的  Wrapper  。\n这些托管的程序集被包含在了  FWTools  的安装包中，  FWTools  中带的版本依赖于  gdal_fw.dll，  gdal_fw.dll是  GDAL  核心类库的修改版，而它依赖的其他非托管程序集太多了，加起来有  18M  左右。所以还是自己下载代码编译的好。\n 这篇文章  介绍了  1.4  版本的编译方法，该方法同样适用于现在的  1.7  版本。\n编译好之后引用、调用、  Debug  都没问题，一切正常，但是如果用  Release  编译并在  VS  之外运行的话则会报出AccessViolationException  ，异常信息提示说访问了受保护的内存。我的第一反应就是托管的  Wrapper  中用  P&#x2F;Invoke调用了非托管程序集，而非托管程序集导致了这个问题。但是这个猜测并不能解释为什么只有在  .NET 4+Release+IDE外运行的情况下才会出错的现象。\n猜来猜去，找来找去找到了问题的所在：\nGDAL  的托管  Wrapper  中有一个叫做  SWIGStringHelper的类型，该类型的静态构造方法中执行了一些比较重要的初始化操作。另外一个叫做  OsrPINVOKE  的类中声明了一个  SWIGStringHelper类型的私有静态字段，并在声明时就初始化了该字段，而且  OsrPINVOKE  中没有显式声明的静态构造。\n把代码简化一下的话，大概是这样的：\nclass OsrPINVOKE &#123; private static SWIGStringHelper helper = new SWIGStringHelper(); public static void DoSomething() &#123;  Console.WriteLine(&quot;static method of OsrPINVOKE&quot;); &#125;&#125;class SWIGStringHelper &#123; static SWIGStringHelper() &#123;  //这里做了一些重要的初始化  Console.WriteLine(&quot;SWIGStringHelper static constructor &quot;); &#125;&#125;\n\n如果有代码调用  DoSomething  ，我对这段代码执行顺序的估计是这样的：\nOsrPINVOKE  的静态构造方法（里面初始化  helper  这个静态字段）；\nSWIGStringHelper  的静态构造方法（输出字符串）；\nSWIGStringHelper  的实例构造方法（里面啥也没有做）；\nDoSomething  方法（输出字符串）。\n所以应该是先输出  SWIGStringHelper static constructor  而后输出  static method of OsrPINVOKE  。\n试着这样调用一下：\nstatic void Main(string[] args) &#123;    OsrPINVOKE.DoSomething();    Console.ReadLine();&#125;\n\n却发现如果用的  target framework  是  .net 4  ，用  release  编译并且在  VS  外运行的话，就会只输出static method of OsrPINVOKE  ，感觉好像  SWIGStringHelper  的静态构造方法没有执行。而如果用的是  .net2.0  、  3.5  ，或者是用  Debug  编译或是在  VS  里面运行的话都不会有问题。\n难道是静态字段的初始化在  .NET 4  中变成  Lazy  的了？\n事实证明真的是这样。所以要解决这个问题的话只要在  OsrPINVOKE  里面显示声明一个静态构造方法，把  new  SWIGStringHelper();  这一句放到里执行就  OK  了。\n如果您在  .NET 4  中调用  GDAL  时遇到了类似的问题，不妨试一下。\n参考：\n http://social.microsoft.com/Forums/zh-CN/visualcshartzhchs/thread/2106ea8e-4889-45bf-82fd-55ab4b3e9aad\n http://social.msdn.microsoft.com/Forums/en-US/csharpgeneral/thread/d3fb3454-b982-4357-bb6b-63f7eceee69b/#96f5cc6b-a31b-4ae2-b2f4-40a99e7581af \n感谢：\n 韦恩卑鄙  \n Nishant Sivakumar \n\n\n\n\n","tags":["疑难"]},{"title":"WPF中ItemContainerStyle不适用的一种情况","url":"/blog/2010/09/13/WPF%E4%B8%ADItemContainerStyle%E4%B8%8D%E9%80%82%E7%94%A8%E7%9A%84%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5/","content":"WPF中的ItemsControl定义了  ItemContainerStyle  这一属性，顾名思义，该属性用来给ItemsControl中包含的每一个Item的容器定义样式  。\n比如在ListBox中这个容器就是ListBoxItem，在TabControl中这个容器就是TabItem。\n下面是  ItemContainerStyle  的一种简单应用：\nXAML：\n&lt;Window&gt;    &lt;StackPanel&gt;        &lt;ListBox Name=&quot;itemsControl&quot; ItemsSource=&quot;&#123;Binding&#125;&quot;&gt;            &lt;ListBox.ItemContainerStyle&gt;                &lt;Style TargetType=&quot;ListBoxItem&quot;&gt;                    &lt;Setter Property=&quot;IsSelected&quot; Value=&quot;&#123;Binding IsSelected, Mode=OneTime&#125;&quot;/&gt;                &lt;/Style&gt;            &lt;/ListBox.ItemContainerStyle&gt;            &lt;ListBox.ItemTemplate&gt;                &lt;DataTemplate&gt;                    &lt;TextBlock Text=&quot;&#123;Binding Text&#125;&quot;/&gt;                &lt;/DataTemplate&gt;            &lt;/ListBox.ItemTemplate&gt;        &lt;/ListBox&gt;    &lt;/StackPanel&gt;&lt;/Window&gt;\n\n在这段  XAML中  定义了一个ListBox，在其ItemTemplate中有一个TextBlock绑定到数据实体的Text属性上。在其ItemContainerStyle  中将其每个Item的IsSelected属性绑定到数据实体的IsSelected上。其数据实体的生成在下面的代码中：\npublic partial class ComboBoxTest: Window &#123; public ComboBoxTest() &#123;  InitializeComponent();  itemsControl.DataContext = GetData(); &#125; private object GetData() &#123;  Collection &lt; object &gt; data = new Collection &lt; object &gt; ();  for (int i = 1; i &lt;= 10; i++) &#123;   data.Add(new &#123;    Text = i.ToString(), IsSelected = i == 5   &#125;);  &#125;  return data; &#125;&#125;\n\n为了简单，没有单独定义实体类而是用了匿名对象。一共生成十个匿名实体，其中第五个的IsSelected设置为true，把这十个实体放入一个Collection中赋值给控件的DataContext，这样XAML中对ItemsSource的绑定就会起效。当然，直接把这个Collection赋值给ItemsSource也可以。\n运行一下，结果和预期的一样，第五项被选中了。\n\n试试把XAML中的ListBox换成TabControl，更换之后的XAML如下：\n&lt;Window ......&gt;    &lt;StackPanel&gt;        &lt;TabControl Name=&quot;itemsControl&quot; ItemsSource=&quot;&#123;Binding&#125;&quot;&gt;            &lt;TabControl.ItemContainerStyle&gt;                &lt;Style TargetType=&quot;TabItem&quot;&gt;                    &lt;Setter Property=&quot;IsSelected&quot; Value=&quot;&#123;Binding IsSelected, Mode=OneTime&#125;&quot;/&gt;                &lt;/Style&gt;            &lt;/TabControl.ItemContainerStyle&gt;            &lt;TabControl.ItemTemplate&gt;                &lt;DataTemplate&gt;                    &lt;TextBlock Text=&quot;&#123;Binding Text&#125;&quot;/&gt;                &lt;/DataTemplate&gt;            &lt;/TabControl.ItemTemplate&gt;        &lt;/TabControl&gt;    &lt;/StackPanel&gt;&lt;/Window&gt;\n\n仅仅是把ListBox换成了TabControl，把ListBoxItem换成了TabItem而已，C#代码没有改。试着运行一下，结果还是和预期的一样，第五项会被选中。\n\nListBox和TabControl都是间接继承自ItemsControl而直接继承自Selector的，那是不是所有Selector的子类都会有如上的行为呢？\n实际上不是，把Selector的另一个子类ComboBox拿出来试试。\n仍然是只改XAML，不改C#代码，改完之后的XAML如下：\n&lt;Window ......&gt;    &lt;StackPanel&gt;        &lt;ComboBox Name=&quot;itemsControl&quot; ItemsSource=&quot;&#123;Binding&#125;&quot;&gt;            &lt;ComboBox.ItemContainerStyle&gt;                &lt;Style TargetType=&quot;ComboBoxItem&quot;&gt;                    &lt;Setter Property=&quot;IsSelected&quot; Value=&quot;&#123;Binding IsSelected, Mode=OneTime&#125;&quot;/&gt;                &lt;/Style&gt;            &lt;/ComboBox.ItemContainerStyle&gt;            &lt;ComboBox.ItemTemplate&gt;                &lt;DataTemplate&gt;                    &lt;TextBlock Text=&quot;&#123;Binding Text&#125;&quot;/&gt;                &lt;/DataTemplate&gt;            &lt;/ComboBox.ItemTemplate&gt;        &lt;/ComboBox&gt;    &lt;/StackPanel&gt;&lt;/Window&gt;\n\n运行之后的效果如下：\n\n可见启动后没有任何选中项。而只有当用鼠标将ComboBox展开时第五项才会被选中。对这种现象，我的猜测是因为  ItemContainerStyle只有在所有  Item加载之后才会生效，而ComboBox默认情况下并不会把其Items展示出来，所以直到用鼠标将ComboBox展开时才会有选中效果。\n对这种情况有一个不太完美的解决方案，把C#代码中的GetData方法修改如下：\nprivate object GetData() &#123; Collection &lt; object &gt; data = new Collection &lt; object &gt; (); for (int i = 1; i &lt;= 10; i++) &#123;  data.Add(new &#123;   Text = i.ToString()  &#125;); &#125; return new &#123;  Data = data, SelectedData = data[4] &#125;;&#125;\n\n上面的代码中再次应用了匿名对象，把整个实体集合放入新的匿名对象中的Data属性，并把集合的第五项赋值给新的匿名对象的SelectedData属性。\n然后修改XAML，把ComboBox的ItemsSource绑定到匿名对象的Data属性，把SelectedValue绑定到匿名对象的SelectedData属性。修改后的XAML如下：\n&lt;Window ......&gt;    &lt;StackPanel&gt;        &lt;ComboBox Name=&quot;itemsControl&quot; ItemsSource=&quot;&#123;Binding Data&#125;&quot; SelectedValue=&quot;&#123;Binding SelectedData, Mode=OneTime&#125;&quot;&gt;            &lt;ComboBox.ItemTemplate&gt;                &lt;DataTemplate&gt;                    &lt;TextBlock Text=&quot;&#123;Binding Text&#125;&quot;/&gt;                &lt;/DataTemplate&gt;            &lt;/ComboBox.ItemTemplate&gt;        &lt;/ComboBox&gt;    &lt;/StackPanel&gt;&lt;/Window&gt;\n\n再运行，启动效果如下：\n\n\n\n\n\n","tags":["WPF"]},{"title":"百度游戏 七彩鱼 自动喂鱼器","url":"/blog/2010/10/04/%E7%99%BE%E5%BA%A6%E6%B8%B8%E6%88%8F%20%E4%B8%83%E5%BD%A9%E9%B1%BC%20%E8%87%AA%E5%8A%A8%E5%96%82%E9%B1%BC%E5%99%A8/","content":"前几天有朋友推荐我玩百度的网页游戏“七彩鱼”，玩儿了几天感觉还行，就是老得盯着喂鱼太麻烦。十一闲着没啥事儿干，于是就自己写了个喂鱼器。\n具体使用方法写起来有点麻烦，我录了一段视频传到了56上，地址在下面：\n http://www.56.com/u84/v_NTUyNzE0NjU.html\n喂鱼器程序的下载地址：\n http://download.csdn.net/source/2732931\n如果您用的是Vista或者Win7，本程序可以直接运行。但是如果是XP用户而且从没安装过.Net Framework的话那需要装一下.NetFramework(2.0或以上版本)。\nPS：我写这个程序主要是自娱自乐，捎带着娱乐一下同好。如果七彩鱼的开发者或者百度的工作人员觉得这个程序对您有损害的话，请在本博客留言。\n\n\n\n\n","tags":["utils"]},{"title":"当Generic.xaml遇上BitmapImage：发现一个疑似WPF Bug而又不似Bug的问题","url":"/blog/2010/09/30/%E5%BD%93Generic.xaml%E9%81%87%E4%B8%8ABitmapImage%EF%BC%9A%E5%8F%91%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%96%91%E4%BC%BCWPF%20Bug%E8%80%8C%E5%8F%88%E4%B8%8D%E4%BC%BCBug%E7%9A%84%E9%97%AE%E9%A2%98/","content":"发现这个有点像  Bug  又不太像  Bug  的东西的过程是这样的：\n我继承自  ContentControl  写了一个  MyContentControl  ，在其中定义了一个叫做  IconProperty的依赖属性及其对应的  CLR  属性并且在其静态构造中调用了  DefaultStyleKeyProperty.OverrideMetadata方法，代码很少，看起来是这个样子的：\nclass MyContentControl: ContentControl &#123; static MyContentControl() &#123;  DefaultStyleKeyProperty.OverrideMetadata(typeof(MyContentControl), new FrameworkPropertyMetadata(typeof(MyContentControl))); &#125; public ImageSource Icon &#123;  get &#123;   return (ImageSource) GetValue(IconProperty);  &#125;  set &#123;   SetValue(IconProperty, value);  &#125; &#125; public static readonly DependencyProperty IconProperty = DependencyProperty.Register(&quot;Icon&quot;, typeof(ImageSource), typeof(MyContentControl));&#125;\n\n其中的  Icon  属性声明类型为  ImageSource  ，目的简单明了，当然就是给这个控件加个图标了。\n然后再给这个自定义控件定义一个放在  Generic.xaml  里的  Template  ，一样很简单，只是用一个  StackPanel  把它的Icon  和  Content  包起来，代码是这样的：\n&lt;Style TargetType=&quot;&#123;x:Type local:MyContentControl&#125;&quot;&gt;    &lt;Style.Setters&gt;        &lt;Setter Property=&quot;Template&quot;&gt;            &lt;Setter.Value&gt;                &lt;ControlTemplate TargetType=&quot;&#123;x:Type local:MyContentControl&#125;&quot;&gt;                    &lt;StackPanel&gt;                        &lt;Image Source=&quot;&#123;TemplateBinding Icon&#125;&quot; Stretch=&quot;Fill&quot;/&gt;                        &lt;ContentPresenter Content=&quot;&#123;TemplateBinding Content&#125;&quot;/&gt;                    &lt;/StackPanel&gt;                &lt;/ControlTemplate&gt;            &lt;/Setter.Value&gt;        &lt;/Setter&gt;    &lt;/Style.Setters&gt;&lt;/Style&gt;\n\n然后定义一个窗体，其中有一个  Canvas  和一个  Button  ，点击  Button  时把  Canvas  清空然后再向其中加  500个位置随机的自定义控件，这部分代码是这样的：\ncanvas.Children.Clear();Random random = new Random();for (int i = 0; i &lt; 500; i++) &#123; MyContentControl marker = new MyContentControl &#123;  Content = i, Icon = bitmap &#125;; marker.SetValue(Canvas.LeftProperty, (double) random.Next(0, (int) canvas.ActualWidth)); marker.SetValue(Canvas.TopProperty, (double) random.Next(0, (int) canvas.ActualHeight)); canvas.Children.Add(marker);&#125;\n\n其中的  bitmap  是窗体的一个私有字段，它关联了一张小箭头式的  png  图片（这个  bitmap 是窗体的私有字段或者是方法中的局部变量会对结果有影响，这点稍后说）。\n再然后运行程序玩一下吧，点一下  Button  之后是这样的：\n\n看起来蛮正常的。\n但是试着多点几次  Button  之后发现不对劲了，怎么几乎每一次都比上一次慢呢？\n于是就又在加入  500  个控件的地方监视了一下时间，代码是这样的：\nStopwatch watch = new Stopwatch();watch.Start();this.Dispatcher.BeginInvoke(new Action(() =&gt; &#123; this.Title = watch.ElapsedMilliseconds.ToString(); if (count &lt;= 10) &#123;  ClearAndAddMarkers(); &#125; else &#123;  count = 0; &#125; count++;&#125;), DispatcherPriority.Loaded);\n\n计时器在  canvas  的  Children  填充之后开始，在  Dispatcher  的  Loaded  时停止，这样确保记录下来的时间是用来Render  的时间而不是填充集合的时间。把这个清空、填充、计时的过程连续跑十次，把记录下来的时间写到窗体的  Title  上。\n在运行一下，点  Button  ，观察一下  Window  的  Title  ，先是  400  多毫秒，然后  600  多，  800  多……  最后一次用了  1300  多。当然，如果您机子配置太好的话得把加入自定义控件的数量调大一点。\n好奇怪啊好奇怪，我开始认定是代码写的有问题（确实也是有一点，不过不是关键），但是找来找去找不到。于是试着把  Generic.xaml改了下名字，不让它自动应用，然后在窗体里面引用这个改了名的资源字典。结果，怪事发生了，每次的时间稳定在了  400  毫秒左右。\n这样看起来好像是  WPF  对  Generic.xaml  这种方式的处理有问题了，可以疑似为是个  Bug  。那为什么标题又说不似  Bug  呢？\n这就涉及到前面说的  bitmap  了，如果去掉这个私有字段而是在填充  canvas  的  Children  的时候每次  new  一个新的BitmapImage  来赋值给每一个自定义控件的  Icon  的话，也可以把每次的时间维持在  400  毫秒左右，所以又说它不太像个  Bug  。\n如果有哪位遇到了类似的问题不妨试一下不要用  Generic.xaml  ，改用自己命名的普通资源字典来试一下；又或者是不要让窗体  hold  住bitmap  这个资源不放手，每次  new  一个  BitmapImage  试一下。\n但是无论如何，同一个  Template  定义在  Generic.xaml中自动应用和定义在普通资源字典中手动引用这两种方式会导致程序的性能不同终究是个奇怪的问题，希望能有高手给出更好的解决方案和解释。\nPS  ：我试过了在  .NET 3.5  和  .NET 4  下分别用  Debug  和  Release  编译，也试过了在  VS  中运行和脱离VS  独立运行，都是有问题的。\n另外，还试过了打微软发布的  KB981107  这个补丁，一样没有用。\n 下载代码 \n\n\n\n\n","tags":["疑难"]},{"title":"C#中的语言特性都是从何而来？","url":"/blog/2011/03/06/CSharp%E4%B8%AD%E7%9A%84%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E9%83%BD%E6%98%AF%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5%EF%BC%9F/","content":"前几天推荐一个同事用“可选参数”，推荐完了我还画蛇添足的说这是.Net 4中的新特性。但是事后才发现这个新特性是C# 4.0的语言特性，与.Net4无关。其实也不只这一次，我平时也经常把语言、框架、运行时，有时甚至还有开发工具混为一谈。于是今天就总结一下C#中我感兴趣的几个语言特性是从何而来的。\n** 1.可选参数  **\n可选参数是C# 4.0中的新特性，其作用在于在调用者不提供参数值时给参数一个默认值，用起来是这样的：\nstatic void Main(string[] args)\n\n\n&#123;\n\n\n    TestMethod();\n\n\n    TestMethod(10);\n\n\n \n\n\n    Console.ReadLine();\n\n\n&#125;\n\n\n \n\n\npublic static void TestMethod(int parameter = 5)\n\n\n&#123;\n\n\n    Console.WriteLine(parameter);\n\n\n&#125;\n\n以上的代码在第一次调用TestMethod时输出5，第二次输出10，也就是在没有给TestMethod提供参数值时，会自动以5作为参数值。\n该特性的实现依赖于OptionalAttribute和DefaultParameterValueAttribute这两个attribute，也就是说TestMethod这个方法完全可以声明为这样：\npublic static void TestMethod([Optional, DefaultParameterValue(5)] int parameter)\n&#123;\n    Console.WriteLine(parameter);\n&#125;\n\n而跑起来的结果是一样的。\nOptionalAttribute和DefaultParameterValueAttribute这两个attribute分别是在.Net 1.1和.Net2.0中引入的，也就是说N年前大家就可以写拥有“可选参数”的方法了，只是用起来没有现在这么爽。\n只要您安装了.Net Framework 4.0（也就是说有了其中附带的新版的C#编译器），您就可以编写如上的代码而同时把targetframework指定为.Net Framework 2.0到.Net Framework 4之间的任何版本。\n小总结：我在这个问题上犯的错误就在于将语言和框架混为一谈了。C#语言的第四版和.Net Framework的第四版一起发布，于是我就理所当然的认为C#4.0中的新特性和.Net Framework 4有关系了。其实，只要微软的人愿意，他们完全可以在.Net Framework 2.0发布之后和.NetFramework 4.0发布之前的任意时间发布一款CTP的编译器来实现这一语言性特性，正如他们前不久发布的Asyn CTP一样。\n** 2.var关键字  **\nvar关键字是在C# 3.0中引入的，其作用在于在声明局部变量时无需指定具体类型，用起来是这样的：\nvar str = &quot;hello&quot;;\nConsole.WriteLine(str);\n\n其结果和把var替换为string完全一样。\n这个语言特性看似鸡肋，实际上它的好处在于接收LinQ语句的返回值，比如说Enumerable.GroupBy的某几个重载的返回值是IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;，如果每次用到group by的时候都需要写这么长的一串代码的话，那玩儿LinQ的快感想必是要降低不少呀。\n这个语言特性的实现要比可选参数简单一些，无需框架的支持，完全是语言规范和编译器的“合谋”。编译器在编译时根据赋值语句推断出真实的类型，编译出的IL中完全没有var的身影。\n** 3.泛型  **\n泛型是C# 2.0中新增的特性，也是.Net 2.0中的新特性。没有错，这次终于可以说它是.Net的新特性了，但是也只是.Net而不是.NetFramework。\n在C#语言层面实现泛型需要CLR的支持，可以说它是.Net世界中的一等公民，IL甚至为它修改了语法。\n比如说如下的类型声明：\npublic class TestClass&lt;T&gt;\n\n在编译为IL之后是这样的：\n.class public auto ansi beforefieldinit TestClass&lt;T&gt;\n    extends [mscorlib]System.Object\n\n可见IL中新增了尖括号的用法。\n以上三个语言特性都比较典型。var关键字纯粹是语言层面的小甜头，只要有了能够理解var的编译器，使用哪个版本的CLR或者.NetFramework完全无所谓。\n可选参数需要编译器能理解参数名后面的赋值语句，同时也需要.Net Framework中提供的attribute的支持。\n泛型同时需要CLR和编译器的支持。\n如果列一张表的话，就是下面这样的：\n语言特性\n实现该特性需要的支持\nvar关键字\nCLR（ ） 框架（ ） 编译器（ ）\n可选参数\nCLR（\n） 框架（ ）编译器（ ）\n泛型\nCLR（ ）框架（ ）编译器（ ）\n上表中每一项的编译器都打上了钩儿。很显然，每一项语法层面的特性都需要编译器的支持，要不然语言规范就只是一纸空文了。在这里还是把它列出来，仅求全面。\n写完之后自己看一遍，觉得很是有考据癖的老学究味道。微软总是把开发工具、框架类库、运行时和编译器的新版本一起发布，所以我们总是被弄得很被动，总是搞不清这几者之间区别。其实有时候把这些东西区分开来去观察，更有利于解释一些困惑。\n当然，最后的表格中列出的东西还是太少了，希望各位补充啊。\nPS：请问CSDN的工作人员一个问题，为什么用Live Writer发布的文章一开始排版，格式都是正确的，只要编辑时勾上推荐到首页的选项格式就全乱了呢\n？\n\n\n\n\n","tags":["《你必须知道的.NET》"]},{"title":"送给所有需要学英语的朋友—Words Via Subtitle","url":"/blog/2010/10/06/%E9%80%81%E7%BB%99%E6%89%80%E6%9C%89%E9%9C%80%E8%A6%81%E5%AD%A6%E8%8B%B1%E8%AF%AD%E7%9A%84%E6%9C%8B%E5%8F%8B%E2%80%94Words%20Via%20Subtitle/","content":"从名字就可以看出来，Words Via Subtitle是用来通过字幕学单词的辅助工具。它通过解析美剧或者电影的字幕文件把其中的生词取出，用网络上提供的开放API或者本地词库解释生词。另外，程序还可以提供单词读音（机器发音），可以播放一个单词在剧中出现的语境，可以把所有生词串起来像幻灯片一样连续播放，也就是说显示一个单词及其解释，然后用机器发音读该单词，然后播放该单词在剧中出现的句子，然后切换到下一个生词再重复这一过程。\n这个程序去年就写过一个雏形，最近断断续续的重写了。这次主要的改进是将字幕的分析和单词的解释从主程序中抽出来做成插件，也就是说主程序部署到一台机器之后如果想要增加对一种字幕格式的支持就只需要写一个插件拷到部署的机器上去就ok了，无需把整个程序重新编译、重新部署。同样，如果想要增加一种单词解释器也可以通过添加一个插件完成，比如说现在只有一个很小的本地词库和一个网络释义，之后有人想给这个程序增加一个Google词典的解释器就可以写一个插件来完成。这次重写用了WPF、MEF，以及Ribbon Controls等最近接触的新东西，不过在这儿暂时不介绍程序是怎么写，也不说字幕解析插件和解释提供器插件如何编写，先简单介绍一下各功能的使用吧。对代码感兴趣的朋友可以去CodePlex上去搜索WVS（Words Via Subtitle的简写），我把这个程序作为一个开源项目上传到那儿了，用的MS-PL协议，完全开源哈。\n下面就开始说一下大概怎么用这个程序吧。\n运行程序，用左上角的Open按钮（](&#x2F;images&#x2F;attachment&#x2F;201010&#x2F;24&#x2F;0_12879076954nrG.gif)）打开一个字幕文件（现在可以支持srt和ass格式的，当然以后可以通过插件来添加对更多种类的字幕的支持）。\n ](&#x2F;images&#x2F;attachment&#x2F;201010&#x2F;24&#x2F;0_1287907700gCeG.gif)\n上图中右下角可选的文件格式会随着插件的增多而增多。\n加载字幕文件之后程序会把字幕中出现的生词列到一个列表中（如何判断一个单词是不是生词呢？程序需要通过一个已知单词列表来比对，这个列表需要使用者自己慢慢的“养”。第一次运行程序会把字幕中出现的所有单词，无论难易、常见还是生僻统统的列出来，这时需要使用者自己把认识的单词标记一下，这样这个单词在下次打开别的字幕文件时就不会再蹦出来烦您了），程序看起来是这样的：\n(&#x2F;images&#x2F;attachment&#x2F;201010&#x2F;24&#x2F;0_1287907709mQwJ.gif)\n在左侧的列表里切换单词，右侧区域的解释就会跟着切换。右侧区域的解释可以在多个解释提供器间切换（可切换的解释提供器的数量取决于插件的数量），现在有两个选择：Dict.cn的解释和一个很小的本地词库，上图中用的是Dict.cn，切换到本地词库是这样的：\n ](&#x2F;images&#x2F;attachment&#x2F;201010&#x2F;24&#x2F;0_128790771673Eq.gif)\n标有Choose Language的Ribbon Group（(&#x2F;images&#x2F;attachment&#x2F;201010&#x2F;24&#x2F;0_1287907720Hs1z.gif)）中的按钮用于切换翻译提供器，其数量会随着插件的增多而增多。\n顺着Ribbon菜单向右走，标为Operations的Ribbon Group里有两个按钮（(&#x2F;images&#x2F;attachment&#x2F;201010&#x2F;24&#x2F;0_1287907721nkeH.gif) ），Known用于把一个单词标记为已知的，这样该单词就会被记录到已知单词列表中，像前文中说的那样，被“养”起来了。Misspelled用于把字幕中拼错的单词从列表中踢出去，这样在使用Slide Show功能（这个稍后介绍）的时候就不会受到错误单词的干扰了。\n菜单中再向右是标为Video的Ribbon Group(&#x2F;images&#x2F;attachment&#x2F;201010&#x2F;24&#x2F;0_12879077225gx7.gif)），第一个按钮用于选择和当前字幕对应的视频，第二个用于播放当前在列表中选中的单词在剧中出现的语境。播放时界面看起来是这样的：\n \n能够支持的视频格式取决于部署机器上装过的解码器，应该是Windows Media Player能播放什么这儿就能播放什么。播放完之后自动切换回单词解释界面。\n继续向右走，是用于发音的两个按钮（\n），很明显左侧的用于读出当前单词，右侧的列表用于选择发音风格（其中选项的多少取决于部署机安装过语音引擎，Win7默认会有两个，其他系统没试过）。\n最右侧的就是这次重写后我自己最喜欢的功能了，Slide Show（ ）。它用于把列表中所有的生词串联成幻灯片一样播放。点击该按钮之后，程序会切换到全屏，显示一个单词及其解释，读出该单词的读音，播放该单词对应的语境，然后切换到下一个生词再重复上述过程。这一步就不截图了，我把一些播放Slides Show的过程录下来放到了VeryCD上了 http://www.verycd.com/topics/2859418/ 。\n程序现有的功能就是这些了，如果您有好主意、建议请留言哈。\n对程序代码有兴趣的朋友可以去CodePlex看看：  http://wvs.codeplex.com/ ，如果您发现代码中有什么不妥的地方还请不吝赐教哈。\n想要用这个程序的朋友可以去这几个地址看看：\n1  http://blog.csdn.net/cuipengfei1/archive/2009/09/03/4516588.aspx\n2  http://blog.csdn.net/cuipengfei1/archive/2009/09/10/4539180.aspx\n3  http://blog.csdn.net/cuipengfei1/archive/2009/09/17/4564389.aspx\n上面的三个链接地址是我去年写的那个雏形，功能大致和本文介绍的新版一致，但是只需要.NET 2.0就可以运行，新版的是一个发烧友式的开源项目，targetframework是.NET 4的。\n程序使用介绍就到这里，字幕解析插件和翻译提供器插件的编写下次再写。\n祝您背单词顺利！\n\n\n\n\n","tags":["Words Via Subtitle"]},{"title":"美国生活第一个月见闻，有图有真相（1）","url":"/blog/2011/05/31/%E7%BE%8E%E5%9B%BD%E7%94%9F%E6%B4%BB%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9C%88%E8%A7%81%E9%97%BB%EF%BC%8C%E6%9C%89%E5%9B%BE%E6%9C%89%E7%9C%9F%E7%9B%B8%EF%BC%881%EF%BC%89/","content":"这是从成都起飞时候在飞机上照的，灰蒙蒙的，什么都看不清楚。\n \n飞行中途没怎么开手机，所以也没怎么拍照，下面是到了公司之后的照片。\n这是公司进门之后墙上挂的的东西\n \nMS合作ISV的牌子，2010-2011，是金的\n \n后面这个变成银的了，为啥呢？因为微软涨价了。。。。。。\n \n产品包装盒，不知道是不是真的有人买光盘而不是下载的\n \n休息室的墙上贴了一堆妇女儿童保护条例之类的东西\n \n周末去看车展，这个是啥车？不认识，不过看起来挺高端的\n \n下面牛逼了，一队辆兰博基尼排成一排，我只拍了其中两个\n \n \n还有一些其他各种各样的车，都不认识，叫不上名字来\n \n\n\n\n这儿的自然环境不错，其实不止是不错，是很好\n \n小区里面的草坪上，树林里有野兔子和松鼠，都不咋怕人\n \n \n小区里的一个桥洞底下竟然有这个，惊讶一把\n \n公司楼下人造湖里的水怪，很有特色\n \n住所后院儿，游泳池\n \n这是某个体育用品超市里面卖枪的专柜\n \n就是这么摆着卖，跟白菜似的\n \n这是另外一家超市，好像是叫frys，里面卖的true blood的全集，没买\n \n今天先贴这些，睡觉了，现在这儿是夜里快十二点了\n\n\n\n\n","tags":["图"]},{"title":"“可选参数”趣事探轶","url":"/blog/2011/04/13/%E2%80%9C%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0%E2%80%9D%E8%B6%A3%E4%BA%8B%E6%8E%A2%E8%BD%B6/","content":" 上一篇博文 中提到了“可选参数”这个C# 4.0中新增的语言特性，但是写过之后还是不满足，心里还是有一些疑问没有得到解释。于是又做了一些探索，过程中竟然发现这么一个小小的语言特性背后隐藏着的有趣问题还真不少。这次就把探索过程中的发现和疑问记录下来。\n“可选参数”的实现Cnblogs上有一篇  蒋金楠的文章中提到一句：“缺省参数最终体现为两个特殊的自定义特性OptionalAttribute和DefaultParameterValueAttribute”。为了验证这个说法的正确性，我自己做了一些试验。\n要研究语言特性的实现原理最好的方法莫过于反编译出IL代码来一探究竟了。所以，那就顺着这条线索走吧。\n首先用C#代码写一个很简单的测试方法：\npublic void TestMethod(string str = &quot;A&quot;)\n&#123;\n&#125;\n\n 上一篇博文 中提到过这种写法跟直接使用OptionalAttribute和DefaultValueAttribute这两个attribute的效果是一样的。\npublic void TestMethodWithAttributes([Optional, DefaultParameterValue(&quot;A&quot;)]string str)\n&#123;\n&#125;\n\n这两段代码编译出来的IL除了名字之外别无二致，下面就以第一个方法为例，它的IL是这样的：\n.method public hidebysig instance void  TestMethod([opt] string str) cil managed\n&#123;\n  .param [1] = &quot;A&quot;\n  // Code size       2 (0x2)\n  .maxstack  8\n  IL_0000:  nop\n  IL_0001:  ret\n&#125; // end of method Program::TestMethod\n\n同时其生成的Metadata是这样的：\nMethodName: TestMethod (06000003)\nFlags     : [Public] [HideBySig] [ReuseSlot]  (00000086)\nRVA       : 0x0000205b\nImplFlags : [IL] [Managed]  (00000000)\nCallCnvntn: [DEFAULT]\nhasThis \nReturnType: Void\n1 Arguments\nArgument #1:  String\n1 Parameters\n(1) ParamToken : (08000002) Name : str flags: [Optional] [HasDefault]  (00001010) Default: (String) \n\n说老实话,上面这两段“天书”我并没有完全读懂，但是还是发现有一些异常，觉得有些东西不太对头，为什么这么说呢？因为一般的attribute编译之后的结果通常不是这样的。比如下面这个例子：\n先自定义一个只能应用到参数上的attribute：\n[AttributeUsage(AttributeTargets.Parameter, Inherited = false, AllowMultiple = true)]\nsealed class MyAttribute : Attribute\n&#123;\n&#125;\n\n然后定义一个被该attribute修饰的方法：\npublic void TestAttribute([My]string str)\n&#123;\n&#125;\n\n这个方法编译之后的IL如下：\n.method public hidebysig instance void  TestAttribute(string str) cil managed\n&#123;\n  .param [1]\n  .custom instance void HowDidTheyImplementOptionalParameters.MyAttribute::.ctor() = ( 01 00 00 00 ) \n  // Code size       2 (0x2)\n  .maxstack  8\n  IL_0000:  nop\n  IL_0001:  ret\n&#125; // end of method Program::TestAttribute\n\n可以看到上面代码中标红的部分是TestMethod的IL中没有的。而且，它的Metadata和TestMethod的也是不同的：\nMethodName: TestAttribute (06000005)\nFlags     : [Public] [HideBySig] [ReuseSlot]  (00000086)\nRVA       : 0x00002061\nImplFlags : [IL] [Managed]  (00000000)\nCallCnvntn: [DEFAULT]\nhasThis \nReturnType: Void\n1 Arguments\n    Argument #1:  String\n1 Parameters\n    (1) ParamToken : (08000004) Name : str flags: [none] (00000000)\n    CustomAttribute #1 (0c000010)\n    -------------------------------------------------------\n        CustomAttribute Type: 06000001\n        CustomAttributeName: HowDidTheyImplementOptionalParameters.MyAttribute :: instance void .ctor()\n                Length: 4\n                Value : 01 00 00 00                                      &gt;                &lt;\n                ctor args: ()\n\n这个方法的Metadata的最后多了一段CustomAttribute的描述，其flags也为空，不像TestMethod的flags后面跟有[Optional] [HasDefault]这样的标志。\n因为我没有读过  ECMA 335  的文档，所以下面只是做一个不太谨慎的推测：OptionalAttribute和DefaultParameterValueAttribute这两个attribute和其他的attribute不同，他们有自己对应的专有的flags。调用TestMethod的代码在被编译时，编译器会去读取存储于元数据中的默认值，并把读取到的值嵌入到IL中去。\n由于在TestMethod的C#代码中、编译出的IL代码中，及其元数据中都不见OptionalAttribute和DefaultParameterValueAttribute的踪迹，所以我认为“缺省参数最终体现为两个特殊的自定义特性OptionalAttribute和DefaultParameterValueAttribute”这种说法是有待商榷的。\n背后的陷阱“可选参数”看起来方便又好用，但是使用它是不是真的是多快好省的绝佳选择呢？实际上不是的，它的背后隐藏着至少两个陷阱（我只发现了两个）。\n第一个陷阱：版本更迭的问题就以上面提到的TestMethod为例，写一个方法来调用它：\npublic void Caller()\n&#123;\n    TestMethod();\n&#125;\n\n这里在调用时没有传入参数，也就是说相当于传入了默认的参数“A”。Caller编译出来的IL是这样的：\n.method public hidebysig instance void  Caller() cil managed\n&#123;\n  // Code size       14 (0xe)\n  .maxstack  8\n  IL_0000:  nop\n  IL_0001:  ldarg.0\n  IL_0002:  ldstr      &quot;A&quot;\n  IL_0007:  call     instance void HowDidTheyImplementOptionalParameters.Program::TestMethod(string)\n  IL_000c:  nop\n  IL_000d:  ret\n&#125; // end of method Program::Caller\n\n请注意标红的两行，Caller的IL中实际是把“A”这个值写死了的。也就是说如果有一个包含“可选参数”的非强命名程序集在版本升级时修改了参数的默认值，其他引用它的程序集如果没有重新编译就无法获得到新的默认参数值，在运行时仍然会传入老版本中定义的值。\n第二个陷阱：跨语言调用并不是所有的语言都被强制要求支持“可选参数”这一特性。对于不支持这一特性的语言来说，完全可以忽略掉元数据中包含的默认值而强制要求这一语言的用户去显式的提供参数值。而这样就会导致代码的运行时行为不一致。\nC#4.0之前都所有版本都是不支持“可选参数”的。也就是说如果在VS2010中用C#4.0的语法和.NET Framework2.0的框架编一个含有“可选参数”的程序集，然后在VS2008中的项目中引用这个程序集的话，则只能显式的提供参数值。\n针对以上两点，我觉得在使用“可选参数”时应该遵循以下的原则：在public API（包括公开类型的公开成员和公开类型的受保护成员）中尽量不要用“可选参数”，而是使用方法重载，以避免API行为不一致。在程序集内部的私有API中，尽情享用吧。\n关于CLS-Compliant 微软一站式示例代码库  的文档中提到说“可选参数”不是CLS-Compliant的。我觉得这种说法是错误的。最简单的验证方式就是加上CLSCompliantAttribute来试试看。\n在含有TestMethod（这里要保证TestMethod是公开类型中的公开方法，因为CLSCompliant只针对publicAPI）的项目的AssemblyInfo.cs中加上这么一行：\n[assembly: CLSCompliant(true)]\n\n然后编译，编译器没有给出任何警告。而如果是在publicAPI中使用了unit这一“臭名昭著”的类型的话，编译器会毫不犹豫的给出一个警告。比如这样的一个方法：\npublic void TestCLSCompliant(uint parameter)\n&#123;\n&#125;\n\n在编译时就会得到一个警告：Argument type ‘uint’ is not CLS-compliant。\n而且  MSDN的文档 中也提到了虽然“可选参数”没有被收录到CLS的规范中，但是CLS是可以“容忍”它的存在的。\nReflector中可能的Bug以上所有反编译都是用IL Dasm来做的，而如果用最新版的Reflector（就是只能试用14天的那个版本）来查看反编译出的C#(把版本设为任何非None的值)代码的话，会发现它会把TestMethod解释为使用了OptionalAttribute和DefaultParameterValueAttribute。我怀疑这是因为无论是使用“可选参数”还是直接使用OptionalAttribute和DefaultParameterValueAttribute，编译出的结果都是一样的，Reflector无从判断源代码中使用的是哪一种，索性就假定为是第二种了。\n存疑虽然OptionalAttribute没有出现在TestMethod的C#代码中，在编译出来的IL和元数据中也不见踪影，但是它还是出现在了编译出的程序集的TypeRefs中，而DefaultValueAttribute却没有出现。这是为什么呢？\n参考MSDN上的：\n http://social.msdn.microsoft.com/Forums/en-US/csharplanguage/thread/d1be12e0-6325-427a-8e25-02fbd8396b1b/#18b08278-28a9-43dc-b3d4-e4694ca0260d \n http://social.msdn.microsoft.com/Forums/en-US/csharplanguage/thread/31731806-dd83-4483-89b4-30001af14ab7/#352d019c-950c-42de-88f6-b0fecdf34351 \n http://social.msdn.microsoft.com/Forums/en-US/csharplanguage/thread/86f6d205-21b8-45e3-b5ec-3e9d5c1f9feb/\nStackOverflow上的：\n http://stackoverflow.com/questions/5456989/is-the-new-feature-of-c-4-0-optional-parameters-cls-compliant\n http://stackoverflow.com/questions/5497514/what-does-opt-mean-in-msil\n http://stackoverflow.com/questions/5522438/why-does-a-custom-attribute-appear-both-in-il-and-metadata \n请问CSDN的工作人员一个问题，为什么用Live Writer发布的文章一开始排版，格式都是正确的，只要在CSDN的WebEditor里面编辑一次就全乱了呢？\n\n\n\n\n","tags":["《你必须知道的.NET》"]},{"title":"美国生活第一个月见闻，有图有真相（2）","url":"/blog/2011/06/01/%E7%BE%8E%E5%9B%BD%E7%94%9F%E6%B4%BB%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9C%88%E8%A7%81%E9%97%BB%EF%BC%8C%E6%9C%89%E5%9B%BE%E6%9C%89%E7%9C%9F%E7%9B%B8%EF%BC%882%EF%BC%89/","content":"书接上回，这是公司楼下湖里的一条鳄鱼，到了中午鳄鱼头上还趴着一只晒暖儿的老龟\n \n鳄鱼只是雕塑，从侧面比较容易看出来\n \n \n中午去吃饭的时候经常走的一条小路，旁边有初生的小兔子\n \n另外还有一些其他的鸟类，见人不跑\n \n这是某天下雨之后的云\n \n从另外一个角度看起来似乎没有那么红了\n \n市政大厅（city hall是这么翻译吧？）门口的雕塑\n \n另外一个雕塑，讲的是这个地方刚通铁路的时候当地群众喜气洋洋的场景\n \n看了一场球赛，当地的达拉斯对阵新英格兰\n \n我不懂足球，但是我觉得两个队水平都不咋样\n \n当地的一个滑冰场\n \n小学生在训练\n \n滑冰场旁边的一个体育用品商店，摆着卖的子弹\n \n同样也是摆在柜台上的枪支\n \n买了一本书\n \n是Tina Fey的Bossypants\n \n摘掉外皮之后的硬壳\n \n今天暂且贴这些，照片没有了，再整理一下，明天应该会有去骑越野摩托的照片\n\n\n\n\n","tags":["图"]},{"title":"美国生活第二个月照片（1）：飙摩托，二造红河谷；乘火车，初访沃斯堡","url":"/blog/2011/06/22/%E7%BE%8E%E5%9B%BD%E7%94%9F%E6%B4%BB%E7%AC%AC%E4%BA%8C%E4%B8%AA%E6%9C%88%E7%85%A7%E7%89%87%EF%BC%881%EF%BC%89%EF%BC%9A%E9%A3%99%E6%91%A9%E6%89%98%EF%BC%8C%E4%BA%8C%E9%80%A0%E7%BA%A2%E6%B2%B3%E8%B0%B7%EF%BC%9B%E4%B9%98%E7%81%AB%E8%BD%A6%EF%BC%8C%E5%88%9D%E8%AE%BF%E6%B2%83%E6%96%AF%E5%A0%A1/","content":"再访红河谷紧接着上次去红河谷骑越野车的一周之后，再次造访此地，体验肾上腺素的急剧分泌。\n这是刚进门的地方，很多人都是开着汽车，挂着拖车，载着摩托车来的\n\n骑过了一大片坑坑洼洼的泥水地，前面就是红河，德克萨斯州和俄克拉荷马州的交界之处。\n前面转弯后完全是豁然开朗的景象。一半流水一半沙，满目葱绿满目花。（其实是没有花儿的，只是为了凑个韵脚）\n\n中途搁浅之后暂停休息\n\n把车弄出来之后满鞋的泥水\n\n初乘列车坐了一次美国的观光火车，完全不给力，要是碰见中国的春运他们肯定应付不了。两个多小时的车程，中途停车检修一个多小时。\n这是火车站所在地，葡萄藤镇\n\n站在一个不知是做什么用的台子上留个影\n\n站台\n\n火车到了\n\n下了火车就是一个观光点，下面的照片都是在那儿拍的。\n做的像靴子一样的花盆\n\n路遇一对莫西干兄弟\n\n天儿太热了，莫西干小爷决定要洗洗胳肢窝\n\n这应该就是“大洋马”吧？够粗壮\n\n还有长角大洋牛\n\n牛仔也疯狂之出函谷关\n\n路边停着的摩托车一个比一个擦得亮\n\n餐馆里墙上挂着的野牛头标本\n\n我点了个猪排吃。这是一挂牛头卖猪肉的美国馆儿。\n餐馆里的油画\n\n\n 点赞  2  \n 收藏  \n 分享 \n\n\n\n\n\n","tags":["图"]},{"title":"美国生活第二个月照片（2）","url":"/blog/2011/06/25/%E7%BE%8E%E5%9B%BD%E7%94%9F%E6%B4%BB%E7%AC%AC%E4%BA%8C%E4%B8%AA%E6%9C%88%E7%85%A7%E7%89%87%EF%BC%882%EF%BC%89/","content":"恰好赶上这个月的十一号GearBox要在Duke Nukem北美发售之前搞一个CommunityDay，就在达拉斯。作为一个八流的FPS爱好者一定要去凑凑热闹。\n去往达拉斯的路上，透过车窗随便拍了一张\n\n到达现场，室内很暗。摆了一些GearBox出品的其他游戏的海报。\n\n这次来点干货，丢大爷的玉照\n\n我才知道Borderland也是GearBox出的，进门之后有一个人偶\n\n应该是一个侏儒在里面\n\n会场里面人头攒动\n\n虽说是以Duke Nukem为主角，但是最先介绍了一个未发布的新游戏，过程中禁止照相和摄像，只拍到一张\n\n这个哥们一直在会场里转悠，大热天的，不容易，再给你个镜头\n\n下面这张是游戏体验室里面进门之后的一个牌子。内容YD，不解释\n\n下面这个是个终极神器\n\n上面正中间是机箱，两边是两个显示器。下面一排是两个水冷的散热器。还要带上3D眼镜玩。\n这是这台PC的背面\n\n现场还有Cosplay的，这个Duke长的太端正了\n\n这个女的是谁不知道，但是大腿露得多，拍之\n\n坐在Duke的椅子上留个影。拍之前想一定要装个慈主明君的样子，结果往那个位子上一坐还是有点暴虐的意思\n\n下面这张稍微好一点\n\n因为就在达拉斯，所以出会场后顺便去了肯尼迪当年遇刺的地方。\n开始没看懂这是个什么建筑，后来听说是按照坟设计的\n\n进去一看果不其然。地上还有一块碑。谁知道肯尼迪的全名竟然这么长\n\n射杀肯尼迪的子弹据说就是从这栋楼射出来的\n\n肯尼迪的车开到路面上的白叉叉的时候，第一枪响了，没打中肯尼迪，打中了旁边无辜的酱油哥\n\n然后车子继续开，到了这个白叉叉所示位置时，第二枪射出，肯尼迪身亡\n\n这是肯尼迪遇刺的那条街的全貌&#x2F;2\n\n回来的路上发现达拉斯城里有一个区域是可以汽车和马车共享机动车道的\n\n回去在这家吃的饭，好吃，分量足\n\n印象很深刻。做个义务广告。这家叫Prairie House，下面一行小字： Frontier Cooking &amp; Catering。\n\n\n\n\n","tags":["图"]},{"title":"[翻译]List为什么实现了那么多接口？","url":"/blog/2011/04/18/%5B%E7%BF%BB%E8%AF%91%5DList%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%9E%E7%8E%B0%E4%BA%86%E9%82%A3%E4%B9%88%E5%A4%9A%E6%8E%A5%E5%8F%A3%EF%BC%9F/","content":"[翻译]List为什么实现了那么多接口？\n原文地址：  http://blogs.msdn.com/b/ericlippert/archive/2011/04/04/so-many-interfaces.aspx \n原作者：  Eric Lippert\nEric Lippert是微软员工，C#编译器的主要开发人员之一。\n今天，我在  StackOverflow 上回答了一个问题。按照以往的习惯，我把它以对话体的形式整理成一篇博客。\nMSDN的文档中说List是这样声明的：\npublic class List : IList&lt;T&gt;, ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, IList, ICollection, IEnumerable\n\n那么List真的实现了这么多接口吗？\n是的。\n为什么会有这么多接口呢？\n比如说IList派生自IEnumerable，那么派生程度较高的接口的实现者就必须要实现派生程度较低的接口。接口继承就是这样的；如果你要满足派生程度较高的类型的契约的话，你就必须要满足派生程度较低的类型。\n那么就是说一个class或者一个struct必须要实现其传递闭包上所有接口定义的所有方法吗？\n非常正确。\n一个实现了派生程度较高的接口的class或者struct必须要在其基类型列表中声明它实现了那些派生程度较低的接口吗？\n不是。\n那会被禁止声明吗？\n不会。\n那么就是说派生程度较低的接口是否被声明在基类列表中是可选的了？\n是的。\n总是这样的吗？\n基本上总是这样的：\ninterface I1 &#123;&#125;\ninterface I2 : I1 &#123;&#125;\ninterface I3 : I2 &#123;&#125;\n\nI3是否显式指明它实现了I1是可选的。\nclass B : I3 &#123;&#125;\n\nI3的实现者必须实现I2和I1，但不一定要显式指明。是否指明是可选的。\nclass D : B &#123;&#125;\n\n派生类可以指明它实现了其基类的接口，但是并不是一定要这么做。\n下面有一个例子：\nclass C&lt;T&gt; where T : I3\n&#123;\n  public virtual void M&lt;U&gt;() where U : I3 &#123;&#125;\n&#125;\n\nT和U所对应的类型参数必须要实现I2和I1，但是T的U的泛型类型约束中却不一定要显式指明出来。\n分布类中是否重新声明它所实现的接口也是可选的：\npartial class E : I3 &#123;&#125;\npartial class E &#123;&#125;\n\n类型E的第二部分可以声明它实现了I3，I2或I1，但并不是一定要这么做。\n好吧，我懂了；这是可选的。那怎么会有人想去声明一个并不是一定要声明的接口呢？\n可能是因为他们认为这么做会让代码更易读更具有自说明性吧。\n有可能某个开发者会写出如下的代码：\ninterface I1 &#123;&#125;\ninterface I2 &#123;&#125;\ninterface I3 : I1, I2 &#123;&#125;\n\n然后他突然发觉I2应该继承自I1。 ** 干嘛非得要求开发者在把I2修改为继承自I1之后再回头去在I3的声明中删除掉对I1的继承呢？ **我找不到任何理由去强制开发人员删除掉冗余的声明信息。\n除了易读性和易懂性之外，在基类列表中显式声明一个接口和虽不声明但实现这个接口会有什么 **技术上 **的区别吗？\n通常没有，但是有一种情况下会有一点细微的差别。假设有个类型D，它的基类B实现了某些接口。D通过B也就自动实现了那些接口。如果你在D的基类列表中显式声明了这些接口的话，那么C#编译器将会做一次 **接口重新实现 **。其细节有些隐晦；如果你对此有兴趣的话那我建议你去仔细阅读C#4语言规范的13.4.6。基本上来说，编译器会“重新开始”并找出哪个方法实现了哪个接口。\nList的源代码中真的显式声明了那么多接口吗？\n不是的。真正的源代码是这样的：\npublic class List&lt;T&gt; : IList&lt;T&gt;, System.Collections.IList\n\n为什么虽然源代码没有显式声明所有接口，但是MSDN还是把所有的接口都列出来了呢？\n因为MSDN是文档，它应该提供尽可能多的信息。在一页文档中给出完整的信息总比让你去翻阅十页文档才能找到一个类型实现的全部接口好一些。\n为什么有些工具，比如说Reflector或者对象浏览器会把所有接口都显示出来呢？\n这些工具不知道源代码是什么样子的。它们只能从元数据入手。因为显式声明全部接口只是可选的，所以这些工具根本就无从得知源代码到底有没有显式声明所有接口。反正怎么显示都有可能是错的，那这些工具还不如就把信息罗列的全面一些。这些工具给你显示了有可能比实际情况更多的信息，而不是向你 _隐藏一些你有可能会需要的信息是因为它们想要帮助你。\n我发现IEnumerable继承自IEnumerable，但是IList并没有继承自IList，这是怎么回事呢？\n这和IEnumerable是协变的而IList不是协变的是一个原因。通过装箱，我们可以把一个整数序列当做一个object的序列来对待。但是一个可读可写的整数列表却不可以被当做一个可读可写的object的列表来对待，因为你有可能给可读可写的object列表中加入一个String。一个实现IEnumerable的类型可以很容易的满足IEnumerable，只要加一个装箱的helper方法就行了。但是实现IList的类型却不一定能够满足IList，所以IList没有继承自IList。\n那为什么List又去实现了IList呢？\n这个有点奇怪，因为除了T为object时之外，其他情况下List都不满足的IList的要求。这有可能是因为想要给升级老的C# 1.0代码的人行个方便吧，好让他们更容易的用到泛型。那些想要升级代码的人可能已经确保了只向列表中加入正确类型的对象。而且多数情况下，当你把一个IList当做参数传递出去的时候，被调用的方法也只是会去按索引访问列表，而不是去向列表中加入一些任意类型的对象。\n\n\n\n\n","tags":["C#"]},{"title":"自己动手重新实现LINQ to Objects 1 - 引言","url":"/blog/2011/08/19/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0LINQ%20to%20Objects1%20-%20%E5%BC%95%E8%A8%80/","content":"本文翻译自  Jon Skeet 的系列博文“Edulinq”。\n本篇原文地址：  http://msmvps.com/blogs/jon_skeet&#x2F;archive&#x2F;2010&#x2F;09&#x2F;03&#x2F;reimplementing-linq-to-objects-part-1-introduction.aspx\n大约一年半之前，我在  DDD 的活动日上做了一次演讲。我当时试图去重新实现LINQ toObjects，在一小时内能实现多少算多少。根据会后的反馈信息来看，我当时做得太快了…而且我还是远远没有实现完整。不过无论如何我还是觉得重新实现LINQto Objects是一个很有趣的练习，所以我觉得我应该用且行且博、不徐不疾方式来再做一遍。\n这一系列的博文都会标上  “Edulinq”的标签，你可以用这种方式过滤出这一系列博文。\n总体思路我的计划是要完整的重新实现LINQ to Objects，用每篇博客来解释一个方法（或者是一组方法）。我将会尽力把代码写的达到生产质量，但是我不会写任何XML文档注释 -既然我已经在写博客来解释了，那我就不想在代码中再重复一次了。我将在适当的情况下做一些优化，但愿会  比LINQ to Objects本身的实现做得更好 。\n我将采取一种相当简单的方式：我将为每一个LINQ方法写一些单元测试（这些单元测试中的大部分不会出现在接下来的博文中），确保.NET的LINQ实现可以通过这些单元测试。然后我会注释掉对System.Linq的引用并引入JonSkeet.Linq。这时单元测试会无法通过，我将会实现测试所针对的方法，最终让单元测试可以绿灯通过。这和通常的TDD做法不太一样，但还是蛮好用的。\n我将为每个LINQ操作符写一篇博文，其中将包含几乎所有的成品代码，不过测试代码的话我只会把有趣的部分贴出来。遇到重要的模式的时候我会把它重点标示出来，这也正是本次练习的一半意义之所在。\n在每篇博文的最后，我会附上一个下载最新代码的链接。为以后的读者考虑，我会给这些下载文件分别编号，而不是不断更新同一个文件，不过我敢说以后肯定会有对这些下载文件做修改的。\n我们的目标不是要做出一个类似于  LINQBridge 的项目来：我将使用.NET 3.5（主要是因为这样我可以直接使用扩展方法，而无需创建自定义Attribute），而且我肯定也不会去担心安装包之类的事儿。这系列博文纯粹是教育性质的：如果你逐一读完这一系列，只要运气不是太差，你会对LINQ有更深的总体的了解，尤其是对LINQ toObjects有更深刻的、细致的认识。比如说，像延迟执行一类的事，人们总是有很多误解：但是如果你看过代码的话，就能够很好的理清头绪了。\n测试我将使用  NUnit 来写单元测试（仅仅是因为我本人对它更熟悉）。很明显，我们将会很频繁的需要测试两个序列是否等价。我们将通过使用 MoreLINQ中的TestExtensions类型 来做到这一点（我把这个类型复制到了项目中了）。我将用来写作这一系列博文的上网本上只安装了C# Express2010，所以我将使用NUnit的外部GUI程序。我把项目的启动项设置为了NUnit的GUI程序…在C#Express中无法直接做此设置，但是修改项目文件也是很简单的：\n&lt;StartAction&gt;Program&lt;/StartAction&gt;&lt;StartProgram&gt;C:\\ProgramFiles\\NUnit-2.5.7.10213\\bin\\net-2.0\\nunit-x86.exe&lt;/StartProgram&gt;\n这种方法虽然有点不太正当，但是完全可用。然后把”additional command lineparameters”设置为JonSkeet.Linq.Tests.dll - 当前目录默认就是bin&#x2F;debug，这样就算做好准备了。很明显，如果你安装了ReSharper或之类的工具，并且自己运行这些单元测试的话，你将发现测试结果会被集成到Visual Studio中。\n尽管我想要写出合理的工业级质量的代码来，但是我觉得自己在真的生产环境中都未必会写那么多的单元测试。虽是如此，我还是完全有理由相信测试代码量将会超过成品代码量。因为边边角角的需要测试的情况实在太多了…而且有时重载也不少。不过请记住，我们此举的目的在于研究LINQ中有趣的特性。\n代码分布就像原版的LINQ to Object一样，我将会创建一个叫做Enumerable的静态类型…但是我会用到分部类，每个方法（包括其多个重载）占用一个代码文件。举例来说：Where方法将会在Where.cs中来实现，而它的测试代码将会写在WhereTest.cs中。\n第一次代码下载代码在这儿下载：  Linq-To-Objects-1.zip。其中暂时还没有任何的成品代码，只有四个Where方法的单元测试，主要目的在于检查NUnit可以正常工作。下一步…实现Where方法。\n\n\n\n\n","tags":["LinQ"]},{"title":"WP7 Tip: 禁用Pivot控件的切换手势","url":"/blog/2011/07/06/WP7%20Tip-%E7%A6%81%E7%94%A8Pivot%E6%8E%A7%E4%BB%B6%E7%9A%84%E5%88%87%E6%8D%A2%E6%89%8B%E5%8A%BF/","content":"原文地址：  http://www.imaginativeuniversal.com/blog/post/2010/12/09/WP7-Tip-disabling-the-Pivot-Control-swipe-gesture.aspx\n原文作者：  James Ashley\n在WP7社区中一个经常被问到的问题就是：在Pivot中放置了可以接受滑动手势的控件（比如说一个Slider）时，如何禁用Pivot控件本身内置的“用手指滑动来切换视图”的功能呢？\n对此问题，微软标准的答案是：你不应该这么做。这是“不好的做法”（Bad Practice），会造成用户体验的混淆。这种说法的前提是假设用户不会自己根据上下文去思考，而总是预期“滑动”这一手势会在任何页面中都有一样的作用。这种答案听起来还不错，而且对于Pivot中内置Slider这种例子来说也很合理。况且，我们还是可以把Slider纵向的放置在Pivot内的，那这个答案就显得更有道理了。\n话又说回来，在WP7的TextBox中，我们可以用“按住并滑动”这一手势来操作光标在文本框内的位置。那么在Pivot控件中放置TextBox算不算是造成了不好的用户体验呢？算不算是“不好的做法”（BadPractice）呢？我是不是应该想办法把TextBox也纵向放置呢？还有，ToggleSwitch控件（此控件来自于Silverlight forWindows Phone Toolkit ）又该怎么办呢？\n滑动这一手势对于手机来说是很常用的。很多针对WP7的新控件都会用到它。如果所有这些即将面世的新控件都不能放置在Pivot控件中的话，那就太可惜了。\n本文接下来讲解如何在Pivot中放置一个横向放置的Slider，并让它正常运行。\n简单来说，做成这件事的关键就是使用Pivot的IsHitTestVisible属性来禁用它的滑动手势。然后还要使用Touch类型的FrameReported事件来决定何时去重新启用Pivot的滑动手势。\n创建一个新工程，在页面中加入一个含有两个PivotItem的Pivot控件，并在其中一个PivotItem中加入一个Slider。\n现在运行的话，你会发现用手指拨动Slider时，Slider中的Thumb可以被拖动，但是同时Pivot也会移动，甚至会切换到另一个视图去。\n要解决这个问题，我们需要处理Slider的ManipulationStarted事件，在其中把Pivot的IsHitTestVisible这一属性设置为false，这样可以确保当手指在Slider上滑动时Pivot是被禁用掉的。\n当滑动手势结束之后，我们需要重新启用Pivot。这件事不能在MouseLeftButtonUp事件的Handler里面做，因为当一个容器的IsHitTestVisible被设为false时，它所包含的所有其他控件都无法触发MouseLeftButtonUp这一事件。我们可以把它放在ManipulationCompleted事件的Handler里面做，但是那样做却会导致一些不一致的行为。\n排除上面两种方案之后，我们可以使用比较底层的Touch API，当“抬起”这个手势发生在Slider上的时候，把Pivot的IsHitTestVisible属性设回为true。这个事件的Handler可以在页面的构造函数中挂上：\nTouch.FrameReported += (s, e) =&gt;\n\n\n&#123;\n\n\n    if (e.GetPrimaryTouchPoint(slider1).Action == TouchAction.Up)\n\n\n    &#123;\n\n\n        pivot1.IsHitTestVisible = true;\n\n\n    &#125;\n\n\n&#125;;\n\n下面是相关的XAML代码：\n&lt;!--ContentPanel - place additional content here--&gt;\n\n\n&lt;Grid x:Name=&quot;ContentPanel&quot; Grid.Row=&quot;1&quot; Margin=&quot;12,0,12,0&quot;&gt;\n\n\n    &lt;controls:Pivot  HorizontalAlignment=&quot;Stretch&quot; Margin=&quot;6,6,0,0&quot;\n\n\n                        Name=&quot;pivot1&quot; Title=&quot;pivot&quot;\n\n\n                        VerticalAlignment=&quot;Top&quot; Height=&quot;595&quot;&gt;\n\n\n        &lt;controls:PivotItem Header=&quot;item1&quot;&gt;\n\n\n            &lt;Grid&gt;\n\n\n                &lt;Slider  Height=&quot;107&quot; HorizontalAlignment=&quot;Left&quot;\n\n\n                            Margin=&quot;-4,109,0,0&quot; Name=&quot;slider1&quot;\n\n\n                            VerticalAlignment=&quot;Top&quot; Width=&quot;460&quot;\n\n\n                            SmallChange=&quot;1&quot;\n\n\n                            Maximum=&quot;100&quot;\n\n\n                            Value=&quot;30&quot;\n\n\n            ManipulationStarted=&quot;slider1_ManipulationStarted&quot; /&gt;\n\n\n            &lt;/Grid&gt;\n\n\n        &lt;/controls:PivotItem&gt;\n\n\n        &lt;controls:PivotItem Header=&quot;item2&quot;&gt;\n\n\n            &lt;Grid /&gt;\n\n\n        &lt;/controls:PivotItem&gt;\n\n\n    &lt;/controls:Pivot&gt;\n\n\n&lt;/Grid&gt;\n\n下面是所需的后台代码：\npublic MainPage()\n\n\n&#123;\n\n\n    InitializeComponent();\n\n\n    Touch.FrameReported += (s, e) =&gt;\n\n\n    &#123;\n\n\n        if (e.GetPrimaryTouchPoint(slider1).Action == TouchAction.Up)\n\n\n        &#123;\n\n\n            pivot1.IsHitTestVisible = true;\n\n\n        &#125;\n\n\n    &#125;;\n\n\n&#125;\n\n\n \n\n\nprivate void slider1_ManipulationStarted(object sender\n\n\n    , ManipulationStartedEventArgs e)\n\n\n&#123;\n\n\n    pivot1.IsHitTestVisible = false;\n\n\n&#125;\n\n\n 点赞  10  \n 收藏  \n 分享 \n\n\n\n\n\n","tags":["C#"]},{"title":"美国生活第一个月见闻，有图有真相（3）","url":"/blog/2011/06/02/%E7%BE%8E%E5%9B%BD%E7%94%9F%E6%B4%BB%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9C%88%E8%A7%81%E9%97%BB%EF%BC%8C%E6%9C%89%E5%9B%BE%E6%9C%89%E7%9C%9F%E7%9B%B8%EF%BC%883%EF%BC%89/","content":"我只带了手机，下面的照片是同事用相机照的。\n这是邻居家的前门\n \n这是我们住的后院\n \n这是小区里的某户大房子，车库都带三开门儿的\n \n人工喷泉后面这家真爽\n \n这是小区里面的路，路旁很绿\n \n接下来这家才是真的夸张，我一开始都觉得这不是住人用的\n \n这个是我所在地的市政厅的大门口\n \n下面是装好了车准备去骑越野摩托了\n \n下面这张，请忽视右侧打酱油的楼主，左边是装在车上的摩托车和四轮车\n \n去往河谷的路很长，两边基本都是这么绿\n \n路旁还有一些风力发电机\n \n终于到了地方了，装备整齐，上车准备开起走\n \n先来个稳步前进\n \n再来个龟速过坡\n \n用力扭转方向盘\n \n屁股后面一溜烟\n \n同志们好，同志们辛苦了\n \n勇过泥水沟\n \n再次勇过泥水沟\n \n最后整的满鞋满裤腿都是泥，翻身下车\n \n\n\n\n\n","tags":["图"]},{"title":"自己动手重新实现LINQ to Objects 2 - Where","url":"/blog/2011/08/21/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0LINQ%20to%20Objects2%20-%20Where/","content":"本文翻译自   Jon Skeet   的系列博文”Edulinq”。\n本篇原文地址：\nhttp://msmvps.com/blogs/jon_skeet&#x2F;archive&#x2F;2010&#x2F;09&#x2F;03&#x2F;reimplementing-linq-to-objects-part-2-quot-where-quot.aspx\n提示：本篇文章较长。虽然我选择了一个比较简单的操作符来在本文中实现，不过我们还是会遇到一些特例以及一些与  LINQ相关的原则。因为我还在试着找出表现本文内容的最佳方式，所以本文的排版方式暂时是实验性的。\n我们将要实现“  Where  ”子句（也可以说是方法或操作符）。  Where  在总体上来说比较容易理解，但是涉及到延迟执行和流式处理的部分会有些麻烦。Where  方法是泛型的，不过只有一个类型参数（在我看来这很重要，因为我觉得一个方法的泛型参数越多就越令人难以理解）。哦，对了，我们将在本文开始涉及查询表达式，这算是本文的一点额外猛料。  \nWhere  是什么？Where  有两个重载：  \npublic static IEnumerable &lt; TSource &gt; Where(this IEnumerable &lt; TSource &gt; source, Func &lt; TSource, bool &gt; predicate)public static IEnumerable &lt; TSource &gt; Where(this IEnumerable &lt; TSource &gt; source, Func &lt; TSource, int, bool &gt; predicate)\n\n在开始讲述  Where  方法到底做什么之前，我先指出几点  LINQ  操作符的常识，这些常识适用于几乎所有的  LINQ  操作符：  \n\nLINQ  操作符都是   扩展方法   -  扩展方法要定义在顶层的，非嵌套的静态类型中而且其第一个参数要带有“  this”修饰符。简单来说，扩展方法可以被其第一个参数的实例调用，就好像它是该参数类型的实例方法一样。\n\nLINQ  操作符是   泛型方法   -  我们要讲的  Where  操作符只有一个叫做  TSource的类型参数，该类型参数指明了要处理的序列的类型。比如说，如果要处理一个  string  的序列，  TSource  就是  string  。\n\nLINQ  操作符接受  Func&lt;…&gt; 这一族的泛型委托作为参数，通常以   lamdba  表达式的方式提供，不过委托的其他表现形式也都可以作为其参数。\n\nLINQ  操作符处理序列。序列以   IEnumerable  的形式出现，  IEnumerable 中含有一个类型为   IEnumerator 的迭代器。\n\n\n我希望本文的读者对以上提及的概念有所了解，所以我就不再深入解释了。如果您对上述内容不够熟悉的话，请在继续读下去之前先去做些功课，否则接下来的内容将让您很难理解。\nWhere  的目的是去过滤一个序列。它接受一个输入序列及一个 谓词 _作为参数，返回一个结果序列。输出序列和输入序列的元素类型相同（也就是说如果输入是一个  string  的序列，输出也会是个  string的序列），输出序列中只会包含输入序列中符合谓词条件的元素。（输入序列中的元素会依次被谓词检验。只有谓词返回  true时，一个元素才会被包含在输出序列中。）\n下面是关于  Where  的几个重要的细节：  \n\nWhere  不会对输入序列做任何修改：它和   List.RemoveAll  之类的方法不一样。\n\nWhere  是延迟执行的  -  在你开始读取输出序列中的元素之前，  Where  不会去输入序列中取元素。\n\n不过也有一点不是延迟执行的，它会立即检查参数是否为  null 。\n\n它以流式处理结果：它每次只处理一个结果元素，它把结果元素  yield  返回而且不会保留其引用。这意味着你可以把  Where应用在一个无限长的序列上（比如说一个随机数的序列）。\n\n你每在输出序列上迭代一次，  Where  方法就会在输入序列上迭代一次。\n\n如果输出序列的迭代器被  Dispose  掉的话，对应的输入序列的迭代器也会被  Dispose  掉。（  C#   中的  foreach语句会用  try&#x2F;finally  来保障迭代器总是会被  Dispose  调，无论循环是因何种原因结束的。）\n\n\n以上几点之中的有些对其它的操作符也适用。\nWhere  的一个重载形式会接受一个  Func&lt;TSource, int, bool&gt; 作为参数，此重载让谓词中不仅可以访问元素值，还可以访问元素的index  。  Index  总是从  0  开始并且每次递增  1  ，无论之前谓词的结果如何。  \n我们要测试些什么？理想情况下，我们要测试上述所有的东西。但是不幸的是，流式处理和序列被迭代多少次的细节测试起来很是麻烦。考虑到我们还要实现那么多的东西，我们以后再去测试那些。\n我们来看看一些测试。首先，看一个“正向”测试  -  有一个整数数组，我们用一个  lambda  表达式来使得输出结果中仅包含小于  4的元素。（“过滤”这个词无处不在，这真是很不幸。“过滤掉”这个说法比“包含”要好理解得多，但是实际上谓词就是以“正向”的方式来处理的。）  \n[Test]public void SimpleFiltering()&#123; int[] source = &#123;  1,  3,  4,  2,  8,  1 &#125;; var result = source.Where(x =&gt; x &lt; 4); result.AssertSequenceEqual(1, 3, 2, 1);&#125;\n\n虽然  NUnit  中已经有了  CollectionAssert  ，我还是在用  MoreLINQ  中的  TestExtension。有三个原因让我觉得  MoreLINQ  的扩展方法更好用：\n\n扩展方法有助于减轻代码的混乱程度。\n\n可以使用变长数组来表示期望的输出，这样更易于表达测试的意图。\n\n断言失败的提示信息更清楚。\n\n\nAssertSequenceEqual 所做的事情看名字就可以猜出来，它检查输出序列（通常就是你调用  AssertSequenceEqual方法时所使用的那个变量）和期望的序列（通常就是作为参数传入的变长数组）是否匹配。\n目前为止进行的还不错。现在来看看参数校验吧：  \n[Test]public void NullSourceThrowsNullArgumentException() &#123; IEnumerable &lt; int &gt; source = null; Assert.Throws &lt; ArgumentNullException &gt; (() =&gt; source.Where(x =&gt; x &gt; 5));&#125;[Test]public void NullPredicateThrowsNullArgumentException() &#123; int[] source = &#123;  1,  3,  7,  9,  10 &#125;; Func &lt; int, bool &gt; predicate = null; Assert.Throws &lt; ArgumentNullException &gt; (() =&gt; source.Where(predicate));&#125;  \n\n我就不再费劲去检查  ArgumentNullException里面的参数名字了，但是我要测试参数是不是立即被校验的，这一点很重要的。我没有迭代输出结果，所以如果参数校验是延迟执行的，这两个测试将不能通过。\n最后还有一个有趣的测试也是与延迟执行有关的。我们将用一个叫做  ThrowingEnumerable  的  helper类来做这个测试，这个类是一个序列，你一旦迭代它，它就会抛出一个  InvalidOperationException  。这个测试是想要测试两点：  \n\n仅仅调用  Where  不会开始迭代输入序列。\n\n调用  GetEnumerator()  来获取迭代器，然后再调用迭代器的  MoveNext()  的话，就开始迭代了，这就会导致一个异常被抛出。\n\n\n对其它的操作符我们也需要做类似的测试，所以我在  ThrowingEnumerable  里写了一个  helper  方法：  \ninternal static void AssertDeferred &lt; T &gt; (Func &lt; IEnumerable &lt; int &gt; , IEnumerable &lt; T &gt;&gt; deferredFunction) &#123; ThrowingEnumerable source = new ThrowingEnumerable(); var result = deferredFunction(source); using(var iterator = result.GetEnumerator()) &#123;  Assert.Throws &lt; InvalidOperationException &gt; (() =&gt; iterator.MoveNext()); &#125;&#125;  \n\n现在我们就可以测试  Where  是不是延迟执行的了：  \n[Test]public  void  ExecutionIsDeferred()&#123;    ThrowingEnumerable.AssertDeferred(src =&gt; src.Where(x =&gt; x &gt; 0  ));&#125;  \n\n以上所示的都是对  Where  的简单重载的测试，也就是那个谓词只能访问元素值而不能访问元素  index  的重载。能够访问  index的那个重载的测试与上述测试非常类似。  \n来动手实现吧！原版的  LINQ to Objects  能够通过所有这些测试，现在来实现我们自己的代码吧。我们将会用到   迭代器代码块 ，它在  C#  2  中被引入来简化IEnumerable 的实现。如果你想了解更多的背景知识的话，我有   几篇  文章你可以去读一下  …  或者读  C#  in Depth  （第一或第二版都可以）的第六章也可以。迭代器代码块让我们可以很简单的实现延迟执行  …不过它也是一把双刃剑，我们马上就会体会到了。\nWhere  的核心部分是这样的：  \n// Naive implementationpublic static IEnumerable &lt; TSource &gt; Where &lt; TSource &gt; (this IEnumerable &lt; TSource &gt; source, Func &lt; TSource, bool &gt; predicate) &#123; foreach(TSource item in source) &#123;  if (predicate(item)) &#123;   yield   return item;  &#125; &#125;&#125;  \n\n很简单，是吧？用迭代器代码块写出来的代码就和用自然语言描述起来差不多：迭代输入序列中的每一个元素，如果谓词在一个元素上返回  true的话，这个元素就可以被  yield  （也就是包含）到输出序列中去。\n诸位请看，有一些单元测试已经可以通过了。现在我们只需要参数校验了。参数校验很简单的，对吧？我们来试试看：  \n// Naive validation - broken!public static IEnumerable &lt; TSource &gt; Where &lt; TSource &gt; (this IEnumerable &lt; TSource &gt; source, Func &lt; TSource, bool &gt; predicate)&#123; if (source == null) &#123;  throw new ArgumentNullException(&quot;source&quot;); &#125; if (predicate == null) &#123;  throw new ArgumentNullException(&quot;predicate&quot;); &#125; foreach(TSource item in source) &#123;  if (predicate(item)) &#123;   yield   return item;  &#125; &#125;&#125;  \n\n呃。测试亮起了红灯，通不过，在“  throw  ”的那一句上设断点也没用  …  断点根本就执行不到。怎么回事儿？\n我之前已经给出过很明显的提示了。导致问题的就是延迟执行。在返回值被迭代之前， 我们的代码不会被执行。我们的代码故意的 没有 _去迭代返回值，所以参数校验也不会被执行。\n我们遇到了一个  C#   设计上的缺陷。  C#   中的迭代器代码块不能很好的对“立即执行”（通常用来做参数校验）和“延迟执行”作出分离。我们必须得把我们上述的实现分为两个方法：第一个方法做参数校验，第二个方法含有迭代器代码块，用来实现延迟执行，第一个方法会调用第二个方法：  \npublic static IEnumerable &lt; TSource &gt; Where &lt; TSource &gt; (this IEnumerable &lt; TSource &gt; source, Func &lt; TSource, bool &gt; predicate) &#123; if (source == null) &#123;  throw new ArgumentNullException(&quot;source&quot;); &#125; if (predicate == null) &#123;  throw new ArgumentNullException(&quot;predicate&quot;); &#125; return WhereImpl(source, predicate);&#125;private static IEnumerable &lt; TSource &gt; WhereImpl &lt; TSource &gt; ( this IEnumerable &lt; TSource &gt; source, Func &lt; TSource, bool &gt; predicate) &#123; foreach(TSource item in source) &#123;  if (predicate(item)) &#123;   yield   return item;  &#125; &#125;&#125;\n\n这样的代码很丑陋，但是能用：所有的针对于  Where  的简单重载（不含有  index  ）的测试都可以通过了。有了现在的基础，要实现  Where的含有  index  的重载也就很简单了：  \npublic static IEnumerable &lt; TSource &gt; Where &lt; TSource &gt; ( this IEnumerable &lt; TSource &gt; source, Func &lt; T, int, bool &gt; predicate) &#123; if (source == null) &#123;  throw new ArgumentNullException(&quot;source&quot;); &#125; if (predicate == null) &#123;  throw new ArgumentNullException(&quot;predicate&quot;); &#125; return WhereImpl(source, predicate);&#125;private static IEnumerable &lt; TSource &gt; WhereImpl &lt; TSource &gt; ( this IEnumerable &lt; TSource &gt; source, Func &lt; TSource, int, bool &gt; predicate) &#123; int index = 0; foreach(TSource item in source) &#123;  if (predicate(item, index)) &#123;   yield   return item;  &#125;  index++; &#125;&#125;  \n\n现在所有单元测试都通过了，我们的实现完成了。不过等一下  …  我们还没有无所不用其极的使用  Where  呢。  \n查询表达式到目前为止，我们都是在直接的调用  Where  方法（尽管是以扩展方法的形式出现的），不过  LINQ  可是还给我们提供了查询表达式的。下面是“SimpleFiltering  ”那个测试的重写版本，其中用到了查询表达式：  \n[Test]public void QueryExpressionSimpleFiltering() &#123; int[] source = &#123;  1,  3,  4,  2,  8,  1 &#125;; var result = from x in source where x &lt; 4 select x; result.AssertSequenceEqual(1, 3, 2, 1);&#125;\n\n（本博文中出现的方法名和下载到的代码中的不同，因为方法名中含有博客服务器的敏感词。呃。）\n以上代码会和我们先前的测试产出 完全相同的  IL 代码。编译器会把这种查询表达式的形式转译成调用方法的形式，并把用  lambda表达式写出来的条件判断（  x &lt; 4  ）转换成一个委托。你可能会感到有点惊讶，因为我们还没有实现  Select  方法呢  …不过我们现在用到的  select投影操作实际上是不做任何事情的；我们并没有做任何真正的投影变换。这种情况下，只要查询表达式中含有任意其他的查询（上述代码中，这个查询就是  Where）在内，编译器就会把“  select  ”从句忽略掉，这样的话我们没有实现  select  也就无关紧要了。如果你把“  select x  ”改写成“select x * 2  ”的话，将无法通过编译，因为我们的  LINQ  实现中只有  Where  。\n查询表达式是基于上述这种模式的，这一强大的特性使得它极具灵活性。举例来说，  LINQ to Rx就是基于这一点才能做到仅需实现对其应用场景有意义的操作符的。与此类似，  C#   编译器在处理查询表达式的时候并不需要知晓任何与IEnumerable 有关的东西，也正是如此，像  IObservable 这样的完全与  IEnumerable无关的接口也可以得以应用。  \n我们学到了什么？本文中有不少不太好理解的东西，其中与我们的实现和  LINQ  核心原则有关的是：  \n\nLINQ to Objects  是基于扩展方法，委托还有  IEnumetable 的。\n\n条件允许的话，  LINQ  操作符会尽量利用延迟执行和流式处理。\n\nLINQ  操作符不会改变输入序列，而是会返回一个包含符合条件的元素的新序列。\n\n查询表达式基于编译器对一些模式的解释；你要用到的查询表达式和哪些模式相关，你就只需要实现那些模式就可以了，无需多劳。\n\n迭代器代码块很适合用来实现延迟执行  …\n\n…  但是它也使得需要立即执行的参数校验变得很难搞。\n\n\n代码下载 Linq-To-Objects-2.zip  \n很多人要求给本项目建一个源码管理服务器，这件事正在进行中；大概下一篇博文之前就可以完成。\n\n\n\n\n","tags":["LinQ"]},{"title":"自己动手重新实现LINQ to Objects 3 - Select","url":"/blog/2011/08/22/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0LINQ%20to%20Objects3%20-%20Select/","content":"本文翻译自   Jon Skeet   的系列博文”Edulinq”。\n本篇原文地址：\nhttp://msmvps.com/blogs/jon_skeet&#x2F;archive&#x2F;2010&#x2F;12&#x2F;23&#x2F;reimplementing-linq-to-objects-part-3-quot-select-quot-and-a-rename.aspx\n距离上次写完本系列博文的   第一篇   和   第二篇 已经有一段日子了，希望接下来的进度会快一些。\n现在我给本项目在   Google Code  上建立了源码管理  ，现在就无需每篇博文包含一个  zip  文件了。创建项目时，我给它取了个显而易见的名字，叫做  Edulinq  。我修改了代码中的命名空间，而且现在 这一系列博文的  tag 也修改为了Edulinq  了。好了，闲话少叙  …  我们来开始重新实现  LINQ  吧，这次要实现  Select  操作符。  \nSelect  操作符是什么？和  Where  类似，   Select  也有两个重载   ：\npublic static IEnumerable &lt; TResult &gt; Select &lt; TSource, TResult &gt; (this IEnumerable &lt; TSource &gt; source, Func &lt; TSource, TResult &gt; selector)public static IEnumerable &lt; TResult &gt; Select &lt; TSource, TResult &gt; (this IEnumerable &lt; TSource &gt; source, Func &lt; TSource, int, TResult &gt; selector)\n\n其第二个重载让投影操作可以访问到序列元素的  index  。\n先说简单的东西：  Select  方法把一个序列 投影成为另一个序列：“  selector”这个作为参数的委托会被依次应用到输入序列中的每一个元素上，并每次  yield  返回一个输出元素。  Select  的行为和  Where很类似（实在是太类似了，以至于下面一段文字都是从上一篇文章中复制过来的，只是稍加修改）：  \n\nSelect  不会对输入序列做任何修改。\n\nSelect  是延迟执行的  -  在你开始读取输出序列中的元素之前，  Select  不会去输入序列中取元素。\n\n不过也有一点不是延迟执行的，它会立即检查参数是否为  null 。\n\n它以流式处理结果：它每次只处理一个结果元素。\n\n你每在输出序列上迭代一次，  Select  方法就会在输入序列上迭代一次，这二者是严格对应的。\n\n每次  yield  返回结果值的时候，“  selector  ”这个委托就会被调用一次。\n\n如果输出序列的迭代器被  Dispose  掉的话，对应的输入序列的迭代器也会被  Dispose  掉。\n\n\n我们要测试什么？对  Select  的测试和对  Where  的测试也是很类似的，之前我们是针对  Where  的过滤功能来做测试，现在我们是针对  Select的投影功能来做测试。\n有几个测试比较有趣。首先，你会发现  Select  方法是泛型的，而且有两个泛型参数，分别是  TSource  和  TResult。虽然这两个参数的含义不言自明，不过还是得写一个单元测试来测一下  TSource  和  TResult  分别为不同类型的情况，比如说把  int转换成  string  的情况。  \n[Test]public void SimpleProjectionToDifferentType() &#123; int[] source = &#123;  1,  5,  2 &#125;; var result = source.Select(x =&gt; x.ToString()); result.AssertSequenceEqual(&quot;1&quot;, &quot;5&quot;, &quot;2&quot;);&#125;  \n\n然后我们看另一个测试，这个测试给我们展示了使用  LINQ  有可能会遇到的奇怪的副作用。其实我们本可以在  Where的单元测试中做这个例子的，不过针对  Select  做起来更清晰一些：  \n[Test]public void SideEffectsInProjection() &#123; int[] source = new int[3];// Actual values won&#x27;t be relevant _ int count = 0; var query = source.Select(x =&gt; count++); query.AssertSequenceEqual(0, 1, 2); query.AssertSequenceEqual(3, 4, 5); count = 10; query.AssertSequenceEqual(10, 11, 12);&#125;  \n\n请注意我们只调用了  Select  一次，但是对  Select  方法返回值的多次迭代结果都不同，这是因为“  count”这个变量的值被保留住了并在每一次的投影过程中都会被修改。希望您不要写出这种代码。\n再然后，我们可以写一些同时包含“  select  ”和“  where  ”的查询表达式：  \n[Test]public void WhereAndSelect() &#123; int[] source = &#123;  1,  3,  4,  2,  8,  1 &#125;; var result = from x in source where x &lt; 4 select x * 2; result.AssertSequenceEqual(2, 6, 4, 2);&#125;\n\n如果你用过  LINQ to Objects  的话，那么上面这些东西对你来说应该是很熟悉很亲切的，没有什么令人惊讶的。  \n来动手实现吧！我们实现  Select  的方式和实现  Where  的方式差不多。我只是把  Where的实现的代码复制过来，稍加修改，这二者真的就是如此的相似。详细说来就是：  \n\n我们利用迭代器代码块来轻松实现序列的返回。\n\n要用到迭代器代码块就意味着必须要把参数校验的代码和核心实现代码分离开。（我写完上一篇博文之后了解到  VB11中将会有匿名迭代器，匿名迭代器可以解决这个问题。哎。羡慕  VB  用户的感觉怪怪的，但是我会学着接受现实的。）\n\n我们在迭代器代码块中使用  foreach  ，这样就可以保证在输出序列的迭代器被  Dispose时或者输入序列的元素被迭代完时，输入序列的迭代器可以被妥当的  Dispose  掉。\n\n\n由于  Select  的实现和  Where  的实现实在是太类似了，下面我直接给出代码。  Select  方法的重载（含有  index的那一个）的实现代码就不展示了，因为它和下面的代码差别实在太小了。  \npublic static IEnumerable &lt; TResult &gt; Select &lt; TSource, TResult &gt; (this IEnumerable &lt; TSource &gt; source, Func &lt; TSource, TResult &gt; selector)&#123; if (source == null) &#123;  throw new ArgumentNullException(&quot;source&quot;); &#125; if (selector == null) &#123;  throw new ArgumentNullException(&quot;selector&quot;); &#125; return SelectImpl(source, selector);&#125;private static IEnumerable &lt; TResult &gt; SelectImpl &lt; TSource, TResult &gt; (this IEnumerable &lt; TSource &gt; source, Func &lt; TSource, TResult &gt; selector) &#123; foreach(TSource item in source) &#123;  yield  return selector(item); &#125;&#125;\n\n很简单，对吧？真正用来实现功能的代码还没有参数校验的代码长呢。  \n结论虽然说我不想让我的读者感到无聊（你们中的有些人 可能会感到惊讶），但是我还是得承认本篇文章颇有些无趣。我重复的强调“和  Where很类似”，强调了那么多次，搞得都有点乏味了，不过这样才足以说明实现  Select  并没有你可能想象的那么复杂。\n下次（我希望就在几天之内）我会写点不一样的东西。我还不确定下次要写哪个方法，待选的方法还有很多  …\n\n\n\n\n","tags":["LinQ"]},{"title":"自己动手重新实现LINQ to Objects 4 - Range","url":"/blog/2011/08/22/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0LINQ%20to%20Objects4%20-%20Range/","content":"本文翻译自   Jon Skeet   的系列博文”Edulinq”。\n本篇原文地址：\nhttp://msmvps.com/blogs/jon_skeet&#x2F;archive&#x2F;2010&#x2F;12&#x2F;24&#x2F;reimplementing-linq-to-objects-part-4-range.aspx\n本篇博文较短，接下来的几篇估计也会比较短。我觉得只有 很相似的几个  LINQ  操作符才适合放到同一篇博文里面，比如  Count  和LongCount  就比较适合放在一起讲。不过我也要采纳读者的意见，如果你喜欢“肥胖”一点的博文的话，请留言说明。\n本文将要讲解  Range  操作符。  \nRange  操作符是什么？ Range   只有一种方法签名：\npublic  static  IEnumerable&lt; int  &gt; Range(int  start, int  count)\n\n和  LINQ  中的其他操作符不同，  Range  不是扩展方法，它就是一个普通的静态方法。  Range  返回一个可枚举的对象，该对象会yield  返回“  count  ”个整数，返回的整数序列从“  start  ”开始，逐次加一。举例来说，Enumerable.Range(6,3)  会返回  6  ，  7  ，  8  。\n由于  Range  不会接受输入序列，所以也就无所谓对输入的流式处理和缓冲了。不过它有以下几点行为：  \n\n参数的校验需要立即执行；参数  count  不可以为负数，也不可以让输出值中包含超出  Int32  范围的值。\n\n输出值是被延迟输出的。  Range  的执行效率应该比创建并返回一个“  count  ”长度的数组来得更高。\n\n\n我们要如何测试呢？要测试普通的静态方法就给我们带来了一个新的挑战，因为我们要在原版的  LINQ  实现和  Edulinq的实现之间做切换。这是由我所使用的命名空间所带来的缺陷，单元测试写在  Edulinq.Tests  这个命名空间内，我们的实现写在  Edulinq这个命名空间中。在编译器寻找一个类型的时候，父级命名空间会比其他的通过  using  引入的命名空间拥有更高的优先级，即使是使用  using来显式引入一个类型的别名时也是如此。\n我选择的解决方式是用一个  using  指令来引入一个叫做  RangeClass  的别名。  using  指令要么指向System.Linq.Enumerable  要么指向  Edulinq.Enumerable  。测试代码中用到  Range  时都是这样写：RangeClass.Range  。为此我创建了两个项目配置，其中一个定义了叫做  NORMAL_LINQ的预处理符号，另一个则没有定义任何预处理符号，这样就可以在两种  LINQ  实现之间做切换了。  RangeTest.cs  中会包含如下的代码：  \n#if NORMAL_LINQusing  RangeClass =  System  .Linq.Enumerable;#elseusing  RangeClass = Edulinq.Enumerable;#endif  \n\n当然了，也有别的办法可以替代以上的方式：  \n\n可以把单元测试代码换到另外一个命名空间中去。\n\n也可以让项目的引用项依赖于不同的项目配置，用于测试原版  LINQ  的项目配置不包含对  Edulinq  的引用，而用于测试  Edulinq的项目配置则不引用  System.Core  。这样就可以在  NORMAL_LINQ  的预处理符号下直接使用  using System.Linq，并直接使用  Enumerable.Range  。测试默认的  LINQ  实现时亦是如此。\n\n\n我喜欢上面提到的第二种方式，但是那需要手动修改测试工程的工程文件，因为  Visual Studio没有提供任何根据不同条件引用不同引用项的功能。我以后或许会用到这个方法，欢迎提供建议。  \n我们要测试什么呢？Range  需要的测试并不多，我只有八个方面需要测试，而且都不怎么很特别：  \n\n一个简单有效的  Range  操作应该可以通过  AssertSequenceEqual 的测试。\n\n起始值应该可以是负数。\n\nRange(Int32.MinValue, 0)  会返回一个空序列。\n\nRange(Int32.MaxValue, 1)  会返回仅包含  Int32.MaxValue  的序列。\n\ncount  不可以为负数。\n\ncount  可以为  0  。\n\nstart+count-1  不可以超过  Int32.MaxValue  （所以  Range(Int32.MaxValue, 2)应该是一个无效操作）。\n\nstart+count-1  可以等于  Int32.MaxValue  （所以  Range(Int32.MaxValue, 1)应该是一个有效操作）。\n\n\n最后两项要分别被几组不同的数据测试，这几组数据是：大的  start  值和小的  count  值，小的  start  值和大的  count值，还有一组是  start  和  count  都相当大。\n请注意我没有做针对于惰性求值的测试，我确实可以测一下返回值是否实现了任何其他的集合接口，不过那会显得有点奇怪。不过我们有一些测试中用到的  count值非常大，给这么大的集合分配内存几乎肯定要失败。  \n开始实现吧！你肯定早就猜到了，我们将会用分隔开的两个方法来实现  Range  。一个  public  的方法用来立即执行参数校验，还有一个  private的方法用来做核心部分的工作，其中包含迭代器代码块。\n由于一开始就确定了参数不会超过  Int32  的上下限，我们在实现的主体部分就可以随意一点了。  \npublic static IEnumerable &lt; int &gt; Range(int start, int count) &#123; if (count &lt; 0) &#123;  throw new ArgumentOutOfRangeException(&quot;count&quot;); &#125;// Convert everything to long to avoid overflows. There are other ways of checking _// for overflow, but this way make the code correct in the most obvious way._ if ((long) start + (long) count - 1 L &gt; int.MaxValue) &#123;  throw new ArgumentOutOfRangeException(&quot;count&quot;); &#125; return RangeImpl(start, count);&#125;private static IEnumerable &lt; int &gt; RangeImpl(int start, int count) &#123; for (int i = 0; i &lt; count; i++) &#123;  yield  return start + i; &#125;&#125;  \n\n有几点需要说明：  \n\n第二段参数校验的代码检查的是“  start  ”和“  count  ”这二者的合法性，而不是仅仅检查“  count  ”。如果能给ArgumentOutOfRangeException  （或者是  ArgumentException）传入多个参数名就好了，这样就能在异常信息中指出多个参数不合法。话虽这么说，  .NET Framework  的实现也是只会指出“  count”不合法。\n\n第二段参数校验的代码还可以有很多其他的写法，把所有的操作数都转换成  long并不是我们仅有的选择。不过我觉得我选择的这个方法是最简单的，而且也是正确的。采取这种方式，我无须考虑多种情况并保证每一种都是正确的。使用  Int64可以确保不会有溢出，也无需去考虑  checked  或  unchecked  。\n\nPrivate  方法中的循环也有其他的实现方式，不过我认为我用的这个是最简单的。一种很容易想到的替代方案就是用两个变量，一个是已经返回过的值的个数，另一个是下一个要返回的值，每次循环都把这两个值各自加一。还有一种比较复杂的替代方案是只使用一个循环变量，但是那样的话你就不能写“  value &lt;start + count  ”了，因为最后一个返回值有可能是  Int32.MaxValue  ，你也不能写“  value &lt;&#x3D; start +count - 1  ”了，因为传入的参数有可能是  Int32.MaxValue  和  0。我不想在代码中处理这么多种临界情况，所以我选择了一个简单正确的方式。如果你真的非常非常注重  Range  的效率的话，你应该去调查一下其他的可行方案。\n\n\n写本文之前，我没有给  Range(Int32.MaxValue, 1)  和  Range(Int32.MinValue, 0)写出好的单元测试。不过写了上面的那段关于替代性方案的话之后，我找到了合适的测试用例。寻找替代方案可以帮助我想到更多的测试用例，这事儿多有趣。  \n结论实现  Range  有助于测试其他的操作符，比如说  Count  。现在既然我已经实现了一个非扩展方法的  LINQ  操作符了，那无妨把另外两个（Empty  和  Repeat  ）也实现了。其实我已经实现了“  Empty  ”了，希望今天就能把它整理成文。  Repeat也不需要多久就能完工，然后我们就可以开始着手于  Count  和  LongCount  了。\n本文中的代码很好的诠释了这种情况：有时，写“傻”一点的代码会比写短一点，快一点的代码更好，因为它更易于读懂。无疑，以后博文中我还会写更多的“傻”代码的。\n\n\n\n\n","tags":["LinQ"]},{"title":"自己动手重新实现LINQ to Objects 6 - Repeat","url":"/blog/2011/08/24/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0LINQ%20to%20Objects6%20-%20Repeat/","content":"本文翻译自   Jon Skeet   的系列博文”Edulinq”。\n本篇原文地址：\nhttp://msmvps.com/blogs/jon_skeet&#x2F;archive&#x2F;2010&#x2F;12&#x2F;24&#x2F;reimplementing-linq-to-objects-part-6-repeat.aspx本文的主题是个无关紧要的方法，  Repeat  。关于  Repeat  ，值得讨论的内容比  Empty还要少。写这篇博文只是为了保证这个系列的完整性。\nRepeat  是什么？  Repeat  是一个静态的泛型方法，不是扩展方法，它只有一个签名形式：\npublic  static  IEnumerable&lt;TResult&gt; Repeat&lt;TResult&gt;(TResult element,int  count)\n它返回一个序列，该序列中反复的包含“  count  ”个指定的元素，。  Repeat  只需要一个参数校验：检验“  count  ”不是负数。\n我们要测试什么呢？ 需要测试的东西真的不多。我只想到了四个场景：\n\n一个简单的测试，把一个字符串重复三次\n\n一个空序列（把一个元素重复  0  次）\n\n一个多次包含  null的序列（仅仅是为了证明“  element  ”可以为  null）\n\n用负数作为“  count  ”来证明参数校验会被执行，而且是立即执行的\n\n\n以上这几点恐怕都不怎么令人兴起。\n来动手实现吧！在实现的时候我们唯一有可能做错的事就是把参数校验的代码和迭代器代码块写到一起。不过我们已经多次的做过“分割实现”了，所以我们肯定不会犯这个错误的。下面的代码就是乏善可陈的  Repeat  方法的全部了：\npublic static IEnumerable &lt; TResult &gt; Repeat &lt; TResult &gt; (TResult element, int count) &#123; if (count &lt; 0) &#123;  throw new ArgumentOutOfRangeException(&quot;count&quot;); &#125; return RepeatImpl(element, count);&#125;private static IEnumerable &lt; TResult &gt; RepeatImpl &lt; TResult &gt; (TResult element, int count) &#123; for (int i = 0; i &lt; count; i++) &#123;  yield  return element; &#125;&#125;\n这就是今天的全部内容了。其中值得指出的部分就是  …  没有什么值得指出的。\n结论其实没有什么结论可写。下一次我们讲  Count  和  LongCount  ，那里面倒是有些有趣的东西可以细说。\n\n\n\n\n","tags":["LinQ"]},{"title":"浅析延迟执行--实现，优点，陷阱以及题外话","url":"/blog/2011/08/31/%E6%B5%85%E6%9E%90%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C--%E5%AE%9E%E7%8E%B0%EF%BC%8C%E4%BC%98%E7%82%B9%EF%BC%8C%E9%99%B7%E9%98%B1%E4%BB%A5%E5%8F%8A%E9%A2%98%E5%A4%96%E8%AF%9D/","content":"上周五在公司内部做了一个小型的sharing，讨论了一些与延迟执行有关的东西。现在把ppt和代码分享出来。如有谬误，请不吝指教 :)\n代码在这儿： http://codeformyblog.codeplex.com/SourceControl/changeset/view/62764#1095173 \nppt在这儿：\n Deferred execution  View more  presentations  from  cuipengfei\n\n\n\n\n","tags":["延迟执行"]},{"title":"自己动手重新实现LINQ to Objects 8 - Concat","url":"/blog/2011/09/14/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0LINQ%20to%20Objects8%20-%20Concat/","content":"本文翻译自   Jon Skeet   的系列博文”Edulinq”。\n本篇原文地址：\nhttp://msmvps.com/blogs/jon_skeet&#x2F;archive&#x2F;2010&#x2F;12&#x2F;27&#x2F;reimplementing-linq-to-objects-part-8-concat.aspx\n上文讲的  Count  和  LongCount  返回的是数值类型，本文我们讲的  Concat  返回的是一个序列。  \nConcat  是什么？    Concat  只有一种签名形式，这让它使用起来很简单：\npublic  static  IEnumerable&lt;TSource&gt; Concat&lt;TSource&gt;(this  IEnumerable&lt;TSource&gt; first, IEnumerable&lt;TSource&gt; second)\nConcat  的返回值依次包含了两个序列中的元素，也就是说把两个序列串联起来了。\n我有时会觉得  .NET  没有提供  Prepend&#x2F;Append  这样的方法是个遗憾，这两个方法应该可以和  Concat做类似的事情，只不过它们把一个序列和一个单个的元素串联起来。如果要做一个填充着国家名和一个“  None”值的下拉列表的话，这两个方法是很有用的。当然，向  Concat中传入一个单元素的数组也可以达到同样的目的，但是我个人认为用特定的方法名做特定的事会让代码的可读性更高。   MoreLINQ 中的   Concat  方法   可以做这件事，不过  Edulinq的目的只是要实现  LINQ to Objects  中已有的方法。\n和往常一样，我们列出  Concat  的行为：\n\n参数校验需要立即执行：两个参数都不允许为  null\n\n返回值是延迟执行的：当  Concat  被调用时，两个参数不会立即被迭代\n\n输入序列只有在需要的时候才会被迭代：如果你停止迭代输出序列时第一个输入序列还没有被耗尽的话，那么第二个序列根本就不会被迭代\n\n\n这几点描述基本就涵盖了  Concat  的所有行为。\n我们需要测试什么呢？ Concat  的串联行为很容易被测试，只需要一个用例就够了。我们或许也可以测试输入空序列会如何，但是那种测试基本没有不通过的可能。\n参数校验的测试方式和往常一样：调用方法时传入非法的参数，然后不去迭代方法的返回值。\n最后，还有一个单元测试用来测试两个输入序列被迭代的时机。这个测试中用到了我们在测试  Where  时用过的  ThrowingEnumerable  ：\n[Test]public void FirstSequenceIsntAccessedBeforeFirstUse() &#123; IEnumerable &lt; int &gt; first = new ThrowingEnumerable(); IEnumerable &lt; int &gt; second = new int[] &#123;  5 &#125;; // No exception yet... _ var query = first.Concat(second); // Still no exception... _ using(var iterator = query.GetEnumerator()) &#123;  // Now it will go bang _  Assert.Throws &lt; InvalidOperationException &gt; (() =&gt; iterator.MoveNext()); &#125;&#125;[Test]public void SecondSequenceIsntAccessedBeforeFirstUse() &#123; IEnumerable &lt; int &gt; first = new int[] &#123;  5 &#125;; IEnumerable &lt; int &gt; second = new ThrowingEnumerable(); // No exception yet... _ var query = first.Concat(second); // Still no exception... _ using(var iterator = query.GetEnumerator()) &#123;  // First element is fine... _  Assert.IsTrue(iterator.MoveNext());  Assert.AreEqual(5, iterator.Current);  // Now it will go bang, as we move into the second sequence _  Assert.Throws &lt; InvalidOperationException &gt; (() =&gt; iterator.MoveNext()); &#125;&#125;\n我们写测试来检查迭代器是否被  Dispose  掉了。但是我们可以预测到输入序列的迭代器应该会被合理的  Dispose掉。实际上，第一个序列的迭代器会在第二个序列开始被迭代之前就被  Dispose  掉。\n开始动手实现吧！ Concat  的实现虽然比较简单，但是我写完之后还是觉得  F#  更值得拥有  …  实现分为参数校验和迭代器代码块两部分，每一部分都不复杂：\npublic static IEnumerable &lt; TSource &gt; Concat &lt; TSource &gt; (this IEnumerable &lt; TSource &gt; first, IEnumerable &lt; TSource &gt; second) &#123; if (first == null) &#123;  throw new ArgumentNullException(&quot;first&quot;); &#125; if (second == null) &#123;  throw new ArgumentNullException(&quot;second&quot;); &#125; return ConcatImpl(first, second);&#125;private static IEnumerable &lt; TSource &gt; ConcatImpl &lt; TSource &gt; ( IEnumerable &lt; TSource &gt; first, IEnumerable &lt; TSource &gt; second) &#123; foreach(TSource item in first) &#123;  yield  return item; &#125; foreach(TSource item in second) &#123;  yield  return item; &#125;&#125;\n如果不能利用迭代器代码块的话，这个实现会变得很麻烦。虽然不会特别难，但是我们需要记住当前正在迭代的是哪个序列。\n如果是在用  F#  的话，我们可以使用  yield!  表达式来把它实现的更简单，  yield!表达式作用于一整个序列而不是单个的元素。必需得承认在这种场景下使用  yield!并不会带来什么性能上的提升（如果是在递归的场景下就很可能会有性能提升），但是能够用一个语句来  yield  返回整个序列确实是一种更优雅的风格。（Spec#  中也有一个类似的结构叫做嵌套迭代器，用   yield foreach   来表示。）我对  F#  和  Spec#了解的都不够深入，所以就不做更深入的比较了。不过我们在以后实现  Edulinq  的过程中还会遇到好几次“  yield返回一个序列中的每个元素”的模式。请记住，我们不能把  yield  返回的代码抽取到一个单独的方法中去，因为“  yield  ”表达式需要  C#编译器的特殊处理。\n#结论\n虽然我用的实现方式还是蛮简单的，但是我还是吐槽一下：） 如果  C#  里面也有嵌套迭代器那多好啊，虽然说没有它也没有令我太苦恼。\nConcat  是一个很有用的操作符，不过它也不过是  SelectMany  的一个特例罢了。  Concat  只能把两个序列连接成一个序列，而SelectMany  则可以把很多个序列连接成一个序列，而且  SelectMany  在有时还更有普遍性。下次我们会实现  SelectMany，而且会展示一些基于  SelectMany  来实现其他操作符的例子。（等实现  Aggregate  的时候，我们会再次见到操作符只返回一个值的例子。）\n附录：避免不必要的保持引用 有一条留言建议说要在遍历完第一个序列后把它设为  null。这样，在遍历完第一个序列后，它就可以被垃圾回收了。如果采取这个建议，那么实现起来会是这样的：\nprivate static IEnumerable &lt; TSource &gt; ConcatImpl &lt; TSource &gt; ( IEnumerable &lt; TSource &gt; first, IEnumerable &lt; TSource &gt; second) &#123; foreach(TSource item in first) &#123;  yield  return item; &#125; // Avoid hanging onto a reference we don&#x27;t really need _ first = null; foreach(TSource item in second) &#123;  yield  return item; &#125;&#125;\n\n在普通情况下，把一个不再使用的局部变量设为  null这种做法是没用的。因为当  CLR在执行优化过的代码，并且没有挂上调试器时，垃圾收集器只关心在方法内部可能还会被访问的变量。\n但是在我们这个特例中，这么做还是有用的。因为第一个参数并不是一个简单的局部变量，在  C#  编译器生成的隐藏类型中，它是一个实例字段，而  CLR无法判断实例字段是否会被再次使用。\n或许我们可以在调用  GetEnumerator  之前清空掉我们对“  first  ”这个参数的唯一引用。我们可以写一个这样的方法：\npublic static T ReturnAndSetToNull &lt; T &gt; (ref T value) where T: class &#123; T tmp = value; value = null; return tmp;&#125;\n\n然后这样调用它：\nforeach (TSource item in ReturnAndSetToNull(ref first))\n\n我认为这样做绝对是有点过了，因为迭代器有可能还会持有对集合的引用。不过在遍历之后把“  first  ”这个参数设为  null在我看来是说得通的。\n需要提醒你一下，我觉得  .NET  的  LINQ to Objects  的实现里面是不会这样做的。（以后我可能会用一个有  finalizer的集合类来测试一下。）\n\n\n\n\n","tags":["LinQ"]},{"title":"自己动手重新实现LINQ to Objects 7 - Count和LongCount","url":"/blog/2011/09/05/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0LINQ%20to%20Objects7%20-%20Count%E5%92%8CLongCount/","content":"本文翻译自   Jon Skeet   的系列博文”Edulinq”。\n本篇原文地址：\nhttp://msmvps.com/blogs/jon_skeet&#x2F;archive&#x2F;2010&#x2F;12&#x2F;26&#x2F;reimplementing-linq-to-objects-part-7-count-and-longcount.aspx\n今天的文章要介绍两个  LINQ  操作符，因为它们实在是太类似了，所以放到一起来讲。  Count  和  LongCount的实现非常相像，不同的只是方法名，返回值类型和几个变量。\nCount  和  LongCount  是什么呢？    Count   和   LongCount各自有两个重载：一个重载接受谓词，另一个不接受。下面是这四个方法的签名：\npublic static int Count &lt; TSource &gt; (this IEnumerable &lt; TSource &gt; source)public static int Count &lt; TSource &gt; (this IEnumerable &lt; TSource &gt; source, Func &lt; TSource, bool &gt; predicate)public static long LongCount &lt; TSource &gt; (this IEnumerable &lt; TSource &gt; source)public static long LongCount &lt; TSource &gt; (this IEnumerable &lt; TSource &gt; source, Func &lt; TSource, bool &gt; predicate)\n\n可以看到，  Count  和  LongCount  的方法签名的差别仅在于返回值类型，一个是  int  （  Int32  ），一个是  long（  Int64  ）。\n不接受谓词的重载返回输入序列中元素的个数；而接受谓词的重载则返回能够通过谓词验证的元素的个数。\n这些方法有一些有趣的行为：  \n\n这四个方法都是扩展  IEnumerable 的方法，你有可能会认为对于不接受谓词的那个重载来说，扩展  IEnumerable会来得更好，因为没有什么会限制元素的类型。\n\nCount  的不接受谓词的那个重载对于  ICollection 和  ICollection  （  .NET4中的接口）做了优化，因为这两个接口都定义有  Count  这个属性，这个属性的实现应该比遍历整个集合要快。  LongCount则没有做优化，稍后的一节中我将会谈到这点。\n\n接受谓词的重载中没有做任何优化，因为不迭代每一个元素就无法知道到底有多少个元素可以通过谓词的检验。\n\n这四个方法都是立即执行的，都不涉及延迟执行。（仔细想想就明白了，这些方法仅仅返回一个  int  或  long  值，确实没什么可延迟执行的）。\n\n所有的参数都只做非  null的校验。\n\n当输入集合的元素个数超出了  int  或  long  的上限值时，应该抛出  OverflowException  。\n\n\n我们要测试什么呢？我们需要对方法的优化做测试，这件事做起来比说起来难，因为我们需要测试以下四种情况：\n\n输入序列同时实现了  ICollection 和  ICollection  （这个简单，直接用  List ）\n\n输入序列实现了  ICollection 但没有实现  ICollection  （还算简单，可以用  HashSet ）\n\n输入序列实现了  ICollection  但没有实现  ICollection ，我还要要求这个类型实现了  IEnumerable（这样才能用到我们的扩展方法）。\n\n输入序列既不实现  ICollection  也不实现  ICollection （简单，用我们已经实现了的  Range  来生成）\n\n\n其中第三点比较麻烦。虽然有很多类型是实现了  ICollection  但没有实现  ICollection 的（比如  ArrayList），但是它们通常也不实现  IEnumerable ，而我们的扩展方法是针对于  IEnumerable 的。所以我只得自己写了一个叫做SemiGenericCollection  的类。\n上述的四种输入序列的类型都找到了，我们现在需要考虑到底怎么测试了。你可能会说我们可以通过检查输入序列是否被迭代过来测试方法是不是真的被优化了。但是要做这个测试就需要写一个有  Count  值但是其  GetEnumerator  方法会抛异常的集合类型。这个测试确实可行，但是我并没有做它。\n对于接受谓词的重载来说，我们无需考虑那几个不同的集合接口，因为我们反正都不会优化这两个方法。\n参数值为  null的几个测试都比较简单，但是有另一个测试比较重要：溢出。我给  Count创建了一个检验溢出行为的单元测试。很不幸，我们现在还不能在  Edulinq  的环境里运行它，因为我们还没有实现  Concat。不过我还是把它写在这里：\n[Test][Ignore(&quot;Takes an enormous amount of time!&quot;)]public void Overflow() &#123; var largeSequence = Enumerable.Range(0, int.MaxValue).Concat(Enumerable.Range(0, 1)); Assert.Throws &lt; OverflowException &gt; (() =&gt; largeSequence.Count());&#125;\n如果  Count  的实现在应该抛出异常的时候把返回值溢出到了  Int.MinValue  的话，这个测试可以发现到它。\n你可以看到，即使在实现了  Concat  并反注释了这段代码之后，这个测试也是被忽略掉了的，因为它需要遍历  20亿个元素，对于几个简单快速的单元测试来说，这可不妙。其实  20  亿还不算太坏，因为  LongCount  的溢出测试需要遍历  2  的  63  次方个元素呢。要生成那么长的序列并不难，难的是遍历它，那要花很长的时间。对于接受谓词的重载来说，我们也需要做溢出测试，直到写这篇文章之前我都忘记了要写这个测试，而写测试的时候还发现了一个方法实现中的  bug :)\n来动手实现吧！我们来看看接受谓词的那个重载的实现吧，它其实挺简单的：\npublic static int Count &lt; TSource &gt; (this IEnumerable &lt; TSource &gt; source, Func &lt; TSource, bool &gt; predicate) &#123; if (source == null) &#123;  throw new ArgumentNullException(&quot;source&quot;); &#125; if (predicate == null) &#123;  throw new ArgumentNullException(&quot;predicate&quot;); &#125; // No way of optimizing this _ checked &#123;  int count = 0;  foreach(TSource item in source) &#123;   if (predicate(item)) &#123;    count++;   &#125;  &#125;  return count; &#125;&#125;\n请注意，在这里我们不需要返回一个序列，所以就没有用到迭代器代码块，因而也就无需把实现拆分到两个方法中去。\n参数校验之后的方法主体部分相当简单，只有一点需要注意：整个的迭代过程都在“  checked  ”代码块中。这样，如果  count值溢出的话，就会抛出异常，而不会令  count  值成为负数。也有其他的方式可以实现这点：  \n\n可以只把给  count  加一的代码放在  checked  代码块中。\n\n可以在每次给  count  加一之前检查  count&#x3D;&#x3D;int.MaxValue  ，如果确实相等，则抛出异常\n\n可以给整个程序集都应用  checked\n\n\n我觉得把这段代码显式的放在  checked  代码块中是很有益的，因为这样可以很明显的凸显出对溢出的检查是方法正确性的需求这一事实。你可能更倾向于只把count++  这一句代码放在  checked  代码块中，不过我个人觉得现在的做法更容易引起读代码的人对  checked的注意，当然这只是我的主观偏好。还有，显式的  checked  代码块有可能会快一些，这一点我不确定，我还没有测试过。\n除了与谓词有关的部分，上面的代码会全部出现在  Count  的优化过的实现中，我们就不再讲解了，直接写出代码：\npublic static int Count &lt; TSource &gt; (this IEnumerable &lt; TSource &gt; source) &#123; if (source == null) &#123;  throw new ArgumentNullException(&quot;source&quot;); &#125; // Optimization for ICollection&lt;T&gt; _ ICollection &lt; TSource &gt; genericCollection = source as ICollection &lt; TSource &gt; ; if (genericCollection != null) &#123;  return genericCollection.Count; &#125;// Optimization for ICollection _ ICollection nonGenericCollection = source as ICollection; if (nonGenericCollection != null) &#123;  return nonGenericCollection.Count; &#125;// Do it the slow way - and make sure we overflow appropriately _ checked &#123;  int count = 0;  using(var iterator = source.GetEnumerator()) &#123;   while (iterator.MoveNext())   &#123;    count++;   &#125;  &#125;  return count; &#125;&#125;\n这个实现里面唯一的“新”代码就是关于优化的那段。优化代码中的两段基本是一样的，它们检查不同的集合接口类型，哪个检查通过就返回哪个的  Count属性。我不知道  .NET Framework  的实现中是先检查  ICollection  还是先检查  ICollection，我可以写一个同时实现了这两个接口，但是在两个  Count属性中返回不同的值的类型来测试一下，但是那么做有点太过了。对于良好实现的集合来说，这点性能差异算不了什么，我们先检查“最有可能”的接口，也就是泛型的ICollection 。\n优化还是不优化？ LongCount  的实现和  Count  的实现几乎完全一样，只是  LongCount  中使用  long  而不是  int  。\n我对  ICollection  和  ICollection 做了优化，但是我不认为  .NET  是如此实现的。（只要创建一个很大的  byte数组，并比较一下  Count  和  LongCount  应用到这个数组上的耗时差距就可以了。）\n关于   Array.GetLongCount   的使用存在一些争议，但是我觉得既然现在的  CLR并不支持长度超过  Int32.MaxValue  的数组，那么这个问题现在就没什么好争议的，只有留待以后证明。除此之外，我不知道  .NET的实现为什么没有优化。对一个实现了  ICollection  或  ICollection 接口的类型来说，如果该集合中包含了超过Int32.MaxValue  个元素的话，它的  Count  属性应该返回什么值呢？这一点并不明确。\n欢迎提出各种建议。不过我还是要指出  LongCount  方法可能会更多的应用在  Queryable  中而不是  Enumerable中，获取一个数据库表的长度的场景会比较多见，而获取一个内存中的集合的长度的场景则不那么常见。\n结论这是我们第一次接触返回数值而不是返回一个序列的  LINQ  操作符，很自然，这样的操作符更容易理解。这些方法很简单的执行，做一些优化，然后返回结果值。这些方法虽然简单，但是还是有一些东西很值得思考，比如说优化的问题，可惜优化的问题并没有一个确定的答案。\n下一次我想我会去实现  Concat  ，主要是因为实现了  Concat  就可以把对  Count  进行溢出测试的代码反注释了。  Concat是一个会返回一个序列的操作符，不过它很简单。\n\n\n\n\n","tags":["LinQ"]},{"title":"自己动手重新实现LINQ to Objects 9 - SelectMany","url":"/blog/2011/12/15/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0LINQ%20to%20Objects9%20-%20SelectMany/","content":"本文翻译自  Jon Skeet  的系列博文”Edulinq”。\n本篇原文地址：\n http://msmvps.com/blogs/jon_skeet&#x2F;archive&#x2F;2010&#x2F;12&#x2F;27&#x2F;reimplementing-linq-to-objects-part-9-selectmany.aspx\n我们接下来要实现的这个操作符是LINQ  中最重要的操作符。大多数（或者是全部？）其他的返回一个序列的操作符都可以通过调用  SelectMany来实现，这是后话按下不表。现在我们首先来实现它吧。\nSelectMany  是什么？\nSelectMany  有四个重载，看起来一个比一个吓人：\npublic static IEnumerable &lt; TResult &gt; SelectMany &lt; TSource, TResult &gt; ( this IEnumerable &lt; TSource &gt; source, Func &lt; TSource, IEnumerable &lt; TResult &gt;&gt; selector)public static IEnumerable &lt; TResult &gt; SelectMany &lt; TSource, TResult &gt; ( this IEnumerable &lt; TSource &gt; source, Func &lt; TSource, int, IEnumerable &lt; TResult &gt;&gt; selector)public static IEnumerable &lt; TResult &gt; SelectMany &lt; TSource, TCollection, TResult &gt; ( this IEnumerable &lt; TSource &gt; source, Func &lt; TSource, IEnumerable &lt; TCollection &gt;&gt; collectionSelector, Func &lt; TSource, TCollection, TResult &gt; resultSelector)public static IEnumerable &lt; TResult &gt; SelectMany &lt; TSource, TCollection, TResult &gt; ( this IEnumerable &lt; TSource &gt; source, Func &lt; TSource, int, IEnumerable &lt; TCollection &gt;&gt; collectionSelector, Func &lt; TSource, TCollection, TResult &gt; resultSelector)\n\n其实还不算太坏，这些重载只是同一个操作的不同形式而已。\n无论是哪个重载，都需要一个输入序列。然后用一个委托来处理输入序列中的每个元素以生成一个子序列，这个委托可能会接受一个代表元素  index  的参数。\n再然后，我们或者把每个子序列中的元素直接返回，或者再用另一个委托来做处理，这个委托接受输入序列中的元素并接受其对应的子序列中的元素。\n以我的经验来说，使用  index  两个重载不太常用，而另外两个重载（上面列出的第一个和第三个）则比较常用。还有，当  C#  编译器处理一个含有多个from  子句的查询表达式的时候，它会把出第一个  from  之外的其他  from  子句转译为上面的第三个重载。\n为了把上面的说法放入实例中理解，我们假设有这样一个查询表达式：\nvar query = from file in Directory.GetFiles(&quot;logs&quot;)from line in File.ReadLines(file)select Path.GetFileName(file) + &quot;: &quot; + line;\n\n上面的查询表达式会被转译为下面的“正常”调用：\nvar query = Directory.GetFiles(&quot;logs&quot;).SelectMany(file =&gt; File.ReadLines(file),(file, line) =&gt; Path.GetFileName(file) + &quot;: &quot; + line);\n\n这个例子中，编译器会把表达式中的  select  子句转译为投影操作；如果表达式后面还跟有  where  子句或其他子句，编译器会把  file  和line  包装在一个匿名类型中传递给投影操作。这是查询表达式转译中最令人难理解的一点，因为这涉及到了透明标识符（  transparentidentifiers  ）。就现在来说，我们只分析上面给出的简单例子。\n上例中的  SelectMany  接受三个参数：\n+ 输入序列，也就是一个字符串序列（  Directory.GetFiles  所返回的文件名）\n+ 一个初始投影操作，它把一个文件名转化为该文件中包含的一行行的字符串\n+ 一个结束投影操作，它把一个文件名和一行文件内容转化为一个由冒号分隔的字符串\n表达式的最后结果会是一个字符串的序列，其中包含所有  log  文件的每一行，每一行会以文件名作为前缀。如果把结果打印出来，大概会是这样的：\ntest1.log: footest1.log: bartest1.log: baztest2.log: Second log filetest2.log: Another line from the second log file\n\n要理解  SelectMany  可能会费点脑子，我当时理解它就费了点力，不过理解它是很重要的。\n在讲测试之前，还有几点关于  SelectMany  的行为细节需要说明：\n+ 参数校验是立即执行的，每个参数都不能是  null\n+ 整个过程都是流式处理的。每次只会从输入序列中读取一个元素，然后生成一个子序列。然后每次只会返回子序列中的一个元素，返回子序列中的全部元素之后再去读取输入序列中的下一个元素，用它来生成下一个子序列，如此循环往复。\n+ 每个迭代器在使用完之后都会被关闭，正如你会预期的一样。\n我们要测试什么呢？\n我有一点变懒了，我不想再写参数为  null的测试了。我给  SelectMany的每一个重载都写了一个测试。我发现我无法把这些测试写得很清晰，不过还是拿出一个例子来，下面的代码是针对  SelectMany  的最复杂的重载的测试：\n[Test]public void FlattenWithProjectionAndIndex() &#123; int[] numbers = &#123;  3,  5,  20,  15 &#125;; var query = numbers.SelectMany((x, index) =&gt; (x +   index).ToString().ToCharArray(),  (x, c) =&gt; x + &quot;: &quot; + c); // 3 =&gt; &quot;3: 3&quot; // 5 =&gt; &quot;5: 6&quot; // 20 =&gt; &quot;20: 2&quot;, &quot;20: 2&quot; // 15 =&gt; &quot;15: 1&quot;, &quot;15: 8&quot; query.AssertSequenceEqual(&quot;3: 3&quot;, &quot;5: 6&quot;, &quot;20: 2&quot;, &quot;20: 2&quot;, &quot;15: 1&quot;, &quot;15: 8&quot;);&#125;\n\n给这个测试做一点解释：\n+ 每一个数字都和它的序号相加  (3+0, 5+1, 20+2, 15+3)\n+ 相加的结果转成字符串，然后转成字符数组。（我们原本不需要调用  ToCharArray  的，因为  String  本身就实现了IEnumerable ，不过现在这样写比较清晰。）\n+ 然后把子序列中的每一个字符和原元素以“原元素：子序列字符”的形式组合在一起\n注释部分是每一个输入元素对应的输出结果，测试最后一句代码给出了完整的输出序列。\n是不是一团乱麻？希望你看了上面逐步分解的解释很清楚一点。好了，现在想办法让测试可以通过吧。\n开始动手实现吧！\n我们可以通过实现一个最复杂的重载并让其他的重载都调用它来实现  SelectMany  ，或者也可以写一个没有参数校验的“  Impl”方法，然后让四个重载都调用它。比如说，最简单重载可以这样实现：\npublic static IEnumerable &lt; TResult &gt; SelectMany &lt; TSource, TResult &gt; ( this IEnumerable &lt; TSource &gt; source, Func &lt; TSource, IEnumerable &lt; TResult &gt;&gt; selector) &#123; if (source == null) &#123;  throw new ArgumentNullException(&quot;source&quot;); &#125; if (selector == null) &#123;  throw new ArgumentNullException(&quot;selector&quot;); &#125; return SelectManyImpl(source,  (value, index) =&gt; selector(value),  (originalElement, subsequenceElement) =&gt; subsequenceElement);&#125;\n\n不过我还是选择为每一重载写一个签名相同的“  SelectManyImpl ”方法。我觉得这样做可以让以后单步调试时更简单一些  …而且这样让我们可以注意到不同重载之间的区别，代码是这样的：\n// Simplest overloadprivate static IEnumerable &lt; TResult &gt; SelectManyImpl &lt; TSource, TResult &gt; ( IEnumerable &lt; TSource &gt; source, Func &lt; TSource, IEnumerable &lt; TResult &gt;&gt; selector) &#123; foreach(TSource item in source) &#123;  foreach(TResult result in selector(item)) &#123;   yield   return result;  &#125; &#125;&#125;// Most complicated overload:// - Original projection takes index as well as value// - There&#x27;s a second projection for each original/subsequence element pairprivate static IEnumerable &lt; TResult &gt; SelectManyImpl &lt; TSource, TCollection, TResult &gt; ( IEnumerable &lt; TSource &gt; source, Func &lt; TSource, int, IEnumerable &lt; TCollection &gt;&gt; collectionSelector, Func &lt; TSource, TCollection, TResult &gt; resultSelector) &#123; int index = 0; foreach(TSource item in source) &#123;  foreach(TCollection collectionItem in collectionSelector(item, index++)) &#123;   yield   return resultSelector(item, collectionItem);  &#125; &#125;&#125;\n\n这两个方法之间的相似性很是明显  …  不过我还是觉得保留着第一种形式很有用，如果我搞不清楚  SelectMany的作用的话，通过第一种最简单的重载就可以很容易的弄懂。以此为基础再去理解余下的重载，跳跃性就不会那么大了。第一个重载在一定程度上起到了一个理解SelectMany  的概念的垫脚石的作用。\n有两点需要指出：\n如果  C#  中可以使用“  yield foreach selector(item)”这种表达式的话，上面的第一个方法就可以实现的稍简单一点。如果要在第二个方法中使用这种做法的话就会难一些，而且可能还要涉及到对  Select的调用，这样的话就有点得不偿失了。\n在第二个方法中，我没有显式的使用“  checked  ”代码块，虽然说“  index  ”是有可能溢出的。我没有看过  BCL的实现是什么样的，但是我认为他们不会写“  checked  ”的。考虑到前后一致性，我或许应该在每一个处理  index  的方法中都是用“checked  ”代码块，或者给整个程序集开启“  checked  ”。\n通过调用  SelectMany  来实现其他操作符\n之前我提到过很多的  LINQ  操作符都可以通过调用  SelectMany  来实现。下面的代码就是这一观点的实例，我们通过调用  SelectMany实现了  Select  ，  Where  和  Concat  ：\npublic static IEnumerable &lt; TResult &gt; Select &lt; TSource, TResult &gt; ( this IEnumerable &lt; TSource &gt; source, Func &lt; TSource, TResult &gt; selector) &#123; if (source == null) &#123;  throw new ArgumentNullException(&quot;source&quot;); &#125; if (selector == null) &#123;  throw new ArgumentNullException(&quot;selector&quot;); &#125; return source.SelectMany(x =&gt; Enumerable.Repeat(selector(x), 1));&#125;public static IEnumerable &lt; TSource &gt; Where &lt; TSource &gt; ( this IEnumerable &lt; TSource &gt; source, Func &lt; TSource, bool &gt; predicate) &#123; if (source == null) &#123;  throw new ArgumentNullException(&quot;source&quot;); &#125; if (predicate == null) &#123;  throw new ArgumentNullException(&quot;predicate&quot;); &#125; return source.SelectMany(x =&gt; Enumerable.Repeat(x, predicate(x) ? 1 : 0));&#125;public static IEnumerable &lt; TSource &gt; Concat &lt; TSource &gt; ( this IEnumerable &lt; TSource &gt; first, IEnumerable &lt; TSource &gt; second) &#123; if (first == null) &#123;  throw new ArgumentNullException(&quot;first&quot;); &#125; if (second == null) &#123;  throw new ArgumentNullException(&quot;second&quot;); &#125; return new [] &#123;  first,  second &#125;.SelectMany(x =&gt; x);&#125;\n\nSelect  和  SelectMany  使用  Enumerable.Repeat来很方便的创建含有一个元素或不包含任何元素的序列。你也可以通过创建一个数组来代替使用  Repeat  的这种做法。  Concat直接使用了一个数组：如果你理解了  SelectMany  的作用就是把多个序列组合为一个序列这一点的话，  Concat这样实现看起来就很自然了。我估计  Empty  和  Repeat  可以通过递归来实现，尽管这样的话性能会很差。\n现在，上面的代码是放在条件编译块里面的。如果大家希望我多写一些借助于  SelectMany来实现的操作符的话，我可能会考虑把它单独分离一个项目出来。不过我感觉以上的代码已经足以显示  SelectMany  的灵活性了，再利用SelectMany  来实现更多的其他操作符也未必能更加充分的说明这一点。\n在理论的意义上，  SelectMany  也很重要，因为它为  LINQ  提供了  monadic  的特性。我不想在这一话题上说的更多，你可以读一读 Wes Dyer  的博客   ，或者直接搜索“  bind monad SelectMany  ”就可以找到很多比我更聪明的人写的文章。\n结论SelectMany  是  LINQ  中的基础之一，初看上去它很是令人生畏。但是一旦你理解了  SelectMany的作用就是把多个序列组合起来这一点之后，它就很容易搞懂了。\n下一次我们讨论  All和  Any  ，这两个操作符很适合放在一起来讲解。\n\n\n\n\n","tags":["LinQ"]},{"title":"自己动手重新实现LINQ to Objects 5 - Empty","url":"/blog/2011/08/23/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0LINQ%20to%20Objects5%20-%20Empty/","content":"本文翻译自   Jon Skeet   的系列博文”Edulinq”。\n本篇原文地址：\nhttp://msmvps.com/blogs/jon_skeet&#x2F;archive&#x2F;2010&#x2F;12&#x2F;24&#x2F;reimplementing-linq-to-objects-part-5-empty.aspx这一篇继续讲非扩展方法。这次我们要讲的是  Empty  ，它有可能是最简单的  LINQ  操作符了。\nEmpty  是什么？ Empty  是一个泛型的，静态的方法，它只有一个签名形式，不接受任何参数：  \npublic  static  IEnumerable Empty()  \n它返回一个特定类型的空序列。这就是它的唯一作用。\n它的行为只有一点比较有趣：文档上说  Empty  会对空序列做缓存。换句话说，对于同一个类型参数来讲，它每次都会返回同一个空序列。  \n我们要测试什么？能够测试的东西也就只有两点：\n\n返回序列为空。\n\n对每个类型参数来说，返回值会被缓存起来。\n\n\n和测试  Range  的时候的方法一样，我们用一个叫做  EmptyClass  的别名来引用包含  Empty  的类型。下面是测试代码：  \n[Test]public void EmptyContainsNoElements() &#123; using(var empty = EmptyClass.Empty &lt; int &gt; ().GetEnumerator()) &#123;  Assert.IsFalse(empty.MoveNext()); &#125;&#125;[Test]public void EmptyIsASingletonPerElementType() &#123; Assert.AreSame(EmptyClass.Empty &lt; int &gt; (), EmptyClass.Empty &lt; int &gt; ()); Assert.AreSame(EmptyClass.Empty &lt; long &gt; (), EmptyClass.Empty &lt; long &gt; ()); Assert.AreSame(EmptyClass.Empty &lt; string &gt; (), EmptyClass.Empty &lt; string &gt; ()); Assert.AreSame(EmptyClass.Empty &lt; object &gt; (), EmptyClass.Empty &lt; object &gt; ()); Assert.AreNotSame(EmptyClass.Empty &lt; long &gt; (), EmptyClass.Empty &lt; int &gt; ()); Assert.AreNotSame(EmptyClass.Empty &lt; string &gt; (), EmptyClass.Empty &lt; object &gt; ());&#125;\n\n当然，以上代码并不能证明缓存不是每个线程一份。不过，这些测试也够了。  \n来动手实现吧！现在看来，  Empty  的实现要比它的描述更有趣。如果不是要做缓存，我们可以这样实现  Empty  ：\n// Doesn&#x27;t cache the empty sequence _public static IEnumerable &lt; TResult &gt; Empty &lt; TResult &gt; ()&#123; yield break;&#125;  \n\n不过我们需要遵守关于缓存的文档。要实现缓存其实也不难。有一个很方便的事实可以为我们所用，  **空数组是不可变的 **。数组的长度是固定的，通常无法使一个数组是只读的。数组中的任何一个元素都是可以改变的。不过一个空数组是不包含任何元素的，所以也就没有什么可被改变的。这样，我们就可以反复的重用同一个数组了。\n现在你可能会猜我会用  Dictionary&lt;Type, Array&gt;来实现，不过我们可以利用一个小手段。在一个泛型类型中，可以用一个静态变量来实现针对类型参数的缓存，因为每一个传入了类型参数的泛型类型的静态变量都是不同的。\n很不幸，  Empty  是一个非泛型类型中的方法。所以我们需要创建另一个泛型类型来包含缓存。这很容易做到，而且  CLR还帮我们做到了线程安全的类型初始化。所以，我们最后的实现会是这样的：  \npublic static IEnumerable &lt; TResult &gt; Empty &lt; TResult &gt; () &#123; return EmptyHolder &lt; TResult &gt; .Array;&#125;private static class EmptyHolder &lt; T &gt; &#123; internal static readonly T[] Array = new T[0];&#125;\n\n以上的实现遵守了所有的关于缓存的文档，而且代码行数也很少。不过这个实现方式需要你很好的了解  .NET  中泛型的工作方式。这种做法和我们上一篇采取的策略相反，我们选择了一种比较难懂的方式，而没有选择使用字典的易懂的方式。不过我很满意这种方案，因为一旦你了解了泛型类型和静态变量的工作方式，这段代码就很简单了。  \n结论Empty  的实现就是这样的。下一个操作符  Repeat  有可能会更简单，虽然它也要分成两个方法来实现。\n附录因为以上讲解的方法有点难懂，所以下面再提供另一种实现：\npublic static IEnumerable &lt; TResult &gt; Empty &lt; TResult &gt; ()&#123; return EmptyEnumerable &lt; TResult &gt; .Instance;&#125;# if AVOID_RETURNING_ARRAYSprivate class EmptyEnumerable &lt; T &gt;: IEnumerable &lt; T &gt; , IEnumerator &lt; T &gt; &#123;  internal static IEnumerable &lt; T &gt; Instance = new EmptyEnumerable &lt; T &gt; (); // Prevent construction elsewhere _  private EmptyEnumerable()  &#123;  &#125;  public IEnumerator &lt; T &gt; GetEnumerator()  &#123;   return this;  &#125;  IEnumerator IEnumerable.GetEnumerator()  &#123;   return this;  &#125;  public T Current  &#123;   get &#123;    throw new InvalidOperationException();   &#125;  &#125;  object IEnumerator.Current  &#123;   get &#123;    throw new InvalidOperationException();   &#125;  &#125;  public void Dispose()  &#123;  // No-op _  &#125;  public bool MoveNext()  &#123;   return false;  // There&#x27;s never a next entry _  &#125;  public void Reset()  &#123;  // No-op _  &#125; &#125;# else private static class EmptyEnumerable &lt; T &gt; &#123;  internal static readonly T[] Instance = new T[0]; &#125;# endif\n\n这下大家都满足了吧：）\n\n\n\n\n","tags":["LinQ"]},{"title":"自己动手重新实现LINQ to Objects 10 - Any和All","url":"/blog/2012/02/15/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0LINQ%20to%20Objects10%20-%20Any%E5%92%8CAll/","content":"本文翻译自  Jon Skeet  的系列博文”Edulinq”。\n本篇原文地址：\n http://msmvps.com/blogs/jon_skeet&#x2F;archive&#x2F;2010&#x2F;12&#x2F;28&#x2F;reimplementing-linq-to-objects-part-10-any-and-all.aspx\n今天我们介绍两个操作符：Any  和  All。\nAny  和  All做什么？\nAny  有两个重载，而  All只有一个：\npublic static bool Any&lt;TSource&gt;( \n\n    this IEnumerable&lt;TSource&gt; source) \n\n \n\npublic static bool Any&lt;TSource&gt;( \n\n    this IEnumerable&lt;TSource&gt; source, \n\n    Func&lt;TSource, bool&gt; predicate) \n\n \n\npublic static bool All&lt;TSource&gt;( \n\n    this IEnumerable&lt;TSource&gt; source, \n\n    Func&lt;TSource, bool&gt; predicate)\n\n 复制代码 \n这两个方法所做的事情完全可以顾名思义：\n+ 不接受谓词的  Any  用于判断输入序列中是否存在任何元素\n+ 接受谓词的  Any  用于判断输入序列中是否存在能够通过谓词检验的元素\n+ All用于判断输入序列中的元素是否全部都能通过谓词的检验\n这两个操作符都是立即执行的，它们在得出最终结果之前不会返回。\n很重要的一点，  All必须要迭代整个输入序列才能返回  true  ，但是它只要遇到一个不能通过谓词检验的元素就会返回  false  ；而  Any只要找到一个可以通过谓词检验的元素就会返回  true  ，但是必须要迭代整个输入序列才能返回  false  。这就引出了一个很简单的  LINQ性能小窍门，下面这种用法几乎在所有情况下都是不可取的：\n// Don&#39;t use this \n\nif (query.Count() != 0)\n\n 复制代码 \n上面的用法会迭代整个输入序列，如果你只想知道序列中是否含有元素的话，这样来做：\n// Use this instead \n\nif (query.Any())\n\n 复制代码 \n如果这是一个较大的  LINQ to SQ+ 查询中的一部分，那么这两种做法的区别可能不大，但是对于  LINQ to Objects  来说，区别很大。\n我们需要测试什么？\n我今晚感觉不错，我甚至把参数校验都做了  …  虽然说参数校验在这个立即执行的特例下并不困难。\n除此之外，我还测试了以下一些场景：\n+ Any  作用于空序列应该返回  false  ，而  All则应该返回  true  。（因为无论谓词是什么样的，没有任何一个元素会通不过检验。）\n+ 一个序列，只要它含有元素，不接受谓词的  Any  就应该返回  true  。\n+ 如果所有元素都不能通过谓词，那么  Any  和  All都应该返回  false  。\n+ 如果部分元素能够通过谓词，  Any  将会返回  true  而  All会返回  false  。\n+ 如果所有元素都能够通过谓词，那么  All会返回  true  。\n以上测试都很简洁明了，我就不给出代码了。还有最后一个测试很有趣：我们要证明  Any  会在找到第一个符合条件的元素之后立即返回，证明的手段是通过把Any  作用在一个被完整迭代时会抛出异常的查询结果上。最简单的方式就是创建一个包含有  0  的整数序列，然后对其做  Select  操作，Select  中会把每一个元素除以某个常数。以下的测试用例中，序列中会导致异常的元素之前存在一个能够通过谓词的元素：\n[Test] \n\npublic void SequenceIsNotEvaluatedAfterFirstMatch() \n\n&#123; \n\n    int[] src = &#123; 10, 2, 0, 3 &#125;; \n\n    var query = src.Select(x =&gt; 10 / x); \n\n    // This will finish at the second element (x = 2, so 10/x = 5) \n\n    // It won&#39;t evaluate 10/0, which would throw an exception \n\n    Assert.IsTrue(query.Any(y =&gt; y &gt; 2)); \n\n&#125;\n\n 复制代码 \n对于  All，也有一个类似的测试用例，其中会导致异常的元素前面存在一个不能通过谓词检验的元素。\n现在所有测试都有了，下面开始有趣的部分了：\n来动手实现吧！有一点需要提醒，我们可以基于接受谓词的  Any  或者基于  All来实现另外两个方法。比如说，如果已经实现了  All的话，那么  Any就可以这样实现：\npublic static bool Any&lt;TSource&gt;( \n\n    this IEnumerable&lt;TSource&gt; source) \n\n&#123; \n\n    return source.Any(x =&gt; true); \n\n&#125; \n\n \n\npublic static bool Any&lt;TSource&gt;( \n\n    this IEnumerable&lt;TSource&gt; source, \n\n    Func&lt;TSource, bool&gt; predicate) \n\n&#123; \n\n    if (predicate == null) \n\n    &#123; \n\n        throw new ArgumentNullException(&quot;predicate&quot;); \n\n    &#125; \n\n    return !source.All(x =&gt; !predicate(x)); \n\n&#125;\n\n 复制代码 \n基于接受谓词的的  Any  来实现不接受谓词的  Any  是最简单的，我们使用了一个对任何元素都会返回  true的谓词，这就意味着只要输出序列中含有元素就会返回  true  ，这正是我们想要的行为。\n上面调用  All时的两次否操作会让你费点脑筋，不过这其实就是   德摩根定律在  LINQ  中的表现形式：我们对谓词做否操作，来检验是否所有的元素都不能通过谓词，得到结果后，再次做否操作并返回。由于否操作的原因，这种实现方式仍然会在合适的情况下提前返回。\n虽然以上的方式可行，但是我更喜欢给每个方法一个单独的实现，这样做简单明了：\npublic static bool Any&lt;TSource&gt;( \n\n    this IEnumerable&lt;TSource&gt; source) \n\n&#123; \n\n    if (source == null) \n\n    &#123; \n\n        throw new ArgumentNullException(&quot;source&quot;); \n\n    &#125; \n\n             \n\n    using (IEnumerator&lt;TSource&gt; iterator = source.GetEnumerator()) \n\n    &#123; \n\n        return iterator.MoveNext(); \n\n    &#125; \n\n&#125; \n\n \n\npublic static bool Any&lt;TSource&gt;( \n\n    this IEnumerable&lt;TSource&gt; source, \n\n    Func&lt;TSource, bool&gt; predicate) \n\n&#123; \n\n    if (source == null) \n\n    &#123; \n\n        throw new ArgumentNullException(&quot;source&quot;); \n\n    &#125; \n\n    if (predicate == null) \n\n    &#123; \n\n        throw new ArgumentNullException(&quot;predicate&quot;); \n\n    &#125; \n\n \n\n    foreach (TSource item in source) \n\n    &#123; \n\n        if (predicate(item)) \n\n        &#123; \n\n            return true; \n\n        &#125; \n\n    &#125; \n\n    return false; \n\n&#125; \n\n \n\n \n\npublic static bool All&lt;TSource&gt;( \n\n    this IEnumerable&lt;TSource&gt; source, \n\n    Func&lt;TSource, bool&gt; predicate) \n\n&#123; \n\n    if (source == null) \n\n    &#123; \n\n        throw new ArgumentNullException(&quot;source&quot;); \n\n    &#125; \n\n    if (predicate == null) \n\n    &#123; \n\n        throw new ArgumentNullException(&quot;predicate&quot;); \n\n    &#125; \n\n \n\n    foreach (TSource item in source) \n\n    &#123; \n\n        if (!predicate(item)) \n\n        &#123; \n\n            return false; \n\n        &#125; \n\n    &#125; \n\n    return true; \n\n&#125;\n\n 复制代码 \n这样的实现方式很明显的凸显了“提前返回”这一特性。而且，这样做也可以使得堆栈跟踪记录更易读。对于一个下游开发者来说，如果调试  Any时在堆栈跟踪记录中看到了调用  All的记录会显得很奇怪；调用  All时看到了  Any  也会很奇怪。\n有一点很有趣，不接受谓词的  Any  中我们没用到  foreach  。而是用了迭代器第一次调用  MoveNext方法时的返回值来表示序列中是否存在元素。读这个方法可以很明显的（至少对我来说很明显）看出我们根本不关心第一个元素的值是什么，因为我们根本就没有去访问它。\n结论尽量使用  Any  而不是  Count  的建议或许是这篇文章中最重要的一点，余下的部分都比较简单，不过能基于一个操作符来实现另一个操作符总是很有趣的。\n下一篇讲什么呢？或许是  Single  、  SingleOrDefault  、  First  、  FirstOrDefault  、  Last或者  LastOrDefault  。也或许我会把它们都放到一篇文章中来阐释它们的相似同时也强调它们之间的差别。\n\n\n\n\n","tags":["LinQ"]},{"title":"自己动手重新实现LINQ to Objects 11 - First，Last，Single以及它们带有OrDefault的重载","url":"/blog/2012/04/09/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0LINQ%20to%20Objects11%20-%20First%EF%BC%8CLast%EF%BC%8CSingle%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E5%B8%A6%E6%9C%89OrDefault%E7%9A%84%E9%87%8D%E8%BD%BD/","content":"本文翻译自  Jon Skeet  的系列博文”Edulinq”。\n本篇原文地址：\n http://msmvps.com/blogs/jon_skeet&#x2F;archive&#x2F;2010&#x2F;12&#x2F;29&#x2F;reimplementing-linq-to-objects-part-11-first-single-last-and-the-ordefault-versions.aspx\n今天我实现了六个操作符，每个操作符都有两个重载。我一开始以为这些操作符的实现会很相似，但是最后发现每个都稍微有些不同…\n今天实现了哪些操作符？\n以下三个集合的排列  {First, Last, Single}, {  带有  &#x2F;  不带有  OrDefault }, {  带有  &#x2F;  不带有谓词}  ，其结果是十二个不同的方法签名：\npublic static TSource First&lt;TSource&gt;(\n    this IEnumerable&lt;TSource&gt; source)\n\npublic static TSource First&lt;TSource&gt;(\n    this IEnumerable&lt;TSource&gt; source,\n    Func&lt;TSource, bool&gt; predicate)\n\npublic static TSource FirstOrDefault&lt;TSource&gt;(\n    this IEnumerable&lt;TSource&gt; source)\n\npublic static TSource FirstOrDefault&lt;TSource&gt;(\n    this IEnumerable&lt;TSource&gt; source,\n    Func&lt;TSource, bool&gt; predicate)\n\npublic static TSource Last&lt;TSource&gt;(\n    this IEnumerable&lt;TSource&gt; source)\n\npublic static TSource Last&lt;TSource&gt;(\n    this IEnumerable&lt;TSource&gt; source,\n    Func&lt;TSource, bool&gt; predicate)\n\npublic static TSource LastOrDefault&lt;TSource&gt;(\n    this IEnumerable&lt;TSource&gt; source)\n\npublic static TSource LastOrDefault&lt;TSource&gt;(\n    this IEnumerable&lt;TSource&gt; source,\n    Func&lt;TSource, bool&gt; predicate)\n\npublic static TSource Single&lt;TSource&gt;(\n    this IEnumerable&lt;TSource&gt; source)\n\npublic static TSource Single&lt;TSource&gt;(\n    this IEnumerable&lt;TSource&gt; source,\n    Func&lt;TSource, bool&gt; predicate)\n\npublic static TSource SingleOrDefault&lt;TSource&gt;(\n    this IEnumerable&lt;TSource&gt; source)\n\npublic static TSource SingleOrDefault&lt;TSource&gt;(\n    this IEnumerable&lt;TSource&gt; source,\n    Func&lt;TSource, bool&gt; predicate)\n\n这些操作符有以下的共同点：\n+ 它们都是接受一个泛型参数的扩展方法\n+ 它们都是立即执行的\n+ 他们都会检查参数是否为  null\n+ 这些操作符的接受谓词的重载和以下形式等价：source.Where(谓词).该操作符()。换句话说，这些接受谓词的重载就是在执行操作符之前过滤一下\n了解了上面这几点之后，对于每个操作符就只需考虑三种可能性：在谓词执行之后（如果有谓词的话），如果源序列是空的怎么处理？源序列只包含一个元素怎么处理？如果源序列包含多个元素如何处理？我们可以用一个简单的表来描述上述问题的结果：\n\n\n\n操作符\n如果源序列是空的\n源序列只包含一个元素\n源序列包含多个元素\n\n\n\nFirst\n抛异常\n返回该元素\n返回第一个元素\n\n\nFirstOrDefault\n返回default(TSource)\n返回该元素\n返回第一个元素\n\n\nLast\n抛异常\n返回该元素\n返回最后一个元素\n\n\nLastOrDefault\n返回default(TSource)\n返回该元素\n返回最后一个元素\n\n\nSingle\n抛异常\n返回该元素\n抛异常\n\n\nSingleOrDefault\n返回default(TSource)\n返回该元素\n抛异常\n\n\n很明显，如果输入序列只有一个元素的话，这几个操作符的执行结果是非常一致的:) 类似的，如果输入的序列是空的的话，那么没有“  OrDefault”的操作符会抛异常（  InvalidOperationException  ），而带有“  OrDefault”的操作符则会返回元素类型的默认值（引用类型的默认值为  null，  int  的默认值为  0  ，等等）。\n如果（可能是被过滤过的）输入序列含有多个元素的话，那这些操作符的执行结果的差异是很大的，First和  Last  的结果是顾名思义的，而  Single抛出异常。值得注意的是，  SingleOrDefault也会抛出异常，因为它要做的事又不是像这样：如果输入序列只有一个元素的话，返回该元素，否则的话返回默认值。如果你需要能够处理多元素序列的操作符的话，用First  或  Last  。如果你需要处理可能为空的序列的话，使用  FirstOrDefault  或  LastOrDefault。请注意，如果使用带有“  OrDefault  ”的操作符的话，那么一个空的序列和一个仅包含默认值的序列的执行结果会是完全一样的。我们稍后会提到DefaultIfEmpty。\n现在我们知道这些操作符做什么了，我们来开始测试吧。\n我们要测试什么？今天早晨，我发了一条推文说我在开始实现之前就写了  72  个测试用例。实际上，我最终写了  80  个，为什么写了  80我们稍后会说。对每一个操作符，我测试了  12  个用例：\n+ 源序列是否为  null的测试（没有谓词的重载）\n+ 源序列是否为  null的测试（有谓词的重载）\n+ 谓词是否为  null的测试\n+ 源序列不包含元素的测试（没有谓词的重载）\n+ 源序列不包含元素的测试（有谓词的重载）\n+ 源序列只包含一个元素的测试（没有谓词的重载）\n+ 源序列只包含一个元素，且该元素符合谓词的测试\n+ 源序列只包含一个元素，且该元素不符合谓词的测试\n+ 源序列包含多个元素的测试（没有谓词的重载）\n+ 源序列包含多个元素且只有一个元素符合谓词的测试\n+ 源序列包含多个元素且多个元素符合谓词的测试\n实现这些测试用例时，我做了很多复制粘贴，每个操作符的测试用例用的都是同一组数据，只是预期的结果值不同。\n另外，First和  FirstOrDefault  分别有两个额外的测试，  Last和LastOrDefault也分别有两个：\n+ First和FirstOrDefault：当没有谓词的时候，这两个方法应该在遇到第一个元素时就立刻返回，不应该继续遍历序列的剩余部分\n+ First  和  FirstOrDefault  ：当有谓词的时候，应该在找到第一个符合谓词的元素时就立刻返回\n+ Last和  LastOrDefault  ：当源序列实现了  IList且没有谓词时，这两个方法使用源序列的  Count属性和索引器去访问最后一个元素，这是一个特殊优化\n+ Last和LastOrDefault：当源序列实现了  IList  且有谓词的时候，则没有上述的优化。这种情况下，这两个方法要彻底遍历整个源序列\n上面提到的后两个测试用到了一个叫做  NonEnumerableList  的新集合类型，这个类型的所有方法实现都依赖于一个  List  ，除了GetEnumerator  方法（泛型的和非泛型的）之外，这两个方法仅仅是抛出NotSupportedException异常。这一点对于测试上述的优化很有帮助，有关优化的问题我们说到的时候再谈。\n来动手实现吧！这几个操作符的实现比我预期的要有趣，所以我下面要把十二个方法实现都列出来。这些方法可不是复制粘贴一下了事的，参数验证的部分除外。\n如果我们基于  Where  和没有谓词的重载来实现有谓词的重载，并且基于  DefaultIfEmpty  和名字中不含  Default的重载来实现名字中含有  Default  的重载的话，那么我们就只需要实现三个没有谓词和名字里没有  Default的方法。但是，就像我之前说过的那样，单独的实现每个操作符会有一些好处。\n为了避免看起来冗余，我把每个方法中的参数检验的部分省略掉了。不过在真实的代码中是含有参数检验的。我们从  First  开始吧：\npublic static TSource First&lt;TSource&gt;(\n    this IEnumerable&lt;TSource&gt; source)\n&#123;\n    // Argument validation elided\n    using (IEnumerator&lt;TSource&gt; iterator = source.GetEnumerator())\n    &#123;\n        if (iterator.MoveNext())\n        &#123;\n            return iterator.Current;\n        &#125;\n        throw new InvalidOperationException(&quot;Sequence was empty&quot;);\n    &#125;\n&#125;\n\npublic static TSource First&lt;TSource&gt;(\n    this IEnumerable&lt;TSource&gt; source,\n    Func&lt;TSource, bool&gt; predicate)\n&#123;\n    // Argument validation elided\n    foreach (TSource item in source)\n    &#123;\n        if (predicate(item))\n        &#123;\n            return item;\n        &#125;\n    &#125;\n    throw new InvalidOperationException(&quot;No items matched the predicate&quot;);\n&#125;\n\n这两个实现看起来差异很大，这是我有意为之的。对于没有谓词的重载，我也可以用  foreach  来实现的，就从  foreach的循环体中无条件的返回就可以了。然而，我想要强调我们在  First中不需要循环遍历。我们只需要移向第一个元素，然后返回就可以了，如果无法移向第一个元素则抛出异常。没有任何迹象显示我们会再次调用  MoveNext。而对于有谓词的重载，我们必须一直循环遍历直到找到一个符合谓词的元素，我们只在遍历完所有元素而找不到符合谓词的元素时才抛出异常。\n下面我们来看看当序列为空时如何返回默认值：\npublic static TSource FirstOrDefault&lt;TSource&gt;(\n    this IEnumerable&lt;TSource&gt; source)\n&#123;\n    // Argument validation elided\n    using (IEnumerator&lt;TSource&gt; iterator = source.GetEnumerator())\n    &#123;\n        return iterator.MoveNext() ? iterator.Current : default(TSource);\n    &#125;\n&#125;\n\npublic static TSource FirstOrDefault&lt;TSource&gt;(\n    this IEnumerable&lt;TSource&gt; source,\n    Func&lt;TSource, bool&gt; predicate)\n&#123;\n    // Argument validation elided\n    foreach (TSource item in source)\n    &#123;\n        if (predicate(item))\n        &#123;\n            return item;\n        &#125;\n    &#125;\n    return default(TSource);\n&#125;\n\n这个有谓词的  FirstOrDefault  看起来和有谓词的  First  非常相似，但是没有谓词的  FirstOrDefault  和没有谓词的First  却有点细微的差别：我们在这里没有用  if  语句而是用了三元运算符（虽然说用  if也是完全可以的）。不管能否移向第一个元素，我们都需要返回值。如果三元运算符允许第二个或第三个操作对象为  throw语句就好了，但是即使不能的话也不是什么大问题。\n接下来我们来实现  Single  ，它在某些方面与  First  的相似性比  Last  与  First  的相似性更大：\npublic static TSource Single&lt;TSource&gt;(\n    this IEnumerable&lt;TSource&gt; source)\n&#123;\n    // Argument validation elided\n    using (IEnumerator&lt;TSource&gt; iterator = source.GetEnumerator())\n    &#123;\n        if (!iterator.MoveNext())\n        &#123;\n            throw new InvalidOperationException(&quot;Sequence was empty&quot;);\n        &#125;\n        TSource ret = iterator.Current;\n        if (iterator.MoveNext())\n        &#123;\n            throw new InvalidOperationException(&quot;Sequence contained multiple elements&quot;);\n        &#125;\n        return ret;\n    &#125;\n&#125;\n\npublic static TSource Single&lt;TSource&gt;(\n    this IEnumerable&lt;TSource&gt; source,\n    Func&lt;TSource, bool&gt; predicate)\n&#123;\n    // Argument validation elided\n    TSource ret = default(TSource);\n    bool foundAny = false;\n    foreach (TSource item in source)\n    &#123;\n        if (predicate(item))\n        &#123;\n            if (foundAny)\n            &#123;\n                throw new InvalidOperationException(&quot;Sequence contained multiple matching elements&quot;);\n            &#125;\n            foundAny = true;\n            ret = item;\n        &#125;\n    &#125;\n    if (!foundAny)\n    &#123;\n        throw new InvalidOperationException(&quot;No items matched the predicate&quot;);\n    &#125;\n    return ret;\n&#125;\n\n这个比  First  复杂多了。没有谓词的重载的开头和  First  的开头一样，不同的是如果能够成功的移向第一个元素的话，我们需要记住第一个元素的值（因为我们可能需要返回该值）然后试着移向第二个元素。如果可以移向第二个元素，就要抛出异常，如果不能移向第二个元素，那就可以返回刚才记录下的值。\n有谓词的重载更麻烦。我们依然需要记住第一个找到的符合谓词的值，不过因为这次我们在循环，我们还需要记住是否已经找到过一个符合谓词的值了。如果能够找到第二个符合谓词的值，就必须抛异常。如果一个符合谓词的值都找不到，也要抛异常。请注意，尽管我们给  ret  赋了一个  default(TSource)的初值，但是我们的  return  语句执行时  ret  肯定不会是初值的状态。然而，  C#的明确赋值的语法无法理解这一点，所以我们需要给  ret  一个“傀儡”式的初值，而  default  (T)是唯一可以用的值。有另外一种不用foreach  的实现方法：遍历序列直到找到第一个符合谓词的元素，此时声明一个局部变量并且把找到的元素赋值给该变量，然后再开始另一个循环，以确保不能再找到其他符合谓词的值了。我个人觉得这种方式太复杂了，所以我选择了用  foreach  的方式。\n下面实现  SingleOrDefault  的两个重载，这两个重载之间的差别就不是那么大了：\npublic static TSource SingleOrDefault&lt;TSource&gt;(\n    this IEnumerable&lt;TSource&gt; source)\n&#123;\n    // Argument validation elided\n    using (IEnumerator&lt;TSource&gt; iterator = source.GetEnumerator())\n    &#123;\n        if (!iterator.MoveNext())\n        &#123;\n            return default(TSource);\n        &#125;\n        TSource ret = iterator.Current;\n        if (iterator.MoveNext())\n        &#123;\n            throw new InvalidOperationException(&quot;Sequence contained multiple elements&quot;);\n        &#125;\n        return ret;\n    &#125;\n&#125;\n\npublic static TSource SingleOrDefault&lt;TSource&gt;(\n    this IEnumerable&lt;TSource&gt; source,\n    Func&lt;TSource, bool&gt; predicate)\n&#123;\n    // Argument validation elided\n    TSource ret = default(TSource);\n    bool foundAny = false;\n    foreach (TSource item in source)\n    &#123;\n        if (predicate(item))\n        &#123;\n            if (foundAny)\n            &#123;\n                throw new InvalidOperationException(&quot;Sequence contained multiple matching elements&quot;);\n            &#125;\n            foundAny = true;\n            ret = item;\n        &#125;\n    &#125;\n    return ret;\n&#125;\n\n这次我们只是把没有谓词的重载里的  throw  语句替换成了  return  语句，并且在有谓词的重载中移除了没有找到符合谓词的元素的判断。我们在这里给ret  赋以初值是有好处的，因为如果后面的代码不会给  ret  赋以其他值，那么  ret  已经有了正确的返回值了。\n下一个是  Last  ：\npublic static TSource Last&lt;TSource&gt;(\n    this IEnumerable&lt;TSource&gt; source)\n&#123;\n    // Argument validation elided\n    IList&lt;TSource&gt; list = source as IList&lt;TSource&gt;;\n    if (list != null)\n    &#123;\n        if (list.Count == 0)\n        &#123;\n            throw new InvalidOperationException(&quot;Sequence was empty&quot;);\n        &#125;\n        return list[list.Count - 1];\n    &#125;\n\n    using (IEnumerator&lt;TSource&gt; iterator = source.GetEnumerator())\n    &#123;\n        if (!iterator.MoveNext())\n        &#123;\n            throw new InvalidOperationException(&quot;Sequence was empty&quot;);\n        &#125;\n        TSource last = iterator.Current;\n        while (iterator.MoveNext())\n        &#123;\n            last = iterator.Current;\n        &#125;\n        return last;\n    &#125;\n&#125;\n\npublic static TSource Last&lt;TSource&gt;(\n    this IEnumerable&lt;TSource&gt; source,\n    Func&lt;TSource, bool&gt; predicate)\n&#123;\n    // Argument validation elided\n    bool foundAny = false;\n    TSource last = default(TSource);\n    foreach (TSource item in source)\n    &#123;\n        if (predicate(item))\n        &#123;\n            foundAny = true;\n            last = item;\n        &#125;\n    &#125;\n    if (!foundAny)\n    &#123;\n        throw new InvalidOperationException(&quot;No items matched the predicate&quot;);\n    &#125;\n    return last;\n&#125;\n\n我们从没有谓词的方法开头的优化谈起吧。如果输入序列是个列表的话，我们可以获取列表的元素数量，然后根据元素数量的不同，或者是抛出异常或者是返回索引最大的元素。如果还要再优化一点的话，我可以把  Count  值存到一个局部变量里，但是我假设获取  IList的  Count的代价是很低的。如果有哪位对这一点持反对意见，我很愿意做出修改：）请注意，我还假设了另一个情况，实现IList的类型含有的元素不会超过Int32.MaxValue，否则的话，这个优化就会失败。\n如果不做优化的话，我们可以遍历整个序列，每次迭代都用最新访问到的元素来更新一个局部变量的值。我在这里没有用  foreach  ，但是并没有什么特别的原因–  我们其实也可以用  foreach  ，每次的迭代都把一个叫做  foundAny  的变量设为  true  ，然后在最后测试foundAny  的值。实际上，上面所描述的就正是有谓词的方法所采用的方式。不许得承认，采用这个方式在一定程度上是不得已而为之  –  我们不能调用MoveNext  然后把获取到的值存起来，因为这个值有可能不符合谓词的约束。\nLast  的有谓词的重载没有优化，这是  LINQ to Objects  （官方实现）的做法，但是我不知道这么做的原因。我们可以利用索引器来从后向前反向遍历。有一个可能的解释是：谓词在处理某些值时有可能会抛出异常，如果我们在处理实现了IList的序列的时候直接跳到序列尾部的话，就会造成可观察的差别。我很想知道这是不是真的原因  –如果哪位能够提供内部信息的话，我会更新这篇博文。\n现在，我们就只有一个操作符需要实现了  –LastOrDefault  ：\npublic static TSource LastOrDefault&lt;TSource&gt;(\n    this IEnumerable&lt;TSource&gt; source)\n&#123;\n    // Argument validation elided\n    IList&lt;TSource&gt; list = source as IList&lt;TSource&gt;;\n    if (list != null)\n    &#123;\n        return list.Count == 0 ? default(TSource) : list[list.Count - 1];\n    &#125;\n\n    TSource last = default(TSource);\n    foreach (TSource item in source)\n    &#123;\n        last = item;\n    &#125;\n    return last;\n&#125;\n\npublic static TSource LastOrDefault&lt;TSource&gt;(\n    this IEnumerable&lt;TSource&gt; source,\n    Func&lt;TSource, bool&gt; predicate)\n&#123;\n    // Argument validation elided\n    TSource last = default(TSource);\n    foreach (TSource item in source)\n    &#123;\n        if (predicate(item))\n        &#123;\n            last = item;\n        &#125;\n    &#125;\n    return last;\n&#125;\n\n除了优化的部分，有谓词的和没有谓词的方法看起来很相似…比其他操作符的两个重载之间的差异要小。两个重载中，我们都是先定义一个返回值，并赋值为default  (TSource)，然后遍历整个序列，并更新返回值，如果有谓词的话，就仅当元素符合谓词时才更新返回值。\n结论我今早起床时没料到这篇博文会写的这么长，不过我希望上述的各个实现之间的差异和”Last&#x2F;LastOrDefault”没有优化的怪事能够值得这么多的辛苦。\n虽然前面提到了  DefaultIfEmpty  ，但是我准备下次再实现它。虽然说如果今晚抓紧的话，还是可以做完的  …\n附录我发现在  LINQ to Objects  （官方实现）中，  Single  和  SingleOrDefault没有谓词的重载在遇到第二个元素时马上就会抛出异常。但是有谓词的重载即使遇到了第二个元素，还是会继续遍历。这看起来很是荒唐，没有连贯性。我发了一个  Connect issue，我们看看会有怎样的答复。\n\n\n\n\n","tags":["LinQ"]},{"title":"自己动手重新实现LINQ to Objects 12 - DefaultIfEmpty","url":"/blog/2012/04/10/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0LINQ%20to%20Objects12%20-%20DefaultIfEmpty/","content":"本文翻译自   Jon Skeet   的系列博文”Edulinq”。\n本篇原文地址：\n http://msmvps.com/blogs/jon_skeet&#x2F;archive&#x2F;2010&#x2F;12&#x2F;29&#x2F;reimplementing-linq-to-objects-part-12-defaultifempty.aspx\n上次实现  First  &#x2F;  Last的时候写了大量的代码，相比起来，今天要讲的  DefaultIfEmpty  就轻松多了。\nDefaultIfEmpty是什么？这个操作符虽然简单，但是还是有   两个重载   ：\npublic static IEnumerable &lt; TSource &gt; DefaultIfEmpty &lt; TSource &gt; (this IEnumerable &lt; TSource &gt; source)public static IEnumerable &lt; TSource &gt; DefaultIfEmpty &lt; TSource &gt; (this IEnumerable &lt; TSource &gt; source, TSource defaultValue)\n\n这个操作符的行为很容易描述：\n\n如果输入序列是空序列的话，那么返回序列中仅包含一个默认值。这个默认值在第一个重载中是  default  (T)  ，在第二个重载中是第二个参数的值。\n\n如果输入序列不是空序列的话，那么输出序列和输入序列相同。\n\n输入序列不能为  null，这个参数检验是立即执行的。\n\n输出序列是延迟执行的  –  除非读取输出序列，否则输入序列不会被读取。\n\n输入序列是流式处理的；所有被读取的值都是立即  yield  返回的；没有缓存。\n\n\n非常简单。\n我们需要测试些什么？虽然天有点晚了，但是我还是决定要对参数检验进行测试  –这件事其实不可小视，我第一次试着把参数检验的代码和真正迭代的代码分开到两个方法的尝试就失败了！由此可见，疏忽是多么容易出现的事啊。\n除了参数检验外，我只找到四个值得测试的地方：\n\n不接受默认值参数的重载，输入序列为空序列的情况\n\n接受默认值参数的重载，输入序列为空序列的情况\n\n不接受默认值参数的重载，输入序列不为空序列的情况\n\n接受默认值参数的重载，输入序列不为空序列的情况\n\n\n这些就是所有的测试用例。我没有测试流式处理，惰性求值，等等。\n来动手实现吧！虽然我不愿意依赖于一个操作符来实现另一个操作符，但是这里这两个操作符之间的关系实在是太明显了，所以我决定就破例一次。我甚至给参数检验实施了  DRY的原则，但是实现还是只有这么简短：\npublic static IEnumerable &lt; TSource &gt; DefaultIfEmpty &lt; TSource &gt; ( this IEnumerable &lt; TSource &gt; source) &#123; // This will perform an appropriate test for source being null first. return source.DefaultIfEmpty(  default (TSource));&#125;public static IEnumerable &lt; TSource &gt; DefaultIfEmpty &lt; TSource &gt; ( this IEnumerable &lt; TSource &gt; source, TSource defaultValue) &#123; if (source == null) &#123;  throw new ArgumentNullException(&quot;source&quot;); &#125; return DefaultIfEmptyImpl(source, defaultValue);&#125;private static IEnumerable &lt; TSource &gt; DefaultIfEmptyImpl &lt; TSource &gt; ( IEnumerable &lt; TSource &gt; source, TSource defaultValue) &#123; bool foundAny = false; foreach(TSource item in source) &#123;  yield  return item;  foundAny = true; &#125; if (!foundAny) &#123;  yield  return defaultValue; &#125;&#125;\n\n现在有人应该会发现一个  bug  …\n除了在较简单的重载中使用  default  (TSource)来调用较复杂的重载外，唯一有点意思的就是最下面的那个方法了。这个方法让我感觉有些不爽，因为它会在每次迭代时都重新给  foundAny  赋值为  true…  但是，如果不这么做的话，那实现起来也很难看：\nprivate static IEnumerable &lt; TSource &gt; DefaultIfEmptyImpl &lt; TSource &gt; ( IEnumerable &lt; TSource &gt; source, TSource defaultValue) &#123; using(IEnumerator &lt; TSource &gt; iterator = source.GetEnumerator()) &#123;  if (!iterator.MoveNext()) &#123;   yield   return defaultValue;   yield   break; // Like a &quot;return&quot;  &#125;  yield  return iterator.Current;  while (iterator.MoveNext()) &#123;   yield   return iterator.Current;  &#125; &#125;&#125;\n\n这种实现或许会稍微高效一点，但是看起来很笨拙。我们可以把  yield break  后面的代码放到  else  里面，这样就可以去掉  yieldbreak  这一句了，但是这种方法我也不是很喜欢。我们可以用  do  &#x2F;while  循环来替换掉  while  循环，那样可以避免“  yieldreturn iterator  .Current  ”的重复出现。但是我也不是很喜欢  do&#x2F;while  循环。我很少用  do&#x2F;while，以至于我读  do&#x2F;while  的代码时要稍微费点力。\n结论除了最后一部分缺少优雅性而让人有点不爽之外，其他地方都没什么有趣的。不过，我们现在可以通过  DefaultIfEmpty  来实现FirstOrDefault&#x2F;LastOrDefault  和  SingleOrDefault  了。比如说，下面是  FirstOrDefault的实现：\npublic static TSource FirstOrDefault &lt; TSource &gt; ( this IEnumerable &lt; TSource &gt; source) &#123; return source.DefaultIfEmpty().First();&#125;public static TSource FirstOrDefault &lt; TSource &gt; ( this IEnumerable &lt; TSource &gt; source, Func &lt; TSource, bool &gt; predicate) &#123; // Can&#x27;t just use source.DefaultIfEmpty().First(predicate) return source.Where(predicate).DefaultIfEmpty().First();&#125;\n\n请注意有谓词的重载中的注释，对  DefaultIfEmpty  的调用需要放在谓词的执行之后  …  不然的话，如果我们传入一个空序列和一个不能让default  (TSource)  通过的谓词，那就会触发一个异常，而得不到默认值了。  LastOrDefault  和SingleOrDefault  也可以通过类似的方式来实现。\n我现在不确定下次要实现哪个操作符。我明早看看会不会有哪个特殊的方法让我获得灵感。\n\n\n\n\n","tags":["LinQ"]},{"title":"测试","url":"/blog/2013/03/04/ce-shi/","content":"测试发布文章\n测试修改\n再次修改\n好久没用了，还能更新吗？test\nis it fixed 10?\n\n\n\n\n"},{"title":"用豆瓣读书Chrome插件，简单购买电子书","url":"/blog/2013/04/01/doubanebookprice/","content":"为什么要做这款插件？在豆瓣上查看一本书的时候，页面的右侧会显示哪些网站可以购买该书以及各自的价格。比如这本《乡关何处》，页面右侧显示了亚马逊，京东，当当等网站的购买链接。\n\n但是豆瓣只会提供纸质书的购买链接，不提供电子书的。除非该书豆瓣自己有售。所以我写了个Chrome的插件来解决这个问题。\n这款插件怎么用？这款插件会在每个图书页面上添加正版电子书的购买链接及其价格。您只需点击链接去购买就好了。\n在Chrome中加载这个插件之后，再访问豆瓣的《乡关何处》的页面，右侧会多出三个链接：\n\n淘宝，多看和亚马逊中文站都卖这本书的电子版。看，纸质书要卖19.2，豆瓣电子书要卖11，多看只要6块钱，噢耶！节省纸张又省钱。\n很多英文原版书在国内卖得很贵，所以这款插件也支持一些国外网站。比如这本《The Pragmatic Programmer》：\n\n原版纸质书亚马逊要卖351，澜瑞外文要卖487，吃人啊！亚马逊英文站的纸质版的售价折合成人民币也要180多，再加运费……\n而电子版则要便宜很多，看截图上的红圈，最便宜的折合人民币只要130左右，嗯，还是有点贵，不过如果想读原版的话，这个kindle版是最好的选择了。\n这款插件现在支持以下的电子书销售商：\n\n多看\n唐茶\n亚马逊kindle中文站\n淘宝\n京东\n亚马逊kindle美国站\nkobo\nnook\n\n如何实现的？是用JavaScript写的。\n基本实现思路是这样的：\n\n获取当前图书的ISBN号码\n根据ISBN去上面罗列的几家网站上搜索是否有这本书\n如果有的话，显示在右侧\n\n例外情况：\n\n有些网站不支持ISBN搜索，对于这些网站直接用书名和作者名搜索的，所以结果有时不太准。\n有时一本书的纸质版的ISBN和电子版的ISBN不同，所以实现中用到了google books的API来获取电子版的ISBN，然后再搜索。\n\n主要技术：knockoutjs和jQuery。\n插件下载和源码插件下载地址：chrome store\n源码：github\nDisclaimer插件的实现中违反了豆瓣API的协议（豆瓣不允许其API的使用者利用豆瓣的数据产生其他网站的购买信息）。如果您对这点很敏感，请慎用。\n\n\n\n\n","tags":["豆瓣","读书"]},{"title":"如何一步一步推导出Y Combinator","url":"/blog/2013/04/09/make-y/","content":"本文讲什么？本文用Scheme（Racket）代码为例，一步一步的推出Y Combinator的实现。\n本文不讲什么？Y Combinator是什么，干什么用的，它为什么能够work，它的数学含义以及实际应用场景，这些话题由于篇幅所限（咳咳，楼主的无知）不在本文论述范围之内。\n如果有兴趣，请参考维基： http://en.wikipedia.org/wiki/Fixed-point_combinator#Y_combinator\n鸣谢感谢Jojo同学的这段JavaScript代码的启发，我写了对应的Scheme实现。然后才有了本文。\n正文开始我们知道Y Combinator可以帮匿名函数实现递归。那就从一个广为人知的递归函数-阶乘开始吧。\n(define (fac1 n)  (if (&lt; n 2) 1      (* n (fac1 (- n 1)))))\n\n如果n小于2，则返回1，否则开始递归，简单明了。如果像这样调用它一下：\n(fac1 5)\n\n会返回120，结果无误。\n上面是阶乘的递归实现，它有一个名字叫做fac1，但是如果用匿名函数实现阶乘呢？\n(lambda (f)   (lambda (n)     (if (&lt; n 2) 1        (* n (f (- n 1))))))\n\n这个匿名函数“梦想着”其调用者会把该函数自己的实现作为参数传递进去。\n(((lambda (f)     (lambda (n)       (if (&lt; n 2) 1          (* n (f (- n 1))))))   (lambda (f)     (lambda (n)       (if (&lt; n 2) 1          (* n (f (- n 1))))))) 1)\n\n我们把匿名函数重复写一遍，就可以计算1或者是0的阶乘，但是要计算3的阶乘呢？那就得这么写：\n(((lambda (f)     (lambda (n)       (if (&lt; n 2) 1          (* n (f (- n 1))))))   ((lambda (f)      (lambda (n)        (if (&lt; n 2) 1           (* n (f (- n 1))))))    ((lambda (f)       (lambda (n)         (if (&lt; n 2) 1            (* n (f (- n 1))))))     (lambda (f)       (lambda (n)         (if (&lt; n 2) 1            (* n (f (- n 1))))))))) 3)\n\n想要计算一个大于2的n的阶乘，就得把这个匿名函数重复写n+1次。这么多的重复代码，这么多的括号。。。\n所以我们需要一个神奇的函数，Y，它可以接受一个匿名的伪递归函数作为参数，产出一个真递归的函数。这个神奇的Y作用在上面的匿名函数上之后产出的结果就可以用来计算任何n的阶乘。下面的代码会输出120（如果Y已经实现了的话）。\n((Y (lambda (f)        (lambda (n)          (if (&lt; n 2) 1             (* n (f (- n 1))))))) 5)\n\n下面就开始一步步的构造这个神奇的Y吧。\n为了便于推导，暂时给这个匿名函数一个名字，叫做fake_fac。\n(define fake_fac   (lambda (f)     (lambda (n)       (if (&lt; n 2) 1          (* n (f (- n 1)))))))\n\n有了这个名字之后，再要计算3的阶乘就容易了一些。\n((fake_fac (fake_fac (fake_fac fake_fac))) 3)\n\n观察上面的代码，我们把fake_fac传递给它自己，得到一个返回值，把这个返回的值再次传递给fake_fac，再得到一个新的返回值，又把新的返回值传递给fake_fac，得到最终的返回值，最后把3传递给这个返回值。\n可以看到，我们在不停的把fake_rec传给它自己，所以定义一个helper吧：\n(define (callself f) (f f))\n\n这个helper一会儿会派上用场。\n现在看看fake_fac中的f是什么呢？对于((fake_fac (fake_fac (fake_fac fake_fac))) 3)这行代码中的最右侧的fake_fac来说，f没有用，因为这个fake_fac自己都没有被调到，它只是起个占位符的作用，实际上这行代码((fake_fac (fake_fac (fake_fac 1))) 3)和上面的那行是等价的。\n对于右侧第二个fake_fac来说，f就是fake_fac。对于左侧第二个fake_fac来说，f是(fake_fac fake_fac)的返回值。\n对于左侧第一个fake_fac来说，f是(fake_fac (fake_fac fake_fac))的返回值。\n由此可见，f是fake_fac对自己反复调用的返回值。而且从fake_fac的定义可见，我们总是给f传递一个数字n，这样的话，我们再写一个helper：\n(lambda (n) ((f f) n))\n\n再把这个helper传递给fake_fac。\n(fake_fac (lambda (n) ((f f) n)))\n\n但是上面这两段代码是有问题的，因为f的值无法确定。\n有句话说的好：if you don’t know exactly what you want to put somewhere in a piece of code, just abstract it out and make it a parameter of a function.所以我们就把f抽成参数吧。\n(define (callselfWithN f)  (fake_fac (lambda (n) ((f f) n))))\n\n我们希望这个helper可以帮fake_fac无限次的调用自己。\n现在，我们该怎么调用callselfWithN呢？不能把fake_fac传给它，因为那样的话(f f)就只是fake_fac对自己的调用，它只能计算0或者1的阶乘。所以要把callselfWithN这个我们希望可以帮fake_fac实现无限次自调用的函数传给callselfWithN它自己。\n((callselfWithN callselfWithN) 5)\n\n这行代码可以返回120，结果正确了！\n记得前面定义的第一个helper吗？现在用的上了：\n((callself callselfWithN) 5)\n\n现在把callselfWithN带入：\n((callself  (lambda (f)  (fake_fac (lambda (n) ((f f) n))))) 5)\n\n可以看出，这段代码和fake_fac是紧耦合的，把它抽到参数上去：\n(define (Y3 fake_recur)  (callself  (lambda (f)               (fake_recur (lambda (n) ((f f) n))))))\n\n然后再把callself也带入：\n(define Y (lambda (fake_recur)             ((lambda (f) (f f))              (lambda (f)                (fake_recur                 (lambda (n) ((f f) n)))))))\n\n现在Y不依赖于任何其他函数了，测试一下Y，把前面的计算阶乘的匿名函数传给它：\n((Y (lambda (f)       (lambda (n)         (if (&lt; n 2) 1            (* n (f (- n 1))))))) 5)\n\n能够返回120，正确！Y Combinator构造完成！\n\n\n\n\n","tags":["Y","FP"]},{"title":"Scala中的语言特性是如何实现的(2)","url":"/blog/2013/05/11/scala-language-features-2/","content":"上篇博文的末尾留了三个问题，现在自问自答一下。\n在Scala中被声明为val的v4为什么在反编译的Java中不是final的呢？在方法中声明局部变量时，如果用Scala的val关键字（或者是Java中的final）来修饰变量，则代表着此变量在赋过初始值之后不可以再被重新赋值。这个val或者final只是给编译器用的，编译器如果发现你给此变量重新赋值会抛出错误。\n而bytecode不具备表达一个局部变量是immutable的能力，也就是说对于JVM来说，不存在不可变的局部变量这个概念。所以v4在反编译之后，就和普通的局部变量无异了。\n在Scala中被声明为val的v2为什么在反编译的C#中不是readonly的呢？这是个挺tricky的问题，我试着解释一下。Scala .NET是基于IKVM实现的，IKVM可以把Java bytecode翻译为CIL。所以Scala编译为CIL的过程实际是这样的：\nScala —–Scala编译器—–&gt; bytecode —–IKVM—–&gt; CIL\nScala编译器编译出的bytecode实际是用final修饰了v2的，但是bytecode中的final和CIL中的initonly（对应C#的readonly）是不一样的。\nJava中，final实例变量定义的时候，可以先声明，而不给初值，然后我们可以在任何一个方法中给它赋初值。这提供了更大的灵活性，一个Java类中的final成员可以依对象而不同，却保持其immutable的特征。\n而CIL的initonly则要严格一点，CLI标准（ECMA-334）这样描述：\n\ninitonly marks fields which are constant after they are initialized. These fields shall only be mutated inside a constructor. If the field is a static field, then it shall be mutated only inside the type initializer of the type in which it was declared. If it is an instance field, then it shall be mutated only in one of the instance constructors of the type in which it was defined. It shall not be mutated in any other method or in any other constructor, including constructors of derived classes.\n\n可见，一个initonly的成员，不是随便在哪儿都可以赋初值的。由于这点不同IKVM就没有直接把final翻译成initonly。如果想让v2在C#代码中变成readonly的，可以给IKVM加上strictfinalfieldsemantics这个参数。\n为什么反编译出来的C#代码中的实例级公开方法都是标有override的呢？这个问题还没搞明白。\n但是有个有趣的现象，如果用Scala .NET来编译Scala源码，编译出的实例级方法都是标有override的；而如果先把Scala代码编译为.class然后再用IKVM把.class文件转换为CIL的话，方法则是标有virtual的。我猜这可能和Java中的方法默认是可以被overirde的有关。\n下面开始正文，前面填坑用了不少篇幅，所以这次只分析一个语言特性：Scala中的constructor。\n##Constructor\nScala中可以在声明class的同时声明一个constructor，比如这样：\nclass ScalaConstructorExample(val x: Double, y: String) &#123;  println(x + y)&#125;\n\n构造函数接收两个参数x和y，然后把x和y拼在一起打印出来。反编译为Java：\npublic class ScalaConstructorExample&#123;  private final double x;  public double x()  &#123;    return this.x;  &#125;  public ScalaConstructorExample(double x, String y)  &#123;    Predef..MODULE$.println(new StringBuilder().append(x).append(y).toString());  &#125;&#125;\n\n可以发现编译器给标为val的x生成了一个getter，很方便的语法糖。而直接写在类内的打印语句则被放到了构造函数内。下面是反编译为C#的代码：\npublic class ScalaConstructorExample : ScalaObject&#123;\tprivate double x = x;\tpublic override double x()\t&#123;\t\treturn this.x;\t&#125;\tpublic ScalaConstructorExample(double x, string y)\t&#123;\t\tPredef$.MODULE$.println(new StringBuilder().Append(x).Append(y).ToString());\t&#125;&#125;\n和Java代码基本无异。比较一下，Scala用3行代码表达的含义，Java和C#要用14行才行。\n现在加一个重载的构造函数：\nclass ScalaConstructorExample(val x: Double, y: String) &#123;  println(x + y)  def this(x: Double) = &#123;  \tthis(x, &quot;hello&quot;)  &#125;&#125;\n\n这个构造函数给了y一个默认值“hello”。反编译为Java：\npublic class ScalaConstructorExample&#123;  private final double x;  public double x()  &#123;    return this.x;  &#125;  public ScalaConstructorExample(double x, String y)  &#123;  \tPredef..MODULE$.println(new StringBuilder().append(x).append(y).toString());  &#125;  public ScalaConstructorExample(double x)  &#123;    this(x, &quot;hello&quot;);  &#125;&#125;\n\n对应的C#代码：\npublic class ScalaConstructorExample : ScalaObject&#123;\tprivate double x = x;\tpublic override double x()\t&#123;\t\treturn this.x;\t&#125;\tpublic ScalaConstructorExample(double x, string y)\t&#123;\t\tPredef$.MODULE$.println(new StringBuilder().Append(x).Append(y).ToString());\t&#125;\tpublic ScalaConstructorExample(double x) : this(x, &quot;hello&quot;)\t&#123;\t&#125;&#125;\n\n构造函数重载这个特性就显得平淡无奇了，不过还是比较一下行数。定义两个构造函数，打印出构造函数的参数，声明一个getter，这三件事Scala只用7行代码就完成了，Java和C#都需要将近20行。\n\n\n\n\n","tags":["Desugar_Scala","Scala"]},{"title":"去掉Scala的糖衣(4) -- type aliase","url":"/blog/2013/12/23/desugar-scala-4/","content":"Scala中有一个type关键字，用来给类型或者是操作起别名，用起来很是方便。\n比如这样：\ntype People = List[Person]\n\n这样就是给List[Person]（方括号是Scala的类型参数的写法）声明了一个别名，叫做People。\n接下来就可以这样使用它：\ndef teenagers(people: People): People = &#123;  people.filter(person =&gt; person.age &lt; 20)&#125;\n\n这个代码编译之后没有什么神奇的，仅仅是把所有出现People这个字眼的地方都用List of Person替代了。\npublic List&lt;Person&gt; teenagers(List&lt;Person&gt; people)&#123;  return (List)people.filter(new AbstractFunction1() &#123; public static final long serialVersionUID = 0L;    public final boolean apply(Person person) &#123; return person.age() &lt; 20; &#125;  &#125;);&#125;\n\n这种给类型一个别名的特性只是一个小糖豆，不太甜，真正有趣的是给一类操作命名（联想C#中定义delegate）。\n比如这样：\ntype PersonPredicate = Person =&gt; Boolean\n\n接受一个Person，返回一个Boolean，我们把这一类用来判断一个人是否符合某个条件的操作统称为PersonPredicate。\n然后我们可以定义以下predicate：\nval teenagerPred: PersonPredicate = person =&gt; person.age &lt; 20\n\n然后前面写过的teenagers方法就可以这样重新定义：\ndef teenagers(people: People): People = &#123;  people.filter(teenagerPred)&#125;\n\n按照这个思路下去，我们就可以开始composite functions了。比如说，我们跟人收税，就可以这么做：\ntype Tax = Person =&gt; Doubleval incomeTax: Tax = person =&gt; person.income * 5 / 100val kejuanzaTax: Tax = person =&gt; person.income * 20 / 100def giveMeYourMoney(p: Person) = &#123;  calculateTax(p, List(incomeTax, kejuanzaTax))&#125;def calculateTax(person: Person, taxes: List[Tax]): Double = &#123;  taxes.foldLeft(0d) &#123;    (acc, curTax) =&gt; acc + curTax(person)  &#125;&#125;\n\n从一个人那里拿到钱，这种操作，我们称之为Tax。然后定义个税和苛捐杂税，或者也可以有任意多的税种。\n然后就可以把任意的几个税种放在一个List里面，和calculateTax去composite了。\n当然，没有type这个关键字，我们也可以composite functions。只不过就得写成这样：\nval teenagerPred: (Person) =&gt; Boolean = person =&gt; person.age &lt; 20def incomeTax: (Person) =&gt; Double = person =&gt; person.income * 5 / 100\n\n看着稍微有点眼花。\n这种用type关键字给一种操作命名的代码反编译之后是这样的：\npublic Function1&lt;Person, Object&gt; teenagerPred()&#123;  return new AbstractFunction1() &#123; public static final long serialVersionUID = 0L;    public final boolean apply(Person person) &#123; return person.age() &lt; 20; &#125;  &#125; ;&#125;public Function1&lt;Person, Object&gt; incomeTax()&#123;  return new AbstractFunction1() &#123; public static final long serialVersionUID = 0L;    public final double apply(Person person) &#123; return person.income() * 5 / 100; &#125;  &#125; ;&#125;public Function1&lt;Person, Object&gt; kejuanzaTax()&#123;\treturn new AbstractFunction1() &#123; public static final long serialVersionUID = 0L;  public final double apply(Person person) &#123; return person.income() * 20 / 100; &#125; &#125; ;&#125;\n\n可以看到所有这种接受一个参数，返回一个值的操作都是Function1&lt;Person, Object&gt;。\n推测一下，接受两个参数，返回一个值的是不是该叫做Function2呢？\ntype TwoToOne = (String, Int) =&gt; Doubledef twoToOneImpl: TwoToOne = (str, i) =&gt; 1\n\n反编译之后，果不其然：\npublic Function2&lt;String, Object, Object&gt; twoToOneImpl()&#123;  return new Hello..anonfun.twoToOneImpl.1(this);&#125;\n\n那不接收参数，只有返回值的呢？\ntype NoInJustOut = () =&gt; Stringdef noInJustOutImpl: NoInJustOut = () =&gt; &quot;hello world&quot;\n\n反编译之后，其实是变成了Function0 of String:\npublic Function0&lt;String&gt; noInJustOutImpl()&#123;  return new Hello..anonfun.noInJustOutImpl.1(this);&#125;\n\n到这里，我们可以总结一下type alia这个糖衣：\n一个类型的type alias，类似于这样的：type t &#x3D; x。编译器将在所有使用到t的地方把t替换为x。\n对于一种操作的type alias，编译器将会根据参数列表和返回值类型的不同将其替换为对应的Function0,Function1,Function2 …… 一直到Function22。\n如果我们真的定义一个超过二十二个参数的操作会如何呢？\ntype twentyThree = (    String, String, String, String,    String, String, String, String,    String, String, String, String,    String, String, String, String,    String, String, String, String,    String, String, String  ) =&gt; String\n\nScala编译器会直接告诉我们：type Function23 is not a member of package scala\n\n\n\n\n","tags":["Desugar_Scala","Scala"]},{"title":"Scala中的语言特性是如何实现的(1)","url":"/blog/2013/05/05/how-are-scala-language-features-implemented/","content":"Scala可以编译为Java bytecode和CIL，从而在JVM和CLI之上运行。Scala有很多在Java和C#的世界中显得陌生的语言特性，本文将分析这些语言特性是如何实现的。\nobjectScala中可以像这样创建object：\nobject HowIsObjectImplementedInScala &#123;  def printSomething() &#123;    println(&quot;printSomething&quot;)  &#125;&#125;\n然后在代码的其他地方调用printSomething，一个object究竟是什么东西呢？我们将这段Scala编译为Java bytecode，然后反编译为Java，会发现编译器为HowIsObjectImplementedInScala这个object生成了两个类：\npublic final class HowIsObjectImplementedInScala&#123;  public static void printSomething()  &#123;    HowIsObjectImplementedInScala..MODULE$.printSomething();  &#125;&#125;public final class HowIsObjectImplementedInScala$&#123;  public static final  MODULE$;  static  &#123;    new ();  &#125;  public void printSomething()  &#123;    Predef..MODULE$.println(&quot;printSomething&quot;);  &#125;  private HowIsObjectImplementedInScala$()  &#123;    MODULE$ = this;  &#125;&#125;\n\n第一个类只包含一个静态方法，其实现依赖于第二个叫做HowIsObjectImplementedInScala$的类。\nHowIsObjectImplementedInScala$是一个单例，其静态块实例化自己并把this赋值给MODULE$这个public static的成员，从而可以被外界访问。\n同样，我们可以把这段代码编译为CIL，然后反编译为C#:\npublic sealed class HowIsObjectImplementedInScala&#123;  public static void printSomething()  &#123;    HowIsObjectImplementedInScala$.MODULE$.printSomething();  &#125;&#125;public sealed class HowIsObjectImplementedInScala$ : ScalaObject&#123;  public static HowIsObjectImplementedInScala$ MODULE$;  public override void printSomething()  &#123;    Predef$.MODULE$.println(&quot;printSomething&quot;);  &#125;  private HowIsObjectImplementedInScala$()  &#123;    HowIsObjectImplementedInScala$.MODULE$ = this;  &#125;  static HowIsObjectImplementedInScala$()  &#123;    new HowIsObjectImplementedInScala$();  &#125;&#125;\n\n和Java代码大同小异，除了静态构造和某几个关键字外，基本一样。一个object就是一个Scala编译器帮我们实现的singleton。\nvar和valvar：可变。val：不可变。关于这两个关键字何时该使用哪一个，这里不做讨论，我们只是观察这二者在编译后是如何被表示的。\n这段Scala代码：\nclass HowAreVarAndValImplementedInScala &#123;  var v1 = 123  val v2 = 456  def method1() = &#123;    var v3 = 123    val v4 = 456    println(v3 + v4)  &#125;&#125;\n\n定义了两个字段一个var，一个val，方法中定义了两个局部变量，一个var，一个val。\n编译为Java bytecode并反编译之后：\npublic class HowAreVarAndValImplementedInScala&#123;  private int v1 = 123;  private final int v2 = 456;  public int v1()  &#123;    return this.v1;  &#125;  public void v1_$eq(int x$1) &#123; this.v1 = x$1; &#125;  public int v2() &#123; return this.v2; &#125;  public void method1() &#123;    int v3 = 123;    int v4 = 456;    Predef..MODULE$.println(BoxesRunTime.boxToInteger(v3 + v4));  &#125;&#125;\n\n声明为字段的v1和v2，一个是普通字段，另一个则被标记为final。编译器为v1生成了getter和setter，为v2则只有getter，因为v2作为immutable的字段是不可以被重新赋值的。\n有趣的是方法中的局部变量都是普通的变量，没有被final修饰。\n再来看这段Scala编译为CIL再反编译为C#之后的样子：\npublic class HowAreVarAndValImplementedInScala : ScalaObject&#123;  private int v1;  private int v2;  public override int v1()  &#123;    return this.v1;  &#125;  public override void v1_$eq(int x$1)  &#123;    this.v1 = x$1;  &#125;  public override int v2()  &#123;    return this.v2;  &#125;  public override void method1()  &#123;    int v3 = 123;    int v4 = 456;    Predef$.MODULE$.println(v3 + v4);  &#125;  public HowAreVarAndValImplementedInScala()  &#123;    this.v1 = 123;    this.v2 = 456;  &#125;&#125;\n\n有一个明显的问题，v2没有标为readonly（C#世界中用于声明变量不可以重新赋值的关键字），这是compiler的bug吗？\n除此之外，和Java代码一致。但是有趣的是代码中的所有public方法（包括上一段演示object的代码）都被标为了override，原因不明。\n小结本来以为研究这么简单的两个语言特性不会有啥收获，仅仅是反编译一下，看看compiler都做了啥，满足下好奇心罢了。\n结果还是有意外收获，我在反编译后的代码中发现了三个有趣的问题：\n\n在Scala中被声明为val的v4为什么在反编译的Java中不是final的呢？\n在Scala中被声明为val的v2为什么在反编译的C#中不是readonly的呢？\n为什么反编译出来的C#代码中的实例级公开方法都是标有override的呢？\n\n为什么呢？为什么呢？为什么呢？答案下期揭晓。\n\n\n\n\n","tags":["Desugar_Scala","Scala"]},{"title":"为什么必须是final的呢？","url":"/blog/2013/06/22/why-does-it-have-to-be-final/","content":"一个谜团如果你用过类似guava这种“伪函数式编程”风格的library的话，那下面这种风格的代码对你来说应该不陌生：\npublic void tryUsingGuava() &#123;    final int expectedLength = 4;    Iterables.filter(Lists.newArrayList(&quot;123&quot;, &quot;1234&quot;), new Predicate&lt;String&gt;() &#123;        @Override        public boolean apply(String str) &#123;            return str.length() == expectedLength;        &#125;    &#125;);&#125;\n\n这段代码对一个字符串的list进行过滤，从中找出长度为4的字符串。看起来很是平常，没什么特别的。\n但是，声明expectedLength时用的那个final看起来有点扎眼，把它去掉试试：\n\nerror: local variable expectedLength is accessed from within inner class; needs to be declared final\n\n结果Java编译器给出了如上的错误，看起来匿名内部类只能够访问final的局部变量。但是，为什么呢？其他的语言也有类似的规定吗？\n在开始用其他语言做实验之前我们先把问题简化一下，不要再带着guava了，我们去除掉噪音，把问题归结为：\n为什么Java中的匿名内部类只可以访问final的局部变量呢？其他语言中的匿名函数也有类似的限制吗？\nScala中有类似的规定吗？def tryAccessingLocalVariable &#123;  var number = 123  println(number)  var lambda = () =&gt; &#123;    number = 456    println(number)  &#125;  lambda.apply()  println(number)&#125;\n\n上面的Scala代码是合法的，number变量是声明为var的，不是val（类似于Java中的final）。而且在匿名函数中可以修改number的值。\n看来Scala中没有类似的规定。\nC#中有类似的规定吗？public void tryUsingLambda ()&#123;\tint number = 123;\tConsole.WriteLine (number);\tAction action = () =&gt; &#123;\t\tnumber = 456;\t\tConsole.WriteLine (number);\t&#125;;\taction ();\tConsole.WriteLine (number);&#125;\n\n这段C#代码也是合法的，number这个局部变量在lambda表达式内外都可以访问和赋值。\n看来C#中也没有类似的规定。\n分析谜团三门语言中只有Java有这种限制，那我们分析一下吧。先来看一下Java中的匿名内部类是如何实现的：\n先定义一个接口：\npublic interface MyInterface &#123;    void doSomething();&#125;\n\n然后创建这个接口的匿名子类：\npublic class TryUsingAnonymousClass &#123;    public void useMyInterface() &#123;        final Integer number = 123;        System.out.println(number);        MyInterface myInterface = new MyInterface() &#123;            @Override            public void doSomething() &#123;                System.out.println(number);            &#125;        &#125;;        myInterface.doSomething();        System.out.println(number);    &#125;&#125;\n\n这个匿名子类会被编译成一个单独的类，反编译的结果是这样的：\nclass TryUsingAnonymousClass$1        implements MyInterface &#123;    private final TryUsingAnonymousClass this$0;    private final Integer paramInteger;    TryUsingAnonymousClass$1(TryUsingAnonymousClass this$0, Integer paramInteger) &#123;        this.this$0 = this$0;        this.paramInteger = paramInteger;    &#125;    public void doSomething() &#123;        System.out.println(this.paramInteger);    &#125;&#125;\n\n可以看到名为number的局部变量是作为构造方法的参数传入匿名内部类的（以上代码经过了手动修改，真实的反编译结果中有一些不可读的命名）。\n如果Java允许匿名内部类访问非final的局部变量的话，那我们就可以在TryUsingAnonymousClass$1中修改paramInteger，但是这不会对number的值有影响，因为它们是不同的reference。\n这就会造成数据不同步的问题。\n所以，谜团解开了：Java为了避免数据不同步的问题，做出了匿名内部类只可以访问final的局部变量的限制。\n但是，新的谜团又出现了：\nScala和C#为什么没有类似的限制呢？它们是如何处理数据同步问题的呢？上面出现过的那段Scala代码中的lambda表达式会编译成这样：\npublic final class TryUsingAnonymousClassInScala$$anonfun$1 extends AbstractFunction0.mcV.sp        implements Serializable &#123;    public static final long serialVersionUID = 0L;    private final IntRef number$2;    public final void apply() &#123;        apply$mcV$sp();    &#125;    public void apply$mcV$sp() &#123;        this.number$2.elem = 456;        Predef..MODULE$.println(BoxesRunTime.boxToInteger(this.number$2.elem));    &#125;    public TryUsingAnonymousClassInScala$$anonfun$1(TryUsingAnonymousClassInScala $outer, IntRef number$2) &#123;        this.number$2 = number$2;    &#125;&#125;\n\n可以看到number也是通过构造方法的参数传入的，但是与Java的不同是这里的number不是直接传入的，是被IntRef包装了一层然后才传入的。对number的值修改也是通过包装类进行的：this.number$2.elem &#x3D; 456;\n这样就保证了lambda表达式内外访问到的是同一个对象。\n再来看看C#的处理方式，反编译一下，发现C#编译器生成了如下的一个类：\nprivate sealed class &lt;tryUsingLambda&gt;c__AnonStorey0&#123;\tinternal int number;\tinternal void &lt;&gt;m__0 ()\t&#123;\t\tthis.number = 456;\t\tConsole.WriteLine (this.number);\t&#125;&#125;\n\n把number包装在这个类内，这样就保证了lambda表达式内外使用的都是同一个number，即便重新赋值也可以保证内外部的数据是同步的。\n小结Scala和C#的编译器通过把局部变量包装在另一个对象中，来实现lambda表达式内外的数据同步。\n而Java的编译器由于未知的原因（怀疑是为了图省事儿？）没有做包装局部变量这件事儿，于是就只好强制用户把局部变量声明为final才能在匿名内部类中使用来避免数据不同步的问题。\n\n\n\n\n","tags":["Java"]},{"title":"剥掉Scala的糖衣(7) -- apply method","url":"/blog/2013/12/29/desugar-scala-7/","content":"apply method是一个很简单的语言特性。如果一个class或者是object有一个主要的方法，那么与其每次显式的调用这个主要的方法，还不如隐式调用。举个例子：\nclass Kettle &#123;  def boil(water: Water) = &#123;    water.isWarm = true    water  &#125;&#125;\n\n一个水壶的主要作用就是烧开水，于是我们每次都要调用boil方法来烧开水:\nval kettle: Kettle = new Kettle()kettle.boil(new Water())\n\n如果要把它改写成apply method的方式，只需要给boil改个名字就好了：\nclass Kettle &#123;  def apply(water: Water) = &#123;    water.isWarm = true    water  &#125;&#125;\n\n然后需要烧开水时，就只需把水倒进壶里就好了：\nval kettle: Kettle = new Kettle()kettle(new Water())\n\n这个语言特性的实现很简单，不用说也可以猜到，无非就是把kettle(water)编译成kettle.apply(water)。反编译一下，Kettle class的定义毫无出奇之处：\npublic class Kettle&#123;  public Water apply(Water water)  &#123;    water.isWarm_$eq(true);    return water;  &#125;&#125;\n\n烧水的代码被编译成了这样：\nKettle kettle = new Kettle();kettle.apply(new Water());\n\n我们刚开始说过apply method也可以用在object里。下面举个例子，我们把Kettle烧水的能力移到它的companion object里面去：\nobject Kettle &#123;  def apply(water: Water) = &#123;    water.isWarm = true    water  &#125;&#125;\n\n然后烧水的时候就可以这样调用：\nKettle(new Water())\n\n反编译出来的结果大同小异，就不再赘述了，唯一的区别就是apply变成了静态方法。\n上面这个水壶烧水的例子并不是最佳实践的作法。apply method的一个最佳实践是用来做工厂。比如Scala标准库中的List就提供了apply方法来给我们创建List：\nList(1, 2, 3)List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)\n\n或者是Map也有类似的用法：\nMap(1 -&gt; &quot;a&quot;, 2 -&gt; &quot;b&quot;, 3 -&gt; &quot;c&quot;)\n\n以上的两段代码并不是在调用List和Map的constructor，而是在调用List和Map的companion objects的apply方法。\nMap的创建可以用apply method，而Map最常用的一个方法就是通过key来取得value，这个也有apply method来做：\nval map = Map(1 -&gt; &quot;a&quot;, 2 -&gt; &quot;b&quot;, 3 -&gt; &quot;c&quot;)map(2)\n\n\n\n\n","tags":["Desugar_Scala","Scala"]},{"title":"Scala中的语言特性是如何实现的(3) -- trait","url":"/blog/2013/10/13/scala-trait/","content":"我在Coursera上跟了一门叫做Functional Programming Principles in Scala的课程，是由Scala的作者Martin Odersky讲授的。其中第三周的作业中使用到了Scala的trait这个语言特性。\n我以前熟知的语言都没有类似的特性（Ruby的mixin和Scala的trait很像，但是Ruby我不熟），所以这周的博客就分析一下这个语言特性是如何实现的。\ntrait在讲trait的实现机制之前，先看一个使用trait的例子。假设我们有以下几个类：\nabstract class Plant &#123;  def photosynthesis = println(&quot;Oh, the sunlight!&quot;)&#125;class Rose extends Plant &#123;  def smell = println(&quot;Good!&quot;)  def makePeopleHappy = println(&quot;People like me&quot;)&#125;class Ruderal extends Plant &#123;  def grow = println(&quot;I take up all the space!&quot;)&#125;abstract class Animal &#123;  def move = println(&quot;I can move!&quot;)&#125;class Dog extends Animal &#123;  def bark = println(&quot;Woof!&quot;)  def makePeopleHappy = println(&quot;People like me&quot;)&#125;class Snake extends Animal &#123;  def bite = println(&quot;I am poisonous!&quot;)&#125;\n\n植物家族有玫瑰和杂草。\n动物家族有狗和毒蛇。\n仔细观察可以发现，玫瑰和狗有一个共同的行为，它们都可以取悦人类，这个行为是用完全一样的代码实现的。\n如何把Rose和Dog中的重复代码消除掉呢？有一种潜在的解决方案：把makePeopleHappy提取到一个类中去，让植物和动物都继承自它。\n这么做虽然消除了重复代码但有两个明显的缺点：\n\n植物和动物继承自同一个类，不太合理\n杂草和毒蛇也具有了取悦于人的能力，也不太合理\n\n这时我们就可以使用trait，它没有上面提到的两个缺点。\ntrait PeoplePleaser &#123;  def makePeopleHappy = println(&quot;People like me&quot;)&#125;class Rose extends Plant with PeoplePleaser &#123;  def smell = println(&quot;Good!&quot;)&#125;class Dog extends Animal with PeoplePleaser &#123;  def bark = println(&quot;Woof!&quot;)&#125;\n\n我们定义一个trait，把makePeopleHappy置于其中，让Rose和Dog都with这个trait。然后就可以写这样的代码来调用它们了：\nnew Rose().makePeopleHappynew Dog().makePeopleHappy\n\n这样我们就解决了重复代码的问题，而且没有触及已存在的继承关系。\n现在看看trait的实现机制吧，我们开始反编译！\npublic abstract interface PeoplePleaser&#123;  public abstract void makePeopleHappy();&#125;public abstract class PeoplePleaser$class&#123;  public static void makePeopleHappy(PeoplePleaser $this)  &#123;    Predef..MODULE$.println(&quot;People like me&quot;);  &#125;  public static void $init$(PeoplePleaser $this)  &#123;  &#125;&#125;public class Rose extends Plant  implements PeoplePleaser&#123;  public void makePeopleHappy()  &#123;    PeoplePleaser$class.makePeopleHappy(this);  &#125;  public void smell() &#123; Predef..MODULE$.println(&quot;Good!&quot;); &#125;  public Rose()  &#123;    PeoplePleaser.class.$init$(this);  &#125;&#125;public class Dog extends Animal  implements PeoplePleaser&#123;  public void makePeopleHappy()  &#123;    PeoplePleaser$class.makePeopleHappy(this);  &#125;  public void bark() &#123; Predef..MODULE$.println(&quot;Woof!&quot;); &#125;  public Dog()  &#123;    PeoplePleaser.class.$init$(this);  &#125;&#125;\n\n真相大白了，PeoplePleaser被编译成了一个接口加一个抽象类。Rose和Dog实现这个接口，并通过调用抽象类中的静态方法来实现了makePeopleHappy。\n很有趣的一点是Rose和Dog在调用静态方法时都把this传了进去，为什么呢？我们把原来的代码改成这样来看：\ntrait PeoplePleaser &#123;  val moreMessage = &quot;&quot;  def makePeopleHappy = println(&quot;People like me. &quot; + moreMessage)&#125;class Rose extends Plant with PeoplePleaser &#123;  override val moreMessage = &quot;Because I smell nice.&quot;  def smell = println(&quot;Good!&quot;)&#125;class Dog extends Animal with PeoplePleaser &#123;  override val moreMessage = &quot;Because I fetch balls.&quot;  def bark = println(&quot;Woof!&quot;)&#125;\n我们给makePeopleHappy加上一段额外的信息。现在再次反编译。\npublic abstract interface PeoplePleaser&#123;  public abstract void objsets$PeoplePleaser$_setter_$moreMessage_$eq(String paramString);  public abstract String moreMessage();  public abstract void makePeopleHappy();&#125;public abstract class PeoplePleaser$class&#123;  public static void makePeopleHappy(PeoplePleaser $this)  &#123;    Predef..MODULE$.println(new StringBuilder()    .append(&quot;People like me. &quot;)    .append($this.moreMessage()).toString());  &#125;  public static void $init$(PeoplePleaser $this)  &#123;    $this.objsets$PeoplePleaser$_setter_$moreMessage_$eq(&quot;&quot;);  &#125;&#125;public class Rose extends Plant  implements PeoplePleaser&#123;  private final String moreMessage;  public void objsets$PeoplePleaser$_setter_$moreMessage_$eq(String x$1)  &#123;  &#125;  public void makePeopleHappy()  &#123;    PeoplePleaser$class.makePeopleHappy(this);  &#125;  public String moreMessage() &#123; return this.moreMessage; &#125;  public void smell() &#123;    Predef..MODULE$.println(&quot;Good!&quot;);  &#125;  public Rose()  &#123;    PeoplePleaser.class.$init$(this);    this.moreMessage = &quot;Because I smell nice.&quot;;  &#125;&#125;public class Dog extends Animal  implements PeoplePleaser&#123;  private final String moreMessage;  public void objsets$PeoplePleaser$_setter_$moreMessage_$eq(String x$1)  &#123;  &#125;  public void makePeopleHappy()  &#123;    PeoplePleaser$class.makePeopleHappy(this);  &#125;  public String moreMessage() &#123; return this.moreMessage; &#125;  public void bark() &#123;    Predef..MODULE$.println(&quot;Woof!&quot;);  &#125;  public Dog()  &#123;    PeoplePleaser.class.$init$(this);    this.moreMessage = &quot;Because I fetch balls.&quot;;  &#125;&#125;\n\n现在就清楚了，抽象类中的静态方法可能会依赖于各个实例不同的状态，所以需要把this传递进去。这样我们才能够给makePeopleHappy加上一段额外的信息。\n\n\n\n\n","tags":["Desugar_Scala","Scala"]},{"title":"褪去Scala的糖衣(6) -- partial application","url":"/blog/2013/12/25/desugar-scala-6/","content":"这篇博客介绍一下Scala中的partial application，局部应用，或者叫做柯里化。\n所谓柯里化就是指把一个接受多个参数的函数的一部分参数写死，剩下的一部分由调用者提供。\n用Java代码来表述，大概可以写成这样：\npublic String greet(String greeting, String name) &#123;    return greeting + &quot; &quot; + name;&#125;public String sayHello(String name) &#123;    return greet(&quot;Hello&quot;, name);&#125;public String greetXiaoMing(String greeting) &#123;    return greet(greeting, &quot;Xiao Ming&quot;);&#125;\n\ngreet用来给某个不确定的人打个不确定的招呼。\nsayHello用来给某个不确定的人说一句固定的Hello。\ngreetXiaoMing用来给一个固定的人小明打一个不确定的招呼。\n如果用Scala来表达同样的含义的话，可以这样写：\ndef greet(greeting: String, name: String) = greeting + &quot; &quot; + namedef sayHello = greet(&quot;hello&quot;, _: String)def greetXiaoMing = greet(_: String, &quot;Xiao Ming&quot;)\n\n其实比Java代码也简单不了多少。只是把暂时不确定的参数用下划线指代出来。\n然后我们就可以在稍后需要调用它们的时候再把参数传入：\nsayHello(&quot;world&quot;)greetXiaoMing(&quot;Ni Hao&quot;)\n\n然后我们看一下这个语言特性是怎么实现的呢？\npublic String greet(String greeting, String name) &#123;    return new StringBuilder().append(greeting).append(&quot; &quot;).append(name).toString();&#125;public Function1&lt;String, String&gt; sayHello() &#123;    return new AbstractFunction1() &#123;        public static final long serialVersionUID = 0L;        public final String apply(String x$1) &#123;            return Hello.this.greet(&quot;hello&quot;, x$1);        &#125;    &#125;;&#125;public Function1&lt;String, String&gt; greetXiaoMing() &#123;    return new AbstractFunction1() &#123;        public static final long serialVersionUID = 0L;        public final String apply(String x$2) &#123;            return Hello.this.greet(x$2, &quot;Xiao Ming&quot;);        &#125;    &#125;;&#125;\n\n可以看到sayHello和greetXiaoMing并不是返回String的，它们返回的是Function1 of String, String。也就是说直接调用它们俩是得不到我们想要的结果的，必须把这个Function1上的apply再调一下才行。实际上正是如此，这段代码：\nsayHello(&quot;world&quot;)greetXiaoMing(&quot;Ni Hao&quot;)\n\n会被编译成：\nsayHello().apply(&quot;world&quot;);greetXiaoMing().apply(&quot;Ni Hao&quot;);\n\n除此之外，partial application还可以有另一种稍微另类一些的写法：\ndef greet(greeting: String)(name: String) = greeting + &quot; &quot; + namedef sayHello = greet(&quot;hello&quot;)(_)def greetXiaoMing = greet(_: String)(&quot;Xiao Ming&quot;)\n\n反编译的结果和上面的代码是完全一致的。\n我不太清楚这种写法存在的意义是不是仅仅起一个向外界宣称“我这个函数之所以出现就是给你局部应用的，不要一下子把两个参数都给我”的作用。\n\n\n\n\n","tags":["Desugar_Scala","Scala"]},{"title":"剥开Scala的糖衣(5) -- lazy","url":"/blog/2013/12/24/desugar-scala-5/","content":"Scala中的lazy关键字是实现延迟加载的好帮手。\n在Java中想要做到延迟加载，常规的做法是大抵是这样的：\nprivate String str = null;public String getStr() &#123;    if (str == null) &#123;        str = getStrFromWebService();    &#125;    return str;&#125;\n\n以这种方式来保证web service不会被无谓的重复请求。\nC#中则可以使用Lazy of T来实现类似的事:\nprivate Lazy&lt;String&gt; str = new Lazy&lt;string&gt; (() =&gt; GetStrFromWebService ());public String Str&#123;\tget\t&#123;\t\treturn str.Value;\t&#125;&#125;\n\nLazy of T保证传入其中的Func只执行一次。\n（其实，Java也可以使用Guava中的memoize来实现类似的事情）\n要么自己写代码，要么通过库来实现。\n而Scala则在语言级别给出了解决方案：\nlazy val str = getStrFromWebService()\n\n仅此一行。\n只要用lazy关键字修饰一下str，延迟执行的事就搞定了。\n其实Scala编译器做的事情和我们手动做的区别不大：\nprivate String str;private volatile boolean bitmap$0;private String str$lzycompute()&#123;  synchronized (this) &#123;  \tif (!this.bitmap$0) &#123;    this.str = getStrFromWebService();    this.bitmap$0 = true;   &#125;  \treturn this.str;  &#125;&#125;public String str() &#123;  return this.bitmap$0 ? this.str : str$lzycompute();&#125;\n\n你看编译器多热心，还加了锁哦。\n小小总结一下：\n对于这样一个表达式：lazy val t:T &#x3D; expr无论expr是什么东西，字面量也好，方法调用也好。Scala的编译器都会把这个expr包在一个方法中，并且生成一个flag来决定只在t第一次被访问时才调用该方法。\n\n\n\n\n","tags":["Desugar_Scala","Scala"]},{"title":"揭开Scala的糖衣(8) -- pattern matching","url":"/blog/2013/12/29/desugar-scala-8/","content":"Pattern matching是Scala中很好用的一个语言特性。先举一个最简单的例子：\nval number = 1number match &#123;  case 1 =&gt; doSomething()  case 2 =&gt; doSomethingElse()  case _ =&gt; doDefault()&#125;\n\n这个代码和我们熟悉的switch case看起来很像，其实，这段代码反编译之后和Java的switch case确实就是一样的：\nint number = 1;int i = number; switch (i)&#123;default:  doDefault(); break;case 2:  doSomethingElse(); break;case 1:  doSomething();&#125;\n\n但是和Java的switch case不一样的是，Scala的pattern matching作为一个expression是可以evaluate一个值出来的，我们把上面的代码改一下，让doSomething,doSomethingElse和doDefault都返回点东西：\nval number = 1val result = number match &#123;  case 1 =&gt; doSomething()  case 2 =&gt; doSomethingElse()  case _ =&gt; doDefault()&#125;\n\n这样，result就承接了能够match上的那个case的返回值。而无需像普通的swtich case一样在每个case中给result赋值。\n单是这样看，pattern matching的魅力还不算怎么大，我们再看一下下面这个例子：\nabstract class Animalcase class Cat(name: String) extends Animalcase class Dog(name: String) extends Animal\n\n首先声明几个case classes。这些case classes会被编译成一些比较复杂的classes，我们暂时不去关心。\n然后看一下如何match类型及其属性：\nval animal = createAnimalanimal match &#123;  case Dog(anyName) =&gt; &quot;this is a dog&quot;  case Cat(&quot;kitty&quot;) =&gt; &quot;this is a cat named kitty&quot;  case _ =&gt; &quot;other animal&quot;&#125;\n\n这段代码很容易懂，如果创建出来的animal是狗的话，无论它的名字叫什么，我们都返回this is a dog，如果是一只名叫kitty的猫，则返回this is a cat named kitty。如果都不是的话，则返回other animal。\n很简单的几行代码，就做出了类型判断而且还有属性判断。\n如果没有pattern matching，那么就要写if去判断类型，如果类型符合还要做类型转换，然后把转换后的变量中的属性取出来，再然后才能对属性的值做判断，最后才能返回点东西……\n类型判断，类型转换，取属性，属性值判断，返回值。这么五件事我们用这样一行代码就都解决了：\ncase Cat(&quot;kitty&quot;) =&gt; &quot;this is a cat named kitty&quot;\n\n这样的Scala代码会被编译成什么样呢？其实就是我们上面描述的很复杂的样子：\nAnimal animal;String string;Animal animal2 = (animal = this.createAnimal());if ((animal2 instanceof Dog)) &#123;    return &quot;this is a dog&quot;;&#125;if (!((animal2 instanceof Cat))) return &quot;other animal&quot;;Cat cat = (Cat)(animal2);String string2 = (string = cat.name());if (&quot;kitty&quot; == null) &#123;    if (string2 == null) return &quot;this is a cat named kitty&quot;;    return &quot;other animal&quot;;&#125; else &#123;    if (!(&quot;kitty&quot;.equals(string2))) return &quot;other animal&quot;;    return &quot;this is a cat named kitty&quot;;&#125;\n\n这段反编译出来的代码不很可读。我们就凑合着粗看一下。里面和我们前面说的一样，都是if else，类型判断，转型，判等……\n当然，用反编译工具给出的Java代码和上面的Scala代码作比较并不公平。我们自己把它写一遍：\nAnimal animal = createAnimal();String result = &quot;other animal&quot;;if (animal instanceof Dog) &#123;    result = &quot;this is a dog&quot;;&#125; else if (animal instanceof Cat) &#123;    Cat cat = (Cat) animal;    if (cat.name() == &quot;kitty&quot;) &#123;        result = &quot;this is a cat named kitty&quot;;    &#125;&#125;return result;\n\n这个样子再和上面的Scala代码比较，可以看到Scala编译器帮我们省掉了局部变量，类型判断和判等这些噪音。\nPattern matching还有很多其他用法，比如用来match tuple：\nval hostPort = (&quot;localhost&quot;, 80)hostPort match &#123;  case (&quot;localhost&quot;, port) =&gt; &quot;this is localhost address&quot;  case (host, port) =&gt; &quot;some other address&quot;&#125;\n\n或者是用来match option：\nval map = Map(1 -&gt; &quot;one&quot;, 2 -&gt; &quot;two&quot;)map.get(1) match &#123;  case Some(str) =&gt; &quot;get something from map: &quot; + str  case None =&gt; &quot;no result&quot;&#125;\n\nScala标准库中的Map的get方法的返回类型是Option，如果能够get到东西则返回Some，其中包着get到的值。如果get不到东西，则返回一个None。\n由于Tuple和Option本身也是case class，所以上面的两段代码反编译出来和上面的Java代码是大同小异的。就不再赘述了。\n\n\n\n\n","tags":["Desugar_Scala","Scala"]},{"title":"掀开Scala的糖衣(9) -- function composition","url":"/blog/2013/12/30/desugar-scala-9/","content":"Function composition，顾名思义，就是函数的组合。直接举例：\ndef sayHi(name: String) = &quot;Hi, &quot; + namedef sayBye(str: String) = str + &quot;, bye&quot;\n\n两个方法，一个说你好，一个说再见。然后我们创建很多个人名：\nval names = List(&quot;world&quot;, &quot;tom&quot;, &quot;xiao ming&quot;)\n\n我们希望对List中的每个人都说你好然后说再见：\nnames.map(sayHi).map(sayBye)\n\n好，这样我们的目的实现了。但是，我们调用了两次map，会对整个List遍历两次。我们希望只遍历一次：\nnames.map &#123;  name =&gt; sayBye(sayHi(name))&#125;\n\n嗯，这样可以了，但是看起来有一点点不爽。按照从左到右的阅读习惯，我们先看到了sayBye，然后才看到sayHi，而且括号还是包了两层。需要想那么一小下才能明白：按照eager evaluation的规则，先运行sayHi，然后把结果传入sayBye，最后得到一个我们想要的结果。\n其实我们真正想要的是一个链式操作，一个pipe：把数据用某种操作进行处理，然后把处理后的结果传递给第二个操作继续处理。类似于这样：a.pipe(b)，或者是这样：a | b。\n而Scala的function composition正是做这件事的：\nnames.map(sayHi _ andThen sayBye)\n\n从左到右，当成英语来读：先sayHi然后再sayBye，清晰明了。\n这个andThen并不是什么神奇的语言关键字。它其实只是定义在Function1上的一个方法而已。我们来看看反编译的结果就知道了：\nfinal List names =List$.MODULE$.apply((Seq)Predef$.MODULE$.wrapRefArray((Object[])new String[] &#123; &quot;world&quot;, &quot;tom&quot;, &quot;xiao ming&quot; &#125;));return (List)names.map(((Function1)new Serializable() &#123;    public static final long serialVersionUID = 0L;    public final String apply(final String name) &#123;        return Hello.this.sayHi(name);    &#125;&#125;).andThen((Function1)new Serializable() &#123;    public static final long serialVersionUID = 0L;    public final String apply(final String str) &#123;        return Hello.this.sayBye(str);    &#125;&#125;), List$.MODULE$.canBuildFrom());\n\n由于反编译工具的原因，这个反编译的结果并不是合法的Java代码，我们凑合着看一下。\n我们看到，sayHi和sayBye都是被包到了Functoin1里面，调一下第一个Function1的andThen方法，把第二个Function1传进去，会返回一个新的Function1。这个返回的新的Function1就是我们想要的链式操作了。\n\n\n\n\n","tags":["Desugar_Scala","Scala"]},{"title":"今天是二零一四年的第一天，回忆一下二零一三年都干了些什么，然后再回忆一下没干什么","url":"/blog/2014/01/01/my-2013/","content":"干了什么上半年：\n看了十几本书；\n写了几篇博客；\n在github上做了一个豆瓣读书的插件；\n肇始了一个十万个为什么的活动，自始至终只有我一个人参与，然后就挂掉了；\n做了三章的SICP，然后卡住做不动了；\n乏善可陈。\n上面列的最后两项的价值最大，但都没做完。究其原因：\n\n坚持不够\nattention span太短\n\n这两项在下半年做的事儿里address到了。\n下半年：\n又看了十几本书（量与上半年持平）；\n又写了几篇博客（量较上半年有增）；\n跟完了Coursera上的Functional programming principles in Scala的课，拿到了Statement of Accomplishment with distinction；\n键盘速度到了60wpm左右；\n找到了坚持和attention span问题的解决方案；\n有善可陈。\n善在最后一项。解决方案是这样的：\n\n戒掉微博，规避碎片化娱乐化的信息。（还没戒掉的是美剧）\n把番茄钟用到自己的时间中去。track用在“正经事儿”上的时间。\n\n不细说了，下面说没干什么。\n没干什么我的情商和people skill很低，低的你都猜不到哦亲。\n我可以预感到这个东西即将成为我的bottle neck。但是我二零一三年并没有在上面做太多事情。\n读了几本我认为会有帮助的书，一些被我认为是不知所云，一些促使我得出了死硬的理性派结论。\n二零一四年需要在这个领域积累知识，然后期待量变带来的质变。\n\n\n\n\n","tags":["me"]},{"title":"剥掉Scala的糖衣(11) -- structural types","url":"/blog/2014/01/02/desugar-scala-11/","content":"Structural types，中文怎么翻译不确定。我们可以用它来实现类似于鸭子类型的效果。为什么说是“类似”鸭子类型呢？稍后会说到它和鸭子类型的区别。\n举一个例子，看看它都可以做什么：\ndef makeNoise(quacker: &#123;def quack(): String&#125;) = quacker.quack\n\n声明一个方法，叫做makeNoise，接受什么类型的参数呢？不做严格限制，我们只声明说参数必须有一个叫做quack的方法，该quack方法返回值类型为String。然后在makeNoise方法内调用quack方法。请注意我们并没有声明一个含有quack方法签名的接口或者类，我们仅仅是在声明参数的同时声明我们期待参数含有什么样的成员。\n然后我们声明一个Duck类：\nclass Duck &#123;  def quack() = &quot;real quack&quot;&#125;\n\n这样就可以调用makeNoise方法了：\nmakeNoise(new Duck)\n\n或者再声明一个NotADuck类：\nclass NotADuck &#123;  def quack() = &quot;fake quack&quot;&#125;\n\n也可以把它传给makeNoise方法：\nmakeNoise(new NotADuck)\n\n甚至是匿名对象也可以：\nmakeNoise(new &#123;  def quack() = &quot;anonymous quack&quot;&#125;)\n\n如果我们把Duck的quack方法改个名字：\nclass Duck &#123;  def quackRenamed() = &quot;real quack&quot;&#125;\n\n那么编译器就会对下面这行代码给出错误：\nmakeNoise(new Duck)\n\ntype mismatch, found : hello.Duck, required: AnyRef{def quack(): String}\n是做了编译时类型检查的。\n然后我们反编译代码，看看它是如何实现的：\nprivate static Class[] reflParams$Cache1;private static volatile SoftReference reflPoly$Cache1;static &#123;    Hello.reflParams$Cache1 = new Class[0];    Hello.reflPoly$Cache1 = new SoftReference((T)new EmptyMethodCache());&#125;public static Method reflMethod$Method1(final Class x$1) &#123;    MethodCache methodCache1 = Hello.reflPoly$Cache1.get();    if (methodCache1 == null) &#123;        methodCache1 = (MethodCache)new EmptyMethodCache();        Hello.reflPoly$Cache1 = new SoftReference((T)methodCache1);    &#125;    Method method1 = methodCache1.find(x$1);    if (method1 != null) &#123;        return method1;    &#125;    method1 = ScalaRunTime$.MODULE$.ensureAccessible(x$1.getMethod(&quot;quack&quot;, Hello.reflParams$Cache1));    Hello.reflPoly$Cache1 = new SoftReference((T)methodCache1.add(x$1, method1));    return method1;&#125;public String makeNoise(final Object quacker) &#123;    final Object invoke;    try &#123;        invoke = reflMethod$Method1(quacker.getClass()).invoke(quacker, new Object[0]);    &#125;    catch (InvocationTargetException ex) &#123;        throw ex.getCause();    &#125;    return (String)invoke;&#125;\n\n我们可以看到，makeNoise方法的参数类型被编译成了Object。方法内部通过反射去调用quack方法。\n再仔细看一下，方法内做了个catch，如果找不到quack方法就把异常抛出来。我们刚才不是看到有编译时类型检查吗？怎么会找不到quack方法呢？\n其实找不到quack方法的情况还是会存在的。假如我们把以上代码打成jar包供别人调用，那别人看到的你这个方法要的是Object啊，随便传一个什么东西进来都可以。如果传入的参数没有quack方法，那自然就会有异常了。这也是一个很好的信号，告诉我们说这个语言特性不适合用在public API中。\n刚开始时提到过，这个语言特性不能叫做鸭子类型，为什么呢？我们看两个真正鸭子类型的例子：\nfunction makeNoise(quacker)&#123;\treturn quacker.quack()&#125;makeNoise(&#123;quack:function()&#123;return &quot;quack quack&quot;&#125;&#125;)\n\n上面的是JavaScript的，下面的是C#的。\nclass Duck&#123;\tpublic String Quack ()\t&#123;\t\treturn &quot;quack quack&quot;;\t&#125;&#125;class Hello&#123;\tpublic String MakeNoise (dynamic quacker)\t&#123;\t\treturn quacker.Quack ();\t&#125;&#125;class MainClass&#123;\tpublic static void Main (string[] args)\t&#123;\t\tConsole.Out.WriteLine (new Hello ().MakeNoise (new Duck ()));\t&#125;&#125;\n\n在上面两段代码中，如果我们把quack或者Quack改个名字的话，都会导致运行失败。而且在声明参数的时候也没有指明我们期待有一个quack或者Quack成员的存在。所以说Scala的这个语言特性不能称之为鸭子类型的原因在于两点：\n\nScala做了编译时类型安全检查\n声明参数时显式的指明了期待的成员\n\n存疑：虽然上面的C#例子看起来是鸭子类型，但是C#的wiki页面上的typing discipline一项里并没有列出duck typing。原因不明。\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n后记：C#的wiki页面没有把duck typing列为其typing discipline的一项。但是，duck typing的wiki页面上又用C#举了例子。互相矛盾啊，于是我在stackoverflow上问了个问题，引来了C#编译器的程序员之一Eric Lippert，他回答问题之后还写了篇博客来表示对duck typing这个名词的困惑。看完之后我表示更晕了。\n所以请不要把上面我说的关于duck typing的东西当真，随便瞄一眼就好了。duck typing是一个没有清晰定义的名词，在我们能够共同认同它的某一种特定的definition之前去讨论它是无谓的。\n下面把链接列出：\nC#的wiki  （typing discipline在页面右侧的那个表里）\nDuck typing的wiki\nEric Lippert的博客\n以上链接，建议别点  :)\n\n\n\n\n","tags":["Desugar_Scala","Scala"]},{"title":"褪去Scala的糖衣(12) -- implicit function（补）","url":"/blog/2014/01/05/more-on-scala-implicit-function/","content":"上次博客谈到了implicit function，但是漏掉了一些东西，今天补上。\n由于上次已经讲过implicit function的实现细节，这次就不再重复了。今天只补充上次漏掉了的implicit function的一种很好的实践。\n先看一段specs2的测试代码：\nimport org.specs2.mutable._class HelloWorldSpec extends Specification &#123;  &quot;The &#x27;Hello world&#x27; string&quot; should &#123;    &quot;contain 11 characters&quot; in &#123;      &quot;Hello world&quot; must have size 11    &#125;  &#125;&#125;\n\n我们试着理解这个测试代码在做什么的时候，无须多少思考，因为它和人类语言一样的亲近和自然。但是如果我们想知道specs2如何做到这一点时，就有点费解了。\n我们知道xObject yMethod zParameter的写法是一个语法糖，它和xObject.yMethod(zParameter)是一样的。也就是说should和in都是方法名。于是，问题来了，should和in前面是个String啊，String上哪有这两个方法的定义？\n想必答案你已经猜到了，specs2定义了一些implicit functions来把String转换成能够调用should和in的对象。至于是哪些对象，因为涉及到了specs2的细节，我们暂不讨论。我们试着模仿specs2来写出一段类似人类语言的代码：\nclass Person(name: String) &#123;  def eat(food: String) = println(&quot;I just ate &quot; + food)&#125;\n\n定义一个Person类，Person有一个名字，只会做一件事：吃。\n然后我们可以这样调用它：\nnew Person(&quot;Xiao ming&quot;).eat(&quot;steamed dumplings&quot;)\n\n我们让小明吃点蒸饺。或者也可以这样：\nnew Person(&quot;Xiao ming&quot;) eat &quot;boiled dumplings&quot;\n\n再煮点饺子让小明吃。这就是我们前面提到过的xObject yMethod zParameter的写法了。让小明吃点东西还得new一个Person出来，这太麻烦了，我们定义一个implicit function：\nimplicit def stringToPerson(name: String) = new Person(name)\n\n这样就可以把String转换成Person了。然后就可以像这样写：\n&quot;Xiao ming&quot; eat &quot;more dumplings&quot;\n\n虽然我们写的是“Xiao ming”，但是编译器会把stringToPerson的调用加上去，然后才调用eat方法。\n这行代码看起来已经很接近人类语言了。\n连吃三顿饺子，明哥，您饱了吧？\n\n\n\n\n","tags":["Desugar_Scala","Scala"]},{"title":"除去Scala的糖衣(13) -- default parameter value","url":"/blog/2014/06/09/desugar-scala-default-parameter-value/","content":"好久没有写博客了，上一次更新竟然是一月份。\n说工作忙都是借口，咋有空看美剧呢。\n这半年荒废掉博客说到底就是懒，惯性的懒惰。写博客这事儿，一丢掉就很久捡不起来。\n闲话到此为止，下面进入正题。\nDefault parameter value，默认参数值。这个很容易理解，给参数一个默认值，如果调用者不显式指明参数值，则使用默认值。如果显式指明了，那就用显式指明的值。\n举个例子：\ndef hello(name: String = &quot;world&quot;) = println(&quot;hello &quot; + name)\n\n这个函数，如果我们不给它传参数，它就会打印hello world。就像这样：\nhello()\n\n如果给了参数：\nhello(&quot;everybody&quot;)\n\n则打印hello everybody。\n这个语言特性都有哪些应用场景呢？\n它经常用来避免过多的重载。一个很常见很典型的例子就是构造函数重载。\n在Java中，为了让调用者能够比较容易的创建某个类的实例，我们通常会提供几个参数列表比较短的构造函数。而这些构造函数存在的唯一意义就是为了写死某几个参数值。而在Scala中，有了这个语言特性，我们就无需那么麻烦了。\n那这个语言特性是如何实现的呢？实际上简单的一塌糊涂。\n这样一段代码：\nclass Greeter &#123;  def hello(name: String = &quot;world&quot;) = println(&quot;hello &quot; + name)&#125;class AnotherClass &#123;  new Greeter().hello()&#125;\n\n我们的Greeter类含有前面提到过的hello方法。在AnotherClass里调用了hello，并且没有显式指明参数值。\n上面的Scala代码生成的bytecode反编译成Java是这样的：\npublic class Greeter &#123;    public void hello(String name) &#123;        Predef..MODULE$.println(new StringBuilder().append(&quot;hello &quot;).append(name).toString());    &#125;    public String hello$default$1() &#123;        return &quot;world&quot;;    &#125;&#125;public class AnotherClass &#123;    public AnotherClass() &#123;        Greeter qual$1 = new Greeter();        String x$1 = qual$1.hello$default$1();        qual$1.hello(x$1);    &#125;&#125;\n\n可以看到，我们所定义的hello方法反编译出来看起来很普通，就是个接受一个参数的方法。\n而在Greeter类中，编译器为我们加入了另一个方法hello$default$1，这个方法就是返回一个写死的字符串，其值为world。\n在AnotherClass中调用hello时，写死的字符串被取到，然后传进了hello里。\n这样，被调用者提供了参数的默认值，调用者在调用时取得该值，然后传入方法。\n题外话到这里我不禁联想起C#中的默认参数值的实现方式。\n在C#中，默认参数的值会被编译成调用者的一个常量，而不是像Scala一样的由被调用者提供。\n这样看起来貌似没啥区别，不就是写死的值换个地方吗？\n其实不然，如果被调用者在A程序集内，调用者在B程序集内，那么A更新时，B就必须重新编译才能得到最新的默认值。也就是说，如果当前部署环境中同时存在A和B，而后我们拿一个新版的A来替换老的，这时B仍然在传递老的默认参数值给A。这样就会造成一些看似很诡异的行为偏差。\n如果对C#的默认参数值的实现有兴趣，请看我很久很久之前写的博客\n现在想来，C#这一语言特性的设计者为什么要把它设计成如此容易出错的样子呢？\n思而不得其解。\n\n\n\n\n","tags":["Desugar_Scala","Scala"]},{"title":"抹掉Scala的糖衣(14) -- update method","url":"/blog/2014/06/12/scala-update-method/","content":"在Scala中，名字叫做update的方法是有特殊作用的。\n比如：\nval scores = new scala.collection.mutable.HashMap[String, Int]scores(&quot;Bob&quot;) = 100val bobsScore = scores(&quot;Bob&quot;)\n\n以上三行代码，我们创建了一个可变的map来存储得分情况，然后我们记录了Bob的得分是100分，最后我们又把Bob的分数取出来了。\n这三行代码看似平淡无奇，实则暗藏了一点点玄机。\n第二行实际是调用了HashMap的update方法。\n第三行实际是调用了HashMap的apply方法。\n我们可以把上面的代码改写成下面的等价形式：\nval scores = new scala.collection.mutable.HashMap[String, Int]scores.update(&quot;Bob&quot;, 100)val bobsScore = scores.apply(&quot;Bob”)\n\n虽然等价，但是可读性却降低了一些。\napply方法我们之前讲过，就不再赘述。\nupdate方法也不太复杂，它的规则就是：\nx(y) = z\n\n这样的代码会被编译为：\nx.update(y, z)\n\n这次博文名字虽然以抹掉糖衣开头，实则有点名不符实，因为这个语言特性过于简单，糖衣很薄，一抹就透。\n这次的目的主要是介绍一个update方法的适用场景。\n我们来看用来修改某个人地址的一段代码：\nclass AddressChanger &#123;  def update(name: String, age: Int, newAddress: String) = &#123;    println(s&quot;changing address of $name, whose age is $age to $newAddress&quot;)    //actually change the address  &#125;&#125;\n\n我们可以这样来调用它：\nval changer = new AddressChanger()changer.update(&quot;xiao ming&quot;, 23, &quot;beijing&quot;)\n\n或者，我们也可以这样来调用它：\nval addressOf = new AddressChanger()addressOf(name = &quot;xiao ming&quot;, age = 23) = &quot;beijing&quot;\n\n这两段代码是等价的。\n比较一下，前一种用法显得中规中矩，没什么特别好的，也没啥特大的毛病。\n可是后一种用法就不同了，读起来很通顺，有读英语语句的感觉：把名字叫做小明，年龄23岁的人的地址改为北京。\n如果再给AddressChanger加上一个apply方法，我们还可以写这样的代码：\nval currentAddress = addressOf(name = &quot;xiao ming&quot;, age = 23)\n\n这样，读取和更新的代码都看起来非常自然。\n如果我们把这两段代码连起来看：\nval currentAddress = addressOf(name = &quot;xiao ming&quot;, age = 23)addressOf(name = &quot;xiao ming&quot;, age = 23) = &quot;beijing&quot;\n\n感觉甚好。\naddressOf(name &#x3D; “xiao ming”, age &#x3D; 23)可以看做一个整体，它就如同一个可读可写的属性。\n我们把它放到赋值语句的右侧，就能取到小明的当前住址。\n我们把它放到赋值语句的左侧，就能修改小明的住址。\napply和update都是蛮简单的语言特性，但是加以合适的应用，却能得到可读性极强的代码。\n\n\n\n\n","tags":["Desugar_Scala","Scala"]},{"title":"Desugar Scala(15) -- unapply和unapplySeq方法","url":"/blog/2014/06/14/scala-unapply-method/","content":"实在想不到什么动词可以当做脱衣服来讲了，所以从现在开始这系列博文就叫做Desugar Scala了。除非哪天才思泉涌，又想到了新词：）\n开始正文。\n名字叫做unapply和unapplySeq的方法在Scala里也是有特殊含义的。\n我们前面说过case class在做pattern match时很好用，而除case class之外，有unapply或unapplySeq方法的对象在pattern match时也有很好的应用场景。\n比如这段代码：\nobject Square &#123;  def unapply(z: Double): Option[Double] = Some(math.sqrt(z))&#125;\n\n我们定义了一个unapply方法，用来计算平方根。我们可以像调用普通方法一样的调用它：\nval number: Double = 36.0Square.unapply(number)\n\n这样会得到36的平方根:6。实际上返回值是Some(6)。\n上面的方式是对unapply的浪费，unapply真正的好处是这样的：\nval number: Double = 36.0number match &#123;\tcase Square(n) =&gt; println(s&quot;square root of $number is $n&quot;)\tcase _ =&gt; println(&quot;nothing matched&quot;)&#125;\n\n这样我们无需显式调用unapply方法，而把是它用在pattern match中，让编译器替我们调用它。\n当我们写下这段pattern match的代码时，编译器其实替我们做了好几件事：\n\n调用unapply，传入number\n接收返回值并判断返回值是None，还是Some\n如果是Some，则将其解开，并将其中的值赋值给n（就是case Square(n)中的n）\n\n这段代码反编译出来是这个样子的：\ndouble number = 36.0D;   double d1 = number;   Option localOption = Square..MODULE$.unapply(d1);   //调用unapply，传入number   BoxedUnit localBoxedUnit;   if (localOption.isEmpty()) &#123;//判断返回值是None     Predef..MODULE$.println(&quot;nothing matched&quot;);     localBoxedUnit = BoxedUnit.UNIT;   &#125;   else &#123;//判断返回值是Some     double n = BoxesRunTime.unboxToDouble(localOption.get());     //将Some解开，并将其中的值赋值给n     Predef..MODULE$.println(new StringContext(Predef..MODULE$.wrapRefArray((Object[]) new String[] &#123;       &quot;square root of &quot;, &quot; is &quot;, &quot;&quot;     &#125;) ).s(Predef..MODULE$.genericWrapArray(new Object[] &#123;       BoxesRunTime.boxToDouble(number), BoxesRunTime.boxToDouble(n)     &#125;)));     localBoxedUnit = BoxedUnit.UNIT;   &#125;\n\n如果没有unapply方法和pattern match语法之间的这种结合，我们自己写代码要写成什么样子呢？\n或许会比上面反编译的代码简单一些，但是显式地调用开平方的方法，用if else来判断Option，以及将真正的返回值从Option里面解出来这三件事是免不掉的。\nunapplySeq和unapply的作用很是类似，例如这样：\nobject Names &#123;  def unapplySeq(str: String): Option[Seq[String]] = &#123;    if (str.contains(&quot;,&quot;)) Some(str.split(&quot;,&quot;))    else None  &#125;&#125;\n\n我们定义一个unapplySeq方法，用逗号作为分隔符来把字符串拆开。\n然后我们可以这样应用它：\nval namesString = &quot;xiao ming,xiao hong,tom&quot;namesString match &#123;  case Names(first, second, third) =&gt; &#123;    println(&quot;the string contains three people&#x27;s names&quot;)    println(s&quot;$first $second $third&quot;)  &#125;  case _ =&gt; println(&quot;nothing matched&quot;)&#125;\n\n与上面的例子很是类似，不过编译器在这里替我们做的事情更多了：\n\n调用unapplySeq，传入namesString\n接收返回值并判断返回值是None，还是Some\n如果是Some，则将其解开\n判断解开之后得到的sequence中的元素的个数是否是三个\n如果是三个，则把三个元素分别取出，赋值给first，second和third\n\n如果没有unapplySeq方法和pattern match语法之间的这种结合，我们自己写代码来做这五件事会显得很是繁琐。\n\n\n\n\n","tags":["Desugar_Scala","Scala"]},{"title":"Scala + Play + sbt + Protractor = one build","url":"/blog/2014/06/22/scala-plus-play-plus-sbt-plus-protractor-equals-one-build/","content":"我所在的项目的技术栈选用的是Play framework做后端API，前端用Angular JS。\n因为用了Scala和Play，构建工具很自然用的就是sbt。\n而由于前端用了Angular，所以functional test就选用了和Angular结合较好的protractor。\n这一切看起来似乎很美好，一个无状态的后端，一个数据和UI双向绑定的前端。What could possibly go wrong？\n一开始也确实如此，没什么问题。我们为了让functional test在CI上跑起来，写了一个脚本来把play dist打出的包部署到CI所在机器上，然后运行protractor。\n这个脚本运行还算ok，偶尔有点小问题，修一修也就好了。\n不过，这也就是说有两个因素可能会使得我们的CI挂掉，一个是用sbt跑的specs2的测试，一个是protractor的测试。而protractor的测试是基于我们自己所写的脚本的，与sbt没啥关系。\n麻烦来了上周五的show case，我们一个小时后就要给客户演示现有产品的示例，但是CI挂掉了，新的代码没法走到QA和UAT的环境，bug fix也过不去。\n最后我们不得不修改jenkins的配置，把sbt test和protractor的test都暂时禁掉，才让最新的代码到了UAT上去。而这一切，是在show case之前一分钟才解决掉的。\n事情总是这样的，出一两次小问题，修修改改就好，我们不会注意到其危害，不会想到其风险。直到琐碎的积累导致了严重的后果，我们才会正视问题的存在。而这个时候问题或许已经复杂和严重到不可修复或者是要花很大成本修复的地步了。保持一个健康的CI是如此。写代码的每一个细节也是如此。\n还好，很幸运，我们的问题还没有那么严重，还来得及修。\n在决定要修之后，先\n定义一下问题是啥往简单里说，就是CI不稳定，动不动就随便挂。\n说的再细一些，就是我们手写脚本去做部署和测试这件事算是重新发明了轮子。而这个轮子不如已有的经过打磨的轮子那么精巧细致，那么稳定好用。以至于我们的CI偶尔就要出格一次。\nOk，问题定义清楚了，那么想想解决方案吧。\n但是，在提出具体的方案之前，先想想，如果把这个现时还未存在的解决方案作用在现有问题之上，会收获一个什么样的结果呢？\n验证标准基于以上所述，我想解决这个问题的方案要满足以下3点：\n\n能让CI重回稳定\n一条命令行执行整个build\n不要再自己造轮子了\n\n第1，2点毋庸赘言，这就是我们问题的核心。关于第3点，是因为我们没有时间精力，也实在没有必要造这个轮子，如果能找到现有的轮子能够解决问题，而且还比我们自己的木头胶皮轮子好用，那岂不妙哉？\n于是，我要开始寻找一个能让CI重归稳定的神圣轮子了！让探险的旅途就此展开吧！\n![图](http://static.comicvine.com/uploads/original/7/75497/2189954-aragorn247_screen.jpg &#x3D;400x300)\n开始寻找轮子我最初的想法是用play的test framework，其中已经集成了selenium，用来做functional test很是合适。但是由于我们基于protractor的测试数量已经不少了，全部重写成本较高，所以这个轮子就放弃了。\n残念，再看下一个轮子再然后我想到的是自定义一个sbt的task，这个task依赖于sbt已有的run。\n这样就能在我的task启动之前把play跑起来，而task本身运行protractor的测试，再之后则杀掉正在运行的play app。\n看起来不错，但是有问题：\n第一，sbt run跑起来后是不会自己退出的，它会维持play一直在待命的状态，这也就是说我自己的task根本就没机会执行。\n第二，即便能找到方法让我自己定义的task和run同时跑起来，protractor运行完毕后还要关掉run，免得占用端口。这又是一件麻烦事儿。\n于是，这第二个轮子也被我自己给枪毙掉了。\n再次残念，还有轮子吗？会有的，总会有的，只要肯去找，还是会有的。\n这次我想到，写sbt的task不成，那就写代码。我写个specs2测试，在case里用代码启动sbt run，然后再启动protractor，最后关闭sbt，总行了吧？\n这样，确实是可以work的，而实际上我也把它做出来验证了可以work了，但是缺点很大。\n第一，由于我们的specs2测试都是用sbt跑的，而在其中再启动sbt，相当于要开两个jvm，消耗很大。在我本地机器上可以压榨的只剩两位数的内存。\n第二，在sbt已经编译好了产品代码和测试代码测试之后，再开始跑另一个sbt run，会导致sbt把代码重新编译一遍。而Scala的代码编译是很慢的。我试了一下，这两次启动sbt，两次编译所消耗的时间是四分钟左右。时间成本太高。CI的速度会被拉下来，受不了。\n基于以上两点原因，我的第三个轮子也被我自己枪毙了。\n命途多舛啊，三次尝试都失败，以你为我要放弃了吗？哼~~~最后，我结合第一次的尝试和第三次的尝试找到了一个满意的答案。\n来看代码吧：\nclass ProtractorSpec extends Specification with NoTimeConversions &#123;  &quot;my application&quot; should &#123;    &quot;pass the protractor tests&quot; in &#123;      running(TestServer(9000)) &#123;        val resp = Await.result(WS.url(&quot;http://localhost:9000&quot;).get(), 2 seconds)        resp.status === 200        runProtractorTests === 0      &#125;    &#125;  &#125;  private def runProtractorTests: Int = &#123;    &quot;protractor functional-test/config/ft.conf.js&quot;      .run(getProcessIO)      .exitValue()  &#125;  private def getProcessIO: ProcessIO = &#123;    new ProcessIO(_ =&gt; (),      stdout =&gt; fromInputStream(stdout).getLines().foreach(println),      _ =&gt; ())  &#125;&#125;\n\n就只有这么一点点代码。\nrunning和TestServer都是play的test framework所提供的API。顾名思义，其作用就是把play的app跑起来。\n然后发一个get请求，assert它的response的status是200，以此来确保play真的是把server运行起来了的。\n再然后运行shell脚本，把protractor跑起来。这里Scala会做implicit conversion，把字符串转换成ProcessBuilder，从而可以调用其run方法。\n最后assert，protractor的shell脚本是返回了0的，意味着functional test跑成功了。如果protractor测试挂掉，返回了1，那么specs2的这个测试也会挂掉，从而挂掉整个build。而这，正是我想要的。\n这个解决方案合规吗？检验一下吧。\n由于server的启动和关闭都是有play的test framework的API负责的，比自己手写得脚本要稳定，所以符合了重归稳定性这一点。\n由于用了specs2的测试，它可以跑在sbt里，所以符合一条命令跑build这一点。\n整个解决方案只用了specs2和play的test framework，没有重新发明轮子，所以这一点也符合了。\n除了符合最初定下的三条标准之外，还有额外的好处：functional test所跑到的代码会被纳入到测试覆盖率里面去。因为和其他specs2的测试一样，protractor的测试也在sbt jacoco:cover的监视下跑的，所以自然就纳入了coverage的范围。\nTakeaway在解决这个问题之后，我想我会有三点takeaway：\n\n多尝试几种方案，不要随便放弃。即便想，也不要。\n\n不要屈就于working solution，要相信一定存在你现在还没想到的更好的方式。\n\n重复发明轮子总是会显得很诱人，因为它看起来可以非常直接而且准确的解决我们的问题。而实际上它常常是直接而且准确的解决我们的问题的现象。如果能找到现象产生的原因，干死这个原因，问题的解决或许会更彻底。\n\n\n\n\n\n\n","tags":["Scala"]},{"title":"论“如果Scala类有方法接收闭包，这些方法在Java里就不可用，因为Java目前尚不支持闭包。”这句话是错的","url":"/blog/2014/06/27/scala-java-interop-closure/","content":"最近在看郑大翻译的《Scala程序设计》，其中第十一章有一句话：\n\n如果Scala类有方法接收闭包，这些方法在Java里就不可用，因为Java目前尚不支持闭包。\n\n口说无凭，拍照为证：\n\n当时看到这句话就感觉不对。因为JVM本身没有对函数式编程提供任何支持，所以无论是Java中常用的Guava，还是Scala，其对闭包的支持都是通过用类来包裹函数实现的。\n如果说Java目前（其时Java 8还没面世）尚不支持闭包，那倒是还说得过去，因为毕竟是要用类包裹一层，不算真正的函数传递。\n但是说如果Scala类有方法接收闭包，这些方法在Java里就不可用，那就不对了，包一层匿名内部类，我不还是能用吗？虽说不太好看，也不能说不能用啊。\n为了验证一下，写点代码来试试吧。\nclass OnePluser &#123;  def plusOne(func: () =&gt; Int): Int = &#123;    func() + 1  &#125;&#125;\n\n先定义一个Scala类，OnePluser，它有一个plusOne方法，接收一个函数，给函数的返回值加1，然后返回。非常简单。\n在Scala里可以这么调用它：\nclass OnePluserCaller &#123;  def callIt(): Int = &#123;    new OnePluser().plusOne(() =&gt; 5)  &#125;&#125;\n\n一样的简单，一个匿名函数传给它，这个匿名函数返回一个写死的5。这样最后的返回值会是6。\n这段代码如果反编译成Java，会是这样的：\npublic class OnePluserCaller&#123;  public int callIt()  &#123;    return new OnePluser().plusOne(new AbstractFunction0.mcI.sp() &#123;      public final int apply() &#123; return apply$mcI$sp(); &#125;      public int apply$mcI$sp() &#123; return 5; &#125;    &#125;);  &#125;&#125;\n\n毫不出奇，调用plusOne的地方需要提供一个不接收参数，返回一个Int的函数，这个函数在Scala里是() &#x3D;&gt; 5，编译出来就是一个AbstractFunction0的实例，其中的apply方法返回一个写死的5。可以想见，在plusOne中就会调用这个apply方法（已验证，非臆测）。\n既然Scala的编译器可以用这种方式来实现函数的传递，那在Java代码中难道就不可以吗？\n我们写点代码来验证一下吧：\nimport scala.runtime.AbstractFunction0;public class OnePluserCallerJ &#123;    public int callIt() &#123;        return new OnePluser().plusOne(new AbstractFunction0&lt;Object&gt;() &#123;            @Override            public Integer apply() &#123;                return 5;            &#125;        &#125;);    &#125;&#125;\n\n这段代码基本就是照上面的反编译结果照抄的，AbstractFunction0的定义在scala.runtime.AbstractFunction0里，在scala-library-xxx.jar里。xxx是版本号。\n上面的代码可以编译，可以运行，而且也可以得到6这个返回值。\n由此可以证明在当前的Scala版本下（我现在用的是2.10.4）作者的这段话是不成立的。\n但是，当时呢？\n我查了一下，这本书的出版日期是09年，然后查了一下Scala的版本，08年的版本是2.7.7。于是我下载了scala-library-2.7.7.jar。发现其中确实没有AbstractFunction0的定义，但是现在版本的AbstractFunction0是实现了Function0的，而Function0的定义在2.7.7中是有的。而当时如果在Java中写一个实现了Function0的匿名内部类，不也是可行的吗？\nOk，不关注那么老的事儿了，可以确定的一点是，在当前版本下，在Java中是可以调用Scala中定义的接收闭包的函数的。\nTHE END\n\n\n\n\n","tags":["Scala"]},{"title":"Desugar Scala(16) -- lower bound","url":"/blog/2014/06/21/desugar-scala-lower-bound/","content":"Lower bound，不知道这个词的确切中文翻译是怎样的。我们直接看例子吧。\nclass Pair[T](val first: T, val second: T) &#123;  def replaceFirst[R &gt;: T](newFirst: R): Pair[R] = new Pair[R](newFirst, second)&#125;\n\n我们定义一个叫做Pair的类，其中可以包含两个元素，元素类型为泛型的T。\nPair类中有一个replaceFirst方法，用来把第二个元素和一个新的元素结合起来组成一个新的Pair。新的元素的类型是泛型的R。新组成的Pair的类型是Pair[R]。\n到这里我们就要想了，一个T和一个R，它们俩怎么组成新的Pair呢？新的Pair的类型怎么能是Pair[R]呢？\nreplaceFirst的签名给我们说明了这一点。[R &gt;: T]。这种标记的含义是说R是T的基类。那么一个T和一个R自然可以组合成一个R的Pair了。\n单是这样干说，有点不好理解，我们看一个例子：\nclass Vehicle &#123;&#125;class Car extends Vehicle &#123;&#125;class Tank extends Vehicle &#123;&#125;\n\n汽车和坦克都是机动车。\n然后我们可以这样使用它们：\nval twoCars: Pair[Car] = new Pair(new Car(), new Car())val tankAndCar: Pair[Vehicle] = twoCars.replaceFirst(new Tank())\n\n首先我们用两辆汽车组成一个Pair，其类型为Pair[Car]。\n然后我们用一辆坦克替代原来的Pair中的第一个元素，让坦克和第二辆车组成一个新的Pair。新的Pari的类型是Pair[Vehicle]。\n这里有一点tricky。我们调用replaceFirst的时候传递的参数的类型是Tank，这是否意味着在这里R就是Tank呢？\n不是的，因为很明显Tank不是Car的基类，然而Tank是一个（is a）Vehicle，Vehicle同时也是Car的基类。于是此处的R就是Vehicle。得到的新的Pair自然就是Pair[Vehicle]。\n也就是说R会被什么具体类型替换呢？这取决于T和newFirst的类型。\n如果newFirst的类型刚好是T的基类，那太好了，R就直接是newFirst的类型。如果newFirst的类型不是T的基类，那R就会是T和newFirst的类型的共同基类。\n这个东西挺麻烦的，它有啥用呢？保证类型安全，Java没有提供给我们的类型安全。\n还是刚才的那段代码：\nval twoCars: Pair[Car] = new Pair(new Car(), new Car())val tankAndCar: Pair[Vehicle] = twoCars.replaceFirst(new Tank())\n\n其中的第二行，Scala可以很聪明的推断出replaceFirst的返回值类型是Pair[Vehicle]。实际上，如果我们试图把tankAndCar声明为Pair[Tank]的话，会看到编译时错误。\n而类似的代码在Java里则没有这么幸运了：\npublic class PairJ&lt;T&gt; &#123;    private T first;    private T second;    public PairJ(T first, T second) &#123;        this.first = first;        this.second = second;    &#125;    public T first() &#123;        return this.first;    &#125;    public T second() &#123;        return this.second;    &#125;    public &lt;R&gt; Pair&lt;R&gt; replaceFirst(R newFirst) &#123;        return new Pair(newFirst, second());    &#125;&#125;\n\n为了标明区别，我们这次称之为PairJ。到这里忍不住要小小的黑Java一下，21行代码，和Scala的3行是等价的：）\n我们重点看一下replaceFirst在这里的声明，其中声明了一个泛型参数R，但是R和T是没有任何关系的。实际上，在Java中，我们无法表达方法的泛型参数和类型的泛型参数之间的关系。（其原因请参看这里）\n我们写出如下的代码：\nPairJ&lt;Car&gt; twoCars = new PairJ(new Car(), new Car());Tank actuallyACar = twoCars.replaceFirst(new Tank()).second();\n\n先创建两辆车的Pair，然后把第一辆车替换成坦克。再把新组成的Pair里面的第二个元素（其类型是车）取出来，赋值给一个类型为坦克的变量。\n如果我们编译这段代码，Java编译器会允许其通过。但是运行起来就会跑出类型转换异常。原因很明显，Car不能转换成Tank。\n这个，就是刚才所说的类型安全性上的差异。\n等等，脱衣服的部分呢？之前的每一篇博客都会把Scala代码编译出的bytecode反编译成Java，来探索其语言特性是如何实现的。\n而这一次颇为不同。之前的语言特性虽说Scala写起来比Java会简便一些，但是还没有超出Java的能力范围。多费点劲，用Java还是能做到。\n而这一次，这种编译时类型安全检验的严格性，实在是在Java中无法表达的。这全靠了Scala编译器的功劳。\n这就意味着，上面所定义的Pair这个类，如果你在Java中使用它，就会失去这种类型安全性。\nScala，这次算你牛，没扒掉你。\n\n\n\n\n","tags":["Desugar_Scala","Scala"]},{"title":"论“如果trait有方法实现，那么Java类就不能实现这个trait”这句话是错的","url":"/blog/2014/06/28/scala-java-interop-trait-with-impl/","content":"最近还是在看郑大翻译的《Scala程序设计》，其中第十一章还有一句话：\n\n如果trait有方法实现，那么Java类就不能实现这个trait\n\n口说还是无凭，还是拍照为证：\n\n我感觉这句话是错的，下面寻根究底地探索一下。\ntrait这个语言特性前面的博文讲过。\n一个含有方法实现的trait会被编译成一个interface，还有一个含有实现的静态方法。\n所有extends或者是with这个trait的Scala类，实际上都是implements了这个interface，在具体实现中调用了静态方法。\n快速的简单回忆一下：\ntrait HappyThoughts &#123;  def whatAreYouThinking(): Unit = &#123;    println(&quot; food :D &quot;)  &#125;&#125;\n\n定义一个含有方法实现的trait。\nclass Animalclass Dog extends Animal with HappyThoughts\n\n然后让Dog去with这个trait。\n之后就可以这样调用：\nnew Dog().whatAreYouThinking()\n\n这样就能打印出food :D了。虽然Dog本身是空的，但是因为with了一个trait，它也拥有了一些行为。\n再来看看反编译出的代码：\npublic interface HappyThoughts&#123;  public abstract void whatAreYouThinking();&#125;public abstract class HappyThoughts$class&#123;  public static void whatAreYouThinking(HappyThoughts $this)  &#123;    Predef..MODULE$.println(&quot; food :D &quot;);  &#125;  public static void $init$(HappyThoughts $this)  &#123;  &#125;&#125;\n\nHappyThoughts就是上面这样的，一个interface，还有一个含有实现的静态方法。\nDog则是这样的：\npublic class Dog extends Animal implements HappyThoughts&#123;  public void whatAreYouThinking()  &#123;    HappyThoughts.class.whatAreYouThinking(this);  &#125;  public Dog()  &#123;  \tHappyThoughts.class.$init$(this);  &#125;&#125;\n\n它implements了HappyThoughts，其实现则依赖于上面提到的静态方法。\nOk，足够清晰了。\n这么一个trait，当真在Java中不可以利用吗？\n写点代码试试看：\npublic class DogJ implements HappyThoughts &#123;    @Override    public void whatAreYouThinking() &#123;        HappyThoughts$class.whatAreYouThinking(this);    &#125;&#125;\n\n基本照抄上面反编译的代码。这段Java代码是可以编译的，而且也可以运行，运行结果也是打印出了food :D。\n这次，我就不去探寻旧版本的Scala是如何处理trait的了。我们只要知道当前版本（比如我用的2.10.4）的Scala中定义的含有方法实现的trait，拿到Java中依然是可用的就行了。虽说用起来有一点蹩脚，但终归是可用的。\n\n\n\n\n","tags":["Scala"]},{"title":"大理","url":"/blog/2014/08/10/da-li/","content":"昆明机场，等待去大理的飞机\n![：）](http://ww2.sinaimg.cn/large/8b1ece2agw1ej7t5jg23zj20hs0nu0wt.jpg &#x3D;800x)\n下了飞机，出租车上，窗外有云，和蓝天\n![：）](http://ww3.sinaimg.cn/large/8b1ece2agw1ej7t5lh0jvj21w02io1ky.jpg &#x3D;800x)\n第二天早上，帮校长画墙\n![：）](http://ww4.sinaimg.cn/large/8b1ece2agw1ej7t6vgeh4j20f20qowfs.jpg &#x3D;800x)\n![：）](http://ww3.sinaimg.cn/large/8b1ece2agw1ej7t6umefgj20qo0f23zj.jpg &#x3D;800x)\n王鹏和顺子也在画\n![：）](http://ww4.sinaimg.cn/large/8b1ece2agw1ej7t5ohwv6j21w02ioe82.jpg &#x3D;800x)\n去环绕洱海\n![：）](http://ww2.sinaimg.cn/large/8b1ece2agw1ej7t5rds9nj22io1w0x6p.jpg &#x3D;1200x)\n视野开阔，水面如镜\n![：）](http://ww4.sinaimg.cn/large/8b1ece2agw1ej7t5tphlyj22io1w0kjl.jpg &#x3D;1200x)\n云，与水，与山\n![：）](http://ww1.sinaimg.cn/large/8b1ece2agw1ej7t5vwmxkj22io1w0kjl.jpg &#x3D;1200x)\n云诡\n![：）](http://ww3.sinaimg.cn/large/8b1ece2agw1ej7t5yjz3ij22io1w0kjl.jpg &#x3D;1200x)\n![：）](http://ww3.sinaimg.cn/large/8b1ece2agw1ej7t677ddmj22io1w0u0x.jpg &#x3D;1200x)\n无尽的路\n![：）](http://ww1.sinaimg.cn/large/8b1ece2agw1ej7t6cjok0j21w02io7wi.jpg &#x3D;1200x)\n![：）](http://ww1.sinaimg.cn/large/8b1ece2agw1ej7t6ouqxcj22io1w04qq.jpg &#x3D;1200x)\n你是一株什么植物？\n![：）](http://ww3.sinaimg.cn/large/8b1ece2agw1ej7t6ilxm1j22io1w0b2a.jpg &#x3D;1200x)\n你又是一簇什么花？\n![：）](http://ww4.sinaimg.cn/large/8b1ece2agw1ej7t6lishyj22io1w0x6p.jpg &#x3D;1200x)\n晚上回来，墙画好了\n![：）](http://ww3.sinaimg.cn/large/8b1ece2agw1ej7twb68w8j20np0hsdh6.jpg &#x3D;1200x)\n![：）](http://ww4.sinaimg.cn/large/8b1ece2agw1ej7twfj2qfj20np0hs76x.jpg &#x3D;1200x)\n大门口也颇有点样子了\n![：）](http://ww3.sinaimg.cn/large/8b1ece2agw1ej7twdzj0gj20np0hs76v.jpg &#x3D;1200x)\n晒出一条麒麟臂\n![：）](http://ww4.sinaimg.cn/large/8b1ece2agw1ej7t6tr10gj20qo0zkgya.jpg &#x3D;1200x)\n你是谁家的狗？\n![：）](http://ww1.sinaimg.cn/large/8b1ece2agw1ej7t6xx53lj21w02iou0x.jpg &#x3D;1200x)\n为什么一到饭点就来？\n![：）](http://ww1.sinaimg.cn/large/8b1ece2agw1ej7t70jalbj22io1w0npd.jpg &#x3D;1200x)\n扎染的布，不需要买一匹\n![：）](http://ww3.sinaimg.cn/large/8b1ece2agw1ej7t740ay1j22io1w0kjm.jpg &#x3D;1200x)\n走，去喝酒\n![：）](http://ww3.sinaimg.cn/large/8b1ece2agw1ej7tb6qowij20qo0f0dgu.jpg &#x3D;1200x)\n尼玛，为什么这么悲壮？\n![：）](http://ww2.sinaimg.cn/large/8b1ece2agw1ej7tb7fs00j20qo0f0ta4.jpg &#x3D;1200x)\n洱海门下听歌\n![：）](http://ww1.sinaimg.cn/large/8b1ece2agw1ej7tb8ywj6j20qo0f00u6.jpg &#x3D;1200x)\n被雨困住走不了\n![：）](http://ww3.sinaimg.cn/large/8b1ece2agw1ej7tb9y5zbj20qo0f0abc.jpg &#x3D;1200x)\n![：）](http://ww4.sinaimg.cn/large/8b1ece2agw1ej7tbb7rv4j20qo0k076g.jpg &#x3D;1200x)\n时间的轨迹变得模糊，不记得这是哪天晚上，大家在画墙\n![：）](http://ww2.sinaimg.cn/large/8b1ece2agw1ej7t74us92j20hs0nujup.jpg &#x3D;800x)\n燕子来了，走，我们再去一次洱海\n![：）](http://ww4.sinaimg.cn/large/8b1ece2agw1ej7tbhdshdj20hs0d9dgm.jpg &#x3D;800x)\nKratos ！ ！ ！\n![：）](http://ww3.sinaimg.cn/large/8b1ece2agw1ej7tbi2kq4j20hs0d9mxy.jpg &#x3D;800x)\n大家都骑的自行车，是的\n![：）](http://ww3.sinaimg.cn/large/8b1ece2agw1ej7tbc1njnj20hs0dc0to.jpg &#x3D;800x)\n停车拍照\n![：）](http://ww2.sinaimg.cn/large/8b1ece2agw1ej7tbjyfjgj20hs0npmyw.jpg &#x3D;800x)\n![：）](http://ww3.sinaimg.cn/mw690/8b1ece2agw1ej7tbj3z0mj20hs0dc0tz.jpg &#x3D;800x)\n![：）](http://ww2.sinaimg.cn/large/8b1ece2agw1ej7t7xldcyj22io1w0x6p.jpg &#x3D;800x)\n又是波谲云诡点击看大图\n![：）](http://ww1.sinaimg.cn/large/8b1ece2agw1ej7t99kua8j28c01ss4qv.jpg &#x3D;4000x)\n又是无尽的路\n![：）](http://ww4.sinaimg.cn/large/8b1ece2agw1ej7t9nv70uj22io1w0u0x.jpg &#x3D;1200x)\n无尽的路全景点击看大图\n![：）](http://ww4.sinaimg.cn/large/8b1ece2agw1ej7taa5gkrj28c01ssx6v.jpg &#x3D;4000x)\n左手山，右手水点击看大图\n![：）](http://ww2.sinaimg.cn/large/8b1ece2agw1ej7tatvzpgj28c01ssb2g.jpg &#x3D;4000x)\n这是我们当天的队伍\n![：）](http://ww4.sinaimg.cn/large/8b1ece2agw1ej7tb640cfj20hs0d9js4.jpg &#x3D;800x)\n下午累了，吃蛋炒饭。我的索马里海盗造型。\n![：）](http://ww3.sinaimg.cn/large/8b1ece2agw1ej7tb496o3j20hs0nuafg.jpg &#x3D;800x)\n脚蹬子掉了，海盗修车\n![：）](http://ww2.sinaimg.cn/large/8b1ece2agw1ej7tb55t2mj20hs0dgab4.jpg &#x3D;800x)\n这是哪天的饭？\n![：）](http://ww3.sinaimg.cn/large/8b1ece2agw1ej7tbglwrxj20k00qodjf.jpg &#x3D;800x)\n翻墙\n![：）](http://ww1.sinaimg.cn/large/8b1ece2agw1ej7tcodq6nj20qo0f275v.jpg &#x3D;800x)\n![：）](http://ww2.sinaimg.cn/large/8b1ece2agw1ej7tcmilqjj20qo0f2jsp.jpg &#x3D;800x)\n降魔杵\n![：）](http://ww1.sinaimg.cn/large/8b1ece2agw1ej7vgwbjczj20k00qodj2.jpg &#x3D;800x)\n寺外全景点击看大图\n![：）](http://ww4.sinaimg.cn/large/8b1ece2agw1ej7tc6hvxsj28c01ssu12.jpg &#x3D;800x)\n点击看大图\n![：）](http://ww4.sinaimg.cn/large/8b1ece2agw1ej7tbxyah7j28c01ssqvc.jpg &#x3D;800x)\n此为何物？\n![：）](http://ww4.sinaimg.cn/large/8b1ece2agw1ej7vgyuar9j20k00qo0ww.jpg &#x3D;800x)\n![：）](http://ww3.sinaimg.cn/large/8b1ece2agw1ej7vgxhsk3j20qo0k00u8.jpg &#x3D;800x)\n我要撤了，大家包饺子\n![：）](http://ww2.sinaimg.cn/mw690/8b1ece2agw1ej7tcgqk6lj20dc09zaac.jpg &#x3D;600x)\n![：）](http://ww1.sinaimg.cn/large/8b1ece2agw1ej7tchgeihj209y0dcmxl.jpg &#x3D;400x)\n![：）](http://ww1.sinaimg.cn/mw690/8b1ece2agw1ej7tciado3j209y0dcmxd.jpg &#x3D;400x)\n![：）](http://ww4.sinaimg.cn/mw690/8b1ece2agw1ej7tcjbj5cj20hs0nsdgw.jpg &#x3D;600x)\n合影\n![：）](http://ww1.sinaimg.cn/mw690/8b1ece2agw1ej7tcbixf4j20f00qowgu.jpg &#x3D;600x)\n再见！\n![：）](http://ww4.sinaimg.cn/large/8b1ece2agw1ej7tceiarqj22io1w0x6p.jpg &#x3D;1000x)\n我走之后棚子搭好了\n![：）](http://ww1.sinaimg.cn/mw690/8b1ece2agw1ej7vgv5561j20qo0k0adm.jpg &#x3D;600x)\n![：）](http://ww1.sinaimg.cn/mw690/8b1ece2agw1ej7vgt5k59j20qo0k0di4.jpg &#x3D;600x)\n大家还在一起吃饭\n![：）](http://ww3.sinaimg.cn/mw690/8b1ece2agw1ej7tckandsj20qo0f00ua.jpg &#x3D;600x)\n![：）](http://ww4.sinaimg.cn/mw690/8b1ece2agw1ej7tcl911qj20qo0f0763.jpg &#x3D;600x)\n故事还在继续\nTHE END\n\n\n\n\n\n","tags":["图"]},{"title":"褪去Scala的糖衣(10) -- implicit function","url":"/blog/2014/01/01/desugar-scala-10/","content":"Implicit function，中文或许应该叫做隐式函数吧。主要用来作隐式类型转换。例子：\nclass Duck &#123;  def makeDuckNoise() = &quot;gua gua&quot;&#125;class Chicken &#123;  def makeChickenNoise() = &quot;ge ge&quot;&#125;class Ducken(chicken: Chicken) extends Duck &#123;  override def makeDuckNoise() = chicken.makeChickenNoise()&#125;\n\n三个类，鸭子，鸡，还有伪装成鸭子的鸡。如果有这么一个函数：\ndef giveMeADuck(duck: Duck) = duck.makeDuckNoise()\n\n该函数要求我们给它提供一只鸭子，我们可以这么调用它：\ngiveMeADuck(new Duck)\n\n要鸭子就给鸭子，没问题。或者是也可以这样：\ngiveMeADuck(new Ducken(new Chicken))\n\n把一只鸡伪装成鸭子给它，也没问题。但是如果直接把鸡给它就不行了：\ngiveMeADuck(new Chicken)\n\n编译器会给出type mismatch的错误。\n我们已经有一个Ducken类可以用来把鸡化装成鸭子了，那有没有一种方法可以让我们鬼鬼祟祟的就把化妆这件事儿做了？那就不用每次都明火执仗的了。\n答案就是用implicit function：\nimplicit def chickenToDuck(chicken: Chicken) = new Ducken(chicken)\n\n它的用法很简单，给函数加上implicit这个修饰符，函数的参数是鸡，返回类型是鸭子 （或者是任何鸭子的子类都行）。\n然后这行代码就可以编译了：\ngiveMeADuck(new Chicken)\n\n来看一下反编译的结果：\npublic String giveMeADuck(Duck duck) &#123;    return duck.makeDuckNoise();&#125;public Ducken chickenToDuck(Chicken chicken) &#123;    return new Ducken(chicken);&#125;\n\ngiveMeADuck和chickenToDuck都被编译成了中规中矩的方法。giveMeADuck(new Chicken)则被编译成了这个样子：\ngiveMeADuck(this.chickenToDuck(new Chicken()));\n\n一点意外都没有，implicit在反编译后无影无踪，它就是很纯的一点点糖。\n我意淫一下：编译器在发现我们给它的chicken和想要的duck之间存在type mismatch的时候先不着急给出错误，看看有没有标为implicit的函数可以把chicken变成duck或者其子类，如果有则调用该方法，没有再给出错误。\n\n\n\n\n","tags":["Desugar_Scala","Scala"]},{"title":"Desugar Scala(17) -- Option和for，以及脑子里发生的事情","url":"/blog/2014/08/30/options-for/","content":"Scala里的for关键字是个很有趣的东西。可以用来把多层嵌套for循环写成一层。比如这样：\nfor(i&lt;-1 to 10;j&lt;-1 to 10;k&lt;-1 to 10) yield(s&quot;$i $j $k&quot;)\n\n这行代码执行的结果是这样的：\n1 1 11 1 21 1 31 1 41 1 51 1 61 1 71 1 81 1 91 1 101 2 11 2 21 2 31 2 41 2 51 2 61 2 71 2 81 2 91 2 10............\n\n这样，就可以用一行代码写出三层循环的效果。代码看起来非常紧凑，噪音很少。\n但是今天主要要说的不是这种for，而是它和Option结合的写法。\nOption本身是一个抽象类，代表一个可能存在，也可能不存在的值（那谁谁的喵？）。它有两个实现类，分别是Some和None。顾名思义，Some代表有值，None代表没有。\n实际上，上面的说法不够准确，Some是一个实现类，而None实际是一个单例，不过这点对后面的内容没影响。\n现在设想一个很简单的场景，需要用单价和数量来算总价，而单价和数量未必拿得到，那代码大概会是这样的：\ndef calculateTotal: Option[Int] = &#123;  val price: Option[Int] = getPrice  val amount: Option[Int] = getAmount  if (price.isEmpty || amount.isEmpty) &#123;    None  &#125; else &#123;    Some(price.get * amount.get)  &#125;&#125;\n\ngetPrice和getAmount都返回一个Option[Int]，就类似Java中Integer可以为null一样。计算出来的总价也是一个Option[Int]，说不定会有，也说不定没有。\n在这段代码中先检查单价和数量是否存在，如果二者中任意一个不存在，那就返回None，代表无法求得总价。如果二者都存在，那就将二者的乘积用Some包起来返回。\n这代码看起来还ok，很常规的写法，但是稍显啰嗦。如果用上for的话，可以大大简化这段代码：\ndef calculateTotalWithFor: Option[Int] = &#123;  for (price &lt;- getPrice; amount &lt;- getAmount) yield price * amount&#125;\n\n这个方法体只有一行了，而它实现出来的行为和上面那段代码是完全一致的。\n这感觉好神奇啊，不用判断价格和数量是否存在，也不需要根据判断结果决定到底返回None还是Some。它是怎么搞的呢？\n看一下反编译的结果吧：\npublic Option&lt;Object&gt; calculateTotalWithFor() &#123;    return getPrice().flatMap(new AbstractFunction1() &#123;        public final Option&lt;Object&gt; apply(final int price) &#123;            return OptionAndFor..MODULE$.account$of$OptionAndFor$$getAmount().map(new AbstractFunction1.mcII.sp() &#123;                private final int price$1;                public final int apply(int amount) &#123;                    return apply$mcII$sp(amount);                &#125;                public int apply$mcII$sp(int amount) &#123;                    return price * amount;                &#125;            &#125;);        &#125;    &#125;);&#125;\n\n这个反编译的结果很不好读，不过还是可以看出个大概。它先是对getPrice的返回值调用了flatMap，给其传入一个匿名函数（AbstractFunction1），在这个匿名函数里面又对getAmount的返回值调用了map，也给其传入了一个匿名函数，再在这第二层匿名函数里做了乘法运算。\n如果用Scala把它表达出来，是这样的：\ndef calculateTotalWithFlatMapAndMap: Option[Int] = &#123;  getPrice.flatMap(price =&gt; getAmount.map(amount =&gt; amount * price))&#125;\n\n由此可见，上面使用for的代码的神奇之处在于它利用了Option的flatMap和map方法。\n这两个方法具有一个共同特征：如果被调用flatMap或者map的当前Option实例为None的话，则忽略传入的匿名函数，直接返回None。\n这很容易理解，要参与运算的成员之一已经是None了，那就不用管剩下的成员到底是啥了，它随便是啥，最终的计算结果都会是None。这和最初写出的用 || 运算符的代码的逻辑是一致的。\n到此为止，我们给Option和for的结合使用脱光了衣服，它就是利用Option的flatMap和map来实现紧凑的代码的。\n神奇之处不仅在于更短的代码，还在于它提高了信噪比，给我们提供了更加简化的思考模型最初那段用if else的代码，在写它或者读它的时候，我们的脑子里面发生了什么呢？\n1. 要获取价格和数量\n2. 要判断价格是否为空，要判断数量是否为空        （与业务关联较小，属于技术范畴）\n3. 如果任意一个为空，结果是空                 （与业务关联较小，属于技术范畴）\n4. 如果两个都不是空，再做乘法运算\n\n而在写或者读用for的那段代码的时候，脑子里又是怎么想的呢？\n1. 获取价格和数量\n2. 做乘法运算\n\n我们写这段代码的目的是要表述业务逻辑，是要给未来读代码的人传递和业务相关的信息。\n而空值判断是偏技术的，把这种代码消掉，我们传递给其他程序员的信息里就含有更少的与业务无关的噪音。而且我们自己写起来的时候，脑子里也不需要考虑那么多的东西。\n对自己，对他人都有利。这实在是一个美妙的语言特性。\n\n\n\n\n","tags":["Desugar_Scala","Scala"]},{"title":"在使用play framework的evolutions？需要支持SQL Server？用Liquibase吧","url":"/blog/2014/07/18/play-evolutions-to-liquibase/","content":"我所在的项目在用Scala + Play framework做一个web app。\nPlay自带的evolutions是一个DB Migration工具，从一开始我们就在用它来做所有阶段的数据迁移工作。\n运行自动化测试时它可以帮每个测试用例在H2中创建数据（H2是Play默认的内存数据库）。在下一个测试用例运行时evolutions则会创建一份和上次完全相同的新数据，这样我们的测试可以获得独立性而不用担心之前的测试遗留的副作用。也不用担心会给下一个测试遗留下什么脏数据。\n在测试或者部署环境中运行时它也可以针对Postgres做数据迁移。\n这一切看起来都挺好，我们就差喊evolutions是我们忠实的好伙伴了。\n但是，快到给终端客户部署时，某一家客户提出他们一定要使用SQL Server，我们最初提出的使用Postgres他们不接受了。这时我们才发现evolutions的设计初衷就是在开发和测试阶段提供便利性，它根本就没想成为一个production ready的东西。\n这样看来我们必须得寻找一个正经的DB Migration的工具了。而且这个DB Migration工具一定要满足以下几点：\n\n能够在运行自动化测试时和H2结合使用（因为我们已经有很多测试在依赖于H2跑了，要换掉成本较高）\n能支持多种数据库（今天有人要SQL Server的支持，明天说不定还会有人要其他的）\n在支持多种数据库时不需要我们写不同风格的SQL脚本（要写出让各个DB都不挑剔的SQL实在是太费劲了）\n\n我最先想到的就是Flyway，之前用过，而且TW的tech radar也提到过它。\n但是它并没有入选，原因在于上面的第三点。Flyway要求使用者自己提供执行所需的SQL脚本。这就意味着我们写SQL时需要同时兼顾H2，Postgres，SQL Server的异同。而且还无法预知未来的其他数据库会对我们现在写出的SQL脚本产生什么样的影响。\n最后我们选择了Liquibase，我们可以通过JSON，YAML，或者XML来定义数据。Liquibase自己负责把我们定义的数据翻译给各种不同的数据库。\n这样，通过一层中间语言。我们就隔离了数据库的差异对我们开发工作可能会造成的影响。\nOk，要用Liquibase这个大方向就确定了。但是具体怎么把它跑起来呢？在什么时机跑它呢？\n用脚本跑？\nLiquibase确实提供了Standalone，我们可以用脚本来调用它。\n但是这怎么和build结合起来呀？在测试时调用它？在app启动时调用它？\n那H2运行的端口每次都未必是一样的，这怎么办啊？\n这个方案想想就费劲。\n把它做成sbt的一个task？\n这样确实比直接用脚本要稍微距离我们的build近一点，但是还是会有类似的问题。我们需要显式地去调用它，还要选择合适的时机去调用它。实现起来也会很麻烦。\n而实际上，Play自己是支持plug in的。我们想要控制执行时机，而有谁比Play自己更了解它的运行时机呢？\n而且已经有人做了liquibase play plug in。我把它fork了一份，更新了liquibase和play的版本，提高了log的level。并且部署到了sonatype去。\n由于是Play自己的plug in，不是我们试图插入的生硬的脚本或者sbt task。Play自己知道该在什么合适的时机去执行它。\n下面说一下如何应用它吧。\n\n在所有的conf文件中删掉所有和evolutions有关的配置\n\n这两个东西不能一起用，要不然我们需要同时维护两种DB Migration的脚本。\n\n在dependencies中加入这一项：\n\n“com.github.cuipengfei” % “play-liquibase_2.11” % “1.1”\n很明显，这是用来引入这个plugin的。\n\n在conf目录下创建一个名为play.plugins的文件，在其中写入：\n\n400:com.github.cuipengfei.LiquibasePlugin\n冒号前的400用来定义plugin的执行优先级，Play会由此决定何时执行该plugin。\n冒号后是plugin的完全限定名。\n\n在你需要的conf文件中加入两行：\n\nliquibaseplugin&#x3D;enabled\napplyLiquibase.default&#x3D;true\n这样用来启用该plugin。\n\n在conf&#x2F;liquibase&#x2F;default&#x2F;下创建一个modules.xml。\n\n在其中写入你的数据定义。（具体如何写，liquibase的官网有详细的介绍）\n如果你用的数据库名字不是default，相应的替换就ok了。\n这样，就大功告成了。\n当你用sbt运行自动化测试时，liquibase会帮你创建数据。\n当你在本地调试运行时，liquibase会帮你set up数据库。\n当应用被部署到生产环境下去的时候，liquibase也可以帮你在第一次运行时进行数据的初创。\n\n\n\n\n","tags":["Scala","ScalaInAction"]},{"title":"Scala中Stream的应用场景及其实现原理","url":"/blog/2014/10/23/scala-stream-application-scenario-and-how-its-implemented/","content":"假设一个场景需要在50个随机数中找到前两个可以被3整除的数字。\n听起来很简单，我们可以这样来写：\ndef randomList = (1 to 50).map(_ =&gt; Random.nextInt(100)).toListdef isDivisibleBy3(n: Int) = &#123;  val isDivisible = n % 3 == 0  println(s&quot;$n $isDivisible&quot;)  isDivisible&#125;randomList.filter(isDivisibleBy3).take(2)\n\n一个产生50个随机数的函数；\n一个检查某数字是否能被3整除的函数；\n最后，对含有50个随机数的List做filter操作，找到其中所有能够被3整除的数字，取其中前两个。\n把这段代码在Scala的console里面跑一下，结果是这样的：\nscala&gt; randomList.filter(isDivisibleBy3).take(2)31 false71 false95 false7 false38 false48 true88 false52 false2 false27 true90 true55 false96 true91 false82 false83 false8 false51 true96 true27 true12 true76 false17 false53 false54 true70 false29 false49 false12 true83 false18 true6 true7 false76 false51 true95 false76 false85 false87 true84 true44 false44 false89 false84 true42 true44 false0 true23 false35 false55 falseres34: List[Int] = List(48, 27)\n\n其最终结果固然是没有问题，找到了48和27这两个数字。但是非常明显的可以看出，isDivisibleBy3被调用了50次，找到了远多于两个的能被3整除的数字，但是最后我们只关心其中前两个结果。\n这似乎有点浪费，做了很多多余的运算。\n对于这个例子来说，这还没什么，我们的List很小，判断整除于否也不是什么耗时操作。\n但是如果List很大，filter时所做的运算很复杂的话，那这种做法就不可取了。\n现有解法的优缺点randomList.filter(isDivisibleBy3).take(2)\n这行代码有一个优点：\n用描述性、声明性的语言描述了我们要做的事是什么，而无需描述怎么做。我们只需说先用filter过滤一下，然后拿前两个，整件事就完成了。\n但是它同时也有一个缺点：\n做了多余的运算，浪费资源，而且这个缺点会随着数据量的增大以及计算复杂度的增加而更为凸显。\n试着解决其缺点解决多余运算的思路很简单，不要过滤完整个List之后再取前两个。而是在过滤的过程中如果发现已经找到两个了，那剩下的就忽略掉不管了。\n顺着这个思路很容易写出如下很像Java的代码：\ndef first2UsingMutable: List[Int] = &#123;  val result = ListBuffer[Int]()  randomList.foreach(n =&gt; &#123;    if (isDivisibleBy3(n)) result.append(n)    if (result.size == 2) return result.toList  &#125;)  result.toList&#125;\n\n创建一个可变的List，开始遍历随机数，找到能被3整除的就把它塞进可变List里面去，找够了两个就返回。\n执行的结果如下：\nscala&gt; first2UsingMutable31 false89 false21 true29 false12 trueres35: List[Int] = List(21, 12)\n\n可以看到，运算量确实变少了，找够了两个就直接收工了。\n但是这实在很糟糕，显式使用了return同时还引入了可变量。\n有什么东西像是一个foreach循环而又可以不引入可变量呢？fold\ndef first2UsingFold: List[Int] = &#123;  randomList.foldLeft(Nil: List[Int])((acc, n) =&gt; &#123;    if (acc.size == 2) return acc    if (isDivisibleBy3(n)) n :: acc    else acc  &#125;)&#125;\n\n执行：\nscala&gt; first2UsingFold98 false77 false68 false93 true93 trueres36: List[Int] = List(93, 93)\n\n效果和上面一段代码类似，没有多余的运算。但是由于需要early termination，所以还是摆脱不了return。\n这两种解法在去除多余运算这个缺点的同时也把原来的优点给丢掉了，我们又退化回了描述如何做而不是做什么的程度了。\n如何保持代码的表意性而又不用做多余运算呢？其实类似的问题是有套路化的解决方案的：使用Stream。\nrandomList.toStream.filter(isDivisibleBy3).take(2).toList\n\n这行代码执行的结果：\nscala&gt; randomList.toStream.filter(isDivisibleBy3).take(2).toList86 false15 true53 false20 false93 trueres42: List[Int] = List(15, 93)\n\n可见没有多余运算了，而且这行代码和最初代码极为相似，都是通过描述先做filter再做take来完成任务的。缺点没有了，优点也保留了下来。\n这同样都是filter和take，代码跟代码的差距咋就这么大呢？\n答案就是：因为Stream利用了惰性求值（lazy evaluation），或者也可以称之为延迟执行（deferred execution）。\n接下来就看一下这两个晦涩的名词是如何帮助Stream完成工作的吧。\n实现原理在这里我借用一下Functional programming in Scala这本书里对Stream实现的代码，之所以不用Scala标准库的源码是因为我们只需要实现filter，take和toList这三个方法就可以展示Stream的原理，就不需要动用重型武器了。\n先假设我们自己实现了一个MyStream，它的用法和Stream是类似的：\nMyStream(randomList: _*).filter(isDivisibleBy3).take(2).toList\n\n以这一行代码为引子，我们来开始解剖MyStream是如何工作的。\n类型签名trait MyStream[+A] &#123;\t. . . . . .&#125;case object Empty extends MyStream[Nothing]case class Cons[+A](h: () =&gt; A, t: () =&gt; MyStream[A]) extends MyStream[A]\n\n一个trait叫做MyStream，其中的内容我们暂时忽略掉。\n它有两个子类，一个Cons，一个Empty。Empty当然是代表空Stream了。\n而Cons则是头尾结构的，头是Stream中的一个元素，尾是Stream中余下的元素。请注意头和尾这两个参数的类型并不是A，头的类型是一个能够返回A的函数，尾的类型是一个能够返回MyStream[A]的函数。\n初始化有了以上的类型定义以及头尾结构，我们就可以把很多个Cons加一个Empty（或者是无限多个Cons，没有Empty）连起来就构成一个Stream了，比如这样：\nCons(()=&gt;1,()=&gt;Cons(()=&gt;2,()=&gt;Empty))\n\n这样就可以构造一个含有1，2的Stream了。\n不过，请注意，上面的说法并不严谨，实际上它是一个包含着两个分别会返回1和2的函数的Stream。\n也就是说当上面的代码在构造Cons的时候，1和2还没有“出生”，它们被包在一个函数里，等着被释放出来。\n如果说我们通常熟知的一些集合包含的是花朵的话，那Stream所包含的就是花苞，它本身不是花，但是有开出花来的能力。\nSmart初始化当然，如果直接暴露Cons的构造函数出去给别人用的话，那这API也未免太不友好了，所以Stream需要提供一个易用的初始化的方式：\nobject MyStream &#123;  def apply[A](elems: A*): MyStream[A] = &#123;    if (elems.isEmpty) empty    else cons(elems.head, apply(elems.tail: _*))  &#125;  def cons[A](hd: =&gt; A, tl: =&gt; MyStream[A]): MyStream[A] = &#123;    lazy val head = hd    lazy val tail = tl    Cons(() =&gt; head, () =&gt; tail)  &#125;  def empty[A]: MyStream[A] = Empty&#125;\n\n这个没有太多好解释的，我们就是用apply和小写的cons这两个方法来把客户代码原本要写的一大堆匿名函数给代劳掉。\n需要注意的一点是apply方法看似是递归的，好像是你调用它的时候如果给它n个元素的话，它会自己调用自己n-1次。事实上它确实会调用自己n-1次，但是并不是立即发生的，为什么呢？\n因为小写的cons方法所接受的第二个参数不是eager evaluation的，这就会使得apply(elems.tail: _*)这个表达式不会立即被求值。这就意味着，apply缺失会被调用n次，但是这n次并不是一次接一次连续发生的，它只会在我们对一个Cons的尾巴求值时才会发生一次。\n如果说普通的集合中包含的是数据的话，那Stream中所包含的就是能够产生数据的算法。\n如何？是不是花朵花苞的感觉又回来了？\n还记得我们开始剖析的时候那句代码是什么吗？\nMyStream(randomList: _*).filter(isDivisibleBy3).take(2).toList\n\n现在我们算是把MyStream(randomList: _*)这一小点说清了。\n接下来看MyStream(randomList: _*).filter(isDivisibleBy3)是如何work的。\nfiltertrait MyStream[+A] &#123;  def filter(p: A =&gt; Boolean): MyStream[A] = &#123;    this match &#123;      case Cons(h, t) =&gt;        if (p(h())) cons(h(), t().filter(p))        else t().filter(p)      case Empty =&gt; empty    &#125;  &#125;. . . . . .&#125;\n\n这个方法定义在基类里，又是一个看似递归的实现。\n为什么说是看似呢？因为在\nif (p(h())) cons(h(), t().filter(p))\n\n这行代码中我们又用到了小写的cons，它所接受的参数不会被立即求值。也就是说filter一旦找到一个合适的元素，它就不再继续跑了，剩下的计算被延迟了。\n比较值得提一下的是：这里的h()是什么呢？h是构造Cons时的第一个参数，它是什么类型的？()&#x3D;&gt;A。它就是之前提到的能够生产数据的算法，就是那个能够开出花朵的花苞。在这里我们说h()，就是在调用这个函数来拿到它所生产的数据，就是让一个花苞开出花朵。\ntakeMyStream(randomList: _*).filter(isDivisibleBy3).take(2)\n\n接下来就该说take是如何work的了。在这里我们可以回顾一下，MyStream(randomList: _*)返回一个类型为MyStream[Int]，其中包含很多个可以返回Int的函数的容器。然后我们调用了这个容器的filter方法，filter又返回一个包含很多个可以返回Int的函数的容器。请注意，到这里为止，真正的计算还没有开始，真正的计算被包含到了一个又一个的函数（花苞）中，等待着被调用（绽放）。\n那对filter的结果调用take又会怎样呢？\ntrait MyStream[+A] &#123;  . . . . . .  def take(n: Int): MyStream[A] = &#123;    if (n &gt; 0) this match &#123;      case Cons(h, t) if n == 1 =&gt; cons(h(), MyStream.empty)      case Cons(h, t) =&gt; cons(h(), t().take(n - 1))      case _ =&gt; MyStream.empty    &#125;    else MyStream()  &#125;  . . . . . .&#125;\n\n看过了前面的apply和filter之后，take就显得顺眼了很多。我们又见到了小写的cons，条件反射一般，我们就可以意识到，只要看见cons，那就意味着作为它的参数的表达式不会被立即求值，那这就意味着计算被放到了函数里，稍后再执行。那稍后到底是什么时候呢？\n那就得看下面的toList了。\ntoListtrait MyStream[+A] &#123;  . . . . . .  def toList: List[A] = &#123;    this match &#123;      case Cons(h, t) =&gt; h() :: t().toList      case Empty =&gt; Nil    &#125;  &#125;&#125;\n\n又是一个递归实现，但是这次可不是看似递归了，这次是实打实的递归：只要还没有遇到空节点，就继续向后遍历。这次没有使用cons，没有任何计算被延迟执行，我们通过不断地对h()求值，来把整个Stream中每一个能够生产数据的函数都调用一遍以此来拿到我们最终想要的数据。\n总结要把以上的代码细节全部load进脑子跑一遍确实不太容易，我们人类的大脑栈空间太浅了。\n所以我们试着从上面所罗列出的纷繁的事实中抽象出一些适合人脑理解的描述性语句吧：\n\nList(1,2,3)会构造一个容器，容器中包含数据\n\nList(1,2,3).filter(n&#x3D;&gt;n&gt;1)会构造出一个新的容器，其中包含2和3，这两块具体的数据\n\nList(1,2,3).filter(n&#x3D;&gt;n&gt;1).take(1)会把上一步中构造成的容器中的第一块数据取出，放入一个新容器\n\nMyStream(1,2,3)也会构造一个容器，但是这个容器中不包含数据，它包含能够生产数据的算法\n\nMyStream(1,2,3).filter(n&#x3D;&gt;n&gt;1)也会构造出一个新的容器，这个容器中所包含的仍然是算法，是基于上一步构造出的能生产1，2，3的算法之上的判断数字是否大于1的算法\n\nMyStream(1,2,3).filter(n&#x3D;&gt;n&gt;1).take(1)会把上一步中构造成的算法容器中的第一个算法取出，放入一个新容器\n\nMyStream(1,2,3).filter(n&#x3D;&gt;n&gt;1).take(1).toList终于把上面所有步骤构造出的算法执行了，从而得到了最终想要的结果\n\n\n上面对List和Stream的应用的区别在哪儿呢？\n就在于List是先把数据构造出来，然后在一堆数据中挑选我们心仪的数据。\n而Stream是先把算法构造出来，挑选心仪的算法，最后只执行一大堆算法中我们需要的那一部分。\n这样，自然就不会执行多余的运算了。\n\n\n\n\n","tags":["Scala","ScalaInAction"]},{"title":"solving regular problems in scala","url":"/blog/2014/09/06/solving-regular-problems-in-scala/","content":"\n\n\n\n\n","tags":["Scala","ScalaInAction"]},{"title":"Spark RDD的fold和aggregate为什么是两个API？为什么不是一个foldLeft？","url":"/blog/2014/10/31/spark-fold-aggregate-why-not-foldleft/","content":"大家都知道Scala标准库的List有一个用来做聚合操作的foldLeft方法。\n比如我定义一个公司类：\ncase class Company(name:String, children:Seq[Company]=Nil)\n它有名字和子公司。然后定义几个公司：\nval companies = List(Company(&quot;B&quot;),Company(&quot;A&quot;),Company(&quot;T&quot;))\n\n三家大公司，然后呢，我假设有一家超牛逼的公司把它们给合并了：\ncompanies.foldLeft(Company(&quot;King&quot;))((king,company)=&gt;Company(name=king.name,king.children:+company))\n\n这个执行的结果是这样的：\nscala&gt; companies.foldLeft(Company(&quot;King&quot;))((king,company)=&gt;Company(name=king.name,king.children:+company))res6: Company = Company(King,List(Company(B,List()), Company(A,List()), Company(T,List())))\n\n可见foldLeft的结果是一家包含了BAT三大家得新公司。\n由List[Company]聚合出一个新的Company，这种属于foldLeft的同构聚合操作。\n同时，foldLeft也可以做异构的聚合操作：\ncompanies.foldLeft(&quot;&quot;)((acc,company)=&gt;acc+company.name)\n\n它的执行结果是这样的：\nscala&gt; companies.foldLeft(&quot;&quot;)((acc,company)=&gt;acc+company.name)res7: String = BAT\n\n由List[Company]聚合出一个String。\n这样的API感觉很方便，只要是聚合，无论同构异构，都可以用它来做。\n最近接触了Spark，其中的RDD是做分布式计算时最常用的一个类。\nRDD有一个叫做fold的API，它和foldLeft的签名很像，唯一区别是它只能做同构聚合操作。\n也就是说如果你有一个RDD[X]，通过fold，你只能构造出一个X。\n如果我想通过一个RDD[X]构造一个Y出来呢？\n那就得用aggregate这个API了，aggregate的签名是这样的：\naggregate[U](zeroValue: U)(seqOp: (U, T) ⇒ U, combOp: (U, U) ⇒ U)(implicit arg0: ClassTag[U]): U\n\n它比fold和foldLeft多需要一个combOp做参数。\n这让我很不解，同构和异构的API干嘛非得拆成两个呢？怎么不能学Scala的标准库，把它做成类似foldLeft的样子呢？\n后来想明白了，这是由于Spark需要分布运算造成的。\n先想一下Scala List的foldLeft是怎么工作的？\ncompanies.foldLeft(Company(&quot;King&quot;))((king,company)=&gt;Company(name=king.name,king.children:+company))\n\n\n拿到初始值，即名字为king的公司，把它和list中的第一个公司合并，成为一个包含一家子公司的新公司\n把上一步中的新公司拿来和list中的第二个公司合并，成为一个包含两家子公司的新公司\n把上一步中的新公司拿来和list中的第三个公司合并，成为一个包含三家子公司的新公司\n\n这是同构的过程。\ncompanies.foldLeft(&quot;&quot;)((acc,company)=&gt;acc+company.name)\n\n\n拿到初始值，即空字符串，把它和list中的第一个公司的名字拼在一起，成为B\n把上一步中的B第二个公司名字拼一起，成为BA\n把上一步中的BA拿来和list中的第三个公司的名字拼一起，成为BAT\n\n这是异构的过程。\n像多米诺骨牌一样，从左到右依次把list中的元素吸收入结果中。\n现在假设RDD[X]中有一个类似foldLeft的API，其签名和foldLeft一致，我现在调用foldLeft，给它一个f:(Y,X)&#x3D;&gt;Y，接下来该发生什么呢？\n\n因为要分布计算，所以我先要把手里的很多个X分成几份，分发到不同的节点上去\n每个节点把拿到的很多个X计算出一个Y出来\n把所有节点的结果拿来，这时我手里就有了很多个Y\n啊。。。我不知道怎么把很多个Y变成一个Y啊。。。\n\n由于Spark的RDD不像Scala的List一样只需要推倒一副多米诺骨牌，而是要推倒很多副，最后再对很多副多米诺骨牌的结果做聚合。\n这时如果是同构还好，我只需要再用f:(X,X)&#x3D;&gt;X做一遍就ok了。\n但是如果是异构的，那我就必须得再需要一个f:(Y,Y)&#x3D;&gt;Y了。\n\n\n\n\n","tags":["Scala","ScalaInAction","Spark"]},{"title":"2014年总结","url":"/blog/2014/12/27/2014/","content":"2014年即将结束，需要做一些总结。\n既然总结是写在博客上的，第一项就先说博客吧。\n博客2014年写了18篇博客，其中15篇和Scala有关，自认为都是有且仅有干货的。\n对此，我比较_满意_。\n不过这个数字存在欺骗性，15篇Scala的博客，其中4篇写于1月份，6篇写于6月份，其余的零散的写就与其他月份。\n66.66…%集中地爆发于两个月里，其余十个月只贡献了总体的33.33…%\n可见写博客这件事于我而言并没有形成持久的习惯，只是随激情而来的自我娱乐。\n明年可以_改进_的是不要嫌话题小，不要嫌话题不够深。有了有价值的想法就记下来，形成惯性。\n读书\n38本，加上马上快读完的一本Ruby的书，算是39本。\n对这个数字，我比较_满意_。\n但是其中直接或间接与技术相关的只有8本，只占20%。\n所以，和上面一节类似，单独观察总体数字本身是极具欺骗性的。\n另一个我不满意的是读书的结果。把这39本书的封面罗列出来放到面前，我都能记得我看过这本书，但是有很多我都记不起其主要观点是什么。\n所以明年的一个_改进_点是做笔记和书评，有利于记忆和吸收。\n另外一个_改进_点是领域，我明年需要看一些轻量级的经济、哲学和社会心理学的书。口说无凭，于此立字为据。\nMOOC\n上图来自MOOC学院，data visualization做的很漂亮，不过没有分年统计。\n2014年实际只上完了4门课。\n对这些课程的质量，从中的收获我都比较_满意_。\n不太满意的是数字，明年_改进_的目标定在6。\n与读书不同，上课需要的时间比较长。有的课会持续两个月。一年能上完的课不会太多，领域不宜太广。\n暂定技术相关的至少3门，其他三门如果有特别好的非技术课就上一下，没有的话就还是上技术课。给自己留一些随性自由发挥的空间：）\nWell-being今年体重从72.5公斤降到了61.1公斤。\n最近三个月的数据统计\n\n\n上张一个月前的裸照：）\n\n\n明年没有太多改进的目标，维持就ok了。\n其他脾气还是不好，察言观色并据此反应的能力还是差。\n今年试过的手段有降低分贝，减慢语速，少用激进词汇，延长反应时间，多听少说。\n有效果，但不是很明显。执行不够有效，自我监控不够严格。\n对此，我_不满意_。\n像这种与天性作斗争的行为，其过程一定是困难，漫长，且鲜有正面自我回馈的。\n明年需要_改进_的是，持续以上改进手段的执行，增加自控强度。\n\n\n\n\n","tags":["me"]},{"title":"2015第一季度","url":"/blog/2015/03/29/2015-first-season/","content":"时间是以何种方式流逝的呢？\n三个月瞬间就不见了。\n对照着去年的总结和当时对未来的期望写一下2015年第一季度吧。\n博客惨不忍睹。\n除了一个应付任务的tech radar的session写在了博客上，其他啥都没写。\n去年博客有产出是因为在刷Scala这个主线任务。\n今年做的都是支线任务，这一点那一点，难以形成有效的产出。\n要形成有效的产出，需要有plan，有execution，有retro。\n兴之所至，就把今年的博客主线任务定为OO与FP的比较和结合应用吧。\n读书不错。\n第一个季度已经读完10本书。数量达标。\n说过要做的笔记也做了。\n笔记的作用确实很好，每隔一段时间回顾一次，spaced repetition可以促进和加深记忆。不会再有“卧槽，这本书我看过吗？作者都讲了些啥啊？”的尴尬事。\n看完了《经济学原理》的微观分册，这是最近几年来读过的最大部头的一本书。鉴于之前一直没有耐心读厚书，这可以算作是一个进步。\n开始把待读的书按照内容领域和期待得到的效果分类放到豆列里。这样每次没书看了就去想读的豆列里挑一本。不用每次都700选一了。\n读书的领域扩张也在按照之前的计划进行，没有风险。\n博客需要有主线任务，读书要配合，可以优先选一些讲paradigm的书来读。\nMOOC尴尬。\n这三个月一个mooc都没有跟。4月13日，reactive programming课要开，这个一定要跟，而且一定要跟完。\n估计完成当时6门课的目标有点悬了。\n非常无耻地修改一下mooc的目标吧：配合主线任务，以读书和mooc作为输入，博客作为产出。数量和领域都不做具体限定。（果然够无耻）\n体重稳定。\n上次写年终总结的时候是61.1公斤，现在是61.0公斤。\n当时写的是：\n\n明年没有太多改进的目标，维持就ok了。\n\n没有了减重目标，没有了改进方向，效果果然是不会自动出现的啊。这是很有意思的一个现象，没有了改进的意愿，或许潜意识里对热量摄入和消耗都没有那么敏感和严格。\n还好胸在变大，肱三在变大，腹肌在浮出水面。\n最后写个阶段性总结还是有用，发掘出了主线任务。\n\n\n\n\n","tags":["me"]},{"title":"Tech radar 武汉 microservice envy","url":"/blog/2015/01/13/tech-radar-wuhan/","content":"\n\n\n\n\n","tags":["TW"]},{"title":"2015武汉郑大晔校第二次课","url":"/blog/2014/11/16/zdyx2015wuhansecondclass/","content":"\n\n\n\n\n","tags":["TW"]},{"title":"English workshop Wuhan 2015.04.14","url":"/blog/2015/04/11/wuhan-english-workshop/","content":"\n\n\n\n\n","tags":["TW"]},{"title":"职业女性确实处于劣势吗？记一次不甚严谨的考据 -- 向胡适之先生的遥远致敬","url":"/blog/2015/04/04/women-in-finance-it-and-r-and-d/","content":"源起前两天，在一个武汉本地程序员聚集的技术社区微信群里某位群友发了两张图片：\n\n\n这是某个IT公司的招聘宣传，为程序员提供的鼓励师。\n（由于图片出现在愚人节期间，不确定该公司是真的有这样的人员配备，还是恶作剧的，此处暂且存疑）\n马上群里就有一位X君跳出来说这种事情就是混蛋啊，怎么女人就得给男人端茶倒水擦汗啊。\n另外一位Y君就说没有啊，这就是开个玩笑啊，不要这么较真啊。\nX君继续说：！@#￥%……&amp;*啊\nY君回应：*&amp;……%￥#@！啊\n于是，你也可以猜到的，这中间X君就说了IT行业对于女性从业者存在歧视，收入不平等之类的话。\n这让我颇为感慨：武汉也无非是这样。武大的樱花烂熳的时节，群中却有这样标致极了的讨论。其实，又何止武汉呢？\n正当X君与Y君酣战之时，有另外一位群友问声称存在收入歧视的X君是否有数据支持其观点。\n恰巧我这周正在看《胡适文选》。胡适之先生反复提醒读者要有怀疑精神，凡事要讲求证据，要用科学的手段得出科学的结论。\n胡适之先生之言于我心有戚戚焉，于是我便想要搜罗数据，深入了解一下这个话题，算作是对胡适之先生的遥远致敬。\n以上，为源起。\n定题近来我正尝试着自我疏离本性中近似于周树人先生的那一部分。\n便不太愿用“歧视”这个颇为尖刻的词汇，因而本文的标题中用了“劣势”这一稍为中性的说法。\n既然要考据，就不妨把话题放大些，不独观察IT行业的女性，莫若把视角扩宽到整个职业女性上去。\n再加上我不是专业的考据家，并没有投入大量时间精力去搜索资料，交叉引证也不够详备，那就不能怕会过谦，也在标题上加上“不甚严谨”这几个字。\n于是便有了这个颇显啰嗦的标题：《职业女性确实处于劣势吗？记一次不甚严谨的考据 – 向胡适之先生的遥远致敬》。\n是为题目由来。\n开篇我是一个颇为庸俗的人，也时常会被称为理性的人。\n于是，别人看待职业女性的眼光、上司是否会给小鞋穿、同事是否会区别对待等等这些无法量化，难以考量的因素均不采用。\n我就只认准了：\n在一个行业中具有某种特征的人群占多数就可以被称作是有优势的\n在一个行业中具有某种特征的人群挣钱多就可以被称作是有优势的\n这两条考校标准。\n所以接下来通篇都围绕着人数多寡和挣钱多少展开。\n什么行业收入高？**中华人民共和国国家统计局，中国统计年鉴（2014）**中有一个条目：按行业分城镇单位就业人员平均工资，以Excel格式提供：\n（这一行Excel实在是太长了，我把它分开截了两张图）\n\n\n其中收入最高的三个行业标记为了红色，分别为金融，IT和科研。\n原数据可以在这里找到：http://www.stats.gov.cn/tjsj/ndsj/2014/indexch.htm\n点击左侧的“四、就业和工资”然后点击第“4-15”项，里面可以下载Excel。\n或者也可以直接通过这个链接下载Excel：http://www.stats.gov.cn/tjsj/ndsj/2014/zk/html/Z0415C.xls\n那接下来就按图索骥，考量这三个行业中女性的状况。\n（为什么只有三个？笔者精力有限，只求管窥，不求完全覆盖）\n金融搜寻良久，实在是找不到国内的资料，只好拿些英文的资料作为旁证了。\n以下是来自美国的公平就业机会委员会（Equal Employment Opportunity Commission,缩写为EEOC）2006年发布的一份报告中关于女性金融从业者比例的图表：\n\n从最后一行的汇总信息可以看出，经理级别的职位，女性占18%左右。\n专业从业者中，女性约为26%。\n技术与销售类的职位则只有个位数的百分点。\n但到了书记员，抄写员（Clerical，表中最后一列）这一类的职位，却有43%是女性。\n由此不难观察到，在美国，金融这个高薪行业中女性在做着勤务工作，升到经理职位的甚少。\n这份报告的出处：http://www.eeoc.gov/eeoc/statistics/reports/finance/finance.pdf\n公平就业机会委员会的wiki页面：http://zh.wikipedia.org/wiki/公平就业机会委员会\n而另外一份来自于英国**平等与人权委员会（Equality and Human Rights Commission，EHRC）**2009年春季发布的报告则有些不同：\n\n从这张男女性别比例的图表可以看出，英国的金融行业男女从业人数基本一比一，差距不大。从最后一行的汇总数据来看，女性还比男性多一个百分点。\n而下面这张出自同一报告的关于收入差距的图表，则显露了另外的信息：\n\n英国金融行业中，全职工作的男性年收入比全职工作的女性多55%。\n而在全社会所有行业中，这个数字也有28%。\n可见在英国女性虽然以同等的人数参与进了金融行业，但是却没有拿到哪怕是接近同等的薪水。\n这份报告的出处：http://www.equalityhumanrights.com/sites/default/files/documents/download__finance_gender_analyis_research.pdf\n平等与人权委员会的wiki页面：http://en.wikipedia.org/wiki/Equality_and_Human_Rights_Commission\nIT接下来开始看三大高收入行业中的第二名：IT行业中女性的状况。\n我找到了一份来自美国的非营利机构：**National Center for Women &amp; Information Technology (NCWIT)**在2009年发布的报告。\n（没找到这个机构确切的中文翻译，就保留原文吧）\n报告中有一张女性IT从业人员比例随年份变化的趋势图：\n\n容易看出，从上个世纪八十年代中期到九十年代初期，女性IT从业者比例在攀升，从30%增长到37%左右。\n在此之后则一路下降，到2008年已经减少到了25%左右。\n出自同一报告的还有另外一张男女收入差距随工作经验变化的趋势图：\n\n可以看出，入行初期男女收入没太大区别，但从第三年开始，逐渐拉开差距，由3%增加到12%。\n好了，又是一个高薪行业。女性只占其中的四分之一，而且收入还比男性少。\n报告出处：http://www.ncwit.org/sites/default/files/legacy/pdf/NCWIT_TheFacts_rev2010.pdf\nNCWIT的wiki页面：http://en.wikipedia.org/wiki/National_Center_for_Women_%26_Information_Technology\n科研高薪行业之三，科研。\n找到了两份来自欧盟的报告。\n第一份报告中有一张科研行业中女性从业者比例的图表，数据采集自1999年：\n\n不难看出，其中希腊和葡萄牙的女性科研工作人员较多，占有41%和43%。\n德国和匈牙利则很低，女性只有14%到19%。\n其他八个国家大致是落在26%到33%这个区间。\n第二份报告发布于2012年，其中有一张男女收入差距的图表：\n\n该图表数据统计于2002年和2006年，从中不难看出，女性在科研行业的各个分支中收入比男性低20%到40%。\n由此可见，在欧洲，科研行业作为一个高薪行业，其中女性从业人员较少。即便进入这个行业的女性，其收入也要较男性低。\n第一份报告出处：https://ec.europa.eu/research/swafs/pdf/pub_gender_equality&#x2F;wir_final.pdf\n第二份报告出处：http://ec.europa.eu/research/science-society/document_library&#x2F;pdf_06&#x2F;meta-analysis-of-gender-and-science-research-synthesis-report.pdf\n发布报告的欧盟网站：http://ec.europa.eu/index_en.htm\n小结以上观察了三个薪水最高的行业：金融，IT和科研，这三个行业中都呈现出了女性从业人员少于男性，且收入低于男性的态势。\n如果这条结论和以上干巴巴的数据无法让您获得感性的认知的话，那我们再结合其他数据做个分析。\n以下是来源于非营利组织National Association of Colleges and Employers (NACE)的一份报告中关于平均年工资涨幅的数据：\n\n可以从最后一行看出，平均工资涨幅是每年7.5%。\n这意味着什么呢？\n[1] pry(main)&gt; Math.log(1.55,1.075)=&gt; 6.059885534213904[2] pry(main)&gt; Math.log(1.12,1.075)=&gt; 1.5670305391527257[3] pry(main)&gt; Math.log(1.20,1.075)=&gt; 2.5210161634544224[4] pry(main)&gt; Math.log(1.40,1.075)=&gt; 4.652504958776575\n\n如果您不是IT行业的看不懂上面的代码没关系，我来解释一下。\n这意味着，如果您是一名金融行业的女性从业者，您旁边座位上是一名和您同时进公司的男同事。你们的关系很好，他甚至都不介意让您看他的工资单。这给在公司属于珍稀物种的您带来了不少宽慰。但是经过分析自己历年的工资涨幅，您会发现如果您想要和他赚到一样多的钱的话，您还要再工作六年才行。\n而这个数字在IT行业是一年半。\n在科研行业是两年半到四年半。\n以上引用报告出处：https://www.naceweb.org/uploadedFiles/Content/static-assets/downloads/executive-summary/2014-september-salary-survey-executive-summary.pdf\nNACE的wiki页面：http://en.wikipedia.org/wiki/National_Association_of_Colleges_and_Employers\n然后呢？以上仅仅是通过交叉引证来描述了职业女性的状况。是属于实证性的表述（positive statement）。\n而关于职业女性应该处于何种状况，那是属于规范性的表述（normative statement），本文就不涉及了。\n女性在这些高薪行业中人数少于男性，这是好事吗？这是坏事吗？\n女性在这些高薪行业中收入低于男性，应该如何评价这件事呢？\n金融，IT和科研，听起来都是理工宅男的专长啊，女的少不是属于正常现象吗？\n女性的收入低于男性，那有可能是她们干活不给力啊，那收入低就是应该的吧？\n所有这些问题，都属于价值判断。通过上面引用的数据，以及常识的积累，我对这些问题会有确定性的判断。想来你也能猜到我的判断是什么。但是我不把它说出来，留待读者自己得出结论。\n2020-11-12 更新感谢读者Victoria Mesbere的来信并推荐了一篇与本文主题契合的文章：技术女性赋权指南。\n与本文只揭示现象不同，这篇文章给出了一些可供实操的建议，推荐阅读：https://www.websiteplanet.com/blog/the-empowering-guide-for-women-in-tech/\n\n\n\n\n","tags":["Fem"]},{"title":"Principles of Reactive Programming Week One作业导学","url":"/blog/2015/04/19/principles-of-reactive-programming-week-one/","content":"#前尘Principles of Reactive Programming在4月13号又开课了。https://www.coursera.org/course/reactive\n上次开课是在2013年的11月，当时我刚第一次上完Functional programming principles in Scala，热情很高于是就报名参加了这门课。还群发了一个邮件找人一起上课。\n但是上了几周发现有点难，于是就放弃了。现在去bitbucket看，最后一次push停留在了2013-11-18。\n后来还在上海被8x鄙视于无形之中。\n后世14年做了几个月的Scala开发，后来Functional programming principles in Scala再次开课又上了一遍，拿了个认证证书。\n感觉似乎可以再挑战一次。\n今生上课习得的知识放在脑子里是不牢靠的。大脑有遗忘周期。\n需要有成文或者成代码的产出，作为日后回忆和做spaced repetition的资料。\n于是就有了这个即将成为系列的博文中的第一篇《Principles of Reactive Programming Week One作业导学》。\n这系列博文的目标读者仅限于报名参加了这门课并且看完了视频，看完了作业的instruction之后仍有困难的同学。\n这系列博文不会公布作业的答案，那是违反Coursera的code of honor的。\n我只会试着解释作业中已有的代码，以及应该如何入手。\n其实，写这个系列博文对我的帮助比对读者的帮助要大。\n正文Heap.scala第一周的代码下载下来之后，先来看一下Heap.scala这个文件。\n这个文件里定义了很多个trait。现在只需要关注其中一个Heap。\n这个就是所有其他trait都会去extend的基类（这个说法合适吗？）。它定义了所有Heap的实现者都需要实现的方法。\n然后BinomialHeap完整实现了Heap定义的所有东西。\nBogus1BinomialHeap到Bogus5BinomialHeap都是继承自BinomialHeap，其中各自覆盖了BinomialHeap的不同方法，以不同的方式引入了bug。第一周作业的目的就是用ScalaCheck把其中的bug找出来。\n这个文件里还有一个IntHeap，这个稍后再说。\n实现代码其实就只有这一个文件，接下来看测试代码。\nQuickCheckSuite.scala这个文件里主要定义了QuickCheckSuite这个测试类。\n这个测试类继承自FunSuite，这是ScalaTest的测试基类。同时mix in了Checkers，这是ScalaTest为了与ScalaCheck集成而提供的trait。\n接下来看测试的case：\ndef checkBogus(p: Prop) &#123;  var foundBug = false  try &#123;    check(p)  &#125; catch &#123;    case e: TestFailedException =&gt;      foundBug = true  &#125;  assert(foundBug, &quot;A bogus heap should NOT satisfy all properties. Try to find the bug!&quot;)&#125;test(&quot;Binomial heap satisfies properties.&quot;) &#123;  check(new QuickCheckHeap with BinomialHeap)&#125;test(&quot;Bogus (1) binomial heap does not satisfy properties.&quot;) &#123;  checkBogus(new QuickCheckHeap with Bogus1BinomialHeap)&#125;test(&quot;Bogus (2) binomial heap does not satisfy properties.&quot;) &#123;  checkBogus(new QuickCheckHeap with Bogus2BinomialHeap)&#125;\n\n可以看到，每个case都调用了check这个方法，或者是check的变体-checkBogus。\ncheckBogus里面则调用了check，并且assert说一定要出现TestFailedException异常了，测试才算成功。也就是说checkBogus的目的就是要在某些Heap的实现中找到bug。\n现在来看check这个方法本身。它接受一个类型为Prop的参数，这些参数从哪儿来呢？这些参数就是：\nnew QuickCheckHeap with BinomialHeapnew QuickCheckHeap with Bogus1BinomialHeap\n这些代码。\n这就意味着QuickCheckHeap一定要是一个Prop，是不是这样呢？\nQuickCheckHeap.scala那就到QuickCheckHeap.scala这个文件中来看一下。\n可以看到QuickCheckHeap这个抽象类确实是extends了Properties，而properties又extends了Prop。那么，没问题，这个类型是匹配的。\nQuickCheckHeap里可以定义任意多个property，这些property将会检查Heap的实现正确与否。\n而且它还mix in了IntHeap，就是前面略过的那个trait。它的目的是锁定Heap这个trait里所定义的A这个元素的类型到Int。\n全部连起来第一周作业的已有代码很少，有用的就是这三个文件。\nHeap.scala定义了很多个Heap的不同实现。有些是正确的，有些是有bug的。\nQuickCheckSuite.scala则是测试的入口点，它由JunitRunner拽着跑起来。其中的test case使用ScalaCheck去检查对于Heap这种数据结构恒定为true的properties是不是hold住的。\n对于Heap这种数据结构恒定为true的properties从哪儿来呢？就来自于QuickCheckHeap.scala。QuickCheckHeap本身是一个抽象类，不可以被实例化。但是由于有了牛逼的trait，就可以用这种代码：\nnew QuickCheckHeap with BinomialHeapnew QuickCheckHeap with Bogus1BinomialHeap\n创建出实例，进行测试了。\n最后，我们的任务就是在QuickCheckHeap.scala添加更多的properties，把所有实现有误的Heap都揪出来。\n题外话有没有发现QuickCheckHeap.scala里面有些奇怪的代码？\nproperty(&quot;min1&quot;) = forAll &#123; (heap: H, a: A) =&gt;  val min = if (isEmpty(heap)) a else findMin(heap)  findMin(insert(min, heap)) == min&#125;\n\nproperty(“min should be min”)，这看起来像是一个方法调用啊。\n尼玛，方法调用后面怎么跟着一个等号啊？等号后面还有一个有返回值的表达式啊？\n这是啥啊？\n这是个乍一看很自然，但是仔细一想很费解的Scala语言特性-update方法。\n详情请见我之前的一篇博客：http://cuipengfei.me/blog/2014/06/12/scala-update-method/\n\n\n\n\n","tags":["Scala","MOOC","Reactive"]},{"title":"Principles of Reactive Programming Week Two作业导学","url":"/blog/2015/04/26/principles-of-reactive-programming-week-2/","content":"声明这系列博文的目标读者仅限于报名参加了这门课并且看完了视频，看完了作业的instruction之后仍有困难的同学。\n这系列博文不会公布作业的答案，那是违反Coursera的code of honor的。\n我只会试着解释作业中已有的代码，以及应该如何入手。\n其实，写这个系列博文对我的帮助比对读者的帮助要大。\n这周的作业不太难，主要就是一个观察者模式。\nSignal是怎么work的？scala&gt; val a = Var(1)a: calculator.Var[Int] = calculator.Var@7ca6f5b9scala&gt; val b = Var(2)b: calculator.Var[Int] = calculator.Var@2286d26scala&gt; val c = Signal(a() + b())c: calculator.Signal[Int] = calculator.Signal@5c60548dscala&gt; c()res8: Int = 3scala&gt; a()=10scala&gt; c()res10: Int = 12scala&gt; b()=20scala&gt; c()res12: Int = 30\n\n如果能搞懂上面的代码是如何work的，作业题中需要用到Signal的地方就不会有太大问题了。\na&#x3D;1，b&#x3D;2，c&#x3D;a+b，所以c就是3。\na变成10之后c就变成了12（10+2）。\nb再变成20之后，c就变成了30（10+29）。\n这个级联的变化是如何发生的呢？\n有两个关键点：\n\nSignal的constructor\nSignal的update方法\n\n先看Signal的constructor。\nclass Signal[T](expr: =&gt; T) &#123;  //......&#125;\n\n以上是它的签名，关键在于expr的类型签名，expr的类型不是T，而是&#x3D;&gt;T。\n这就意味着expr可以是任何类型为T的表达式，可以是一个字面量，也可以是任意复杂的代码块。\n比如Signal(123)是可以的，Signal(complicatedMethodCall())也可以。\n最上面那块代码中的val c &#x3D; Signal(a() + b())就属于后一种。\na() + b()不会被立即求值成3然后传入Signal的constructor，而是整体作为一个可以被反复求值的表达式被记录在Signal的实例中。\nconstructor的入口参数可以被反复求值是级联变化的基础，那是什么触发了真正的变化呢？\n那就是关键点之二：update方法。\nupdate方法的妙处在于，如果一个类A有update方法，那么：\nval x = new A()x(y)=z\n\n在编译之后会变成这样：\nval x = new A()x.update(y,z)\n\n详情请见我之前的一篇博客：http://cuipengfei.me/blog/2014/06/12/scala-update-method/\nSignal的update方法是protected的，不可访问，所以它只可以从变，不可自变。\n而Var把update方法public出来了，这样，在下面这样的代码执行时：\na()=10//a.update(10)\n\na就会通知它的observers去重新求值。这样就实现了a或者b这样的Var变化的时候，c这样的Signal跟着变化的效果。\n搞懂了上面的内容就足以去做作业了。\n怎么和html页面结合起来的？执行instruction里提到的webUI&#x2F;fastOptJS这个task就会把Scala作业代码编译成js。\n这个task是scalajs这个dependency带进来的（在webui.sbt里）。\nwebui这个项目里有一个CalculatorUI.scala文件，也会被编译成js。其中的代码就把作业代码和html的UI结合起来了。\n就是这样了，这周的作业不难懂也不太难做。\n\n\n\n\n","tags":["Scala","MOOC","Reactive"]},{"title":"twu pecha kucha","url":"/blog/2015/04/22/twu-pecha-kucha/","content":"\n\n\n\n\n","tags":["TWU"]},{"title":"职责链模式的别扭就像用门框夹核桃","url":"/blog/2015/05/30/fp-implementation-of-chain-of-responsibility/","content":"职责链模式\n责任链模式在面向对象程式设计里是一种软件设计模式，它包含了一些命令对象和一系列的处理对象。每一个处理对象决定它能处理哪些命令对象，它也知道如何将它不能处理的命令对象传递给该链中的下一个处理对象。该模式还描述了往该处理链的末尾添加新的处理对象的方法。\n\n以上是wiki对职责链模式的定义。\n举个例子来说，我们的系统中需要记录日志的功能。日志需要根据优先级被发送到不同的地方。\n低优先级的日志输出到命令行就好了。而高优先级的错误信息则需要通过邮件通知相关人员并且输出到命令行。\n这个例子也是来自wiki的。\n以下是wiki提供的Java实现：\nJava\n\n首先定义一个Logger抽象类。从其setNext和message这两个方法可以看出，我们后面会把多个具有不同writeMessage实现的Logger链到一起，并且依次让它们处理某件需要被记录的事件。\n\n\n\n\n\n\n然后有三个Logger的实现，分别为向命令行输出消息，发送邮件（当然是假的），向命令行输出错误。\n\n\n最后，有一个main函数，创建三个Logger的实例，把它们通过setNext链在一起。 只需要调用一次message就可以让三个Logger依次工作。\n如果以后再有更多的Logger呢，还是可以通过同样的方式把它们链接起来协同工作。\n很好，很强大，很易于扩展，对吧？\n不过再想一下这三个Logger的实现类看起来都非常的单薄，弱不禁风。\n一个接收mask的构造函数，其唯一职责就是把接收到的mask传递给父类的构造函数。\n然后父类根据mask和所发生事件优先级的大小关系决定到底要不要调用子类实现的writeMessage方法。\n也就是说，子类完全没有定义自己的实例级状态，其实例级方法的行为也就谈不上随着其状态的变化而变化了。\n换句话说，这几个子类存在的价值就在于为父类提供writeMessage这个函数。\n啊。。。。。。！\n一说到提供函数，我就想到了。。。。。。\nfunctions我想到的自然是FP了，既然需要的是函数，那我们就使用函数好了。\n何必用更重的抽象手段：类，去包裹函数呢？\n下面就是比较偏函数式的Scala实现：\n\n\n这个代码已经简短到我不想解释的程度了。不过还是解释一下吧。\n三个log的的等级ERR，NOTICE和DEBUG和之前Java的实现是一样的。\n一个case class Event，用来包裹需要被log的事件。\ntype Logger则是声明了一个函数签名，凡是符合这个签名的函数都可以作为logger被使用。\n然后便是三个函数实现，它们将mask通过闭包封进函数内。这三个函数共同依赖一个私有handleEvent函数，其作用和Java代码中的message类似，判断mask和正在发生的事件之间优先级大小关系，并以此决定当前logger是否需要处理该事件。\n哎？等一下，这个是职责链模式啊，那个啥，链在哪儿呢？就在main函数里。其中的andThen就可以把三个logger链在一起。\n这个andThen是个什么东西？何以如此神奇？\n欲知详情，请参考我之前的另一篇博客： http://cuipengfei.me/blog/2013/12/30/desugar-scala-9/\n而链接之后的结果本身也是一个函数，于是我们就可以调用chain并传入Event了。\n这份代码和前面Java版的行为是等价的，输出是一致的。\n门框夹核桃最后回到标题上去：门框夹核桃，意即用不合适的工具解决问题。\n职责链模式想要做到的事情其实就是把多个函数链起来调用。\n该模式提出的时候FP并不如今日盛行，其作者选用类来包装需要被链接的多个函数，这无可厚非。\n无论是class，还是function，都是为程序员提供抽象的手段。当我们想要链接的东西就是多个function，选择直接用function而非class就会显得更加自然，也更加轻量且合适。\n当年design pattern的作者广为传播各种patterns，实为功德。\n不过今天我们有了核桃夹，就无需一定要用门框了。\n最后，依照惯例，羞辱Java一小下下。以上wiki提供的实现有77行，偏FP风的实现只有38行，只有一个实体Event。\n\n\n\n\n","tags":["Scala","OODP"]},{"title":"策略模式的尴尬就像用菜刀开啤酒","url":"/blog/2015/05/27/trait-and-fp-makes-strategy-pattern-irrelevant/","content":"策略模式\n策略模式作为一种软件设计模式，指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。\n\n以上是中文wiki中对策略模式的定义。\n\nIn computer programming, the strategy pattern (also known as the policy pattern) is a software design pattern that enables an algorithm’s behavior to be selected at runtime. The strategy pattern:\n\n\ndefines a family of algorithms,\nencapsulates each algorithm, and\nmakes the algorithms interchangeable within that family.\n\n\nStrategy lets the algorithm vary independently from clients that use it.\n\n以上是英文版的。\n鸭子这种偏学术性的描述实在太绕嘴，来思考一个实例：\n我们需要创建一些鸭子，鸭子有什么行为呢？\n\n鸭子会飞\n会叫\n会游泳\n\n不过，是否所有的鸭子都是这样呢？万一是玩具鸭子呢？万一是猎人放在水里的用来勾引公鸭子的木质母鸭子呢？万一是外星来客太空鸭呢？\n你已经知道什么意思了。\n鸭子的各个子类的飞和叫的行为不尽相同。所以我们想把飞和叫这两种行为独立开来，让它们可以自由组合在鸭子的不同子类中。\n以上例子来自著名的《Head first design patterns》。\nJava以下是《Head first design patterns》附带的代码：\n\n\n\n\n\n\n飞行的接口，以及两个实现：一个真会飞，一个不会飞。\n\n\n\n\n\n\n叫的接口，两个实现，一个真会叫，一个不会叫。\n\n\n\n\n\n\n最后，终于到了鸭子。鸭子的顶层抽象类声明两个字段，一个用来飞，一个用来叫。\n这样在子类里就可以把这两个字段锁定到某个特定的实现，以实现任意的组合。\n可以看到，绿头鸭（mallard）组合了真会飞和真会叫。而诱饵鸭（decoy，猎人用来勾引鸭子上钩的那个）则组合了不会飞和不会叫。\n可以想象随着飞和叫这两个家族的扩大，我们可以组合出更多种类的鸭子来。\n很好，很灵活，很强大，对吧？\n不过再想一下我们想要的不过是把两个家族的不同行为塞到鸭子的子类里去。是否有更容易的办法来做到呢？\ntrait一说到把行为塞到某个类里，就会想到mix in，很自然就想到了Scala的trait。\n更多关于Scala的trait的详情请参考我的另一篇博客： http://cuipengfei.me/blog/2013/10/13/scala-trait/\n\n\n飞行家族。\n\n\n叫的行为的家族。\n\n\n最后，鸭子的各种实现。\n貌似和Java版的实现差距不大，飞和叫的interface和class变成了trait。\nDuck原来是持有Fly和Quack的实例，现在则是变成了混入Fly和Quack这两个trait。\n这个代码比Java短一些，紧凑一些，构造函数中的赋值变成了类型声明时的混入。\n不过再想一下我们不过是想要把某种行为塞入到某个类里面去，真的有必要用interface，class，trait来把这些行为包裹起来吗？\n行为通常是以哪种形式承载的呢？\nfunctions行为通常是以函数承载的。\n也就是说我们想要做的不过是把符合某个签名的函数塞到鸭子的子类里去而已，而却用interface，class，trait来把这些行为包裹起来了。有些臃肿不是吗？\n下面是直接把函数塞入鸭子子类的做法：\n\n\nFly和Quack不再是interface或者是trait。而是type aliase。\nScala的type aliase就类似于C#的delegate，用来声明function signature。\n更多关于type aliase的更多详情请参考我的另一篇博客： http://cuipengfei.me/blog/2013/12/23/desugar-scala-4/\n这样，会飞不会飞，会叫不会叫就无需被class或者trait包裹着了，直接就是一个个的函数。\n鸭子的子类通过构造函数接收飞和叫的两个函数作为参数，就能够组合不同的行为了。\n如果说之前triat的实现方式与Java实现版相比偏重了inheritance而不是composition，这一版的实现则又回到了纯composition的路上了。\n紧凑程度，实体数量都比以上两版有改进。这一点从行数上可以窥见：Java版63行，trait版29行，最后一版21行。\n菜刀开啤酒最后回到标题上去：菜刀开啤酒，意即用不合适的工具解决问题。\nstrategy patten要解决的问题其实就是如何把一族行为的不同实现注入到某个类里去。\n这一点，最开头的wiki定义已经说的很明白了：\n\nStrategy lets the algorithm vary independently from clients that use it.\n\n无论是class，还是function，都是为程序员提供抽象的手段。当我们想要抽象的东西就是一段algorithm（正如wiki所说）的时候，用function来做抽象就是更加轻量且合适的选择。\n该模式提出的时候FP并不如今日盛行，其作者选用纯OO的方式解决了问题，并广为传播，实为功德。\n不过今天我们有了开瓶器，就无需一定要用菜刀了。\n最后是一个Java 8的实现：\n\n\n\n\n\n\n\n\n\n\n\n\n看起来比最开始的那一版好一些，但是我还是看它不顺眼。\n为什么呢？\n一定是由于我强烈的偏见而没有其他任何原因，一定是这样的。\n\n\n\n\n","tags":["Scala","OODP"]},{"title":"解释器模式：OOP versus Functional Decomposition","url":"/blog/2015/06/05/interpreter-pattern-oop-versus-functional-decomposition/","content":"解释器模式\nIn computer programming, the interpreter pattern is a design pattern that specifies how to evaluate sentences in a language. The basic idea is to have a class for each symbol (terminal or nonterminal) in a specialized computer language. The syntax tree of a sentence in the language is an instance of the composite pattern and is used to evaluate (interpret) the sentence for a client.\n\n以上是wiki对解释器模式的描述。\n这是一个学术性稍强的模式，不太好找到生活化的比喻。\n就直接上代码吧。\nJavainterface Expression &#123;    int interpret(Map&lt;String, Expression&gt; variables);&#125;\n\n首先有一个表达式的接口，定义一个求值的方法，该方法接收一个String -&gt; Expression的map。\n可以猜到，这个map就是该表达式求值的时候需要用到的context。\nclass Plus implements Expression &#123;    Expression leftOperand;    Expression rightOperand;    public Plus(Expression left, Expression right) &#123;        leftOperand = left;        rightOperand = right;    &#125;    public int interpret(Map&lt;String, Expression&gt; variables) &#123;        return leftOperand.interpret(variables) + rightOperand.interpret(variables);    &#125;&#125;class Minus implements Expression &#123;    Expression leftOperand;    Expression rightOperand;    public Minus(Expression left, Expression right) &#123;        leftOperand = left;        rightOperand = right;    &#125;    public int interpret(Map&lt;String, Expression&gt; variables) &#123;        return leftOperand.interpret(variables) - rightOperand.interpret(variables);    &#125;&#125;class Number implements Expression &#123;    private int number;    public Number(int number) &#123;        this.number = number;    &#125;    public int interpret(Map&lt;String, Expression&gt; variables) &#123;        return number;    &#125;&#125;class Variable implements Expression &#123;    private String name;    public Variable(String name) &#123;        this.name = name;    &#125;    public int interpret(Map&lt;String, Expression&gt; variables) &#123;        if (null == variables.get(name)) return 0;        return variables.get(name).interpret(variables);    &#125;&#125;\n\n然后有表达式的四个实现类：加法表达式，减法表达式，数字表达式，还有变量。\n数字表达式在求值的时候就直接返回它被创建时拿到的数字就好了，这是最简单的。\n加法和减法的interpret方法在求值的时候仅仅是把行为委托给了两个子表达式，再对子表达式的求值结果做加减法。\n变量在求值的时候则是去context里面寻找其name对应的表达式（也就是它所指向的表达式），然后对其求值。\n下面是对它们的结合使用：\npublic class InterpreterExample &#123;    public static void main(String[] args) &#123;        Map&lt;String, Expression&gt; context = new HashMap&lt;&gt;();        context.put(&quot;w&quot;, new Number(5));        context.put(&quot;x&quot;, new Number(10));        context.put(&quot;z&quot;, new Number(42));        Plus expr = new Plus(new Variable(&quot;w&quot;),                new Minus(new Variable(&quot;x&quot;),                        new Variable(&quot;z&quot;)));        System.out.println(expr.interpret(context));    &#125;&#125;\n\n首先构造一个context，里面有w，x，z三个数字。然后计算w+(x-z)的值（看着像不像Lisp？）。\n不过再想一下这些代码实际做的是什么事呢？\n实际就是把一个以遇到Number为退出条件的递归算法拆碎了。\n如果我们不把它拆碎，就写成递归函数会如何呢？\nfunctions用Scala试着实现一下：\ntrait Exprcase class Plus(left: Expr, right: Expr) extends Exprcase class Minus(left: Expr, right: Expr) extends Exprcase class Number(n: Int) extends Exprcase class Var(name: String) extends Exprobject ExprEval &#123;  def eval(expr: Expr, context: Map[String, Expr]): Int = &#123;    expr match &#123;      case Plus(l, r) =&gt; eval(l, context) + eval(r, context)      case Minus(l, r) =&gt; eval(l, context) - eval(r, context)      case Var(name) =&gt; eval(context(name), context)      case Number(n) =&gt; n    &#125;  &#125;  def main(args: Array[String]) &#123;    val context = Map(&quot;w&quot; -&gt; Number(5), &quot;x&quot; -&gt; Number(10), &quot;z&quot; -&gt; Number(42))    val expr = Plus(Var(&quot;w&quot;), Minus(Var(&quot;x&quot;), Var(&quot;z&quot;)))    println(eval(expr, context))  &#125;&#125;\n\n以上就是全部代码，与Java版等价。递归函数很容易看懂，其退出条件也很容易看出来。\n69行代码变成了26行。\n四个case class代表四种表达式，其中并没有什么方法，只是用来作为数据的承载者。\n一个eval函数，用pattern match来对四种表达式进行不同的处理。\n不过这次我倒不是要宣扬说解释器模式属于是用不合适的工具解决问题。\n而是要介绍两种组织代码的方式：按行组织还是按列组织。\n按行组织代码与按列组织代码昨天我在看解释器模式，准备写一个Java实现，再写一个Scala实现，并以此来达到我黑Java的阴暗目的。\n但是看了wiki上的示例代码后，马上就想起了去年上过的一门MOOC：《Programming languages》。（这门课是由华盛顿大学的Dan Grossman教授讲授的，内容极好，强烈推荐。）\n这门课里有一节就提到了上面说的两种组织代码的方式：按行组织还是按列组织。这节课的视频在这里：https://www.youtube.com/watch?v=uEHnI3pq_FM）\n比如我们上面的两版代码，Java代码把对表达式的求值分散在每个不同的表达式类里。\n而Scala代码把求值代码集中写在一个函数里，pattern match每种表达式类型并求值。\n如果要做成一个表格的话，就是这样的：\n\n其中的问号代表具体的求值实现。\nJava代码横向组织，有一个Plus类，里面有interpret方法，有一个Minus类，里面有interpret方法，等等。这是按照行组织。\n而Scala代码则纵向组织，有一个eval函数，纵向把四种表达式的求值都包揽了。这是按列组织。\n上面的表格太小，看着不明显，现在假设我们需要打印表达式的功能。那么表格就会变成这样：\n\n可以想象，Java代码里会在每个表达式类里加一个toString函数的实现。横向扩展，一个类把数据和算法组织在一起。\n而在Scala代码里则会写一个toString的递归函数，包揽所有字符串打印的工作。纵向扩展，一个函数去分辨数据类型，并据此选择计算策略。\nOOP versus Functional Decomposition那到底哪种组织方式更好呢？\n并没有确定的答案，Dan Grossman教授在课程中给出的解释是这样的：\n\nFP and OOP often doing the same thing in exact opposite way: organize the program “by rows” or “by columns”.Which is “most natural” may depend on what you are doing (e.g., an interpreter vs. a GUI) or personal taste.\n\n到底如何组织取决于你想要解决什么样的问题，比如你要做一个GUI库，那么数据与算法放在一起，互相接近是最自然的组织方式。这时选择OOP是最好的设计决策。\n而如果你要实现的东西类似于本文中的解释器，那么一个递归的算法来统一处理所有表达式类型则是最自然的。这时选择Functional Decomposition是最好的设计决策。\n结语OOP与Functional Decomposition，这二者并不是完全对立的。\n熟练掌握多种抽象与代码组织方式，正确识别应用场景，据此选择合适的范式，或者是选择多种范式结合使用，才是这一系列博文的真实用意。\n只不过由于传统的OO设计模式过于盛行，FP范式接受度不够，才会有这一系列博文黑Java，捧Scala的表象。\n\n\n\n\n","tags":["Scala","OODP"]},{"title":"观察者模式 in FP：Mutation vs Transformation","url":"/blog/2015/06/13/observers-pattern-fp/","content":"观察者模式\n观察者模式（有时又被称为发布&#x2F;订阅模式）是软件设计模式的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实作事件处理系统。\n\n以上是wiki对观察者模式的解释。\n举一个《Head first design pattern》中的例子：\n比如说有一个气象站，每当气象有变化的时候就需要显示当前天气。需要显示历史平均气温，最高气温和最低气温。还需要根据气压预测晴雨。\n这种情况就很适合使用观察者模式，每种需要显示气象的装置作为观察者，气象数据本身作为可以被观察的对象。每当气象变化的时候，被观察的对象就会通知观察者来根据新的数据作出新的显示。\n以下是书中给出的代码：\nJavapublic interface Observer &#123;    void update(float temp, float humidity, float pressure);&#125;public interface Subject &#123;    void registerObserver(Observer o);    void notifyObservers();&#125;\n\n首先定义两个接口，一个是观察者，接收新的气象数据。一个是被观察者，可以注册观察者以及通知观察者。\npublic class WeatherData implements Subject &#123;    private ArrayList&lt;Observer&gt; observers = new ArrayList&lt;&gt;();    private float temperature;    private float humidity;    private float pressure;    public void registerObserver(Observer o) &#123;        observers.add(o);    &#125;    public void notifyObservers() &#123;        for (Observer observer : observers) &#123;            observer.update(temperature, humidity, pressure);        &#125;    &#125;    public void setMeasurements(float temperature, float humidity, float pressure) &#123;        this.temperature = temperature;        this.humidity = humidity;        this.pressure = pressure;        notifyObservers();    &#125;&#125;\n\n接下来定义气象数据本身。代码很容易理解，把观察者保存在一个list里，每当气象数据变化的时候就通知这些观察者去做出新的处理。\npublic class CurrentConditionsDisplay implements Observer &#123;    public CurrentConditionsDisplay(Subject weatherData) &#123;        weatherData.registerObserver(this);    &#125;    public void update(float temperature, float humidity, float pressure) &#123;        System.out.println(&quot;Current conditions: &quot; + temperature                + &quot;F degrees and &quot; + humidity + &quot;% humidity&quot;);    &#125;&#125;public class StatisticsDisplay implements Observer &#123;    private float maxTemp = 0.0f;    private float minTemp = 200;    private float tempSum = 0.0f;    private int numReadings;    public StatisticsDisplay(WeatherData weatherData) &#123;        weatherData.registerObserver(this);    &#125;    public void update(float temp, float humidity, float pressure) &#123;        tempSum += temp;        numReadings++;        if (temp &gt; maxTemp) &#123;            maxTemp = temp;        &#125;        if (temp &lt; minTemp) &#123;            minTemp = temp;        &#125;        System.out.println(&quot;Avg/Max/Min temperature = &quot; + (tempSum / numReadings)                + &quot;/&quot; + maxTemp + &quot;/&quot; + minTemp);    &#125;&#125;public class ForecastDisplay implements Observer &#123;    private float currentPressure = 29.92f;    private float lastPressure;    public ForecastDisplay(WeatherData weatherData) &#123;        weatherData.registerObserver(this);    &#125;    public void update(float temp, float humidity, float pressure) &#123;        lastPressure = currentPressure;        currentPressure = pressure;        System.out.print(&quot;Forecast: &quot;);        if (currentPressure &gt; lastPressure) &#123;            System.out.println(&quot;Improving weather on the way!&quot;);        &#125; else if (currentPressure == lastPressure) &#123;            System.out.println(&quot;More of the same&quot;);        &#125; else if (currentPressure &lt; lastPressure) &#123;            System.out.println(&quot;Watch out for cooler, rainy weather&quot;);        &#125;    &#125;&#125;\n\n然后有三个观察者，分别负责显示当前气象，气象历史分析和晴雨预测。\nCurrentConditionsDisplay是最简单的，没有任何状态，它只是负责在每次气象有变化的时候把最新的气象显示出来。\nStatisticsDisplay复杂一点点，它需要记录历史气温，以便于计算平均温度，最高和最低气温。这是一个会有状态变化的对象。\nForecastDisplay也有状态变化，它需要记录上次的气压，以便于根据气压变化来预测晴雨。\npublic class WeatherStation &#123;    public static void main(String[] args) &#123;        WeatherData weatherData = new WeatherData();        CurrentConditionsDisplay currentDisplay = new CurrentConditionsDisplay(weatherData);        StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);        ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData);        weatherData.setMeasurements(80, 65, 30.4f);        weatherData.setMeasurements(82, 70, 29.2f);        weatherData.setMeasurements(78, 90, 29.2f);    &#125;&#125;\n\n最后，有一个main函数，把以上所有代码串起来。\n三个观察者都在观察同一个气象数据，每当气象有变化的时候，三个观察者都会被通知，并作出相应处理。\n如果我们需要其他的更复杂的气象显示装置，只需要实现Observer接口，注册到气象数据上去，那么在每次气象有变化的时候就可以收到通知并作出处理。不需要对已有代码做出任何改变。\n很灵活，很强大，对吧？\n不过再想一下观察者模式有没有更好地实现方式呢？\n答案肯定是有的。\nC#的delegate和Event就是一种用来实现观察者模式的很好的语言特性。它在语言级别为添加事件订阅和取消订阅提供了支持。\n不过这一篇博客主要是想要讲一个immutable的观察者模式实现，C#就不多讲了。\n可以想一下，上面的Java代码里的三个观察者，CurrentConditionsDisplay是没有任何状态变化的，它存在的意义仅在于其update方法。而这个方法每次都是接受最新的气象数据，并作出输出。\nStatisticsDisplay和ForecastDisplay则是截取气象历史数据不同的片段，将其作为可变状态封装在内部，并据其状态的改变决定update方法的行为。\n这样看来，如果我们有一种方式，可以提供完整的气象数据历史，那么这三个观察者就都可以各取所需，而不需要拥有自己的可变状态了。\n具体该怎么做呢？\nfunctions以下是Scala的实现：\ncase class WeatherData(temperature: Float = 0,                       humidity: Float = 0,                       pressure: Float = 0,                       observers: Seq[Observer] = Nil,                       history: Seq[WeatherData] = Seq(WeatherData(history = Nil))) &#123;  def register(observer: Observer) =    this.copy(temperature, humidity, pressure, observers :+ observer, history)  def weatherChanged(weatherData: WeatherData) = &#123;    val newHistory = history :+ weatherData    observers.foreach(observer =&gt; observer(newHistory))    this.copy(temperature, humidity, pressure, observers, newHistory)  &#125;&#125;object Observers &#123;  type Observer = Seq[WeatherData] =&gt; Unit  val currentConditionsDisplay: Observer = history =&gt;    println(s&quot;Current conditions: &quot; +      s&quot;$&#123;history.last.temperature&#125; F degrees and &quot; +      s&quot;$&#123;history.last.humidity&#125; % humidity&quot;)  val statisticsDisplay: Observer = history =&gt;    println(s&quot;Avg/Max/Min temperature = &quot; +      s&quot;$&#123;history.map(_.temperature).sum / history.size&#125;&quot; +      s&quot;/$&#123;history.map(_.temperature).max&#125;&quot; +      s&quot;/$&#123;history.map(_.temperature).max&#125;&quot;)  val forecastDisplay: Observer = history =&gt; &#123;    val currentPressure = history.last.pressure    val lastPressure = history.dropRight(1).last.pressure    print(&quot;Forecast: &quot;)    if (currentPressure &gt; lastPressure) println(&quot;Improving weather on the way!&quot;)    else if (currentPressure == lastPressure) println(&quot;More of the same&quot;)    else if (currentPressure &lt; lastPressure) println(&quot;Watch out for cooler, rainy weather&quot;)  &#125;&#125;object WeatherStation &#123;  def main(args: Array[String]) &#123;    val weatherData = WeatherData()      .register(currentConditionsDisplay)      .register(statisticsDisplay)      .register(forecastDisplay)    weatherData      .weatherChanged(WeatherData(80, 65, 30.4f))      .weatherChanged(WeatherData(82, 70, 29.2f))      .weatherChanged(WeatherData(78, 90, 29.2f))  &#125;&#125;\n\n以上就是Scala实现的全部代码了。\n开始分析之前，先做一个极其复杂的数学运算：106行的Java代码，等价于54行Scala代码。7个类，变成了3个。\n下面开始正经的分析。\n首先有一个叫做WeatherData的case class，它是完全不可变的。\n其register方法，接受一个新的Observer作为参数，并产生一个新的包含比原来多一个Observer的WeatherData实例。\n其weatherChanged方法接受一个新的气象数据，生成一个新的历史数据Seq，并把目前为止包含所有历史气象数据的Seq传递给每一个Observer去做处理。最后返回一个包含最新历史数据的新的WeatherData实例。\n那么这些Observer具体是怎么定义的呢？\n首先Observer只是一个type，不是一个class，它是没有状态的，用来定义函数签名。\n三个具体的display仅仅是三个符合Observer签名的函数，它们都接受气象历史数据作为参数，在历史数据中各取所需，作出处理。都是没有任何副作用的。这很合理，毕竟只是display，仅需要对数据进行分析和显示，只读不写，没有什么要改变已有数据的必要性。\n最后一个main函数把所有代码串起来，就得到了一份没有任何可变性的代码。\nMutation vs Transformation在Java版的代码中，不同的显示设备不断地根据最新的气象数据改变自己的状态，并根据改变之后的状态来决定其update的行为。\n而在Scala代码中，不同的显示设备没有状态，它们都仅仅是函数而已。它们在每次气象变化时根据全部气象历史数据决定自己的行为。\n全部代码中没有重新赋值语句，所有的赋值操作都是对局部变量的赋值，程序员可以感知到的变化就只在于observers列表和history列表的增长。而即便是这两个数据结构的增长都是通过不断生成新的不可变的Seq来实现的。\n总结来说，Java版代码通过改变已有数据来达成行为的改变。而Scala代码则通过利用不可变的函数和不断生成不可变的数据来实现行为的改变。\n这种不可变的代码于什么优势呢？\n其好处在于需要程序员操心的事情更少。变化的点越少，麻烦事越少。\n如果以上的Java代码有问题，程序员除了需要检查计算平均气温，最高最低气温，气压变化的算法之外，还需要检查重新赋值语句所造成的效果。气温的sum是否算对了？测温次数是否算错了？气压变化是否记录对了？这些都是变化的点，这些都是导致错误的可能性之所在。\n而在Scala代码中，如果代码有问题，同样需要检查算法的正确性，也就是检查不可变的函数的正确性。除此之外，只需要检查history列表的增长就可以了。而一个列表的增长是很难出错的。\nJava中所有对象状态的改变分散在代码中不同的地方，到了Scala代码中它们都集中到了一个列表的增长上，仅仅通过对这个列表的transformation就驱动了其余全部代码的行为改变。减少了变化的点，就减少了出错的可能情况的数量，减少了程序员的负担。\n\n\n\n\n","tags":["Scala","OODP"]},{"title":"访问者模式 in FP：Pattern Matching","url":"/blog/2015/06/16/visitor-pattern-pattern-match/","content":"\n访问者模式是一种将算法与对象结构分离的软件设计模式。\n\n\n这个模式的基本想法如下：首先我们拥有一个由许多对象构成的对象结构，这些对象的类都拥有一个accept方法用来接受访问者对象；访问者是一个接口，它拥有一个visit方法，这个方法对访问到的对象结构中不同类型的元素作出不同的反应；在对象结构的一次访问过程中，我们遍历整个对象结构，对每一个元素都实施accept方法，在每一个元素的accept方法中回调访问者的visit方法，从而使访问者得以处理对象结构的每一个元素。我们可以针对对象结构设计不同的实在的访问者类来完成不同的操作。\n\n以上是wiki对访问者模式的定义。\n这个定义着实难读。我们来看wiki给出的例子：\n假设我们要为汽车建模，汽车有不同的组成部件，轮胎，车身，和引擎。\n在开车之前需要先检查车辆每个部件的状况，然后依次启动所有部件以启动汽车。\n在这里我们很容易识别出车的组件各自应该是一个实体。而对车辆组件进行检查和启动的代码应该分别处于不同的实体中。\n这样就有了访问者的代码（来自wiki）：\nJavainterface ICarElement &#123;    void accept(ICarElementVisitor visitor);&#125;class Wheel implements ICarElement &#123;    private String name;    public Wheel(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return this.name;    &#125;    public void accept(ICarElementVisitor visitor) &#123;        visitor.visit(this);    &#125;&#125;class Engine implements ICarElement &#123;    public void accept(ICarElementVisitor visitor) &#123;        visitor.visit(this);    &#125;&#125;class Body implements ICarElement &#123;    public void accept(ICarElementVisitor visitor) &#123;        visitor.visit(this);    &#125;&#125;class Car implements ICarElement &#123;    ICarElement[] elements;    public Car() &#123;        this.elements = new ICarElement[]&#123;new Wheel(&quot;front left&quot;),                new Wheel(&quot;front right&quot;), new Wheel(&quot;back left&quot;),                new Wheel(&quot;back right&quot;), new Body(), new Engine()&#125;;    &#125;    public void accept(ICarElementVisitor visitor) &#123;        for (ICarElement elem : elements) &#123;            elem.accept(visitor);        &#125;        visitor.visit(this);    &#125;&#125;\n\n首先是汽车部件的实体。它们都实现同一个ICarElement的接口。该接口定义一个accept方法，用来接受访问者然后用访问者来访问所有汽车部件。\ninterface ICarElementVisitor &#123;    void visit(Wheel wheel);    void visit(Engine engine);    void visit(Body body);    void visit(Car car);&#125;class CarElementPrintVisitor implements ICarElementVisitor &#123;    public void visit(Wheel wheel) &#123;        System.out.println(&quot;Visiting &quot; + wheel.getName() + &quot; wheel&quot;);    &#125;    public void visit(Engine engine) &#123;        System.out.println(&quot;Visiting engine&quot;);    &#125;    public void visit(Body body) &#123;        System.out.println(&quot;Visiting body&quot;);    &#125;    public void visit(Car car) &#123;        System.out.println(&quot;Visiting car&quot;);    &#125;&#125;class CarElementDoVisitor implements ICarElementVisitor &#123;    public void visit(Wheel wheel) &#123;        System.out.println(&quot;Kicking my &quot; + wheel.getName() + &quot; wheel&quot;);    &#125;    public void visit(Engine engine) &#123;        System.out.println(&quot;Starting my engine&quot;);    &#125;    public void visit(Body body) &#123;        System.out.println(&quot;Moving my body&quot;);    &#125;    public void visit(Car car) &#123;        System.out.println(&quot;Starting my car&quot;);    &#125;&#125;\n\n然后就是访问者的实体。它们都实现ICarElementVisitor接口。这个接口里定义的方法有点多，分别对应每个汽车部件定义了一个visit方法的重载。\n在实现的时候自然是做检查的实体实现每个部件的检查，启动的实体实现每个部件的启动。\n这里就有一个陷阱，如果代码发展的趋势是汽车部件的种类会增加的话，那这个接口就很不稳定。每增加一种汽车部件就要修改接口并且修改每个实现类。\n而如果代码发展的趋势是在自检和启动之外加一些保养啊，洗车啊之类的话就没问题，不需要对已有代码进行修改。\n所以使用访问者模式的时候要注意识别被访问者是否是相对稳定而访问者是有扩展趋势的，这样用这个模式才合适。\n接下来的代码把以上所有代码串起来执行：\npublic class VisitorDemo &#123;    public static void main(String[] args) &#123;        ICarElement car = new Car();        car.accept(new CarElementPrintVisitor());        car.accept(new CarElementDoVisitor());    &#125;&#125;\n\n从最后的main函数来看，只要能确保汽车部件的数量不会增加，而只有访问者增加，那么客户代码只需要增加一行就能够增加对整车进行清洗或者保养的行为。\n车的部件和对部件的操作相互分离，独立发展。很灵活，很巧妙，对吧？\n不过再想一下其实也不需要使劲想了，如果你看过这一系列博文前面的几篇的话，想必已经能够猜到我的用意了。\n这些访问者存在的意义就在于承载对汽车部件的某些具体操作，操作是个好听的词儿，说白了就是函数啊。\n那既然这些类只是承载函数而已，何不直接就用函数而不费劲去用类包裹一层呢？\nfunctions那接下来就是用Scala的实现：\ntrait CarElement &#123;  def accept(visitor: Visitor) = visitor(this)&#125;case class Body() extends CarElementcase class Engine() extends CarElementcase class Wheel(name: String) extends CarElementcase class Car() extends CarElement &#123;  val elements: Seq[CarElement] = Seq(    Wheel(&quot;front left&quot;), Wheel(&quot;front right&quot;),    Wheel(&quot;back left&quot;), Wheel(&quot;back right&quot;),    Body(), Engine())  override def accept(visitor: Visitor) = &#123;    elements.foreach(_.accept(visitor))    visitor(this)  &#125;&#125;\n\n以上是汽车各种部件的定义，和Java代码没有太大区别。\nobject Visitors &#123;  type Visitor = CarElement =&gt; Unit  val printVisitor: Visitor = &#123;    case Wheel(name) =&gt; println(s&quot;Visiting $name wheel&quot;)    case Body() =&gt; println(&quot;Visiting Body&quot;)    case Engine() =&gt; println(&quot;Visiting Engine&quot;)    case Car() =&gt; println(&quot;Visiting Car&quot;)  &#125;  val doVisitor: Visitor = &#123;    case Wheel(name) =&gt; println(s&quot;Kicking my $name wheel&quot;)    case Body() =&gt; println(&quot;Moving my body&quot;)    case Engine() =&gt; println(&quot;Starting my engine&quot;)    case Car() =&gt; println(&quot;Starting my car&quot;)  &#125;&#125;\n\n上面这一段定义了一个叫做Visitor的type，它只是一个函数签名。任何接受一个汽车部件作为参数并且没有返回值的函数都符合它的签名，也就可以被视作Visitor。\n接下来是两个符合Visitor签名的函数，都是用pattern match实现的。\npattern match这种神奇的语言特性是如何实现的呢？背后的原因并不神奇，更多详情请参考我之前的另一篇博客：http://cuipengfei.me/blog/2013/12/29/desugar-scala-8/\nobject VisitorDemo &#123;  def main(args: Array[String]) &#123;    val car = Car()    car.accept(printVisitor)    car.accept(doVisitor)  &#125;&#125;\n\n最后定义一个main函数，与Java的main函数做的事情是等价的。\n这样，100行变成了45行。Visitor不再作为臃肿的实体存在，而只是函数。\n而且如果遵照同样的假设，认为车的部件是稳定的，而访问者是会增多的，那这段Scala代码的增长趋势是每加一个访问者就加一个函数。与Java代码的增长趋势相同。\n结语这次分析的访问者模式和之前的一些模式很类似，当我们需要的实体仅仅是作为承载某种行为的一个载具，那就可以考虑将实体消去，而换用函数这种更简单，更轻量级的抽象方式来实现我们想要的东西。\n当年OO模式出现的时候，FP并不盛行，原作者提出的方案无可厚非。不过我们今天有了FP这种更趁手的工具，就可以考虑在合适的时候将其与OO结合使用来达到更好的设计的目的。\n\n\n\n\n","tags":["Scala","OODP"]},{"title":"模板方法模式：子类型多态和高阶函数","url":"/blog/2015/06/23/template-method-pattern/","content":"\n模板方法模式定义了一个算法的步骤，并允许次类别为一个或多个步骤提供其实践方式。让次类别在不改变算法架构的情况下，重新定义算法中的某些步骤。\n\n以上是wiki对模板方法的定义。\n比较容易理解，我们有一个算法，其中某些步骤是确定的不太会变的代码。而另外一些步骤则需要变化并且自由组合。\n《Head First Design Patterns》里有一个🌰：\n假设我们需要制作咖啡因饮品，其实就是咖啡和茶。制作步骤有些类似，分为四步：1烧水，2泡，3装杯，4加调料。\n其中第一步和第三步是稳定的代码，变化可能性不大，而第二步和第四步则每种饮品有自己的风味。\n这样就有了下面的代码：\nJava\n\n首先有一个咖啡因饮品的抽象类，定义一个算法骨架：1烧水，2泡，3装杯，4加调料。其中的第二步和第四步是有待实现的抽象方法，留给子类决定怎么搞。第一步和第三步是写死的。\n\n\n接下来是咖啡，它实现了过滤咖啡和添加牛奶、糖的步骤。这样当它的实例的prepareRecipe方法被调用时就会执行父类的烧水、装杯，以及自己的泡和加调料。\n\n\n还有，就是茶了。它和咖啡不一样，是用浸泡而不是过滤，加的是柠檬而不是牛奶和糖。\n\n\n最后用一个main函数来执行制作咖啡和茶的代码。\n很好，如果再有其他的咖啡因饮品，只需要增加一个子类，并且实现两个方法就好了。只要我们对于四个步骤的定义在该领域中足够稳定，这份代码就是很好很强大，易于扩展的。\n有代码如此，夫复何求呢？\n不过再想一下这个模式想要达到的，不过是将一个算法的某些部分做的灵活一些，可以自由替换和组合。\n那这个，不就是函数组合吗？如果我们使用的是允许高阶函数的语言的话，那还有什么必要把这些函数包装在类里呢？\nfunctions接下来是用Scala实现的版本：\n\n\n首先，定义三个type，分别是泡和加调料这两个步骤，还有饮品本身（这三个type其实是一样的，看起来有点傻）。\n然后有一个算法骨架，把第一和第三步锁死，把第二和第四步空出来，分别用一个参数来实现注入不同的实现。\n接下来有泡和加调料的四种不同实现，分别是一个函数，符合各自的函数签名。\n最后，用一个main函数来执行。可以看到，泡和加调料的函数是作为参数传入的。如果我们需要加牛奶和糖的茶，或者是柠檬味的咖啡的话，也会变得非常容易。\n就这样，51行代码变成了28行。四个类变成了一个object。\n而如果是要用子类型多态（subtype polymorphism）来做到这样的自由组合，那么我们需要的或许就是策略模式，把泡和加调料分别写成接口并提供不同的实现类来组合。可以想象，这会导致很多的boilerplate。\n结语Java代码中实现多态的方式是通过子类继承父类并且实现抽象方法来实现的。而Scala代码中则是通过把不同的函数传入骨架组合出一个新的函数来实现的。\n子类型多态（subtype polymorphism）是个好东西，但是在某些场景下显得有点重。能用高阶函数这种轻量级的方式来实现的时候，就没有必要选择子类型多态这种过重的方式。\n\n\n\n\n","tags":["Scala","OODP"]},{"title":"命令模式的不爽就像用指甲刀刮胡子","url":"/blog/2015/06/01/command-pattern-fp-implementation/","content":"命令模式\n在面向对象程式设计的范畴中，命令模式是一种设计模式，它尝试以物件来代表实际行动。命令物件可以把行动(action) 及其参数封装起来，于是这些行动可以被：\n\n\n\n重复多次\n取消（如果该物件有实作的话）\n取消后又再重做\n\n\n以上是wiki对命令模式的定义（术语像是台湾的）。\n下面是来自《Head first design patterns》的一个例子：\n假设你有很多家用电器：电灯泡，电视，音响，还有一个水疗浴缸。（就是没有手电筒）\n每个家用电器都有自己的开关装置，处于不同的位置。如果你想把它们都开启，需要一个一个地去按按钮。\n现在你想要有一个遥控器，一键开启所有电器，一键关闭所有电器。\n或者是一键完成任意的电器操作组合。\n每个电器的接口都是不同的，但是又需要和同一个遥控器集成，于是呢，肯定要有一个统一的接口了。\n于是就有了下面命令模式的实现代码。\nJava\n\n\n\n\n\n\n\n首先是有四大件家用电器。各自之间没有什么关系。\n这里面的代码都有点傻，不过没关系，我们就想象这都是些很复杂的硬件通信之类的代码就好了。\n\n\n然后，定义一个Command接口，其中只有一个execute()方法。\n之后我们会用它的实现类来操作各种电器。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n这一大坨，就是Command的实现了。\n四大件电器，于是便有八个Command，分别负责每个电器的开启和关闭。\n有些电器的开启和关闭比别的要复杂一些，不过这没有关系，因为它们的细节都被封装在Command的实现类里面了，我们接下来的代码只要和Command这个接口打交道就好了。\n\n\n还有一个宏命令，用来组合其他命令。\n\n\n可以实现遥控器了。\n\n这个遥控器上的按钮都是空白的，我们可以给它置入任意我们想要的命令。\n\n\n终于可以写一个main函数了：\n\n把家用电器和其对应的Command联系起来\n把各种Command组合成开启和关闭两个宏命令\n把宏命令置入遥控器\n\n然后，只要按一个按钮，就可以开启所有电器，享受资产阶级奢靡的生活了。\n享受够了之后只要再按一个按钮就可以把所有电器关闭掉。\n如果再有别的电器，只需要实现几个新的Command，把新的Command组合入宏命令，继续使用遥控器就好了。\n换句话说，因为遥控器和电器之间通过Command解耦了，增加新的电器和新的Command对于遥控器没有影响，遥控器的代码是稳定的。这也就是所谓的对扩展开放，对修改关闭。\n很好，很符合良好的设计原则，看着就舒服对吧？\n不过再想一下电灯的开启和关闭这两个命令仅仅是对电灯的两个方法的简单代理。\n音响的开启和关闭这两个命令仅仅是对音响的两个方法的简单代理。\n电视机的关闭也是简单的代理。\n这些命令类是否看起来太单薄了呢？它们的方法异常瘦弱，营养不良。\n它们除了持有一个需要操作的电器的实例之外，基本没有什么实例级状态。\n（电视开机还好，由于需要选择频道，好歹调用了两个方法。水疗浴缸操作比较复杂，需要调节温度，所以也还稍微好一些。）\n每次看到这种贫血的类，我就怀疑它们存在的必要性。\n如果我们只是想要给家用电器内的方法构造一个统一个的对外接口，是不是可以用函数式来实现呢？\nfunctions来试试用Scala实现：\n\n\n\n\n\n\n\n\n首先是有四大件家用电器，这部分和Java的代码等价。\n\n\n这一段用来定义各种命令的代码就不同了。\n我们对家用电器的各种方法的调用都是只期待其副作用，不期待任何返回值的。所以可以定义一个函数签名Command来涵盖所有这类操作。\n和上面的Java代码类似，这里也有一个宏命令，只不过实现简单一些。\n电视的开启，水疗浴缸的开和关都有对应的方法来把家用电器的实例封入闭包中。\n咦？电灯的开关，音响的开关，以及电视的关闭都跑哪儿去了呢？\n由于这几个操作都只涉及到一个方法的调用，它们直接就符合Command的函数签名，所以不用再封入任何闭包了。这一点看下面的代码就明白了。\n\n\n\n\n我们可以定义一个遥控器。其中有开启，和关闭两排按钮。\n最后，可以写一个main函数，其中所做的事情和之前Java代码main函数所做的事情是一样的。\n只不过，不需要创建各种Command的实例。\n而且light.on，stereo.on，light.off，stereo.off，tv.off这几个方法由于符合Command的签名，是可以直接拿来当Command用的。（注意方法名后面没有()，不是调用，而是函数传递）\n前后两版代码是等价的。只不过：\n\n247行代码变成了93行代码\n16个实体变成了7个\n\n作为一个多按几个按钮都嫌麻烦的好逸恶劳的资产阶级，这个结果是我所乐于见到的。\n更少，更紧凑的代码。更少的实体。我终于可以用更小的成本来享受我昂贵的家用电器了。\n指甲刀刮胡子最后回到标题上去：指甲刀刮胡子，意即用不合适的工具解决问题。\n命令模式想要做到的事情其实就是给各种不同的操作寻找一个统一的接口，从而实现调用者（遥控器）和被调用者（家用电器）之间的解耦。\n给不同的操作寻找一个统一的接口这件事可以通过接口来做，但是我们同时要承担写一堆贫血类的代价。\n而如果直接用函数来做的话，则可以得到更紧凑简洁的代码（就像object Commands这个实体内的代码一样）。\n该模式提出的时候FP并不如今日盛行，其作者选用了可能会导致贫血类泛滥的解决方案，这无可厚非。传播了解耦和开闭等良好设计的原则也实为功德。\n不过今天我们有了剃须刀，就无需一定要用指甲刀来刮胡子了。\n\n\n\n\n","tags":["Scala","OODP"]},{"title":"2015第二季度","url":"/blog/2015/07/04/2015-second-season/","content":"2015竟然这么快就过去一半了。逝者如斯夫。\n博客第一季度总结的时候说：\n\n今年的博客主线任务定为OO与FP的比较和结合应用吧。\n\n这个任务完成的不错，这个主题写了7篇博客。\n迭代器已经irrelevant了，中介者和备忘录太简单就没写，状态模式没找到好的FP实现方式。这样11种行为模式除去上述4个，算是基本覆盖完了。\nPrinciples of Reactive Programming作业导学写了两篇，后面的有点难，写不出来了。。。这一点后面MOOC再说。\n还有一篇gender pay gap的博客，算是今年到目前为止阅读量最多的得意之作。\n在武汉做了一次学英语的workshop，在TWU做了pecha kucha，总结成了两篇。\n这样，不算季度总结的博客，写了12篇，数量和内容自己都满意。和技术相关的还可以充当复习和刷新记忆的资料。\n不错，博客这方面达标了。\n读书这个季度比较惨。这一季度只读了五本书。\n一部分原因在于TWU的日程太紧，一部分原因在于博客，MOOC和翻译占用的时间很多，不可兼得。\n还好第一季度看书比较多，所以到目前为止这半年一共读过16本书，总体数量还不算太惨。\n这十六本书里有7本有笔记，可以充当复习和刷新记忆的资料，而且效果很好。自己写的笔记，瞄一眼，整本书的内容和重点就全部复活。\n不过看书的领域方面有点杂，2014总结的时候说：\n\n明年需要看一些轻量级的经济、哲学和社会心理学的书。\n\n这方面执行的不好。\n\n于是建了一个trello，把2015下半年要读的书预先plan出来。每个月plan两三本，一部分符合上述他山之石的领域，一部分符合OOP和FP的技术主线。\n\n这样plan的数量并不大，如果突然出现兴趣很高，或者优先级很高的书的话，可以随时插入计划中。\n另外，pipeline定义清晰，每本书要读完，有笔记，有复习，有某种形式的产出（笔记也算）。\nMOOC把Principles of Reactive Programming跟完了，证书拿到了。\n\n但是照实说，这门课没学懂，只是应付过了。后四周的作业导学没写出来。\n主要原因在于事先对课程难度估计过低，投入时间不够。下次开课，需要再跟一遍。\n除此之外，下半年对于MOOC这方面不做过多预期，有特别好的特别感兴趣的就跟，没有就算了。\n算是对年初说过的话彻底食言了。。。\n体重在印度这段时间健身房出勤率74%左右，还挺好。\n现在，60.5公斤，第一季度结束时是61。基本算是没变。充分说明了没有改进目标就不会有成绩。\n不过鉴于我现在已经不算胖子了，这方面仍然不做过多奢求，维持就好。\n另外，腹肌的轮廓开始出现了，我很开心：）\n\n\n\n\n翻译接了出版社一个翻译的活儿，《Seven more languages in seven weeks》，是本蛮不错的书。这个额外的任务投入时间较多也是读书方面有欠缺的原因之一。\n对出版充满期待。\n时间管理与统计从四月一号开始，开始使用pomotodo这款超赞的番茄钟软件。从开始的第一天开始，到现在为止，凡是需要坐下来专心执行的事情都有记录。\n\n这款软件的统计分析功能很好用，每个番茄钟还可以加tag。可以看到，这三个月做多的时间放在了TWU的备课上（26%），其次是翻译书（16%），mooc和blog紧跟其后（13%和10%），然后还有读书和写TWU需要的总结反馈（都是7%）。\n这样，有数据，为什么读书少就一目了然了。\n另外，可以看到这三个月平均日完成7.55个番茄钟。这个数量很说明问题，工作的效率靠感觉是感觉不出来的，要靠统计数据和分析。7.55个番茄钟，相当于四个小时左右。每天平均专心工作，执行任务的时间只有四个小时啊！\n这里面有一部分原因是TWU过程中需要听别的讲师的很多sessions，如果没有这个因素，日均数量应该是9个左右。\n下个季度这方面的数据会是什么样的很难说，如果做的工作中有很大部分涉及沟通和协调的话，这个数字或许会走低。\n\n\n\n\n","tags":["me"]},{"title":"2015第三季度","url":"/blog/2015/10/05/2015-3rd-season/","content":"惨。\n八月份上了一个大客户的项目，到了晚上没力气也没心情做任何事情。\n博客没写。上个季度六月的系列告一段落后7月没写。到了8月就不用说了。\n读书七月八月读了7本书，9月一本未读。\n在trello中建的计划，其中7月执行的不错，8月一般，九月，当让，啥都没做。\nMOOC无。\n翻译上次提到的书已经交稿了，坐等出版。\n健身这项不错，我从一开始就想好，无论什么事没时间没心情做，这件事不能停。\n从八月份开始，有了系统的计划\n\n三个大肌群，所有小肌群，各自一个计划。\n从八月初执行至今，共记录41次workout，举铁345吨。\n\n平均每次去健身房8吨，日最高记录15吨。\n这段时间出勤率67%。\n从去年6月8日到现在，共485天，出勤314次，出勤率64%。\n其中武汉201次，印度72次，成都41次。\n总之\n\n\n\n\n","tags":["me"]},{"title":"2015","url":"/blog/2016/01/03/2015/","content":"2015年结束了，一如已经结束了的每一年，非常迅速。\n按惯例，从博客说起。\n博客15年写了16篇博客，其中9篇是与Scala，Reactive，OODP相关的。这个数字倒还不算太坏。\n14年总结的时候说：\n\n明年可以改进的是不要嫌话题小，不要嫌话题不够深。 有了有价值的想法就记下来，形成惯性。\n\n15年第一季度没有执行这一条原则。其原因在于懒惰。\n15年第二季度超额执行。其原因在于找到了主线任务，足够的探索便促成了足够的产出。\n第三季度和第四季度未执行。其原因在于到客户现场去工作彻底打乱了所有的日常习惯与日程计划。\n这么看来，博客这一块有得有失，得者为要找到一个足够有趣的主线任务，用来催生产出。失者为习惯的打破与难以重补。\n由此得出16年需要执行的事项：\n主线任务要明确，暂定为Reactive以及与之相关的一切。Review不能每个季度做一次，要每个月做一次，每次可以短，不能没有，这样强迫自己去关注进度，不可斜视。\n读书\n\n\n\n这个数字可以，分布情况不太漂亮。5月和9月是两个空档。\n5月是因为刚去TWU，说得过去。9月是因为去了客户现场，其实也说得过去。\n但是内容控制的不好。\n14年总结说的是：\n\n另外一个改进点是领域，我明年需要看一些轻量级的经济、哲学和社会心理学的书。口说无凭，于此立字为据。\n\n这方面第一季度执行的可以，第二季度开始用trello track，也不错。但是下半年就废了，还是前文提过的同样的原因。\n16年的trello重新建了一个board，遵循上段同样的方式，每个月review。\nMOOC极其差。\n一年只上完了一门课。没有勇气提16年的目标了。看际遇吧。\n健身这个坚持执行的很好。还探索出了好的玩法。\n\n\n数据统计不完整，但是可以凑合看，增重0.4，减脂0.1，算是净增1斤肌肉。曲线不难看，但是这个数字不算漂亮。\n\n\n从8月4号开始用bodyspace来track运动量，至此共91次，重量累计935吨。\n这个数字累积到1000吨（也就是100万千克）时就换方法，不着重统计重量了，而是统计围度。\n下面统计下出勤率：\n从14年6月8日到现在,共574天。出勤362次，出勤率63%。\n时间管理与统计这个统计是从15年4月1日开始的，9，10月份由于去客户现场的原因，中断掉了。数据就放在这儿，不分析了。\n\n\n其他这一年脾气见好，不错。\n\n\n\n\n","tags":["me"]},{"title":"利用CouchBase为弱网环境构建云同步Android应用","url":"/blog/2016/03/10/couchbase-android-sync/","content":"背景Wifi，4G，3G，这些我们习以为常的东西，未必对所有人来说都是随时可用的。\n以我当前所在项目为例，应用场景是某欠发达地区医疗服务机构的药品库存管理。\n所谓欠发达，具体怎样呢？\n\n没有台式电脑\n没有笔记本\n只能使用低端的安卓平板\n4G，3G信号不要想\n我们去过现场的一位同事甚至要爬到树上去，才能勉强收到2G信号\n即便是2G信号，也是时断时续，非常不稳定\n\n因此，需要随时保持连通的BS结构基本不可行，我们选择了重度依赖移动端设备本地存储的CS结构（胖客户端）。\n网络不可用时，库存变动存储在安卓本地，何时网络可用，再将数据与服务器同步。\n问题以上描述的解决方案似乎合情合理，但是真实实施中还是遇到不少问题：\n\n本地schema与服务器schema不一致，中间涉及数据转换与回转\n本地到服务器的同步数据流动链条过长（本地orm-&gt;本地Json serialization-&gt;服务器Json deserialization-&gt;服务器orm），链条中任何一环都有出差池的可能性。换句话说，导致数据健全性受损的可能性分散在了太多的点上，一旦出错，难以定位\n服务器到本地的数据同步，上一条中所描述的链条的逆向，同样是链条太长，潜在的出现错误的点太多\n服务器端所掌握的数据只是客户端真实数据的一个变体，并且还未必是最新的，这样就导致当移动端应用因其本地数据而出错的时候，我们只能对着服务器干着急\n\n以上描述的问题并不是偶发性的，它不像这里有个bug今天修了，明天那里有个bug再修一次就好。\n只要我们仍然要在弱网环境中运行应用，我们就需要重度依赖本地存储，就需要持续的在移动端和服务端进行双向数据同步，以上的问题就将会一直存在。\n这是自然环境限制与技术选择所带来的固有的内在的问题。\n解决方案上面提到：\n\n这是自然环境限制与技术选择所带来的固有的内在的问题。\n\n这句话再解释明白一些，自然环境限制指的是很差的网络可用性，技术选择指的是服务器端提供REST API，移动端利用该API进行通信。\n以上这二者相结合导致了上述情况成为了固有的内在的问题。\n自然环境的限制我们无法突破，我们不能把基站部署过去，让大家打电话之前不用再爬到树上去。\n但是技术选择是完全受我们控制的，是有做文章的空间的。\n这就引出了文章标题提到的CouchBase。\nCouchBase关于CouchBase是一个怎样的DB，请大家自行搜索。\n我们主要关注它推出的CouchBase-Lite（android和iOS均有对应版本）。\n\n左边的绿色方框是移动端应用，它通过蓝色标示的Sync Gateway与CouchBase Server通信。\n请注意图中的箭头都是双向的，任何一方对本地数据库的写操作，都会导致对方的更新。任何一方的网络暂时中断也没有关系，在网络恢复的时候将会自动重试。\n这样一来，数据同步的思路就变了，不再是在服务器端定义上传下载的API，移动端进行调用。而是利用DB自有的replication机制进行数据同步。\n这就意味着我们在移动端只需要关注建立领域特定的模型，并将其存储入移动端本地的CouchBase即可，至于后面的序列化、网络通信等等问题就不需要我们去担心了。\n关注点中很大一部分就这样被分离了出去，交由infrastructure去完成。\n至于DB自有的replication机制的可靠性，应该可以比较安全的做出假设，认为一个有商用场景的DB厂商的通用数据备份机制不会比我们自己拼凑出来的更差。\n一个原型https://github.com/cuipengfei/Spikes/tree/master/android/sync-prototype\n上面的链接是一个基本可用的购物清单应用。全部代码都在，供参考。\n下面谈如何把玩它。\n第一步下载CouchBase Server： http://www.couchbase.com/nosql-databases/downloads#，安装，配置管理员账户，不赘述。\n在CouchBase Server的Admin console(默认地址： http://127.0.0.1:8091/index.html)中创建一个bucket，命名为demodb。\n第二步安装sync_gateway，Mac用户可以：\tbrew install sync_gateway\n以上github代码克隆下来后，sync-gateway路径下有个名为start_sync_gateway_server.sh的脚本，运行它来启动sync gateway。\n第三步运行同一个路径下的create_user.sh，来创建一个名为user1的用户，然后运行create_session.sh，为该用户创建一个session。\ncreate_session.sh脚本有类似如下的输出：\n&#123;&quot;session_id&quot;:&quot;a469f18027647e4957ffd1743e2ea33ce0386dbc&quot;,&quot;expires&quot;:&quot;2016-02-21T17:51:43.071175586+08:00&quot;,&quot;cookie_name&quot;:&quot;SyncGatewaySession&quot;&#125;\n\n把其中的session id记下备用。\n（注：这里的用户和session都是sync gateway需要的，与CouchBase Server无直接关系）\n第四步找到代码中的MainActivity类，在startSync方法中加入session id：\n//......Replication pullReplication = database.createPullReplication(syncUrl);pullReplication.setCookie(&quot;SyncGatewaySession&quot;, &quot;a469f18027647e4957ffd1743e2ea33ce0386dbc&quot;, null, 86400000000000L, false, false);pullReplication.setChannels(asList(&quot;user1&quot;));pullReplication.setContinuous(true);Replication pushReplication = database.createPushReplication(syncUrl);pushReplication.setCookie(&quot;SyncGatewaySession&quot;, &quot;a469f18027647e4957ffd1743e2ea33ce0386dbc&quot;, null, 86400000000000L, false, false);pushReplication.setChannels(asList(&quot;user1&quot;));pushReplication.setContinuous(true);\n\n这段代码负责启动replication，双向同步从此而起。\n找到createGroceryItem，为其中创建document的代码指定其所归属的用户：\n//......Document document = database.createDocument();Map&lt;String, Object&gt; properties = new HashMap&lt;String, Object&gt;();properties.put(&quot;channels&quot;, asList(&quot;user1&quot;));\n\n这几行代码可以保证各个移动端用户之间的数据不会混杂在一起。\n第五步在genymotion中启动android虚拟机（如果使用其他虚拟设备或者真机，请注意修改代码中的服务器ip地址）。\n在购物清单中创建几条记录，然后清空移动端本机数据，重启应用，可以看到刚刚被清空的购物清单会从服务器上同步回来。\n也可以尝试把虚拟机的网络连接断掉，创建或者修改几条记录，稍后重新连通网络，可以发现数据仍然可以上传到服务器。\n还可以尝试用第三步中提到的脚本多创建几个用户，在不同的android虚拟机中使用不同用户，可以发现它们对彼此的数据是没有访问权的。\n总结以上第五步提到的双向同步，离线操作，不同用户之间的数据隔离，都不需要我们写任何特殊的代码来实现。\n我们移动端的代码与CouchBase的集成基本就只涉及到第四步中提到的启动replication和创建document，那这样移动端剩下的工作就只有构建业务逻辑了。\n如果你的移动端应用也需要在弱网环境下进行离线操作，在网络恢复时与服务器同步数据的话，不妨尝试一下CouchBase。\n\n\n\n\n","tags":["Android"]},{"title":"自己动手实现Promises/A+规范","url":"/blog/2016/05/15/promise/","content":"Promise并不是一个新的概念,它已经有将近30年的历史.\n其早期的雏形还有里氏替换原则的提出者Barbara Liskov的贡献在其中.\nhttps://en.wikipedia.org/wiki/Futures_and_promises#History\n而Promises&#x2F;A+这个规范的出现,则为JavaScript世界中众多Promise实现库提供了一套统一的API和交互机制.\nPromises&#x2F;A+提供了配套的测试集:https://github.com/promises-aplus/promises-tests.\n其中共有872个测试,如果你的实现能够让全部测试绿起来,则可以认为该实现符合了标准.\n我的Promise实现:https://github.com/cuipengfei/Spikes/tree/master/js/promise\n在npm上的发布:https://www.npmjs.com/package/RWPromise\n要实现Promises&#x2F;A+的规范其实并不需要很多代码,我的实现只有88行.当然,仅仅是符合规范和一个可用,易用的Promise库之间还有很大的差距.\n如果作为教学或者演示的目的,我认为我的这份实现是已有实现中最简洁的一版.\n自己实现Promise规范时需要注意的几点:1. promise的状态一旦确定,不可更改一个符合规范的promise有三种可能的状态:pending,resolved,rejected。\n这三者是互斥的。\n一个pending的promise可以变成resolved,或者rejected。\n但是一旦进入resolved或者rejected状态,就再也不能变了。\n用形象的语言来描述的话:一个promise就是一个关于未来的承诺,诺言一旦履行,不能反悔。\n假设有如下代码:\nvar p = ???();//首先以某种方式拿到一个promise,假设这个promise现在是pending的p.then(x,y);//然后把你希望在成功和失败时执行的x,y通过then方法挂进去\n\n时间流逝,假设???()方法内部在未来某个不确定的时间执行了:\np.resolve();\n\n然后,你的x函数应该会被调用。\n再然后,无论p的resolve方法或者reject方法再怎么被调用,p的状态都不会再变更,x和y也再不会被执行了。\n2. 树状结构对then方法的多次调用会形成一个树状的数据结构。\n假设有如下代码:\nvar p = ???();//首先以某种方式拿到一个promisep    .then(a,b) //假设这次then的调用返回的是一个新的promise实例,称之为p1    .then(c,d);//假设这次then的调用返回的是一个新的promise实例,称之为p2\n\n上述代码等价于:\nvar p = ???();//首先以某种方式拿到一个promisevar p1 = p.then(a,b);var p2 = p1.then(c,d);\n\n\n\n当然,这个代码形成的会是类似于一个链表的结构,可以把它看作是树状结构的一个特例,也就是树中每个节点都最多只有一个子节点。\n而如下的代码则会形成我们惯常看到的树:\nvar p = ???();var p1 = p.then(a,b);var p2 = p.then(c,d);var p3 = p.then(e,f);var p4 = p1.then(g,h);var p5 = p3.then(i,j);\n\n\n\n这时,树中每一个节点可以有任意多的子节点(取决于它的then被调用了多少次)。\n了解promise的树状结构,将有助于实现promise时在自己脑子里构造递归模型。\n3. 回调的执行时机这是实现promise的时候,最容易把人搞晕的一点。\nvar p = ???();//首先以某种方式拿到一个promise,假设这时p是pending的状态var p1 = p.then(a,b);var p2 = p1.then(c,d);\n\n以上代码执行完之后,我们手里有3个promise:p,p1,p2.\n这时,a,b,c,d都还没有执行。\n在未来某个不确定的时间,如果p的resolve方法被调用了,接下来会发生的事情是:\n\np会把传给resolve方法的参数value记住,并把自己的状态标记为resolved (以后就再也不能变了)\na会被调用到,其参数为value\n如果a执行过程中不出错\np1的状态被变成resolved,p1会把a的返回值记住\nc会被调用到,其参数为a的返回值\n如果c执行过程中不出错\np2的状态被变成resolved,p2会把c的返回值记住\n\n\n如果c执行过程中出错\np2的状态被变成rejected,p2会把c抛出的异常记住\n\n\n\n\n\n\n如果a执行过程中出错\np1的状态被变成rejected,p1会把a抛出的异常记住\nd会被调用到,参数为a抛出的异常\n如果d执行过程中不出错\np2的状态被变成resolved,p2会把d的返回值记住\n\n\n如果d执行过程中出错\np2的状态被变成rejected,p2会把d抛出的异常记住\n\n\n\n\n\n\n\n\n\n这样,就看出递归的意思来了。不过b并没有在上面出现,这是因为p本身是被resolve的,b只有在p被reject的时候才会执行。\n在未来某个不确定的时间,如果p的reject方法被调用了,接下来会发生的事情是:\n。。。 。。。\n就不用写了,把上面的ａ替换为ｂ就好了。\n以上的例子中,我们拿到p的时候它的状态是pending的,我们会先调用p的then,然后p才会被resolve(或者reject掉)。也就是说当我们通过调用then传递给promise两个回调的时候,promise还没有能力确定应该执行哪个回调,只有当未来promise自己被resolve或者reject了的时候,它自己的状态确定了,它才知道该挑哪一个回调来执行。\n还有另一种可能性,那就是当你拿到p的时候p就已经被resolve(或者reject掉了),这时如果你再调用then方法的话,所传入的两个回调,到底哪个应该被调用,马上就可以决定了。\n也就是说回调被调用的触发点一共有三个,then,resolve,reject这三个方法。\n\n\n\n\n","tags":["Promises/A+"]},{"title":"当锤子遇到钉子","url":"/blog/2016/06/04/when-hammer-meets-nail/","content":"此文标题党。更切题的标题应该叫做《如何用统计科学来黑星座》或者是《积极注册Facehub，促进统计科学蓬勃发展》 \n锤子　JS Promise最近对JS社区里的Promises&#x2F;A+规范产生了很浓的兴趣，感觉Promise这套东西确实蛮不错的，给异步算法的编写者和异步算法的消费者之间提供了一套统一的沟通手段，也为异步算法的消费者提供了更悦目易读的代码组织方式。\n自己把它实现了一遍:https://www.npmjs.com/package/RWPromise\n然后在武汉办公室run了3次workshop:http://cuipengfei.me/blog/2016/05/15/promise/。\n手里有了这么一把锤子就总想找个钉子敲一敲。总在想能去哪里找N多异步操作来让我来组织一下呢?\n钉子　《异类》无巧不成书，刚好最近在豆瓣上买了一本叫做《异类》的书在看:　https://read.douban.com/ebook/10580943/\n书中一开篇就提到了加拿大冰球运动员选拔机制中很有趣的一件轶事:\n\n职业青年队绝大多数球员的生日集中在1月、2月和3月，这实在有点不可思议\n\n\n加拿大冰球队按年龄分组所依据的分界线是1月1日，即从1月1日到当年12月31日之间出生的球员将会被分在同一组。也就是说，一个1月1日出生的选手，是在跟许多年纪比他小的队友争夺晋级权——在青春期到来之前，由于有将近12个月的年龄差距，球员之间在生理成熟度上将会表现出巨大的差异。\n\n\n正如冰球队员的成长经历一样，因年龄大几个月而显现的微弱优势会在孩子的成长过程中不断积累，最终引导孩子走向成功或不成功，自信或不自信的轨道中，其影响会延伸许多年。\n\n能否进入加拿大职业青年冰球队竟然和出生月份有关系，实在是太有趣了。\n假想如果你运动天赋非常好，但是不幸出生在12月，于是不得不从小和大你将近一岁的少年运动员一起训练。表现难免显得不那么出色，不受教练待见，得不到正面反馈，出场坐冷板凳……逐渐逐渐，伤仲永。\n由此就联想到了，到TW来工作的人其出生月份是否也存在什么神奇的规律呢？\nFacehub生日信息哪家强？Facehub帮你忙，它可以查到每个注册用户的生日(只有月日，没有年)。\n（注：Facehub是ThoughtWorks公司内部的一个社交网站，只对员工开放注册。用户可以在该网站了解其他同事的信息。）\n作为一个内部推广的网站，FaceHub在公司内邮件组里总是铺天盖地、见缝插针地作广告宣传，每次看到觉得审美都疲劳了，不过到了需要的时候第一个就想到了它。广告的作用，诚不我欺。\n我先目测，Facehub用户不会超过500人。并且用户的id是连续的自增数字，这就很好办了，我只要构造N多获取用户数据的GET请求就好了。这N多的GET请求，肯定不能一个一个慢慢发送，那就需要异步请求了，这就是钉子啊！这就是大量的需要被组织的异步操作啊！钉锤终于有机会合体了。\n于是我就写了这么个脚本:　https://github.com/cuipengfei/Spikes/blob/master/js/birth/birth.js\n其中使用Promise把大量的异步Http请求组织起来，然后统计其结果。\n(注:如果需要自己跑这个脚本，需要把第七行的token替换成你自己的合法值，如果您没有账号的话就无需尝试了哦)\n以下是统计结果，获取到用户数量348：\n\n\n由此可以看到，来TW工作的人，11月，10月，8月出生的最多，5月出生的最少。\n由于样本量不够大(只有348人)，所以统计数据的含义还不太好说。\n下面是我胡乱猜测的、不科学的、不严谨的理论\n我们小学入学时卡生日印象中是用8月卡的，那么这就和加拿大的冰球挑队员卡1月类似。\n\n\n那这样，小学入学后，优势的积累就应该会倾向于8，9，10这几月的学生(类比冰球青年职业队队员集中分布在1，2，3这几个月)。\n\n\n这几个月生日的小学生从小积累优势，并在成年后把优势携带到了求职之中去。\n\n\n那为什么我们统计出来是8，10，11月份的人份额多呢?怎么不是8，9，10这几个月呢?统计出来的数据为什么把9月给跳过去了呢？可怜的9月得罪谁了呢？\n\n\n我猜是由于9月这群人会成为某种星座的几率实在是太高了，被命运之神无情的给镇压掉了。:(抱歉\n\n既然已经有了这份代码，可以统计出生月份，索性再统计些其他侧面的数据:\n\n\n可见天秤和狮子座的最多，金牛座的最少。和上面的月份排名差异不大。\n仔细看下的话，发现我只得罪了7.4%的人，好欣慰:)\n\n\n看入职日期，大学毕业和跳槽的高峰期很凸显。9，10月最少，这倒不算什么惊人的发现。\n最后由于只统计了348人的信息，所以以上猜测仅供娱乐，请勿当真。\n请大家积极注册Facehub，并填写真实的生日信息，以促进统计科学的繁荣发展。（如果您无法注册，可以考虑投一份简历，然后再来促进统计科学的繁荣发展哦）\n\n\n\n\n","tags":["TW","星座"]},{"title":"Desugar Scala(18) -- stackable traits","url":"/blog/2017/06/14/desugar-scala-stackable-traits/","content":"Stackable traits是一种怎样的特性呢？\n来举一个🌰\nabstract class IntQueue &#123;  def get(): Int  def put(x: Int)&#125;\n\n定义一个IntQueue，抽象类，定义了get和put，没有实现。\nclass BasicIntQueue extends IntQueue &#123;  private val buf = new ArrayBuffer[Int]  def get() = buf.remove(0)  def put(x: Int) = &#123;    buf += x  &#125;&#125;\n\n再定义一个BasicIntQueue，把上述IntQueue实现了。它的实现没有什么花样，就是先进先出。\n接下来就有意思了：\ntrait Incrementing extends IntQueue &#123;  abstract override def put(x: Int) = &#123;    super.put(x + 1)  &#125;&#125;trait Doubling extends IntQueue &#123;  abstract override def put(x: Int) = &#123;    super.put(2 * x)  &#125;&#125;\n\n定义了两个trait，都扩展自IntQueue。一个是把数字先加一再放进队列，另一个是先把数字加倍再放入队列。\n要注意这里的modifier：abstract override，以及在trait中对super的调用。稍后反编译的时候可以看懂它们的真实含义。\n那这两个trait可以怎么使用呢？\nclass MagicQueue extends BasicIntQueue with Incrementing with Doubling\n\n定义一个MagicQueue，它扩展自BasicIntQueue，同时mixin了上面的两个trait。\nMagicQueue它自己是一行实现代码都没有的，那么它的行为会是什么样子呢？\nval queue = new MagicQueuequeue.put(100)queue.get() //会返回201queue.put(500)queue.get() //会返回1001\n\n可以看到，它会先把数字乘以二，然后加一再放入队列。\nMagicQueue继承了BasicIntQueue，混入了Incrementing和Doubling，它的行为就会是先跑Doubling后跑Incrementing最后跑BasicIntQueue（从右到左依序生效）。\n这是种很实用的语言特性，你可以写很多个不同的trait，让它们都extend IntQueue。同时写很多class让它们实现IntQueue。然后每一个实现了IntQueue的class都可以和任意一个或者任意多个trait随意组合应用。\n这给语言的使用者提供了很强的composition的便利性。\n那下面看下这个语言特性是如何实现的。\npublic abstract class IntQueue&#123;    public abstract int get();    public abstract void put(final int p0);&#125;public class BasicIntQueue extends IntQueue&#123;    private final ArrayBuffer&lt;Object&gt; buf;    private ArrayBuffer&lt;Object&gt; buf() &#123;        return this.buf;    &#125;    public int get() &#123;        return BoxesRunTime.unboxToInt(this.buf().remove(0));    &#125;    public void put(final int x) &#123;        this.buf().$plus$eq((Object)BoxesRunTime.boxToInteger(x));    &#125;    public BasicIntQueue() &#123;        this.buf = (ArrayBuffer&lt;Object&gt;)new ArrayBuffer();    &#125;&#125;\n\n首先，IntQueue和BasicIntQueue反编译之后平淡无奇，一个抽象类，一个实现类。\npublic interface Doubling&#123;    void chap12$Doubling$$super$put(final int p0);    void put(final int p0);&#125;public abstract class Doubling$class&#123;    public static void put(final Doubling $this, final int x) &#123;        $this.chap12$Doubling$$super$put(2 * x);    &#125;    public static void $init$(final Doubling $this) &#123;    &#125;&#125;\n\nDoubling这个trait则被编译成了一个接口加一个抽象类，其中除了put之外还有一个名字有点奇怪的方法声明。稍后可以看到它有什么用。\npublic interface Incrementing&#123;    void chap12$Incrementing$$super$put(final int p0);    void put(final int p0);&#125;public abstract class Incrementing$class&#123;    public static void put(final Incrementing $this, final int x) &#123;        $this.chap12$Incrementing$$super$put(x + 1);    &#125;    public static void $init$(final Incrementing $this) &#123;    &#125;&#125;\n\nIncrementing则和Doubling是一个路数。\n（这里出现的chap12字样是我写代码时package的名字）\n最后揭露真相的时候到了：\npublic class MagicQueue extends BasicIntQueue implements Incrementing, Doubling&#123;    public void chap12$Doubling$$super$put(final int x) &#123;        Incrementing$class.put((Incrementing)this, x);    &#125;    public void put(final int x) &#123;        Doubling$class.put((Doubling)this, x);    &#125;    public void chap12$Incrementing$$super$put(final int x) &#123;        super.put(x);    &#125;    public MagicQueue() &#123;        Incrementing$class.$init$((Incrementing)this);        Doubling$class.$init$((Doubling)this);    &#125;&#125;\n\nMagicQueue本身被编译成了以上的样子。\n我们看一下它的put方法被调用时会怎样呢？\n\n它去调用Doubling$class.put这个静态方法，把自己和数字都传入\n\nDoubling$class.put则会先把数字乘以二，然后把乘积传给MagicQueue的chap12$Doubling$$super$put\n\nMagicQueue的chap12$Doubling$$super$put方法则会把MagicQueue自己的实例以及乘积都传给Incrementing$class.put这个静态方法\n\nIncrementing$class.put则会把接收到的参数，也就是乘积，加一，然后把加和后的数字传给MagicQueue的chap12$Incrementing$$super$put\n\nMagicQueue的chap12$Incrementing$$super$put最终把乘以二又加了一的数字传给了super.put\n\nsuper.put其实就是BasicIntQueue.put了，到这里终于把数字存到ArrayBuffer里面了\n\n\n这样，Doubling,Incrementing,BasicIntQueue它们三个的行为就堆叠（stackable）在一起了。\n\n\n\n\n","tags":["Desugar_Scala","Scala"]},{"title":"今日简史","url":"/blog/2018/10/21/JIN-RI-JIAN-SHI/","content":"第一部分科技颠覆\n20世纪，来自纽约、伦敦、柏林和莫斯科的全球精英讲述了三大故事，号称能够解释人类过去、预测全球未来。这三大故事是：法西斯主义故事、共产主义故事，以及自由主义故事。第二次世界大战打倒了法西斯主义故事，于是从20世纪40年代末到80年代末，世界成为共产主义故事和自由主义故事的战场。等到共产主义受挫，自由主义故事就成为人类了解过去的主要指南、未来无法取代的使用手册\n\n\n1938年，人类有三种全球性的故事可以选择；1968年只剩下两个；1998年，似乎只有一个故事胜出；2018年，这个数字降到了0。\n\n\n过去推动俄国、中国和古巴革命的，是一群对经济至关重要但缺乏政治权力的人；而2016年，支持英国脱欧和特朗普的，却是一群虽然还享有政治权力却担心失去经济价值的人。\n自由主义分别学习了帝国主义、法西斯主义和共产主义某些最优秀的概念。\n\n\n自由主义学习了共产主义，于是扩大了同理的范围，开始在重视自由之外也同时重视平等。\n\n\n即使在第二次世界大战之后，西方自由主义者还是很少将他们所谓的共通价值应用到非西方人民的身上。所以，荷兰人在自己的国土被纳粹残酷占领5年，于1945年重新站起来之后做的第一件事，就是召集军队横跨半个地球，希望重新占领前殖民地印度尼西亚。尽管在1940年，荷兰人只战斗了4天就举手投降放弃独立地位，但为了压制印度尼西亚的独立，他们却鏖战了4年之久。这也就难怪全球许多民族解放运动所寄望的都是苏联和中国，而不是自诩为自由主义领导者的西方国家。\n\n\n自由主义能够让无产阶级与资产阶级、信徒与无神论者、原住民与移民、欧洲人与亚洲人之间都和睦相处，靠的就是保证每个人都能拿到更大的一块饼。\n\n\n接下来该做些什么？第一步是缓和对末日预言的反应，从恐慌转为困惑。恐慌其实是一种傲慢，是自以为完全知道世界正在走向毁灭；困惑则是比较谦逊的态度，也就能看得比较清楚。\n\n\n19世纪汽车取代马车时的情景，当时有许多马车夫转行当出租车司机，只是我们可能不是那些马车夫，而是被淘汰的马。\n\n\nAlphaZero从零开始学习国际象棋，用了多久才准备好与Stockfish8的对局，而且发展出天才般的直觉？答案是4小时。你没看错，就是4小时。\n\n\n所有的公投和选举，诉诸的永远是人类的“感觉”，而不是人类的理性。如果民主谈的就是理性决策，那么哪还有理由让人人都享有平等的投票权？甚至还投什么票呢？早就有充分的证据显示，就是有一些人比别人学识更渊博、更具理性，特别是讲到特定的经济和政治问题时更是如此。[2]英国脱欧投票之后，著名生物学家理查德·道金斯（RichardDawkins）就提出抗议，认为绝大多数英国民众（包括他自己）其实都缺乏必要的经济和政治科学背景，根本不该要求他们投下这张公投票。“这岂不就像是要用全国公投决定爱因斯坦的代数算得对不对，又或是让乘客表决飞机驾驶员该在哪条跑道降落？”[3]\n\n\n在20世纪后期，民主国家的表现通常优于专制国家，是因为民主国家更善于处理数据。民主制度采用分布式的信息处理，由许多人和机构来做出决定，而专制制度则是把所有信息和权力都集中在一处。鉴于20世纪的科技水平，把太多信息和权力都集中在一个地方并不是有效率的做法。在当时，没有人能够及时处理完所有信息，并做出正确决定。这也就成了苏联做出的决策水平远低于美国，苏联经济远远落后于美国经济的部分原因。然而，人工智能很快就会让钟摆摆向相反的方向。有了人工智能，就能集中处理大量的信息，甚至因为机器学习在分析越多信息之后效果越好，所以人工智能可能会让集中式系统比分布式系统效率更高。\n\n\n到了21世纪，除了过去的集体歧视之外，我们可能还要面临日益严重的个人歧视问题。[31]\n\n\n今天世界各地的政治家似乎可以在各种不同的经济政策之间做选择，政治家有种以为自己可以选的错觉，但真正重要的决定早就由经济学家、金融专家和商人在提出选项时就做完了。也就是说，是他们为政治家定下了选择的方向。而再过几十年，就可能是由人工智能来提出选项，供政治家进行挑选了。\n\n\n智能是解决问题的能力，意识则是能够感受痛苦、喜悦、爱和愤怒等事物的能力。我们之所以会两者不分，是因为对人类和其他哺乳动物来说，智能与意识会携手同行。哺乳动物处理大多数问题时靠的是“感觉”，但计算机会用完全不同的方式来解决问题。\n\n\n大多数人类的痛苦将不再是受到剥削，而是更糟的局面：再也无足轻重。\n\n\n农业革命之后，财产不断增加，分配不平等的问题也随之出现。人类拥有土地、动物、植物和工具之后，僵化的等级社会出现了，一小群精英世世代代垄断了大部分的财富和权力。人类也学会了接受这种情况，认为这再自然不过，甚至可能是天命难违。\n\n\n但到了现代晚期，平等已经成为几乎所有人类社会的理想。部分原因在于共产主义和自由主义等新思想的兴起，还有部分原因是工业革命使民众比以往任何时候都更加重要。工业化的经济需要大量的普通劳动者，工业化的军队也需要大量的普通士兵。无论哪种政体的国家，都极为重视国民的健康、教育和福利，因为它们需要几百万健康的劳动者在生产线工作，需要几百万个忠诚的士兵在战壕里作战。\n\n\n在生物工程与人工智能兴起之后，人类可能会分裂成两个群体：一小群超人类，以及绝大多数位于下层而且毫无用途的智人。雪上加霜的是，等到民众不再具备经济与政治上的力量，国家对国民健康、教育和福利的投资意愿也可能降低。成了多余的人，是件非常危险的事。这时候，民众的未来只能依赖一小群精英能否心存善意。就算这种善意能维持几十年，但只要遭逢危难（例如气候突变），要把多余的人抛到脑后实在太诱人，也太简单。\n\n\n在古代，土地是世界上最重要的资产，政治斗争是为了控制土地，而一旦太多的土地集中在少数人手中，社会就分裂成贵族和平民。到了现代，机器和工厂的重要性超过土地，政治斗争便转为争夺这些重要生产工具的控制权。等到太多机器集中在少数人手中，社会就分裂成资本家和无产阶级。但到21世纪，数据的重要性又会超越土地和机器，于是政治斗争就是要争夺数据流的控制权。\n\n\n他们真正的业务不是销售广告，而是靠吸引我们的注意力，取得了关于我们的大量数据，这些数据远比任何广告收入更有价值。我们不是他们的用户，而是商品。\n\n\n这些巨头在短期内可能仍然需要卖广告，但它们现在评估应用程序、产品和公司的标准已经不再是能赚多少钱，而是能收集到多少数据。某款热门的应用程序可能缺乏商业模式，甚至短期内还会亏损，但只要能取得数据，就能价值数十亿美元。\n\n\n该由谁拥有数据？关于我的DNA、我的大脑和我的生命，这些数据到底是属于我、属于政府、属于企业，还是属于全体人类？\n\n\n企业发挥抑制作用，但也可能导致令人毛骨悚然的数字独裁。政治人物有点儿像音乐家，只不过他们手中的乐器是人类的情绪和生化系统。他们发表讲话，于是全国就感到一阵恐惧；他们发了一则推文，于是就爆发了一股仇恨。在我看来，实在不该让这些“音乐家”拿到更先进的乐器。如果哪天政治人物可以直接按下我们的情绪按钮，随意让我们感到焦虑、仇恨、欢乐或无趣，政治就只会是一场情绪的闹剧。虽然我们担心企业的力量过于强大，但从历史上来看，让政府的力量过于强大也不见得更好。\n\n第二部分政治挑战\n有无数演讲和文献直接把古代雅典的民主制度和今日的欧盟联系在一起，赞颂欧洲自由民主的历史长达2500年，但这就像盲人摸象的寓言，盲人只摸到了大象的尾巴，就以为大象像一支画笔一样。确实，数百年来，民主思想都是欧洲文化的一部分，但它从来不是欧洲文化的全貌。虽然雅典民主制度赫赫有名、影响深远，但其实就只是在巴尔干半岛的一个小角落，做了一个称不上真心实意的实验，而且只撑了200多年。如果说欧洲文明在过去25个世纪就是民主、就是人权，那么又怎么解释斯巴达和恺撒、十字军和西班牙征服者、宗教裁判所和奴隶贸易，以及路易十四和拿破仑？难道这些都是异地文明的入侵？\n\n\n2011年，总部位于纽约布鲁克林的犹太极端正统派刊物《日志》（DiTzeitung）爆出丑闻。《日志》刊出了一张美国总统偕高层观看美军突袭本·拉登的照片，却用修图软件把所有女性抹去，其中包括国务卿希拉里。该报解释，根据犹太教的“庄重法则”，不得不这么做。类似的另一则丑闻，则是在《查理周刊》（CharlieHebdo）遭遇恐怖袭击之后，多国领导人在巴黎参加了一场反恐大游行，但以色列《预兆报》（HaMevaser）所刊出的照片也用修图软件抹去了德国总理默克尔，希望避免她的影像让虔诚的读者心中生起任何淫念。另一家极端正统派报纸《通信报》（Hamodia）的发行人也声援这种做法，解释这种做法的背后是“数千年的犹太传统”。[5]\n\n\n大约700万年前，黑猩猩和大猩猩的祖先本来是同一个物种，后来才分裂成两个族群，各自演化。物种一旦分裂，就没有回头路了。由于不同物种交配所生的后代不具繁殖能力，因此物种永远不会融合。\n\n\n普鲁士铁血宰相俾斯麦读了达尔文的《物种起源》（OntheOriginofSpecies）之后曾说，巴伐利亚人正是奥地利人与人类之间缺少的那个环节。[10]\n\n\n“伊斯兰国”占领叙利亚和伊拉克的大片国土后，杀害了数万人，炸毁了历史遗迹，推倒了雕像，有系统地毁掉了过往政权和西方文化影响的符号象征。[13]但当“伊斯兰国”的士兵走进当地银行，看到美元上有美国总统的肖像、用英文写着赞颂美国政治与宗教理想的语句时，却不会烧毁美国的这一象征。因为美元超越了政治和宗教分歧，得到了世界的广泛认可。\n\n\n各地民众开始觉得全球资本主义冷酷无情，令人感到孤立无援，再加上担心未来国家健康、教育和福利制度无以为继，于是又投入民族主义的怀抱来寻求安慰和意义。\n\n\n冷战在几乎没有流血的情况下结束，建立了新的国际主义世界秩序，人类进入前所未有的和平时代。不仅核战争免于爆发，各种战争的数量也在减少。自1945年以来，单纯因为侵略而造成的边界变化少之又少，大多数国家也不再将战争作为标准的政治工具。\n\n\n目前，肉类产业不仅给数十亿动物造成无尽的苦难，同时也是全球变暖的主要原因；肉类产业大量使用抗生素和有毒物质，是污染空气、土地和水资源的一个元凶。根据英国机械工程师协会（InstitutionofMechanicalEngineers）2013年的报告，每生产1千克牛肉需要15000升淡水，而生产1千克马铃薯只需要287升淡水。[11]\n\n\n在这样一个充满无情竞争的世界，落后的代价谁都承受不起，所以只要有一个国家选择走上高风险、高回报的科技之路，其他国家就会被迫跟进。为了避免这样的向下竞争，人类需要某种全球性的认同和忠诚。\n\n第三部分绝望与希望\n那么，恐怖分子怎么指望自己有什么影响力呢？他们发动恐怖袭击之后，对手的士兵、坦克和舰船数量丝毫没有减少，通信网络、公路和铁路基本完好无损，工厂、港口和基地也不动如山。其实，恐怖分子所指望的，正在于，虽然几乎无法破坏对手的任何实质力量，但袭击造成的恐惧和混乱会让对手全力出击，过度反应。在恐怖分子的算计之中，激怒对手，让对手动用其强大的力量来反击，所造成的军事和政治风暴绝对会比恐怖分子自己所能造成的更大。\n\n\n恐怖分子其实就像一只苍蝇，想要摧毁一家瓷器店。苍蝇力气那么小，连一只茶杯都动不了，怎样才能如愿？最好的办法就是找头公牛，飞进它的耳朵，开始嗡嗡作响，让这头公牛因恐惧和愤怒而发狂，在瓷器店里横冲直撞。这正是“9·11”事件后的情景，恐怖主义分子刺激了美国这头公牛在中东这家瓷器店横冲直撞。\n\n\n只是挑衅对手，却不去摧毁对手的任何武器或选择，其实就是一种绝望的表现，可见已经实在没有别的选项。如果还有其他选项，能够给对手造成严重的实质损害，任何人都不会选择恐怖主义袭击。\n\n\n恐怖分子其实是在执行一种不可能完成的任务：手上没有军队，却想用暴力来改变政治权力的平衡。为达到目的，恐怖分子就会向政府提出一个不可能的挑战：要政府证明自己可以随时随地保护所有公民免遭暴力侵害。恐怖分子希望在政府试着应对这项不可能的挑战时，让政治重新洗牌，并拿到一些预料之外的王牌。\n\n\n现代政权的合法性正来自保证公共领域不受政治暴力的影响。\n\n\n14世纪，黑死病夺走了欧洲1&#x2F;4~1&#x2F;2人口的生命，但没有任何一位国王因此失去王位，也没有任何一位国王为了战胜这场瘟疫做过什么努力，原因就在于当时并没有人认为预防瘟疫是国王职责的一部分。但是，当时的统治者如果允许宗教异端在其领土传播，不仅可能丢了王冠，还可能掉了脑袋。\n\n\n如果放在1150年，几个伊斯兰教徒在耶路撒冷杀害了几个平民，要求基督教军队离开圣城，非但不会让人觉得恐怖，反而会招来耻笑。想让人把你当回事儿，你至少得先夺下一两座固若金汤的城堡吧？对我们中世纪的祖先来说，恐怖主义实在算不上什么，他们有太多更大的问题需要处理。\n\n\n到了现代，中央集权的结果，国家使领土内的政治暴力日益减少，而在过去几十年，西方国家境内几乎已经完全看不到政治暴力。法国、英国或美国的公民无须拥有武力，也能争取城镇、企业、组织甚至政府本身的控制权。就连几万亿美元、几百万士兵和几千艘战舰、战机和核导弹的控制权，也能够在不打一发子弹的前提下，从一批政客手中转移到另一批政客手上。人类很快就习惯了这种情形，认为这就是自然的权利。这种时候，就算只是偶尔杀害几十人的零星政治暴力行为，似乎也成了对国家政权合法性甚至存在的致命威胁。这就像往大空瓶里丢一枚小硬币，会发出很大的噪声。\n\n\n国家体制创造了一个没有政治暴力的巨大空间，结果就像装了回音板，即便再小的政治暴力声音，也会被回音板放大。一个国家里的政治暴力越少，公众受到恐怖主义行为的冲击就越大。\n\n\n到21世纪，为什么各大强权想要打一场成功的战争竟如此困难？原因之一在于经济本质的改变。在过去，经济资产主要是实物资产，因此可以很直观地通过征服使自己壮大。\n\n\n犹太教在人类故事中的角色，有点儿像弗洛伊德的母亲在现代西方史中的角色。无论是好是坏，西格蒙德·弗洛伊德已经深深影响了现代西方的科学、文化、艺术和民间智慧。没有弗洛伊德的母亲，就不会有弗洛伊德，而且他的个性、抱负与想法也很有可能深受他与母亲的关系影响（他也一定会肯定这种说法）。但在撰写现代西方史的时候，没人会认为值得花上整整一章来写弗洛伊德的母亲。同样，如果没有犹太教，就不会有基督教，但在撰写世界历史的时候，犹太教并不值得花费太大的篇幅。\n\n\n猿类首领早就发展出这种倾向：它们愿意帮助贫寒、穷乏和无父无母的成员。而又过了几百万年，才轮到《圣经》告诉古代以色列人“不可苦待寡妇和孤儿”\n\n\n一神论有一点影响是毫无疑问的，那就是让许多人比以前更不宽容，于是导致宗教迫害与宗教战争蔓延肆虐各方。在多神论者的眼中，不同民族崇拜不同的神灵，进行各式各样的仪礼和仪式，完全没有问题。因此多神论者也很少仅因为他人宗教信仰不同，就加以斗争、迫害或杀害。与此相反，一神论者相信只有自己的神是唯一的真神，也相信这个神要求所有人都要服从他。因此，随着基督教和伊斯兰教传播到世界各地，各种宗教战争、宗教裁判和宗教歧视的发生率也节节攀升。\n\n\n犹太科学家之所以成就非凡，原因之一就在于犹太文化极为重视教育。\n\n\n而在所有形式的谦逊当中，或许最重要的就是在神的面前谦逊。每次讲到神，人们往往都自称卑微，但转头就以神之名，对同胞颐指气使。\n\n\n世俗主义最重视的就是“真相”（truth）。这里的真相必须基于观察和证据，而非只单纯依靠信仰。世俗主义努力不把真相与相信混为一谈。\n\n\n通常，正是因为故事本身并不真实，才更需要有强烈的信仰。\n\n\n资本主义也同样以一种开放的科学理论开始，但逐渐变成一种教条。许多资本主义者不断重复呼喊着自由市场和经济成长的口号，却无视现实的改变。不论现代化、工业化或私有化有时会造成怎样的可怕后果，资本主义的虔诚信徒都会将之视为“成长的烦恼”，保证只要再成长一点，一切就会变好。\n\n\n自由主义者常常就会展现出绝对的信仰，相信“普选”这个神奇的仪式能扭转乾坤。他们在伊拉克、阿富汗和刚果等地参加战斗，投入数十亿美元，坚信只要能够举行普选，就能让这些地方如同丹麦一样拥有更灿烂的阳光。尽管这种做法一再失败，在早有普选传统的地方也偶尔会选出专制平民主义者，但最后的结果与多数的独裁统治相差无几。如果你想质疑普选究竟能否达到所声称的效果，虽然不会被送到劳改营，但各种教条上的霸凌很可能会像一桶冰水浇到你的头上。\n\n\n人类并非真的天生就有生命权或自由权，但正是出于对这个故事的信念，让我们得以约束专制政权的力量，\n\n第四部分真相\n现代的全球化世界天生就有一个特点：因果关系高度分化且复杂。\n\n\n现代历史最严重的罪行，不仅源于仇恨和贪婪，还源于无知和冷漠。美丽迷人的英国淑女虽然从未去过非洲或加勒比海，但通过购买在伦敦证交所上市的股票和债券，就让大西洋的奴隶贸易获得了资金。接着，淑女在下午4点左右喝着下午茶，加入雪白的方糖让茶更为香甜，但这些方糖产自环境如地狱般的奴隶庄园，而她当然对此一无所知。\n\n\n人类一直活在后真相时代。智人就是一种后真相物种，创造并相信虚构故事的能力越高，就越能发挥更多的能力。\n\n\n智人之所以能够征服地球，最重要的因素就在于创造并传播虚构故事的独特能力。人类是唯一能与众多陌生个体合作的哺乳动物，原因就在于只有人类能够创造虚构故事，并且把这些故事流传出去，让几百万人相信。只要每个人都相信同样的故事、遵守同样的法律，就能有效地彼此合作。\n\n\n如果你想指责脸谱网或那些政客开启了全新而恐怖的后真相时代，请提醒自己，不过几百年前，还有几百万的基督徒把自己锁在一个不断自我强化的神话泡泡里，从来不敢质疑《圣经》在各种事实上是否真实。几千年来，人类社群网络里许多的“新闻”和“事实”其实都是虚构的，讲述着奇迹、天使、恶魔和女巫的故事，是无畏的记者从地狱最深处给我们带来了第一手报道。我们没有任何科学证据指出夏娃被蛇诱惑、所有异教徒死后的灵魂都在地狱燃烧，也没有任何科学证据证明如果婆罗门阶层与吠舍阶层的人通婚会令宇宙的创造者震怒。然而就是有几十亿人相信这些故事，一信就是几千年。有些假新闻，就是能够长长久久。\n\n\n如果只有1000个人，相信某个编造的故事，相信一个月，这是假新闻。但如果是10亿人，相信某个编造的故事，相信1000年，这就成了宗教信仰，而且会警告所有其他人不准说这是“假新闻”，否则就会伤害了信徒的感情（或是引发他们的怒火）。\n\n\n想到可口可乐，你的脑中浮现的是什么画面？是一群健康的年轻人一起快乐运动，还是一群超重的糖尿病患者躺在病床上？大口灌下可口可乐并不会让你变年轻，不会让你变健康，也不会让你变得像运动员一样，反而只会增加患上肥胖和糖尿病的概率。然而，可口可乐几十年来投入几十亿美元，把自己与年轻、健康和运动联系在一起，几十亿人潜意识里也就这么相信了。\n\n\n想测试群众是否忠诚，与其要求他们相信某个事实，还不如要求他们相信某件荒谬的事。如果头头表示“太阳从东边升起，从西边落下”，就算属下对他没半点儿忠诚，也会鼓掌同意；但如果头头表示“太阳从西边升起，从东边落下”，只有真正效忠的属下才会愿意鼓掌。\n\n\n假设有个神秘的亿万富翁向你提议：“我每个月给你30美元，而你要让我每天给你洗脑一小时，在你心中植入我想植入的各种政治和商业偏见。”理智的人大概都会拒绝。这个神秘的亿万富翁稍微改变了一下提议：“你让我每天给你洗脑一小时，而我为你提供的这项服务完全免费！”忽然之间，全球就有几亿人觉得这真是个好主意。\n\n\n2015年的电影《机械姬》（ExMachina），表面上讲的是一位人工智能专家爱上一个女性机器人，却遭到她的欺瞒和玩弄的故事。但事实上，这部电影描绘的并不是人类对于智能机器人的恐惧，而是男性对于聪明女性的恐惧，特别是害怕女性解放可能造成女性统治的结果。\n\n\n赫胥黎的火眼金睛看穿了这片密布的乌云，预想未来的社会没有战争、饥荒和瘟疫，只有永续的健康、繁荣与和平。那是个消费主义的世界，性、药物和摇滚毫无限制，只以幸福快乐为最高价值。《美丽新世界》的基本假设是：人类就是生化算法，而科学可以破解这套算法，再运用技术加以操控。\n\n\n赫胥黎的天才之处就在于点出如果想要控制民众，利用“爱”和“快乐”会比利用“恐惧”和“暴力”更为可靠。\n\n\n读《美丽新世界》，其实既令人不安，也发人深省，因为你很难去指责把这一切变成反面乌托邦的因素。毕竟，世界繁荣和平，人人满意欢喜，这又有什么不好呢？\n\n第五部分生存下去\n没有任何政府有能力隐藏它们不喜欢的所有信息；另一方面，现在如果想用各种互相矛盾的报道、无关紧要的话题来影响大众，完全是轻而易举。比如，全球民众现在如果想知道叙利亚的阿勒颇（Aleppo）遭轰炸的情况，或是南极冰盖融化的最新情形，只要上网点一下就能得到信息。然而网络上众说纷纭，实在难以判断哪些内容可信。正是因为只要点一下就能得到无数其他信息，也就令人难以专注。\n\n\n许多教育专家认为，学校现在该教的就是“4C”，即批判性思考（criticalthinking）、沟通（communication）、合作（collaboration）和创意（creativity）。[3]说得宽泛一点儿，学校不应该太看重特定的工作技能，而要强调通用的生活技能。最重要的是能够随机应变，学习新事物，在不熟悉的环境里仍然保持心智平衡。想跟上2050年的世界，人类不只需要发明新的想法和产品，最重要的是得一次又一次地重塑自己。\n\n\n想在这样的世界过得顺风顺水，需要心态非常灵活、情感极度平衡。人类将不得不一再放弃某些自己最熟悉的事物，并要学会与未知和平相处。\n\n\n一套故事可以纯粹出于虚构，只要能让我们有身份认同，觉得人生有意义，就已足够。事实上，如果以我们目前的科学知识来判断，全世界有史以来所有文化、宗教和部落的千千万万个故事，没有一个是真实的，全部只是人类的发明。如果你想问人生有何真正的意义，而对方是用一个故事来回答你，这个答案肯定是错的。故事细节如何并不会有所区别，任何故事，都一定是错的。原因在于，宇宙绝不是以故事的方式运作。\n\n\n多数故事之所以仍能屹立不倒，靠的并不是稳固的地基，而是屋顶的重量。以基督教的故事为例，这套故事的基础实在薄弱。到底有什么证据可以证明全宇宙创造者的儿子是在大约两千年前、在银河系的某个地方以碳基生命[5]形式诞生？又有什么证据可以证明这事发生在加利利，而且他的母亲还是个处女？虽然如此，以这个故事为基础，全球就是建立起了许多重要的机构与体制，而且单凭其重量就形成了强大的力量，使这个故事颠扑不破。\n\n\n“仪式”是一种神奇的行为，能让抽象变得具体、虚构变得真实。\n\n\n而讲到军事，纪律和仪式的关系密不可分，从古罗马到如今，士兵花上无数小时，练习着行进，敬礼，把靴子擦得锃亮。拿破仑有句名言，说他只要用一个勋章，就能让士兵愿意献出自己的生命。\n\n\n而讲到仪式的重要性，或许最懂这件事的就是孔子了。对孔子来说，尊礼是社会和谐、政治稳定的关键。诸如《礼记》《周礼》《仪礼》等儒家经典，记载了各种国事场合需要怎样的仪式，甚至连礼器的数量、乐器的种类、礼服的颜色，诸多规范巨细无遗。而每当国家遭遇危机，儒家很快就会认为必定是哪里失了礼，就好像在打了一场败仗之后，长官认为败因在于士兵没有把靴子擦干净。[9]\n\n\n在现代西方，儒家对礼仪的执迷往往被认为是浅薄的和过时的，但事实上，由此或许正可看出孔子对人性有着怎样深刻和永恒的理解。儒家之所以能够从中国流传到韩国、越南和日本，并且形成源远流长的社会和政治结构，或许并非偶然。如果想知道生命的终极真相，礼仪和仪式会是个巨大的障碍。但如果你想知道的是如何达到社会的稳定与和谐（就像孔子那样），真相往往只是一种负担，而礼仪和仪式反而是你最好的伙伴。\n\n\n到了2018年，还是有很多人认为两根木棍钉在一起就成了上帝，墙上一张五颜六色的海报就成了革命，而在风中飘扬的一块布就成了国家。你当然不可能看到或听到法国，因为法国只存在于人的想象当中，但你确实可以看到三色旗，听到《马赛曲》。于是，靠着挥舞国旗，咏唱国歌，国家就从一个抽象的故事变得现实且一触可及。\n\n\n印度政府要把资源拿来升起巨大的国旗，而不是在德里的贫民窟建造污水处理系统？原因就在于这面国旗可以让印度变得“真实”，而这是污水处理系统做不到的。\n\n\n就算你因为信仰上帝或相信国家的概念而受苦，并不能证明就真有上帝或真有国家。或许你只是因为自己太轻信谣言，所以得付出代价？但大多数人并不喜欢承认自己是傻瓜。所以，他们为某种信念牺牲越多，这种信念就会越强烈。这正是牺牲献祭这件事神奇的魔力。主持献祭的神职人员想让我们臣服于神威之下，并不需要给我们什么（无论是雨水、金钱，还是胜利），反而要从我们这里取走一些东西。只要我们被说服并做出某些痛苦的牺牲，我们就会被困在这个概念里。\n\n\n你认为女性为什么想要对方为自己戴上钻戒？对方一旦做出如此巨大的经济牺牲，就得说服自己，这一切一定有价值、有意义。\n\n\n如果你因某个故事之名给自己造成痛苦，你的选择是：“我要么相信这个故事是真的，要么就是个容易受骗的傻瓜。”但如果你是因某个故事之名给别人造成痛苦，你的选择则是：“我要么相信这个故事是真的，要么就是个残忍无情的坏蛋。”而因为我们既不想承认自己是傻瓜，也不想承认自己是坏蛋，只好相信这个故事是真的。\n\n\n人类很少把所有的信念都投注在单一的故事上，而是有个“信念组合”，里面有几个不同的故事、几个不同的身份认同，可以配合需求任意切换。几乎所有的社会和运动，都有这种认知失调的情形。\n\n\n可以找到许多伯尼·桑德斯（BernieSanders）的支持者，一边相信未来会出现革命，一边相信应该做出明智的投资。就算原本是在讨论现在的财富分配如何不公平，他们也可以轻轻松松忽然转向讨论他们在华尔街的投资表现。\n\n\n民族主义告诉我的，是我的国家独一无二，而我对自己国家的义务应该不同于一般；而法西斯主义告诉我的，是我的国家比别人的更优越，而我对自己国家的义务应该排挤掉其他一切义务。在任何情况下，其他团体或个人的利益，都不应该超越我的国家的利益。就算我的国家会给远方土地上几百万个陌生人造成极大的痛苦，而且换得的利益微不足道，我还是该无条件地支持我的国家，否则我就是个卑鄙的叛徒。我的国家要我杀几百万人，我就该杀几百万人。我的国家要我背叛真相、背叛美的事物，我就该背叛真相、背叛美的事物。\n\n\n这种国家崇拜对人很有吸引力，因为这会让人觉得自己的国家是全世界最美、最重要的。第二次世界大战与纳粹大屠杀事件，就代表这种思维方式可能带来的骇人结果。很遗憾，现在要批评法西斯主义究竟有何不好，常常成效不彰，原因在于只把法西斯主义讲得像头恐怖的怪兽，却没提法西斯主义有何诱人之处。\n\n\n确实，纳粹大约有20%的区长（gauleiter，相当于现在的省长或州长）、10%的将军决定自尽[19]，但这也代表有80%的区长、90%的将军非常乐意继续活下去。至于绝大多数领有党证的纳粹党员，甚至盖世太保的成员，都既没有发疯，也没有自杀，后来成了很好的农夫、教师、医生或保险代理人。\n\n\n只要政客的话语开始掺杂一些神秘的语词，就该提高警惕。面对真实的痛苦，这些人可能会用某些空泛难解的表达来加以包装，作为申辩。其中有四个词要特别小心：牺牲、永恒、纯净、恢复。只要听到其中任何一个，心中就该警铃大作。如果领导人常常说“他们的牺牲，将能恢复我们这个永恒国家的纯净”之类的话，你就该知道自己问题大了。想要维持理智，就要记得把这些空话转回现实：有士兵痛苦地哭泣，有妇女遭到殴打和残虐，有儿童恐惧地颤抖。\n\n\n内观（Vipassana，这是古印度巴利文，意为“内省”）禅修课程。\n\n\n\n\n\n","tags":["读书"]},{"title":"让你的系统在上线之前就接受炮火的洗礼-影子流量","url":"/blog/2018/11/22/shadow-traffic/","content":"随着持续集成，持续交付等理念的传播，很多软件开发团队都搭建了自己的staging、UAT等类生产环境。这些环境的软硬件及网络配置会尽量贴近真实的生产环境，起到沙盘演练的作用。\n类生产环境毕竟前面还有一个类字，沙盘毕竟不是真实的战场，尽量贴近毕竟还不是完全吻合。\n类生产环境与真实生产环境的一个重要差异就是访问量。稍具规模的互联网应用每天几百万访问量是很正常的，而类生产环境的访问量一般都会相形见绌。\n有各种工具可以弥合这个差异，比如Apache JMeter，Gatling。测试人员可以和开发人员一起设计测试用例，以自动化或者半自动化的方式对类生产环境进行压力测试。\n不过即便是精心设计出来的用例也还是用例，不是真实请求。真实请求具有多样性，会随着昼夜交替而变化，会随着时事热点而波动，这是很难用工具模拟出来的。\n这就引出了这篇文章的主角-影子流量（shadow traffic）。\n简言之，影子流量（shadow traffic）就是将发给生产环境的请求复制一份转发到类生产环境上去，以此来达到压力测试和正确性测试的目的。\n这就如同把真实战场上的敌方炮火投放到演习场里去。\n实现方式Shadow traffic通常有两种实现方式：服务端实现，客户端实现。\n下图描述的是服务端实现的简化示例。\n\n\n生产环境接收到来自于用户或者是上游系统的请求，在响应该请求的同时，将这个请求原封不动的也发送给类生产环境。\n下图描述的是客户端的实现。\n\n\n客户设备或者上游系统在发给生产环境请求的同时，给类生产环境也发送一个一模一样的请求。\n这两种实现方式各有优劣，放到服务端做可以减少客户端设备的流量消耗，这一点对于移动应用很重要。\n客户端的实现则较简单，通常只需要几行代码即可。如果后端架构较复杂，则可以选择前端实现。\n无论前端还是后端实现，都需要遵循发射后不管(fire and forget)的原则，以免阻塞正常流程或者增加响应时间。\n适用场景笼统来说，shadow traffic可以适用于所有互联网应用。而在以下场景中，shadow traffic的作用格外明显：\n\n要用新系统替换掉老旧系统\n系统经历了大规模改造，直接上线面对客户风险较大\n系统更新，需要提供向后兼容性\n试验性质的架构调整\n\n在以上场景运用shadow traffic，可以在不影响终端用户的情况下完成验证与测试。\n启用时机在上线之前一段时间集中地进行测试固然是一种可行的方式，不过我个人更倾向于在项目运转的早期引入shadow traffic。\n这样做可以让开发团队尽早的并且持续的接触到真实的外界压力。相当于用一种成本并不怎么高的方式构建出了具有产品运维经验的开发团队。\n配套机制Shadow traffic的原理和实现方式并不深奥，但要让它发挥出应有的价值还需要一些前期工作的配合。\n基础设施监控要了解系统的表现，基础设施监控是必不可少的。\n上图是我所经历过的一个项目的可视化监控界面。监控范围涵盖了docker container的数量，请求数量，响应时间，以4或者5打头的HTTP状态码的数量，网络、内存、CPU用量等等。\n通过如上的可视化图表，开发团队可以实时得到反馈。\n日志基础设施监控可以提供一个外部视角，日志则能够窥见应用内部。\n日志可以帮助开发团队定位shadow traffic中发现的问题，shadow traffic也可以促使开发团队提升日志的质量。这二者可以起到双向的积极促进作用。\n下游系统的配合如果一个系统开启了shadow traffic，可以想见它的下游系统所面对的压力也会陡升。\n这时有必要与下游系统负责团队做好事先沟通。\n用法变式Shadow traffic并非是一成不变的技术实践，可以按需微调。\n请求挑取并非每一个请求都有被转发的必要。可以优先选取流量大或者业务价值高的请求。\n流量控制如果想做极限压力测试，可以把每一个请求重复发送多次给类生产环境。\n当然也可以只挑取10%的请求来发送给类生产环境，随着团队信心的提升而逐步升高。\n重播可以截取并保存每天尖峰时刻的请求，在其他时段反复重播。\n这种考验可以有效的锻炼团队的心理素质，并促使团队形成应急预案。\n小结如果明天要上线，今天会是一个让人惴惴不安的日子。\n系统性能表现如何？会不会有奇形怪状的用户行为导致系统异常？与上下游系统的衔接会不会出现问题？\n这些问题的答案，可以通过测试人员的精心模拟来寻找。但仍难免会挂一漏万。\n启用shadow traffic，如果开发团队可以习惯于有shadow traffic的日常，也就具有了应对线上运维问题的能力。\n\n\n\n\n","tags":["shadow traffic","ops"]},{"title":"信息安全要做好，身份认证不能少。众邦银行胡乱搞，别人知我钱多少。","url":"/blog/2018/10/14/zb-bank/","content":"一首绝句作为定场诗，接下来开始正式的内容。\n最近，我在网上进行了一些稀奇古怪的操作，于是乎我莫名其妙的得到了一个“众邦银行”的账户。\n这个名字并不是很熟悉，查了一下，看起来还算是有头有脸的样子。\n\n武汉众邦银行股份有限公司（简称武汉众邦银行，英语：Wuhan Zhongbang Bank Co., Ltd.，缩写：Z-BANK）是中华人民共和国境内第11家开业的民营银行，也是湖北省首家获批开业的民营银行。\n\n以上是wiki的信息。\n\n国内一共十七家民营银行，这个众邦是第十一家，或许应该不会太差吧？\n这样想的我实在是too young，too simple，还需要继续提高自己的知识水平。\n这家银行其他方面不敢说，但是信息安全方面，是非常值得质疑的。\n下面是我的众邦银行账户上的一部分流水：\n\n首先，时间的格式化有问题，小时和分钟之间有两个冒号，这叫个啥？\n分钟的两位数中间又有一个冒号，这叫个啥？\n秒钟干脆就没有了，这叫个啥？\n不但没有秒钟，分钟的第二位数后面还有一个冒号，这又是个啥？\n这就算了，时间的格式化，小问题，大概还是能看懂的。\n关键是这个页面的URL啊，同志们。\n它的URL有啥问题呢？先不着急说。我们看两个其他的例子先。\n京东查看我在京东的历史订单，URL是这样的：https://order.jd.com/center/list.action\n域名&#x2F;center&#x2F;list.action，这里面不包含任何多余的信息。\n如果我把这个URL发给别人，别人如果正处于登录了京东的状态的话，打开看到的肯定是人家自己的订单。\n如果没有登录京东，就会看到京东的登录页面。\n没有问题，这很好，很合理。\n支付宝再看看支付宝，查看我在支付宝的流水，URL是这样的：https://consumeprod.alipay.com/record/standard.htm\n域名&#x2F;record&#x2F;standard.htm，也很干净，path里没有啥脏东西。\n如果我把这个URL发给别人，别人如果正处于登录了支付宝的状态的话，打开看到的肯定是人家自己的流水。\n如果没有登录支付宝，就会看到支付宝的登录页面。\n好了，应该不需要更多的例子了，大的原则就是我的购物和流水信息别人不应该仅仅通过一个URL就能看到。\n接下来，看一看反面典型吧。没错，反面典型就是这个“中华人民共和国境内第11家开业的民营银行，也是湖北省首家获批开业的民营银行”–众邦银行。\nhttps://perbank.z-bank.com/weixinServer/htmlShow/weixinBank/views/transfer/tradeRecord.html?/iwJPm77nZq2HJfE5F1i0O8eJZlV6AJqePqv0T7or1bZwkrWnishU3vmqDhXVKGFRuCcJFfjMxcu9khuk5DU8JtIvYvdELXHJMfGepT4I1UAYMCuutU8mQotdPwHAgq4nhocB1nKeeE4HKhWkNMG3kvv/HqUv0QA5F+oxCtdtYRpM9hwNz4mbAL/7VALq7818qWxJgTpWGt9zmO/G9tFb6rSBiW00BT1aPSPCBsswXk939y2I2qc/8yclDRs41ex=\n上面是我在众邦银行的流水页面的URL。\n哇呀，好花哨啊，这么多字符呀，看起来乱呼呼的，想必很安全吧？\n并没有！\n任何一个人，在任何一台设备上，使用任何浏览器，访问这个URL，就可以得到，你猜是啥？\n没错，就是我在众邦银行的流水了。\n不信的话，你访问一下那个URL，看到的内容和本文上面的截图里是一样的。\n实在不是我想要搞一个大新闻，然后把众邦银行批判一番，而是众邦银行犯的这个错误太低级了。\n作为国家批准钦定的民营银行，你们怎么能这个样子呢？将来用户的信息安全有了偏差的话，你们是不是要负责任的呀？\n你们搞的这个东西呀，一点都不excited，简直让我折寿-1s。\n你们这样搞啊，行不通的，这绝对不是坠吼的，简直不知道低到哪里去了。\n希望你们能努力提高自身的知识水平，积累一点人生经验。\n悄悄地做一点微小的工作，修复这个问题，之后就可以慢声大发财。\n来日才好和用户们谈笑风生啊。\n\n\n\n\n","tags":["🐸"]},{"title":"小岛经济学","url":"/blog/2019/01/06/2019-1-6-island-economy/","content":"第一章一个好点子出炉了基本的经济原则，这个原则可以提高人们的生活水平：消费不足，敢于冒险！\n在经济学术语中，资本指的是一种设备，这种设备的建设和使用本身没有什么意义，其意义在于利用设备建设和制造其他需要的东西。艾伯想要的不是那张网，而是鱼。这张网或许可以给他带来更多的鱼。因此，这张网就是一种资本，是有价值的。\n在艾伯孤注一掷去编织渔网之前，小岛上还没有什么储蓄之所。他决定冒险挨饿制造的这张网成了小岛上的第一件资本设备。这件设备接着会带来储蓄（为了让这个故事能够继续进行，我们假设这些鱼不会腐烂变质），而这种剩余产品就是健康经济的命脉。\n工具改变了一切，使经济的出现成为可能。长矛帮助我们捕获猎物，铲子帮助我们种植庄稼，渔网帮助我们捕鱼。这些工具提高了我们的劳动效率。我们生产的东西越多，可以消费的东西就越多，我们的生活也就变得越美好。\n努力使有限的资源（每种资源都是有限的）产生最大的效益以尽可能满足人类的需求，这就是经济这一概念最简单的定义。工具、资本以及创新是实现这一目标的关键。\n经济增长的原因：找到了生产人类所需物品的更好方式。不管一个经济体最后变得多么强大，这个原因是不会改变的。\n第一章，经济的增长主要取决于生产力的提高。\n第二章把财富分享给别人虽然艾伯从来没有刻意使他人受益，但他的资本无疑帮助了岛上的所有人。\n处理储蓄（鱼）的方式只有5种：1.他可以把储蓄存起来。2.他可以把储蓄消费掉。3.他可以把储蓄借出去。4.他可以用储蓄投资。5.他可以将上述4个方式有机结合起来。毫无疑问，艾伯的最终决定取决于个人对风险和回报的偏好。但不管最终方案是什么，他的抉择都会惠及这座小岛的经济，而且也不会给自己的两个邻居增加负担。\n有了多余的鱼，小岛上的几位居民每天终于可以比原来多吃一些鱼了（原来是每天一条鱼），但是经济并没有增长，因为他们的消费增长了。而他们的消费之所以增长，是因为经济增长了。这个道理很简单，但令人不解的是现代经济学家竟然会在这个简单的问题上纠缠不休。\n大多数经济学家认为，给老百姓更多的钱花就可以增加需求，但是这种做法并不能改变真正的需求，只会使人们花更多的钱购买已经生产出来的商品。只有增加供给才能切实满足人们更多的需求。\n假设艾伯对自己的相对财富有些负罪感，听了两个人的说法后思想动摇了，于是无偿地把鱼分给了他们，那么贝克和查理会怎样处理这些鱼呢？没有了还款的压力，两个人最有可能做的是利用这份礼物享受闲暇时光。这样做并没有什么错（事实上，这也是大多数人类行为的目标），但是贝克和查理的假日时光并不能提高这座小岛的生产能力。因此，尽管慈善之举听起来颇有雅量，也会提升艾伯的人气，但这一举动却无法像商业贷款一样推动经济发展。\n最根本的是，所有能够增加捕鱼（生产）量的事物都会惠及小岛，鱼越多，大家就越有可能吃到更多东西，也就越有可能做捕鱼以外的事情，\n也许有人会想，如果艾伯果真是一个贪心的人，拿着自己的新财富生财，从而变得越来越富有，那该怎么办？这样真的很危险吗？如果艾伯增加储蓄（而不需要亲自劳动）的唯一途径就是将这些储蓄借给自己的邻居的话，那他又何必大量囤积呢？但若非如此，他的财产就不会增加，甚至还会越来越少，因为他自己还要消费呢！私人资本主义可以促使那些将个人利益作为唯一动机的人帮助他人提高生活水平，这是最有意义的。\n财富从来就是一个相对的概念。\n富人致富的原因（至少开始时）是他们为他人提供了有价值的东西。艾伯就为那些没有足够储蓄的人提供了储蓄。如果他赢利了，那也是因为他提供的服务对别人是有价值的。\n第二章。资本的流动有助于提高生产力。\n借贷市场会受到外力挤压，如果出现这种情况，灾难便在所难免了。\n第三章信用卡的多种用途商业贷款是资本的最佳用途，因为这样可以扩大生产。\n当然，通过借钱或借鱼的做法创业，无法保证企业一定会成功，因为借款人可能无法完全实现自己最初的计划。\n商业贷款并非社会储蓄的唯一选择，艾伯还可以选择其他贷款形式——消费贷款和应急贷款。\n消费贷款如果不能提高产能的话，这笔贷款无论是对贷款人还是借款人来说都是一种负担。\n出现了紧急情况，艾伯可以从自己的储蓄（鱼）中拿出一部分作为困难生活贷款。贝克和查理可以先吃借来的鱼，等身体恢复了再出去捕鱼。尽管艾伯很清楚这次的“贷款”血本无归的可能性很大，但他知道，如果不贷款给他们，风险更高。与消费贷款不同，如果艾伯不向贝克和查理提供这份应急贷款，两人很可能会丧命。如果真的发生这种情况，这座小岛就失去生产能力了。\n这些政策的关键推动因素就是认为政府规划者要比储蓄者更清楚什么有利于社会发展的观念。\n实际信贷是受有限储备制约的。\n现在，人们都认为信贷市场的有效运作所需要的就是有意愿的借款人。然而，与其他资源一样，在发放贷款前必须先积累储蓄才行。\n第四章经济到底是如何发展的这些丰富的活动说明了人类社会在农业发展之后所发生的变化。只有当我们能够生产出额外的食物时，我们才有时间做其他事情。\n一笔备用的储蓄会防止经济崩溃，可以迅速重建受损的资产。\n消费不能超过产能，我们的借款不能超出存款，\n储蓄创造了资本，而资本使生产扩大成为可能，所以储蓄起来的一美元对经济产生的积极影响要大于消费掉的一美元。\n第五章在鱼被指定为货币之后岛上的价格体系和鱼的真实（或者固有）价格相关。\n达菲提高生产率，受益的不只是他自己，还有岛民。价格降低之后，更多的人买得起独木舟，因此他的顾客群也扩大了。\n由于生产率提高了（储蓄、创新和投资的结果），独木舟的价格便随之下降，更多顾客能够享受到拥有独木舟的好处。昔日富人独享的奢侈品也成了普通消费品。\n技术创新是个单向的过程。除非人们失去记忆，否则生产效率必然会越来越高。因此，价格具有随着时间推移而降低的趋势。\n得益于他的资本，莫里收费更低，但是赚取的利润更多。\n如果货币供应稳定（就像美联储成立前的美国那样），生产率的提高会促使价格下降。\n价格下降并不一定会影响特定行业的发展，我们不止一次地见证过这一点。\n虽然计算机的价格不断大幅下降，但是这个行业的赢利还是非常丰厚。产品价格的下跌并未阻挡计算机革新的步伐。\n起决定作用的不是消费，而是生产！\n虽然有这么多反面证据，通货紧缩还是被当作经济的头号敌人。这是因为通货紧缩（与通货膨胀相反）是政治家最好的朋友。这一点我们在后面会详细说明。\n第六章为什么会有储蓄虽然岛民愿意通过贷款和投资使自己多余的鱼增值，但是大多数人既没有时间也没有能力判断某项商业计划的优劣。\n他用邻居的储蓄放贷，所获收益的一部分作为储户的利息和看守人员的工资，剩下的部分作为自己的利润。\n有时生产率大幅提高，岛上的存鱼量也随之大大增加。如果储藏室里堆满了鱼，银行就会主动降低贷款利率。因为此时银行承受损失的能力较强，而且健康的经济也为新企业的发展提供了良好的环境。\n当存鱼较少时，迈克斯放贷就格外谨慎。因为在储蓄不足的情况下，一旦有人拖欠贷款，后果将非常严重。为了抵消高风险可能带来的损失，迈克斯会向借款人收取更高的利率，并提高存款利率以刺激储蓄。\n高利率会抑制借贷，延缓经济增长。但同时，高利率也能刺激储蓄。最终，银行资产会再次积累起来，到那时利率又会下降。\n曼尼从那些对银行存款利率不满意的储户那里募集存鱼，然后再把募集到的鱼投入备受瞩目的项目。\n美联储的决定总是基于政治考量而非经济因素。因为低利率能够使经济表面上表现更好，降低还款压力，还能帮金融公司赚钱，所以很多人都喜欢低利率。\n低利率会刺激借贷、抑制储蓄，\n第七章基础设施与贸易提供就业岗位并非经济的目的。经济的目的是不断提高生产力。\n第八章一个共和国就这样诞生了如果生产者不缴纳税款，政府雇员连饭都吃不上。\n第九章政府的职能开始转变了一些参议员基于情感原因认为，宪法中关于纳税与投票权的关系从根本上来说是非民主的。基于进步主义精神，这项规定被废除了，很多不太关心政府预算支出的人也获得了投票权。\n你们每发行10张钞票，我都只有9条鱼可以兑换。如果储户发现我们没有足够的鱼可以兑换，他们就会蜂拥到银行来兑现，那时我就没有存鱼啦。你必须停止发行鱼邦储备券，并提高税率。我们必须恢复储备。”\n一旦岛上的储户意识到把鱼存在银行不安全，他们就会停止储蓄。他们会像从前那样把鱼堆在家里。那样的话，我们就没有足够的资本维持我们现在赖以生存的设施，更没有资金投资新的项目了！我们的整个经济就会崩溃！”\n1913年，美联储成立。美联储发行纸币，承诺纸币持有者可以随时将其兑换成黄金，从而取代了当时流通的私营银行发行的钞票。\n第十章不断缩水的鱼就像货币一样官鱼越来越小，不久后岛民每天只吃一条鱼已经无法填饱肚子了，大多数人每天至少要吃两条鱼。因为官鱼是岛上的货币，所以物价都必须相应上涨才能弥补鱼损失的营养价值。于是通鱼膨胀的难题产生了。\n随着通鱼膨胀愈演愈烈，岛民们终于注意到他们从银行取出的鱼比他们存入银行的鱼要小。因此，虽然有利息的诱惑，人们还是开始减少储蓄，有些人索性一点儿也不储蓄了。反过来，由于物价不断快速上涨，人们必须抓紧消费，以免损失鱼的价值。\n快速的通鱼膨胀的最大受害者是退休人员。在参加工作的那些年里他们把鱼存入银行，而现在他们每天必须吃两三条鱼才能果腹。他们原以为可以让他们维持生活20年的储蓄，四五年就用光了。\n通鱼膨胀抑制储蓄，银行储蓄额随之降低了。结果，可以用来投资有前景的项目或者支持不景气的企业的存鱼减少了。\n通货膨胀其实就是货币供应量增加，与其相反的情况即为通货紧缩，意指货币供应收紧。从另一方面来说，价格自身其实不会膨胀或者紧缩，只会上涨或下跌。所以膨胀的不是价格，而是货币供应。\n凡是1990年以前出版的字典对通货膨胀的定义都是货币供应量的增加。较新版本的字典的定义就开始松动了。\n忘记了一旦物价下跌到一定程度，人们就会开始消费。这个过程淘汰了不必要的产能，把物价调低到符合内在供求关系的水平。\n产能过剩\n第十一章中岛帝国：远方的生命线多年来，经济学家对美中关系的理解一直是错误的。大多数人认为那是一种互利互惠的双边关系：美国得到廉价商品和贷款，中国得到制造业的就业机会。然而，这真的是一种双赢的安排吗？美国人占了便宜：他们不用生产就可以得到商品，不必储蓄就可以得到贷款。而对于中国人来说，他们辛勤工作却不能消费自己生产的产品，他们努力储蓄却得不到贷款。\n美国的低利率很大程度上是由国外的高储蓄率造成的，大多数当代经济学权威都没有意识到这一点。要记住，想要借贷，就必须先储蓄。所幸，对于美国来说，全球经济使得借与存的关系可以不受国境的限制。\n外国人持有的美元很多都存在美国的银行里，因而又可以借贷给美国人。这么一来，美国人即使不储蓄也可以获得贷款。\n如果没有中国和其他国家的储蓄，美国人以及美国政府想要借钱就会很困难，他们将不得不承担高额的贷款利率。对于靠贷款推动的美国经济而言，利率偏高和信贷吃紧是一个致命的组合。\n第十二章服务业是如何崛起的正常来讲，贸易逆差能够自我调节。如果一个国家处于贸易顺差状态，也就是说其出口额大于进口额，就会在国际上形成对其货币的需求。如果你想要该国的产品，你就需要该国的货币。所以，强势的贸易地位会使一国货币坚挺，弱势的贸易地位会导致该国货币疲软。如果没有人想购买你的产品，也就没有人需要你的货币。但是，一旦一国的货币升值，该国的产品也会相应涨价。这就给处于弱势贸易地位的国家提供了进入该国市场的机会。他们的商品销售得越多，国际市场对其货币的需求就越大。这股货币平衡力量会使脱缰野马般的贸易失衡得到控制。\n第十四章棚屋价格是如何涨上去的银行想寻找一个稳妥的项目，最后它们盯上了岛上沉睡着的棚屋贷款市场，认为那是低风险贷款的理想对象。\n虽然棚屋贷款不能提高岛上的生产能力和借款人的还款能力（商业贷款则可以），但是这些贷款安全性很高。与那些借给前途未卜的企业家的商业贷款不同，棚屋贷款有天然的抵押物，也就是所购买的棚屋。如果借款人不能还款，银行还可以没收棚屋，把它卖掉，以偿还贷款。\n有些岛民愤愤不平，因为并不是所有人都有机会获得棚屋贷款。富人一般很容易得到贷款，而没有储蓄或者信用记录较差的人就没那么幸运了。有人觉得穷人被剥夺了使用岛上财富的权利。参议员认为这是潜在的竞选议题，于是插手进来，想要解决这个问题。\n第十五章快了！快了！棚屋市场要崩溃了他们手里已经有很多钞票了。如果他们不接受，那些钞票只会更加贬值。他们现在只能任由我们摆布。\n第十六章情形怎么变得如此糟糕选择很简单：1．减少消费，用储蓄还债；2．增大产量，卖掉多余的货物还债；3．追加贷款，继续保持现有的消费水平。在前两个选择中，美索尼亚人都要吃苦。要么努力工作，要么减少消费，再不然就是双管齐下。而第三种选择可以把一切痛苦转嫁给外国人。毫无疑问，参议员们勇敢地选择让外国人当替罪羊。通过这些措施，他们希望恢复消费支出，重新建立国内健康的经济环境。\n记住，一国的经济不会因为人们的消费而增长，而是经济增长带动人们的消费。\n2009年，美国的存款率多年来首次升高，贸易逆差在飙升10年后也开始萎缩。但是，小布什和奥巴马政府的刺激计划结束了这一进程。美国人本该回到与生产力相称的生活水平上去，但他们的计划制造了更加巨大的债务，从而延缓了这个过程。\n如果美国政府不在财政上严于律己，美国的债权人（主要是中国和日本）迟早会要求美国那么做。债权人可以选择多种方式让美国就范，最有效的一招就是停止购买美国的国债。\n第十七章缓兵之计所谓“PIGS”（即葡萄牙、意大利、希腊和西班牙）国家卷入泥潭的债务危机。\n尽管希腊从2004~2006年的房地产建设热潮中获益不少，但到了2010年，一个事实却越来越清晰：这个国家已经无望偿还已有的债务，更没有可能兑现自己对公民的承诺了。希腊成了一个臭名昭著的国家，成了短期工作、长期罢工、提早退休、连续逃税的代名词。通常来说，一个国家沦落到希腊这样的地步，会通过否认债务或货币贬值来应对危机。但作为欧元区的一员，这些做法希腊一样也不能采用。\n欧洲的诸多问题对美国而言，无异于天赐良机。希腊首都雅典大街上游行的人群不仅是经济恶化的醒目标志，还使恐惧蔓延，令整个欧洲大陆深陷泥潭。这样的剧变使许多投资基金转而越过大西洋，去寻找更安全的避风港。于是，在美国经济亟须支撑之时，大量资金及时涌入美国。讽刺的是，许多经济学家对此的评论居然是，欧洲的问题已经成为美国经济的负担，然而实际上，这些问题带给美国的明明是一种福祉。\n尽管很多人知道美国依赖量化宽松，但很少有人真正看透其本质：向金融市场注入新的资金，以推动价格上涨。实际上，量化宽松不过是通货膨胀的一种委婉表达，它也成为美联储将政府债务货币化的隐秘手段。\n第十九章无鱼不起浪通货膨胀不过是把财富从以某种货币储蓄的人手中转移到以同种货币负债的人那里。\n如果遇到恶性通货膨胀，存款就会变得一文不值，负债却一笔勾销。（拥有固定资产的人情况会好一些，因为与以货币形式储蓄不同，固定资产的账面价值会暴涨。）这样\n18世纪90年代的法国，19世纪60年代的美国南部邦联，20世纪20年代的德国，20世纪40年代的匈牙利，20世纪七八十年代的阿根廷和巴西以及现在的津巴布韦。在所有的这些例子中，引发恶性通货膨胀以及随后的经济灾难的原因都惊人地相似。这些国家都是通过降低货币价值偿还巨额外债，结果，本国的人民陷入了赤贫之中。\n后记金融危机发生数月以来，大家一致认为是因为缺乏足够的监管才会酿成苦果，在很大程度上忽视了政府和美联储的责任。结果，不该来的（财政支出和限制性规定）越来越多，该来的（储蓄和自由企业）越来越少。\n\n\n\n\n","tags":["读书","经济"]},{"title":"读屠龙术五卷，粗浅总结一下太祖的套路","url":"/blog/2019/04/11/tu-long-shu-mao/","content":"最近快速浏览完了太祖的五卷选集。粗浅的尝试着总结一下太祖做事情和分析问题解决问题时都会运用一些什么样的套路。\n性质决定形式革命不是请客吃饭，不是做文章，不是绘画绣花，不能那样雅致，那样从容不迫，文质彬彬，那样温良恭俭让。革命是暴动，是一个阶级推翻一个阶级的暴烈的行动。\n\n大家明白，不论做什么事，不懂得那件事的情形，它的性质，它和它以外的事情的关联，就不知道那件事的规律，就不知道如何去做，就不能做好那件事。\n\n中国是一个经过了一次革命的、政治经济发展不平衡的、半殖民地的大国，这是中国革命战争的第一个特点。这个特点，不但基本地规定了我们政治上的战略和战术，而且也基本地规定了我们军事上的战略和战术。\n\n办法是跟着方针来的。方针是不抵抗主义的时候，一切办法都反映不抵抗主义，这个我们已经有了六年的教训。方针如果是坚决抗战，那就非实行合乎这个方针的一套办法不可，非实行这八大纲领不可。\n要究根源开会时要使到会的人尽量发表意见。有争论的问题，要把是非弄明白，不要调和敷衍。一次不能解决的，二次再议（以不妨碍工作为条件），以期得到明晰的结论。\n\n战争问题中的唯心论和机械论的倾向，是一切错误观点的认识论上的根源。他们看问题的方法是主观的和片面的。或者是毫无根据地纯主观地说一顿；或者是只根据问题的一侧面、一时候的表现，也同样主观地把它夸大起来，当作全体看。 … … 反对战争问题中的唯心论和机械论的倾向，采用客观的观点和全面的观点去考察战争，才能使战争问题得出正确的结论。\n抓大放小有些同志的批评不注意大的方面，只注意小的方面。他们不明白批评的主要任务，是指出政治上的错误和组织上的错误。至于个人缺点，如果不是与政治的和组织的错误有联系，则不必多所指摘，使同志们无所措手足。而且这种批评一发展，党内精神完全集注到小的缺点方面，人人变成了谨小慎微的君子，就会忘记党的政治任务，这是很大的危险。\n\n据衡山的调查，贫农领袖百人中八十五人都变得很好，很能干，很努力。只有百分之十五，尚有些不良习惯。这只能叫做“少数不良分子”，决不能跟着土豪劣绅的口白，笼统地骂“痞子”。要解决这“少数不良分子”的问题，也只能在农会整顿纪律的口号之下，对群众做宣传，对他们本人进行训练，把农会的纪律整好，决不能随便派兵捉人，损害贫农阶级的威信，助长土豪劣绅的气势。这一点是非常要注意的。\n\n要充分相信青年人，绝大多数是会胜任的。个别人可能不称职，也不用怕，以后可以改选掉。这样做，基本方向是不会错的。\n注重调查研究而后有解决方案你对于那个问题不能解决吗？那末，你就去调查那个问题的现状和它的历史吧！你完完全全调查明白了，你对那个问题就有解决的办法了。一切结论产生于调查情况的末尾，而不是在它的先头。只有蠢人，才是他一个人，或者邀集一堆人，不作调查，而只是冥思苦索地“想办法”，“打主意”。须知这是一定不能想出什么好办法，打出什么好主意的。换一句话说，他一定要产生错办法和错主意。\n\n调查就像“十月怀胎”，解决问题就像“一朝分娩”。\n\n对于国内和国际的政治、军事、经济、文化的任何一方面，我们所收集的材料还是零碎的，我们的研究工作还是没有系统的。二十年来，一般地说，我们并没有对于上述各方面作过系统的周密的收集材料加以研究的工作，缺乏调查研究客观实际状况的浓厚空气。“闭塞眼睛捉麻雀”，“瞎子摸鱼”，粗枝大叶，夸夸其谈，满足于一知半解，这种极坏的作风，这种完全违反马克思列宁主义基本精神的作风，还在我党许多同志中继续存在着。\n不要盲从我们说上级领导机关的指示是正确的，决不单是因为它出于“上级领导机关”，而是因为它的内容是适合于斗争中客观和主观情势的，是斗争所需要的。\n\n我们说马克思主义是对的，决不是因为马克思这个人是什么“先哲”，而是因为他的理论，在我们的实践中，在我们的斗争中，证明了是对的。\n\n马克思说的武装起义之后一刻也不应该停止进攻，这是说乘敌不备而突然起义的群众，应该不让反动的统治者有保守政权或恢复政权的机会，趁此一瞬间把国内反动的统治势力打个措手不及，而不要满足于已得的胜利，轻视敌人，放松对于敌人的进攻，或者畏缩不前，坐失消灭敌人的时机，招致革命的失败。这是正确的。然而不是说，敌我双方已在军事对抗中，而且敌人是优势，当受敌人压迫时，革命党人也不应该采取防御手段。如果这样想，那就是第一号的傻子。\n\n不要迷信。中国人也好，外国人也好，死人也好，活人也好，对的就是对的，不对的就是不对的，不然就叫做迷信。要破除迷信。不论古代的也好，现代的也好，正确的就信，不正确的就不信，不仅不信而且还要批评。这才是科学的态度。\n注重工作细节每到一处，壁上写满了口号。惟缺绘图的技术人材，请中央和两省委送几个来。\n\n大家要努力去发展农业和手工业的生产，多造农具，多产石灰，使明年的收获增多，恢复钨砂、木头、樟脑、纸张、烟叶、夏布、香菇、薄荷油等特产过去的产量，并把它们大批地输出到白区去。\n\n我郑重地向大会提出，我们应该深刻地注意群众生活的问题，从土地、劳动问题，到柴米油盐问题。妇女群众要学习犁耙，找什么人去教她们呢？小孩子要求读书，小学办起了没有呢？对面的木桥太小会跌倒行人，要不要修理一下呢？许多人生疮害病，想个什么办法呢？一切这些群众生活上的问题，都应该把它提到自己的议事日程上。\n不要用静态的眼光看问题革命的道路，同世界上一切事物活动的道路一样，总是曲折的，不是笔直的。革命和反革命的阵线可能变动，也同世界上一切事物的可能变动一样。\n\n国民党营垒中，在民族危机到了严重关头的时候，是要发生破裂的。\n\n日本是小国，地小、物少、人少、兵少，中国是大国，地大、物博、人多、兵多这一个条件，于是在强弱对比之外，就还有小国、退步、寡助和大国、进步、多助的对比，这就是中国决不会亡的根据。强弱对比虽然规定了日本能够在中国有一定时期和一定程度的横行，中国不可避免地要走一段艰难的路程，抗日战争是持久战而不是速决战；然而小国、退步、寡助和大国、进步、多助的对比，又规定了日本不能横行到底，必然要遭到最后的失败，中国决不会亡，必然要取得最后的胜利。\n先行动起来革命战争是民众的事，常常不是先学好了再干，而是干起来再学习，干就是学习。\n批判的学习对于外国文化，排外主义的方针是错误的，应当尽量吸收进步的外国文化，以为发展中国新文化的借镜；盲目搬用的方针也是错误的，应当以中国人民的实际需要为基础，批判地吸收外国文化。苏联所创造的新文化，应当成为我们建设人民文化的范例。对于中国古代文化，同样，既不是一概排斥，也不是盲目搬用，而是批判地接收它，以利于推进中国的新文化。\n\n后起而且发展得很快的帝国主义国家，即德日两国的军事家中，积极地鼓吹战略进攻的利益，反对战略防御。这种思想，是根本不合于中国革命战争的。德日帝国主义的军事家们指出防御的一个重要的弱点是不能振奋人心，反而使人心动摇。这是说的阶级矛盾剧烈，而战争的利益仅仅属于反动的统治阶层乃至反动的当权政派的那种国家。我们的情况不同。在保卫革命根据地和保卫中国的口号下，我们能够团结最大多数人民万众一心地作战\n不耻下问，兼听则明其中还有些问题没有弄清楚，需要先征求下级的意见。我们切不可强不知以为知，要“不耻下问”[2]，要善于倾听下面干部的意见。先做学生，然后再做先生；先向下面干部请教，然后再下命令。\n\n你们对上述计划意见如何？这个计划有何缺点？执行有何困难？统望考虑电告。\n\n像卫立煌、翁文灏这样的有爱国心的国民党军政人员，我们应当继续调动他们的积极性。就是那些骂我们的，像龙云、梁漱溟、彭一湖之类，我们也要养起来，让他们骂，骂得无理，我们反驳，骂得有理，我们接受。这对党，对人民，对社会主义比较有利。\n定量分析胸中有“数”。这是说，对情况和问题一定要注意到它们的数量方面，要有基本的数量的分析。任何质量都表现为一定的数量，没有数量也就没有质量。我们有许多同志至今不懂得注意事物的数量方面，不懂得注意基本的统计、主要的百分比，不懂得注意决定事物质量的数量界限，一切都是胸中无“数”，结果就不能不犯错误。\n分清屁股（立场）十月革命推翻了资产阶级，这在世界上是个新鲜事情。对这个革命，国际资产阶级不管三七二十一，骂的多，总是说不好。俄国资产阶级是个反革命阶级，那个时候，国家资本主义这一套他不干，他怠工，破坏，拿起枪来打。俄国无产阶级没有别的办法，只好干掉他。这就惹火了各国资产阶级，他们就骂人。我们这里对待民族资产阶级比较缓和一点，他就舒服一点，觉得还有些好处。现在艾森豪威尔威尔、杜勒斯不让美国的新闻记者到中国来，实际上就是承认我们的政策有这个好处。如果我们这里是一塌糊涂，他们就会放那些人来，横直是写骂人文章。他们就是怕写出来的文章不专门骂人，还讲一点好话，那个事情就不好办。\n\n江苏作了一个调查，有的地区，县区乡三级干部中间，有百分之三十的人替农民叫苦。后头一查，这些替农民叫苦的人，大多数是家里比较富裕，有余粮出卖的人。这些人的所谓“苦”，就是有余粮。所谓“帮助农民”、“关心农民”，就是有余粮不要卖给国家。这些叫苦的人到底代表谁呢？他们不是代表广大农民群众，而是代表少数富裕农民。\n\n“人性论”。有没有人性这种东西？当然有的。但是只有具体的人性，没有抽象的人性。在阶级社会里就是只有带着阶级性的人性，而没有什么超阶级的人性。我们主张无产阶级的人性，人民大众的人性，而地主阶级资产阶级则主张地主阶级资产阶级的人性，不过他们口头上不这样说，却说成为唯一的人性。有些小资产阶级知识分子所鼓吹的人性，也是脱离人民大众或者反对人民大众的，他们的所谓人性实质上不过是资产阶级的个人主义，因此在他们眼中，无产阶级的人性就不合于人性。现在延安有些人们所主张的作为所谓文艺理论基础的“人性论”，就是这样讲，这是完全错误的。\n\n对于革命的文艺家，暴露的对象，只能是侵略者、剥削者、压迫者及其在人民中所遗留的恶劣影响，而不能是人民大众。人民大众也是有缺点的，这些缺点应当用人民内部的批评和自我批评来克服，而进行这种批评和自我批评也是文艺的最重要任务之一。但这不应该说是什么“暴露人民”。对于人民，基本上是一个教育和提高他们的问题。\n事物的两面性把毒草，把非马克思主义和反马克思主义的东西，摆在我们同志面前，摆在人民群众和民主人士面前，让他们受到锻炼。不要封锁起来，封锁起来反而危险。这一条我们跟苏联的做法不同。为什么要种牛痘？就是人为地把一种病毒放到人体里面去，实行“细菌战”，跟你作斗争，使你的身体里头产生一种免疫力。\n\n日本国度比较地小，其人力、军力、财力、物力均感缺乏，经不起长期的战争。日本统治者想从战争中解决这个困难问题，但同样，将达到其所期求的反面，这就是说，它为解决这个困难问题而发动战争，结果将因战争而增加困难，战争将连它原有的东西也消耗掉。\n\n国民党是一个复杂的政党。它虽被这个代表大地主、大银行家、大买办阶层的反动集团所统治，所领导，却并不整个儿等于这个反动集团。它有一部分领袖人物不属于这个集团，而且被这个集团所打击、排斥或轻视。它有不少的干部、党员群众和三民主义青年团的团员群众并不满意这个集团的领导，而且有些甚至是反对它的领导的。\n\n坏事也算一种经验，也有很大的作用。我们就有陈独秀、李立三、王明、张国焘、高岗、饶漱石这些人，他们是我们的教员。此外，我们还有别的教员。在国内来说，最好的教员是蒋介石。我们说不服的人，蒋介石一教，就说得服了。蒋介石用什么办法来教呢？他是用机关枪、大炮、飞机来教。还有帝国主义这个教员，它教育了我们六亿人民。一百多年来，几个帝国主义强国压迫我们，教育了我们。所以，坏事有个教育作用，有个借鉴作用。\n\n军队的生产自给，在我们的条件下，形式上是落后的、倒退的，实质上是进步的，具有重大历史意义的。在形式上，我们违背了分工的原则。但是，在我们的条件下——国家贫困、国家分裂（这些都是国民党主要统治集团所造成的罪恶结果）以及分散的长期的人民游击战争，我们这样做，就是进步的了。大家看，国民党的军队面黄肌瘦，解放区的军队身强力壮。大家看，我们自己，在没有生产自给的时候，何等困难，一经生产自给，何等舒服。\n\n\n\n\n","tags":["读书","marx"]},{"title":"被诅咒的与被祝福的","url":"/blog/2019/06/20/zxz-swd/","content":"身陷南洋囹圄，心系故园风物，无以聊赖之中，撰文权作慰藉。\n从Neal Ford的一段话讲开去前段时间看了Neal Ford的一个演讲，原视频\n其中一段讲到了传统工程与软件工程的区别。\n於我心甚有戚戚焉。\n译如下：\n\n软件工程和传统工程是截然不同的。\n\n\n在传统工程的世界中，当你进入施工阶段时，你基本上是在给原子塑形，原子结构是很难重构的。一旦你将它们塑造成特定的形状，它们往往会保持这种形状，很难将它们变成其他形状。除非你熔化它们再回炉重造。因此，制造物理物品是一个非常昂贵的过程。这就意味着，我们会希望在施工开始之前正确做出设计。\n\n\n但在软件世界中，我们不是在铸造原子。我们在比特（bit）的世界里，这些比特（bit）都非常具有可塑性。对比特（bit）进行更改非常容易。我们来比较一下，传统工程中有施工，软件世界中与之对应的是什么呢？那就是是编译和部署。编译和部署实际上是我们所设计的东西在现实世界中的表征，电子沿导电线路移动，对现实世界施加影响力。这就表明，对于我们软件世界而言，我们的设计蓝图就是我们的源代码。\n\n\n在传统工程业中，最昂贵的部分是施工阶段。在桥梁和其他种类的物理制造中存在许多预测性数学，这样做的原因并不是为了获得更安全的结构，虽说它在客观上确实会达成这一点。初衷其实是为了节约成本。造完了一座桥梁，然后让重物碾压过去，观察桥梁是否会崩塌，从而来确认桥梁质量达标与否，这样做，万一垮塌了，这成本就实在是太昂贵了。所以你需要可预测性，因为制造这些东西太贵了。\n\n\n但在软件世界中，因为施工过程对应的是编译和部署，所以改变的成本非常低，可以随时进行。我们甚至不必为此操心，每当我们停止打字时，我们的计算机内都会涌现出一小群精灵把我们设计的东西给制造出来，以便我们能够以一种逼真的方式对其进行测试。\n\n\n所以Reeves先生说，“鉴于软件设计相对容易并且基本上可以免费构建，一个不足为奇的启示是，软件设计往往非常庞大和复杂。”\n\n\n我相信软件是现在人类思维创造出来的最复杂的东西，有几个原因导致它们如此复杂，其中一个原因是物理世界中存在许多有用的约束，而软件的世界中这样的约束太少。\n\n\n蓝图设计对应源码编写，建造施工对应编译部署，这着实有趣。\n我们使用建筑这个隐喻来关照软件的时候，通常都是把架构设计对照到蓝图上去，而把源码编写对照到建造施工上去。\n而Neal Ford不是这样使用建筑隐喻的。\n\n可以看出来，Neal Ford这个隐喻在落地程度上更进一层。\n牛老爵爷的诅咒Neal Ford这段话的内容非常丰富。\n除了上述隐喻之外，还有桥梁不能像软件一样测试，软件如此复杂的原因是我们缺乏真实世界中的物理限制。\n诚哉斯言，与土木工程师比起来，我们软件工程师确实是具有非常奢侈的环境。这个代码怎样？跑跑测试就知道了。\n能想象土木工程师说这种话吗？\n老板娘: 那栋楼设计搞的怎么样了？有没有仔细的检查过？\n工程师: 我觉得没问题，直接施工建造出来看看就好了。\n老板娘: 好，我相信你，既然你这么有信心，那就来吧。\n\n\n工程师: 😳 😳 😳\n老板娘: 请问您信心的来源是啥？有依据吗？你这么乱搞，我得陪多少钱？\n工程师: 这是个小工程，有点粗心了。另一个，那个大桥的项目，我一定用心！\n\n老板娘: 合龙这部分，你是不是忘了设计喜鹊了？你打算让牛郎织女自己组成一个平行四边形吗？\n工程师: 卒\n老板娘: 破产\n一旦发现失误，拆掉重造太贵，土木工程师没法像我们软件工程师一样动不动就跑测试，动不动就debug，只能事先把设计做好。\n不过，也正是由于牛顿老爵爷设下了诅咒，土木工程师被逼练就了严谨的作风，扎实的推算能力。\n（此处用牛老爵爷代表包括麦克斯韦在内的诸多先贤）\n蛮荒西部 牛顿管不了 图灵没来得及立法牛爷的诅咒持久而坚固，不过，还是有它管不到的法外之地。\n引力，电磁力，强力，弱力，你们能耐程序员何？程序员就是要任性地玩弄bits。\n祖师爷死得早，一口苹果啃完，留待我等程序员飘零纵欲至今。\n福兮？祸兮？\nRobert C. Martin：还是要设立并遵守基本法无独有偶。最近看了《架构整洁之道》这本书。作者Robert C. Martin讲述了编程范式的发展历史，字里行间表达了与Neal Ford颇为神似的一些观点。\n摘抄如下：\n\n结构化编程是第一个普遍被采用的编程范式（但是却不是第一个被提出的），由Edsger Wybe Dijkstra于1968年最先提出。与此同时，Dijkstra还论证了使用goto这样的无限制跳转语句将会损害程序的整体结构。接下来的章节我们还会说到，也是这位Dijkstra最先主张用我们现在熟知的if&#x2F;then&#x2F;else语句和do&#x2F;while&#x2F;until语句来代替跳转语句的。我们可以将结构化编程范式归结为一句话：结构化编程对程序控制权的直接转移进行了限制和规范。\n\n\n面向对象编程对程序控制权的间接转移进行了限制和规范。\n\n\n函数式编程对程序中的赋值进行了限制和规范。\n\n\n它们都从某一方面限制和规范了程序员的能力。没有一个范式是增加新能力的。也就是说，每个编程范式的目的都是设置限制。这些范式主要是为了告诉我们不能做什么，而不是可以做什么。\n\n\n这三个编程范式分别限制了goto语句、函数指针和赋值语句的使用。那么除此之外，还有什么可以去除的吗\n\n\n这些编程范式的历史知识与软件架构有关系吗？当然有，而且关系相当密切。譬如说，多态是我们跨越架构边界的手段，函数式编程是我们规范和限制数据存放位置与访问权限的手段，结构化编程则是各模块的算法实现基础。这和软件架构的三大关注重点不谋而合：功能性、组件独立性以及数据管理。\n\n\n原文的意思非常明白，Structured programming，OO，FP都是在约束我们作为程序员的行为，给我们立下基本法，免得我们瞎搞。\nNeal Ford: 自然界的物理定律是个好东西啊，可以限制土木工程师，让他们无法乱搞。我们软件世界里缺的就是这个。\nRobert C. Martin: 老弟所言甚是。缺少自然的馈赠，我们就搞人为的规约。诸多编程范式都已经尝试过做这件事了。天不立法人立法。\n张信哲表示同意张信哲：你俩说的对，自由是个好东西，但是不能《过火》，免得过犹不及。\n\n工程师之荣光 演绎 归纳\n人类99%的机率都在使用归纳法，只有1%的机率使用演绎法因为演绎法需要消耗认知能量，所以默认使用归纳法。\n\n土木工程师要仰仗演绎推理，这是理工科之荣光。\n此乃吾辈偏执之骄傲。\n怎奈沦落为软件工程师，我们要重度依赖归纳才能勉强维持生活这样子。\n代码有问题？跑一跑tests，改一改。还不行？再改改，再跑跑。仍然不行？那我可要debug了！！！\n反复利用run tests和debug的方式来观察现象，收集现象，总结现象，反推原理。\n这是软件工程师在脑力不断失败的绝望中不断降低自己身段的慷慨悲歌。\n福兮？祸兮？\n测试要先写 别着急跑 debug不到万不得已最好别用为了保护我们宝贵的智商与荣光，在此作出如下建议。\n测试写完，然后去写实现代码的时候要尽力去争取一遍过。\n在试图用run test去验证刚刚写完的实现代码之前，别着急，可以先回头把代码捋一遍，用肉脑跑一遍先。\n不到万不得已，别用debug。因为一旦你开始debug，就是认输了，认怂了。承认无法通过肉脑来演绎推理明白了。\n不要过于骄纵，不要过量服用软件世界给我们的自由，多给自己一些人为设置的限制，向土木工程师看齐。\n没想到吧？前面写的神神叨叨，最后来到了如此接地气的建议上。\n别误会 不是那个意思不是宣扬big upfront design。\n不是反对short feedback loop。\n不是反对跑测试，只是建议别着急跑，不要太过依赖跑测试，优先用肉脑，然后才跑测试。\n不是否认debug的价值，只是希望大家尽力放慢做出要去debug的决定的速度，让子弹飞一会，给肉脑机会，让它跑一会。\n不是否认归纳的价值，只是建议演绎与归纳不可偏废，不要过度依赖归纳而冷落演绎。\n\n谨以此文与诸君共勉。For the serious hardcore programmers。\n\n\n\n\n","tags":["Uncle Bob"]},{"title":"[译] FP vs OO","url":"/blog/2019/11/03/fp-vs-oo/","content":"原文地址：https://blog.cleancoder.com/uncle-bob/2018/04/13/FPvsOO.html\n原作者：Robert C. Martin (Uncle Bob)\n在过去的几年中，我通过与人结对来学习函数式编程，他们中的很多人表达了反对OO的偏见。他们经常会说：“啊，这太像对象了。”\n他们会这样说是因为他们认为FP和OO在某种程度上是互斥的。许多人似乎认为程序FP的程度等同于其非OO的程度。我认为这种观点是学习新事物的自然结果。\n当我们采用一种新技术时，我们通常倾向于避开以前使用的旧技术。这很自然，因为我们认为新技术“更好”，因此旧技术就一定是“更糟”的。\n在此博客中，我将说明OO和FP是正交的，但它们并不互斥。一个好的函数式程序可以（并且应该）是面向对象的。而且一个好的面向对象程序可以（并且应该）是函数式的。在此之前，我们必须非常谨慎地给FP和OO这两个词语下个定义。\n什么是OO？我将在这里采取非常还原主义的立场。OO有许多有效的定义，涵盖了丰富的概念，原理，技术，模式和哲学。在这里，我将忽略所有这些内容，而将重点放在最基础的东西上。我采取这种还原主义的原因是，很多围绕着OO的丰富特性实际上根本不是OO所特有的，而是整体软件开发丰富性的一部分。在这里，我将重点介绍面向对象不可分割的那部分。\n看看以下两个表达式：\n1：f(o);2：o.f();\n\n有什么区别？\n显然，没有实际的语义差异。差异完全在语法上。但是一个看起来是FP的，另一个看起来是OO的。这是因为我们会推断表达式2具有特殊的语义行为，同时我们推断表达式1不具有这种特殊语义行为。这种特殊语义行为就是：多态性。\n当我们看到表达式1时，我们看到名为f的函数被应用在了o上。我们推断只有一个名为f的函数，并且它可能不是围绕着o的标准函数中的一员。\n另一方面，当我们看到表达式2时，我们看到一个名为f的消息被发送给了一个名为o的对象。我们推测可能还有其他类型的对象可以接受该消息f，因此我们不知道被调用的f具体是哪一个。其行为取决于o的类型，即f是多态的。\n对多态性的这种预期是OO编程的本质。这是还原论的定义；它与OO密不可分。没有多态性的OO不是OO。OO的所有其他属性，例如封装的数据，绑定到该数据的方法，甚至继承，与表达式1的关系要比与表达式2的关系更多。\nC和Pascal程序员（甚至在某种程度上甚至包括Fortran和Cobol程序员）都创建了包含封装函数和数据结构的系统。要创建和使用这种封装的结构并不一定非得需要OO语言。封装，甚至简单的继承，在此类语言中都是显而易见且自然的。（在C和Pascal中比其他更自然。）\n因此，真正将OO程序与非OO程序区分开的是多态性。\n您可能会说可以通过在f内部使用switch语句或if&#x2F;else来实现多态。的确如此，因此我必须向OO添加一个约束。\n\n多态机制一定不能创建从调用方到被调用方的源码依赖关系。\n\n为了解释这一点，请再次看看上文的两个表达式。表达式1：f(o)似乎对f函数的源码有依赖。我们之所以如此推断是因为我们推断只有一个f，所以调用者必须认识被调用者。\n但是，当我们看表达式2时，从o.f()我们推断出一些不同的东西。我们知道可能会有很多个f的实现，而且我们不知道真正要被调用到的是其中哪个。因此表达式2对于f函数的源码没有依赖。\n具体来说，这意味着包含对函数进行多态调用的模块（源文件）绝对不能以任何方式引用包含这些函数实现的模块（源文件）。不可以有任何include或use或require或任何其它这样的声明使得一个源文件依赖另一个。\n因此，我们对OO的简化定义是：\n\n调用者的源码对于被调用者的源码不产生依赖的一种动态多态技巧。\n\n什么是FP？同样，我将采用还原主义。FP具有悠久的历史和传统，可追溯到软件之外的其他领域。FP范式里存在很多原理，技术，定理，哲学和概念。我将忽略所有这些内容，直接进入将FP与任何其他范式区分开的不可分割的属性。简而言之，就是：\n当 a==b 时 f(a)==f(b)\n\n在函数式程序中，每次调用同一个函数并给出同一个参数时，都会得到相同的结果。无论程序执行了多长时间。这叫做引用透明性。\n这意味着函数f不可以更改任何影响函数f行为方式的全局状态。而且，如果我们说函数f可以代表系统中的所有函数 – 系统中的所有函数都必须是引用透明的 – 那么系统中的任何函数都无法改变任何全局状态。系统中的任何函数都无法执行任何操作，来导致系统中的另一个函数对相同的输入返回不同的值。\n其更深的含义是，任何命名值都无法更改。也就是说，不能有赋值运算符。\n现在，如果您仔细地考虑一下，您可能会得出这样的结论：仅由引用透明的函数组成的程序根本无法执行任何操作-因为任何有用的系统行为都会改变某些事物的状态。即使只是打印机或显示器的状态。但是，如果我们从引用透明性约束中排除硬件以及外界的任何元素，那么事实证明我们确实可以创建非常有用的系统。\n诀窍当然是递归。考虑一个以state数据结构作为参数的函数。此参数包含函数工作需要的所有状态信息。该函数将创建一个新的state，里面包含更新过的值。该函数做的最后一件事就是调用它自己并把新的state作为参数传递进去。\n这是函数式程序可以用来跟踪内部状态的变化而无需真正改变任何内部状态的简单技巧之一。\n因此，函数式编程的简化定义为：\n\n引用透明 – 没有重新赋值。\n\nFP vs OO现在OO和FP社区都要向我开炮了。还原主义不是赢得朋友的好方法。但这有时很有用。我认为有必要在似乎正在传播的FP vs OO的迷因上说两句。\n显然，我选择的两个归约定义是完全正交的。多态和引用透明之间没有任何关系。它们之间没有交集。\n但是正交并不意味着相互排斥（问问麦克斯韦就知道了）。建立同时使用动态多态性和引用透明性的系统是完全可能的。不仅可能，而且是可取的！\n为什么是可取的？二者各自独立可取，合一仍可取！我们希望系统具有动态多态性，为了解耦。依赖关系可以跨架构边界反转。可以使用Mocks and Fakes和其他类型的Test Doubles进行测试。可以在不强制更改其他模块的情况下修改模块。这使得系统更易于更改和改进。\n我们还希望系统具有引用透明性，为了可预测性。无法更改内部状态使系统更易于理解，更改和改进。它大大减少了竞态和其他并发更新问题的机会。\n底线是：\n没有FP vs OO。\nFP和OO可以很好地合作。这两个属性都是现代系统所希望具有的。同时基于OO和FP原理构建的系统将最大限度地提高灵活性，可维护性，可测试性，简单性和健壮性。排斥一个赞成另一个只会削弱系统的结构。\n\n\n\n\n","tags":["Uncle Bob"]},{"title":"「译」大规模敏捷","url":"/blog/2019/12/06/in-the-large/","content":"原文地址： https://blog.cleancoder.com/uncle-bob/2018/04/02/InTheLarge.html\n原作者：Robert C. Martin (Uncle Bob)\n自敏捷之开端始，我们就思考大规模敏捷的问题。我们是否能够把轻量级，迭代，增量，快速反馈等软件开发的原理应用于规模巨大的项目呢？\n最初我们想到的答案是Scrum of Scrums之类的东西。这个想法是在更高的层次上递归地应用敏捷开发的原理。如果一个项目需要超过5-12个开发人员，那么可以组织两个这样的团队，以及一个更高级别的团队来“监督？”他们。\n请注意上面的问号。当我们开始考虑大型项目时，我们不可避免地要谈及层级化的组织。但是敏捷似乎是厌恶组织层级的。毕竟，敏捷就是关于平等主义的。敏捷是拒绝命令和控制的。敏捷是拒绝计划和时间表的，还有…\n无稽之谈！并不是这样的！\n敏捷其实是一场“风水轮流转”的革命。在软件行业的早期，我们原本就以敏捷的方式编写代码。我们写小块代码片段，对其进行了测试，将它们构建为更大的块，如此循环往复。如果您回到1960年代后期，并观察当时人们编写代码的方式，您会发现敏捷的小荷尖尖角正在显露出来。\n当然，当时我们在硬件方面受到了很大的限制。编译要跑好几个小时。代码编辑要用电传打字机。那时，大多数程序员根本不会使用键盘。因此他们让按键操作员替他们输入代码。在这种环境下，很难实现快速反馈机制。\n即便如此，我们仍竭尽所能去缩短反馈周期。我们使用汇编器编写程序，坐在控制台前通过用八进制或十六进制打补丁的方式来进行调试。我们可以通过在调试器中执行代码，甚至通过单步执行来测试代码。经年累月，熟能生巧。这是在合理的时间内完成工作的唯一方法。\n但是“风水轮流转”了。我们开始使用在控制台上不容易调试的语言。我们开始编写越来越大的程序。为了在反馈周期如此长的环境中工作，我们需要制定计划。\n瀑布就在这样的环境中诞生了出来。当编辑,编译,测试的循环周期需要一整天的时候，我们需要进行大量的计划和检查。在24小时的循环周期内做TDD和重构是不现实的！\n但是“风水”一直在转动。今天的大多数程序员都没有深切体会到摩尔定律的指数发展。我们从1970年的24小时循环周期，到1980年的60分钟循环周期，到1990年的十分钟循环周期，再到2000年的10秒循环周期。到2005年，大多数程序员的循环周期不到1秒。\n敏捷就在这样的环境中诞生了出来。敏捷是对1960年代快速周转，高频反馈开发策略的一种历史回归，不过这次我们有了更强大的机器，更强大的语言和工具以及更大规模的项目。\n敏捷也可以说是从历史的灰烬中浴火重生而来的。瀑布虽然在70年代和80年代是很有必要的，但却令人非常痛苦。在那几十年中，我们学会了哪些事情是不该做的。因此，当敏捷在90年代末出现时，它也承载着之前那段黑暗时期所积累的教训。\n敏捷却也不仅仅是对短反馈周期的历史回归。敏捷在短反馈周期的基础之上增强了纪律。诸如测试，重构，结对编程和高度自动化之类的实践。敏捷确实让我们从六十年代的策略中前进了。\n不过前进的方向是什么？敏捷革命改进了什么？\n敏捷革命关注的是相对较小的团队如何开发相对较小的软件项目。请注意，我强调了“小”这个字。\n敏捷团队擅长于创建十万行左右的软件系统。十万行已经可以做很多事情了。对于许多公司而言，一两个敏捷团队足以满足他们。\n另一方面，如果您需要创建一个千万行代码的系统，那么一个敏捷团队就不够了。您需要大约一百个团队来构建千万代码行级别的系统。\n但是，您如何管理一百个敏捷团队？您如何给他们提供用户故事？您如何协调它们之间的接口？您如何在那千万行代码中创造边界而让团队可以彼此独立工作？\n以及您如何以“敏捷”的方式做到这一点？ （这才是真正的问题）\n答案是：你不能！\n我们人类非常擅长于建设大型项目。长久以来我们就知道如何做这件事。\n\n想想我们人类完成过的真正巨大的项目吧。\n\n阿波罗登月：我们把人送到月球上！\n诺曼底战役：我们在50英里坚固的防线上，以156000名士兵入侵了诺曼底。\n我们拥有支持80亿人口的世界经济。\n全球各地都有庞大的网络，您可以在树林里徒步时在手机上读这篇文章！\n你要买东西吗？按几下手机，明天甚至今天就会有人来送快递。\n我们将红色跑车驶入了太阳轨道。\n\n应该不用说更多例子了。我们人类确实非常擅长做大事。\n那为什么我们对大型软件会有所忧虑呢？我们已经知道如何构建大型软件了。我们已经这样做了50多年或更久了。“大”的部分实际上从来不是问题所在。我们用敏捷解决的问题是关于“小”的那部分。我们之前不知道如何搞定的，是做小型项目。\n我们一直都知道如何做大型项目。那就是分而治之。敏捷解决了其中“小”的那一部分。敏捷与“大”的部分无关。\n但是，但是，但是，但是……平等主义！拒绝计划和命令与控制！敏捷！\n无稽之谈！\n敏捷不是平等主义。敏捷不是拒绝计划，也不是拒绝命令和控制。事实上，敏捷是命令和控制体系中最小单元的体现：战术小队。\n是的，在层级结构的末端，命令和控制不再有效。一小组人可以通过大量反馈和激烈的沟通在较短的周期内工作，以实现目标。这就是一支敏捷的团队。在这个级别上，严格的命令和控制是极为有害的。但是在此级别之上，命令和控制就变得有必要了。在层级上越往上走，这种效应就越明显。没有大量的命令和控制，就无法设计，建造，生产和销售数以亿部的iPhone。\n市场上有很多种大规模敏捷的玩法。有关该主题的书籍和博客也有很多。也有人成立了咨询公司，专门为大公司做大规模敏捷的转型。这没有什么不好的。\n这些大规模敏捷方法所讲的策略和技术都没有错。只不过，它们不是敏捷的。它们与敏捷无关。它们是在人类几千年来用于完成重大工作的策略和技术的基础上加了点敏捷的“味道”。\n这点味道来自敏捷使用的词汇和概念。增添些口味没有错–没问题。如果您喜欢使用敏捷中的词语和概念，那就尽管去用。但是不要过分关注它的“敏捷性”。一旦你要做大规模的事情，就离开了敏捷的领域。希望您的各个开发小组正在使用敏捷；但是整个大规模项目并不是敏捷的。\n因为敏捷是专注于做”小“事情的。\n\n\n\n\n","tags":["Uncle Bob"]},{"title":"Future-异步函数的两个视角","url":"/blog/2019/12/29/future-from-two-perspectives/","content":"我们来一起看一下两个程序员之间的故事。\n以下示例代码是用Scala写的，不过本文所讲的话题并不仅限于Scala，任何有Future&#x2F;Promise支持的语言都是适用的。下面这个wiki页面罗列了各个有Future&#x2F;Promise支持的语言，已经涵盖了大多数的常用语言。Future与promise实现列表\n我是异步函数的编写者我写了两个异步函数,来提供给其他程序员同事使用。\ntype CallBack = Try[String] =&gt; Unitdef pretendCallAPI(callBack: CallBack, okMsg: String, failedMsg: String) = &#123;  val task = new TimerTask &#123;    override def run() = &#123;      val percentage = Random.between(1, 100)      if (percentage &gt;= 50)        callBack(Success(okMsg))      else if (percentage &lt;= 30)        callBack(Failure(new Exception(failedMsg)))      else        callBack(Failure(new Exception(&quot;network problem&quot;)))    &#125;  &#125;  new Timer().schedule(task, Random.between(200, 500))&#125;val searchTB = pretendCallAPI(_, &quot;product price found&quot;, &quot;product not listed&quot;)val buyFromTB = pretendCallAPI(_, &quot;product bought&quot;, &quot;can not buy, no money left&quot;)\n\n这两个异步函数: searchTB用来从淘宝搜索物品,另一个buyFromTB用来购买搜到的物品。\n由于仅仅是为了演示而写的,他们两个都是基于一个叫做pretendCallAPI的函数实现的。顾名思义,pretendCallAPI并不会真的去调用淘宝的API,而只是模拟API的行为。\n这个pretendCallAPI函数有几个行为特征:\n\n每次耗时200到500毫秒之间\n每次执行有50%的几率成功\n20%的几率遇到网络故障\n另外30%的几率虽然网络没问题但是服务器会给你一个非正常的结果\n\n当然,由于我写的是异步算法,需要避免block caller thread。所以当你调用pretendCallAPI的时候,这个函数是瞬间立即返回的。那么当然我就无法在函数返回的时候return什么有用的东西给你了。\n如果你想知道执行的结果到底是啥,你需要传给我一个CallBack,在我执行完后,通过CallBack来告知你执行的结果。这个CallBack的完整签名表达式展开是Try[String] =&gt; Unit\n大家看searchTB和buyFromTB可能觉得他们长的有点奇怪,这是Scala里柯里化的写法。也就是通过把pretendCallAPI包一层来构造新的函数,锁死两个参数,剩下的一个参数(也就是CallBack)就变成了新构造出来的函数的唯一参数了。也就是说searchTB和buyFromTB的签名是(Try[String] =&gt; Unit) =&gt; Unit。\n关于柯里化这个语言特性的更多信息:https://cuipengfei.me/blog/2013/12/25/desugar-scala-6/\n好了,现在这两个函数可以提供给大家使用了。\n我是异步函数的调用者听说异步函数已经写好了,我终于可以用他们来实现剁手业务了。\n听函数作者讲了一下,用起来应该不会很难,那我来实现一下吧。\ndef searchPriceThenBuy() = &#123;  searchTB &#123;    case Success(searchMsg) =&gt;      println(searchMsg)      buyFromTB &#123;        case Success(buyMsg) =&gt; println(buyMsg)        case Failure(err) =&gt; println(err.getMessage)      &#125;    case Failure(err) =&gt; println(err.getMessage)  &#125;&#125;\n\n使用searchTB和buyFromTB并不难. 他们两个都是接受CallBack作为参数的函数。CallBack本身是个函数,它的签名是Try[String] =&gt; Unit。而Try有两种形式,分别是Success和Failure。\n所以在调用searchTB和buyFromTB的时候,必须把两个分支都给到(以免pattern match不到)。这样在异步函数有结果的时候(无论成败)才能call back过来到我的代码,以便我能够在合适的时机做后续的处理(无论是基于成功做后续业务,还是做error handling)。\n关于pattern match,可以参考这里:https://cuipengfei.me/blog/2013/12/29/desugar-scala-8/https://cuipengfei.me/blog/2015/06/16/visitor-pattern-pattern-match/\n这段代码跑一下的话,会有这么几种结果:\n\n搜到了,也买到了\n搜到了,购买时遇到了网络故障\n搜到了,由于支付宝钱不够而没买到\n没搜到,购买行为未触发\n搜索遇到网络故障,购买行为未触发\n\n一共就这么几种可能,因为pretendCallAPI是跑概率的,多跑几次这些情况都能遇到。\n虽然实现出来不难,执行结果也没问题,但是总有点隐忧。\n这里只有searchTB和buyFromTB两个函数,如果其他场景下我需要把更多的异步函数组合起来使用呢?岂不是要缩进很多层?\n当然,缩进只是个视觉审美问题,是个表象,不是特别要紧.关键是我的业务逻辑很容易被这样的代码给割裂的鸡零狗碎,那就不好了。我要给上游编写异步函数的同事反馈一下，看是否有办法解决这个问题。\n镜头切回到异步函数编写者之前写的两个函数反馈不太好，主要是因为同事们认为使用CallBack不是最优的方式。这个反馈确实很中肯，如果只有一个异步函数单独使用，用CallBack也没什么太大的问题，如果是很多个异步函数组合使用确实会形成多层嵌套的问题。我作为上游程序员，确实需要更多地为下游调用者考虑。\n既然如此，那我改版一下，免除掉让下游使用CallBack的必要性。\ntype CallBackBasedFunction = (CallBack) =&gt; Unitdef futurize(f: CallBackBasedFunction) = () =&gt; &#123;  val promise = Promise[String]()  f &#123;    case Success(msg) =&gt; promise.success(msg)    case Failure(err) =&gt; promise.failure(err)  &#125;  promise.future&#125;val searchTBFutureVersion = futurize(searchTB)val buyFromTBFutureVersion = futurize(buyFromTB)\n\n先定义一个CallBackBasedFunction，它代表一个接受CallBack为参数的函数的签名。\n表达式展开后就是：　(Try[String] =&gt; Unit) =&gt; Unit这就符合了searchTB和buyFromTB两个函数的签名。\nfuturize算是个higher order function,它接受一个CallBackBasedFunction作为参数，返回一个() =&gt; Future[String]。(Future是Scala标准库的内容，可以认为和JS Promises&#x2F;A+是类似的概念)\n也就是说futurize可以把searchTB和buyFromTB改造成返回Future的函数。上面代码最后两行就是改造的结果。\n这样，原本接受CallBack做为参数且没有返回值的函数，就变成了不接受参数且返回Future的函数。\n再看futurize的具体实现，它使用了Scala的Promise，让返回的Future在原版函数成功时成功，在原版函数失败时失败。\n这样，我就得到了searchTBFutureVersion和buyFromTBFutureVersion这两个仍然是立即瞬间返回，不会block caller thread的函数。\n关于Scala中Promise和Future的更多信息：https://docs.scala-lang.org/overviews/core/futures.html\n镜头再切到异步函数调用者现在有了searchTBFutureVersion和buyFromTBFutureVersion，我来试着重新实现一次：\ndef searchPriceThenBuyFutureVersion() = &#123;  val eventualResult = for &#123;    searchResult &lt;- searchTBFutureVersion().map(msg =&gt; println(msg))    buyResult &lt;- buyFromTBFutureVersion().map(msg =&gt; println(msg))  &#125; yield (searchResult, buyResult)  eventualResult.onComplete &#123;    case Failure(err) =&gt; println(err.getMessage)    case _ =&gt;  &#125;&#125;\n\n这里用到了Scala的for comprehension，编译后会变成map，flatMap等等monadic operator。而map,flatMap等操作符正是Scala中Future拿来做组合用的。\n这样，用for把两个返回Future的异步函数组织起来，形成一个新的Future，然后在新的Future complete时统一处理异常。\n关于for的更多信息：https://cuipengfei.me/blog/2014/08/30/options-for/\n这次实现的代码与上次的行为是一致的,没什么两样。不过我的业务代码从鸡零狗碎变成了平铺直叙平易近人。(这种效果在这里表现的并不是特别突出，不过很容易想象如果需要组合使用的异步函数更多一些的话，这种效果的好处就显露出来了)\n当然了，让业务代码易读易懂主要还是要靠个人奋斗，而有了Promise和Future这种历史进程的推力，则更有增益作用。\n小结最近在看Scala Reactive的一些内容想起了很久之前写过一篇叫做自己动手实现Promises&#x2F;A+规范的博客，用JS实现了一个简版的Promise:https://cuipengfei.me/blog/2016/05/15/promise/\n我在当时的一段演示代码里面写了两句注释：\n\nPromise的作用在于\n\n给异步算法的编写者和使用者之间提供一种统一的交流手段\n给异步算法的使用者提供一种组织代码的手段,以便于将一层又一层嵌套的业务主流程变成一次一次的对then的调用\n\n\n不过当时的博客里只讲了实现Promise规范的事情,并没有详细解释过这两句话。既然又遇到了这个话题，于是写点Scala来把当时没展开写到的内容补充了一下。\n上文的四个镜头展现了两个角色的思考过程，通过这个过程其实也就解释了上面两句注释的含义。\n\n\n给异步算法的编写者和使用者之间提供一种统一的交流手段\n\n\n所谓统一的交流手段，其实就是异步函数的签名问题。由于需要处理的业务五花八门，异步函数接受的参数列表没法统一，但是返回值是可以统一的。\n一个异步函数，接受了外界给的参数，立即瞬间返回一个Js的Promise或者Scala的Future(或者是任何语言中类似概念的叫法)。然后在异步任务执行完的时候把Promise resolve&#x2F;reject掉(让Future success或者failure),借此来让调用方的代码知道该到了它跑后续处理的时候了。\n这样我们就获得了一个sensible default，无需在每次设计异步函数的时候都去商议该返回什么东西，该怎么获得异步执行的结果。\n\n\n给异步算法的使用者提供一种组织代码的手段,以便于将一层又一层嵌套的业务主流程变成一次一次的对then的调用\n\n\n所谓组织代码的手段，就是关于异步函数调用者的那两个镜头的内容了。一开始CallBack套着CallBack，异步的味道很重，这体现出了代码的组织方式在向代码的技术实现低头。或者说是代码的技术实现干扰了我行文的风格。后来变成了看起来很像是消费同步函数结果的写法。从而让我惯常的文风得以保持。\n\n\n\n\n","tags":["Scala","Reactive","🐸","Future"]},{"title":"Desugar Scala(19) -- Partial Function","url":"/blog/2020/01/05/desugar-scala-19-partial-function/","content":"先看这么一段Scala代码：\nobject PFBlog &#123;  def usePF(pf: PartialFunction[Option[Int], Int]) = &#123;    pf(Some(11))  &#125;  usePF &#123;    case Some(x) =&gt; x + 1    case None =&gt; 0  &#125;&#125;\n\n声明一个usePF方法，接受一个PartialFunction作为参数，它的实现就是传一个 Some(11) 给pf。pf的具体类型是 PartialFunction[Option[Int], Int] 所以传递给它一个Some(11)可以期待它会返回一个Int。\n然后调用usePF，传递给usePF的是一个pattern match表达式。给Some加一，给None返回0。\n这时问题就来了，这个pattern match表达式是怎么能够符合usePF需要的参数类型的呢？这么单纯的一个pattern match表达式怎么变成PartialFunction[Option[Int], Int]的呢？\n为了探寻答案，先把这几行Scala代码编译成class文件，然后把byte code反编译成Java来一探究竟吧。\n以上Scala代码会编译出3个class文件：\n\nPFBlog.class\nPFBlog$.class\nPFBlog$$anonfun$1.class\n\n逐个反编译出来看一下。\npublic final class PFBlog&#123;    public static int usePF(final PartialFunction&lt;Option&lt;Object&gt;, Object&gt; pf) &#123;        return PFBlog$.MODULE$.usePF((PartialFunction)pf);    &#125;&#125;\n\n首先是PFBlog，里面声明了一个usePF方法，它的实现完全代理给PFBlog$。那么它就只是对应Scala代码内的object PFBlog的对外声明。\n接下来，那就看下PFBlog$吧：\npublic final class PFBlog$&#123;    public static final PFBlog$ MODULE$;        static &#123;        (MODULE$ = new PFBlog$()).usePF((PartialFunction&lt;Option&lt;Object&gt;, Object&gt;)new PFBlog$$anonfun.PFBlog$$anonfun$1());    &#125;        public int usePF(final PartialFunction&lt;Option&lt;Object&gt;, Object&gt; pf) &#123;        return BoxesRunTime.unboxToInt(pf.apply((Object)new Some((Object)BoxesRunTime.boxToInteger(11))));    &#125;        private PFBlog$() &#123;        super();    &#125;&#125;\n\n这里面的usePF就有真的实现了，对应原Scala的usePF。调用pf.apply，并传递Some(11)。并且，它的静态块里自己调用了usePF。这就对应了原Scala中对usePF的调用。值得注意的调用usePF时传递的参数，是一个new PFBlog$$anonfun.PFBlog$$anonfun$1()，这就是第三个class文件的内容了。那这个new PFBlog$$anonfun.PFBlog$$anonfun$1()就一定是对应原本的pattern match表达式了。\n接下来看下PFBlog$$anonfun$1.class :\npublic final class PFBlog$$anonfun$1 extends AbstractPartialFunction&lt;Option&lt;Object&gt;, Object&gt; implements Serializable &#123;    private static final long serialVersionUID = 0L;        public final &lt;A1 extends Option&lt;Object&gt;, B1&gt; B1 applyOrElse(final A1 x1, final Function1&lt;A1, B1&gt; default) &#123;        Object o;        if (x1 instanceof Some) &#123;            final int x2 = BoxesRunTime.unboxToInt(((Some)x1).value());            o = BoxesRunTime.boxToInteger(x2 + 1);        &#125;        else if (None$.MODULE$.equals(x1)) &#123;            o = BoxesRunTime.boxToInteger(0);        &#125;        else &#123;            o = default.apply((Object)x1);        &#125;        return (B1)o;    &#125;        public final boolean isDefinedAt(final Option&lt;Object&gt; x1) &#123;        return x1 instanceof Some || None$.MODULE$.equals(x1);    &#125;        public PFBlog$$anonfun$1() &#123;        super();    &#125;&#125;\n\n可以看到，PFBlog$$anonfun$1继承了AbstractPartialFunction。这个AbstractPartialFunction是在Scala标准库里定义了的，它mixin了PartialFunction。所以，PFBlog$$anonfun$1自然就符合了usePF对参数要求的类型。\n再看PFBlog$$anonfun$1内的具体实现，isDefinedAt对于Some或者None返回true。applyOrElse则做了原Scala中pattern match表达式给Some加一，给None返回零的逻辑。\n由于AbstractPartialFunction中的apply方法是这样的：\ndef apply(x: T1): R = applyOrElse(x, PartialFunction.empty)\n\n这就确保了当PFBlog$$anonfun$1的apply被调用到的时候，我们原Scala中的pattern match表达式的逻辑可以得到执行。\n到这里就明白了，Scala编译器很勤劳，吭哧吭哧的给：\ncase Some(x) =&gt; x + 1case None =&gt; 0\n产出了一个PFBlog$$anonfun$1并产出了isDefinedAt和applyOrElse方法。从而让这个pattern match表达式可以符合usePF的参数类型。\n最后，很久前写过一个关于partial application的博客： https://cuipengfei.me/blog/2013/12/25/desugar-scala-6/值得注意的是，虽然partial function和partial application名字里都有partial这个字，但是他俩其实没啥关系。一个是关于把pattern match表达式编译成PartialFunction的实现类的。另一个是关于柯里化的。\n这篇博客只关心Scala编译器是怎么支持Partial Function这个语言特性的。关于Partial Function的更多信息，可以看看老人家的文章： https://www.jianshu.com/p/b0b4e3a349c3\n\n\n\n\n","tags":["Desugar_Scala","Scala"]},{"title":"Desugar Scala 20 -- Self Type","url":"/blog/2020/01/07/desugar-scala-20-self-type/","content":"Scala里有一个很有趣的语言特性叫做Self Type，可以用来限定一个trait可以被mixin到哪里去。\n看个例子：\ntrait User &#123;  def username: String&#125;trait Tweeter &#123;  self: User =&gt;  def tweet(tweetText: String) = println(s&quot;$username: $tweetText&quot;)&#125;class VerifiedTweeter(val username_ : String) &#123;  def username = s&quot;real $username_&quot;&#125;object SelfTypeBlog &#123;  def main(args: Array[String]): Unit = &#123;    val realBeyoncé = new VerifiedTweeter(&quot;Beyoncé&quot;) with User with Tweeter    realBeyoncé.tweet(&quot;Just spilled my glass of lemonade&quot;)  &#125;&#125;\n\nUser就仅仅相当于一个Interface，定义一个username。\nTweeter内的第一行是重点 self: User =&gt; 就限定了Tweeter只能被mixin到实现了User的类里面去。由于可以确定Tweeter只能被mixin到实现了User的类里面去，这样Tweeter的tweet方法内就可以放心大胆地用 username 了。\nVerifiedTweeter是一个很普通的class，别人new它的时候给什么字符串，它的username就是啥。\n最后，在main函数里new一个VerifiedTweeter，把User和Tweeter都mixin进去。然后就可以调用tweet方法了。\n而如果没有mixin User，直接试图mixin Tweeter，就会出一个编译错误：\nIllegal inheritance, self-type VerifiedTweeter with Tweeter does not conform to User\n\n到这里，其实就可以猜到了：由于Self Type是在编译时限定一个trait可以被mixin到哪里去的，并且我们知道在bytecode level上没有限定一个Interface可以被谁实现的机制。由此可知，反编译这段Scala对应的class文件是看不到任何神奇的东西的。\n不过，很久之前写过“Scala中的语言特性是如何实现的(3) – trait”：https://cuipengfei.me/blog/2013/10/13/scala-trait/\n其中对于Scala如何编译trait做了逆向工程的分析，当时的trait是编译成了一个抽象类加一个接口。这个信息已经过时了。现在更新版的Scala可以编译出bytecode version 52，这一版是有interface default method的。\n所以，还是反编译一下吧。\npublic interface User&#123;    String username();&#125;public interface Tweeter&#123;    default /* synthetic */ void tweet$(final Tweeter $this, final String tweetText) &#123;        $this.tweet(tweetText);    &#125;        default void tweet(final String tweetText) &#123;        Predef$.MODULE$.println((Object)new StringBuilder(2).append(((User)this).username()).append(&quot;: &quot;).append(tweetText).toString());    &#125;        default void $init$(final Tweeter $this) &#123;    &#125;&#125;public class VerifiedTweeter&#123;    private final String username_;        public String username_() &#123;        return this.username_;    &#125;        public String username() &#123;        return new StringBuilder(5).append(&quot;real &quot;).append(this.username_()).toString();    &#125;        public VerifiedTweeter(final String username_) &#123;        this.username_ = username_;        super();    &#125;&#125;\n\n上面是User Tweeter VerifiedTweeter他们三个的反编译结果，都比较单纯。只是Tweeter这个含有一个实现方法的trait被编译成了有default method的Interface，而不像老版本的Scala要编译成一个抽象类加一个Interface。\n然后看一下main函数反编译出来的样子：\npublic void main(final String[] args) &#123;    final VerifiedTweeter realBeyonc\\u00e9 = (VerifiedTweeter)new SelfTypeBlog$$anon.SelfTypeBlog$$anon$1();    ((Tweeter)realBeyonc\\u00e9).tweet(&quot;Just spilled my glass of lemonade&quot;);&#125;\n\n可以看到这里new的是一个叫做SelfTypeBlog$$anon$1的类。这个类反编译出来是这样的：\npublic final class SelfTypeBlog$$anon$1 extends VerifiedTweeter implements User, Tweeter &#123;    public void tweet(final String tweetText) &#123;        Tweeter.tweet$((Tweeter)this, tweetText);    &#125;        public SelfTypeBlog$$anon$1() &#123;        super(&quot;Beyonc\\u00e9&quot;);    &#125;        &#123;        Tweeter.$init$((Tweeter)this);    &#125;&#125;\n\n它继承了VerifiedTweeter，实现了User和Tweeter。由此可见Scala中在对象创建时才with trait的写法，Scala编译器会产出一个类来表达。\n如同前面推测的一样，在bytecode level上，没有神奇的东西，self type这个语言特性是仰赖于Scala compiler来做到的。\n不过，既然是全靠Scala compiler来做到的，那就意味着如果我用别的compiler的话，这个限定就无法在编译时生效了。\n来试一下：\npublic class JNotUser implements Tweeter &#123;    private String abc() &#123;        return &quot;abc&quot;;    &#125;&#125;\n\n这段Java代码编译起来完全没问题，没人强迫我去实现User，毕竟Tweeter对于Java来说就是个普通的Interface嘛。\n然后跑一下\nnew JNotUser().tweet(&quot;hello&quot;);\n会怎样呢？\n结果是执行的时候出现一个类型转换异常：\nException in thread &quot;main&quot; java.lang.ClassCastException: class TraitSelfTypeBlog.JNotUser cannot be cast to class TraitSelfTypeBlog.User\n\n为啥会这样呢？仔细看下上面Tweeter反编译的结果中tweet方法的内容：\ndefault void tweet(final String tweetText) &#123;    Predef$.MODULE$.println((Object)new StringBuilder(2).append(((User)this).username()).append(&quot;: &quot;).append(tweetText).toString());&#125;\n关键就在这个 (User)this 了。\n虽然编译时限制不住，运行时终归逃不过。\n\n\n\n\n","tags":["Desugar_Scala","Scala"]},{"title":"分布式键值存储（Distributed Key-Value Store）","url":"/blog/2020/02/21/distributed-key-value-store/","content":"前言分布式键值存储（Distributed Key-Value Store）并不是一个新鲜的玩意。常见的Redis，Memcache等等都有很多人在用。\n不过如果要是说其中的细节，如replicate，读写，一致性，retry等等的话，又是经常会遇到把自己绕的混淆不清的情况。。恰巧我最近在看的一门网课《Programming Reactive Systems》中有一道作业题就是要自己实现一个Distributed Key-Value Store，那就正好借此机会详细写下其中的关键点。\n组成系统的参与者既然是分布式键值存储，那么肯定会有主从节点，每个结点又会有自己的持久化，而主从之间也需要协调，于是就得出了如下关键参与者：\n\nPrimary： 主节点。接受来自client的更新（增&#x2F;删&#x2F;改）操作，并把更新后的数据扩散到其它节点。当然，也可以接受来自于client的读操作。\nSecondary： 从节点。接受来自主节点的更新操作。接受来自client的只读操作。\nArbiter： 仲裁者。任何节点，无论主从，都要把自己注册到Arbiter上去。当有从节点加入或者离开集群的时候，Arbiter负责告知主节点。\nPersistence： 每个节点都拥有自己的独享的Persistence。用于把节点上的数据持久化。\nClients： 客户端，可能与主或者从节点通信，进行各种读写操作。\n\n此外，还有另一个相对不那么关键的参与者：\n\nReplicator： 复制器，负责扩散数据。主节点和从节点之间的桥梁。主节点扩散到从节点去的数据要经手Replicator。之所以需要它是为了把一部分维护内部状态的职责从Primary身上解除出去，具体来说是一个sequence number序列号，后面会提到。\n\n参与者之间的关系\n可以看出，系统中有一个Primary，多个Secondary（虽然图中只画了两个，但是理论上可以有任意N多个）。Primary向Secondary扩散数据是通过Replicator进行的，并且是给每个Secondary配了一个单独的Replicator。也就是说Replicator和Secondary是成双成对的。\n注：上图描述的是各个参与者之间的关系，上下左右位置并不代表先后顺序\n一些限制我们并不是要做一个可以在Prod环境中使用的KV Store，而只是借助自己实现来厘清KV Store的一些知识点，所以做出了如下的限制来简化实现：\n\n只有主节点可以接受写操作，所有从节点都只能接受读操作\n假设主节点是稳定可靠的，不会挂（不处理主节点身份转移）\n假设Arbiter是可靠的，不会挂\n不处理背压（back pressure）\n客户端使用的请求id是不会重复的\n\n各参与者的职责及相互之间的交互以下的这些图，每一张都只关心系统中的一个局部。主要原因在于把整个系统的交互放到一张图里会导致要素太多而难以阅读。\nArbiter\n来的早的会被Arbiter当作Primary，来的晚的就是Secondary了。并且，每一个来的晚的成为Secondary之后，Arbiter还会告知Primary说：来新节点了。以便Primary可以知道后续需要把数据扩散给谁。如果有Secondary由于某种原因而离开了集群，Arbiter也会告知Primary，从而避免Primary继续给已经不在了的Secondary发消息。\nPersistence\n前面提到过，每个节点，无论主从，都有一个自己独享的persistence。所以上图中的Node兼指主或者从节点。Persistence本身的职责很简单，把Node告诉它的数据持久化下来。但是，此处我们并没有假设持久化总是可靠的，所以上图中的第二根线是未必总是能成功发生的。\nNode\n这里的Node兼指主或者从节点。也就是说上图中的事情是每个Node无论主从都要做的。每一个Node，在它生命周期的最早开始作的第一件事就是告诉Arbiter：“我来了“。\n上面提到过，Persistence未必总是可靠的。所以每个Node一旦开始存活，就会给自己启动一个定时任务，每隔100ms就去retry persist，直到Persitence回话说Persisted为止才停止retry。\nSecondarySecondary - Snapshot\n上图描述的是当Replicator向Secondary扩散数据的时候，Secondary如何处理。一旦一个Replicator告诉Secondary去更新数据（增&#x2F;删&#x2F;改），Secondary先去更新自己内部的kv，然后去告知Persistence去做持久化。\n这里有一个细节，就是图中出现的seq（sequence number 序列号）。Replicator和Secondary之间就是靠这个seq来保证数据更新操作总是先来的先处理，后来的后处理。据此来提供一定程度的consistency。避免老数据覆盖新数据（此处需要结合下文中replicator的retry snapshot来理解）。\nSecondary - Persisted\n上图描述的是，当Persistence告诉Secondary：“持久化好了“的时候，Secondary如何处理。可以看出来，只有确认持久化完成之后，Secondary才会告诉Replicator：“扩散数据完成了“，并且在Secondary自己内部取消掉这一条数据的retry persist。\nSecondary - Get\n对于来自于Client的读取操作，Secondary总是心直口快，有就是有，没有就是没有。\nReplicatorReplicator - retry snapshots\n上面提到过，Persistence未必总是可靠的，也就意味着数据扩散操作也未必总是成功，所以，Replicator一旦启动（被Primary创建出来），就要开始一个定时任务来不断retry尚未成功的数据扩散操作。\nReplicator - Replicate\n上图描述的是当Primary要求Replicator去扩散数据到一个Secondary的时候Replicator如何处理。那么Replicator首先告诉Secondary去更新数据，然后在自体内部把刚才的操作记下来，以便后续retry。并且把自己的seq加一，这里的seq就是Replicator和Secondary之间的信物，用来维持consistency。\nReplicator - SnapshotAck\n上图描述的是Replicator在被Secondary告知扩散数据成功后如何处理。先把这个好消息告诉给Primary，然后在retry的列表里面去除掉刚刚成功的这次操作，这样后面就再也不会再去retry这次操作了。\nPrimary最后是Primary。作为主节点，它的职责是最多最辛劳的。\nPrimary - Insert&#x2F;Remove\n上图是Primary处理来自Client的Insert或者Remove请求。前面一半和Secondary处理Snapshot方式基本一致。\n不同之处就在于：Primary还要负责告诉所有现存的Replicator（图里只画了两个，理论上可以有任意N个）去扩散数据。并且把这个操作记在内部状态里。以及设置一个定时任务，一秒钟之后，如果没有达成Primary自己persist成功并且每一个Replicator都扩散成功的状态，那就告诉Client这次操作是失败的。\nPrimary - Get至于Primary处理来自于Client的Get请求的图就不画了，与Secondary完全一致。\nPrimary - Persisted\n上图是Primary收到Persistence成功消息的时候要做的事情。首先从pending persist列表中移除刚刚persist成功的一条。然后检查下是不是所有Replications也都完成了，两个条件的都符合的话，就告诉Client说操作完成了。\nPrimary - Replicated\n上图是Primary收到来自Replicator的扩散成功消息时候的处理。首先把刚成功的这一条从pending replicates中移除。然后检查下是不是所有的replications都完成了（毕竟这里只是收到了一个replicator的消息），并且persist也完成了，如果两条都符合，就告诉Client说操作完成了。\n到这里就明显可以看出，pending replicates的作用就是primary用来记录尚未完成的replication。\nPrimary - Replicas\n最后一张图，描述的是当Arbiter告知Primary集群中有变动时，Primary的处理方式。\n对于新加入的Secondary，给它们每个都创建一个新的Replicator。然后通过Replicator把所有现存的kv数据都甩给新加入的Secondary。类似于给插班生补课。\n对于离开集群的Secondary，把和它们相关的pending replicates都删掉，既然它离开了，那就没必要等它了。删除掉之后马上检查一下是不是replications和persist都完了（因为有可能当前等的就是这个离开的Secondary，它一离开，没有别的需要等的了），如果是的话，那就告诉Client更新成功了。最后，销毁掉对应的replicator。这个Secondary的历史使命就算终结了。如果后续这个Secondary又加入回来了，那走的就是上面一段补课的处理。\nOK虽然讲的是一个加了若干限制的分布式键值存储，但是还是用了十四张图。\n这些图里没能体现到的一点是关于异步的问题，在最后补充一句：除了Client之外，以上所有提到的参与者，每一个都是严格单线程的，不会在任何时候同时做两件事。实际的实现代码中，是用akka写的，这些参与者做的多数都是async message passing的工作。由于这是一门课的作业题，所以具体实现代码就不提及了。\n希望这些图表对于理解分布式键值存储（Distributed Key-Value Store）会有一些帮助。\n\n\n\n\n","tags":["Reactive","分布式"]},{"title":"[译] 类 vs 数据结构","url":"/blog/2020/02/15/classes-vs-data-structures/","content":"原文作者：Robert C. Martin (Uncle Bob)原文链接：https://blog.cleancoder.com/uncle-bob/2019/06/16/ObjectsAndDataStructures.html\n\n类是什么？\n\n类是一组相似对象的范本。\n\n对象又是什么呢？\n\n对象是对封装的数据进行操作的一组函数。\n\n不如这么说:对象是对隐含数据进行操作的一组函数。\n\n隐式数据？什么意思？\n\n对象的函数隐含意味着某些数据是存在的。但是该数据无法在对象外部直接访问或看到。\n\n数据不是对象内部的吗？\n\n可能是; 但没有规则说必须如此。从用户的角度来看，一个对象不过是一组函数。这些函数所需要的数据必须存在，但是用户不知道该数据的位置。\n\n嗯，好，我同意。\n\n好。现在说说，数据结构是什么？\n\n数据结构是一组内聚的数据。\n\n或者，换句话说，数据结构是由隐含函数操作的一组数据。\n\n好的，好的。我知道了。数据结构没有定义对数据结构进行操作的函数，但是数据结构的存在意味着某些函数必须存在。\n\n对。你有什么发现没有？\n\n对象和数据结构似乎是彼此相反的。\n\n确实。它们是彼此互补的。\n\n对象是对隐式数据进行操作的一组函数。\n数据结构是被隐式函数操作的一组数据。\n\n\n哇，所以对象不是数据结构了？\n\n说对了。对象与数据结构相反。\n\n那么DTO（Data Transfer Object）不是对象吗？\n\nDTO是数据结构。\n\n所以数据库表也不是对象吗？\n\n数据库包含数据结构，而不是对象。\n\n可是，等等。ORM(Object Relational Mapper)不是将数据库表映射到对象吗？\n\n当然不是。数据库表和对象之间没有映射。数据库表是数据结构，而不是对象。\n\n那么，ORM算是干嘛的呢？\n\n在数据结构之间传输数据。\n\nORM与对象无关是吗？\n\n完全无关，ORM其实是不存在的。因为数据库表和对象之间没有映射。\n\n但是我还以为ORM为我们创建了业务对象呢。\n\n不对，ORM会提取业务对象所操作的数据。该数据包含在ORM加载的数据结构中。\n\n但是，业务对象是不是会包含该数据结构啊？\n\n它可能包含，也可能不包含。但是这不关ORM的事。\n\n这种说法似乎是咬文嚼字，不太重要。\n\n不，这具有重大意义。\n\n怎么讲？\n\n例如数据库schema的设计与业务对象的设计。业务对象定义业务行为的结构。数据库schema定义业务数据的结构。这两个结构受到非常不同的力的约束。业务数据的结构不一定是业务行为的最佳结构。\n\n嗯？令人困惑。\n\n这样想吧。数据库schema不仅为一个应用程序服务；它必须服务于整个企业。因此，该数据的结构是许多不同应用程序之间的折衷方案。\n\n好，我知道了。\n\n好。但是现在来说单独的应用程序。每个应用程序的对象模型描述了该应用程序的行为的构造方式。每个应用程序将具有不同的对象模型，并根据该应用程序的行为进行调整。\n\n哦，我懂了。由于数据库schema是各种应用程序的折衷方案，因此该schema将不符合任何特定应用程序的对象模型。\n\n对！对象和数据结构受到非常不同的作用力的约束。他们很少能对齐。人们习惯称其为对象&#x2F;关系阻抗失衡（Object&#x2F;Relational impedance mismatch）。\n\n我听说过，但是我认为阻抗失衡是由ORM解决的。\n\n现在你知道不是这样的了。因为对象和数据结构是互补的，而不是同构的，所以没有阻抗失配。\n\n什么？\n\n它们是对立的，不是相似的实体。\n\n相反吗?\n\n是的，以一种非常有趣的方式。你会看到，对象和数据结构意味着相反的控制结构。\n\n等一下，什么?\n\n考虑一组符合公共接口的类。例如，想象一下表示二维形状的类，这些类都具有计算area面积和perimeter周长的函数。\n\n为什么每个软件示例都总是提到形状？\n\n让我们只考虑两种不同的类型：Square和Circle。应该很容易看清楚的是，这两个类的area和permimeter函数在不同的隐式数据结构上运行。还应该清楚的是，调用这些函数的方式是通过动态多态性进行的。\n\n等下，慢一点，什么？\n\n有两种不同的area函数；一个是Square的，另一个是Circle的。当调用者在特定对象上调用area函数时，只有该对象才知道要调用哪个函数。我们称之为动态多态性。\n\n好。当然。该对象知道其方法的实现。当然。\n\n现在，让我们将这些对象换成数据结构。我们将使用标签联合（discriminated union）。\n\n标签联合是什么？\n\n标签联合。在我们当前讨论的情况下，这只是两个不同的数据结构。一个是Square另一个是Circle。Circle数据结构有一个圆心和半径。它还有一个将其标识为Circle的类型码。\n\n你是说像枚举？\n\n当然。Square数据结构有左顶点，和边长。它还有类型区分符(type discriminator)–枚举。\n\n好。具有类型码的两个数据结构。\n\n对。现在考虑area函数。它要有一个switch语句，不是吗？\n\n嗯，当然，对应两种不同的情况。一个用于Square另一个用于Circle。并且perimeter函数也需要类似的switch语句。\n\n对。现在考虑这两种场景的结构。在对象场景中，area函数的两个实现彼此独立，并且（在某种意义上）从属于类型。Square的area函数属于Square，Circle的area函数属于Circle。\n\n好的，我知道您的意思了。在数据结构场景中，area的两个实现在同一个函数中，它们并不“从属于”类型。\n\n接下来会更有趣。如果要将Triangle类型添加到对象方案中，必须更改哪些代码？\n\n无需更改代码。您只需创建新Triangle类。哦，我想必须更改实例的创建者。\n\n对。因此，当添加新类型时，几乎没有什么变化。现在，假设您要添加一个新函数-比如center函数。\n\n那么，你就必须在Circle，Square，和Triangle这三个类里面都去添加center函数。\n\n好。因此添加新函数很困难，必须更改每个类。\n\n但是在数据结构上却有所不同。为了添加Triangle，必须更改每个函数以将Triangle的case添加到switch语句里面去。\n\n对。添加新类型很困难，必须更改每个函数。\n\n但是，当您添加新center函数时，无需更改任何现存代码。\n\n对。添加新函数很容易。\n\n哇。恰恰相反。\n\n对。我们来复习：\n\n向一组类中添加新函数很困难，必须更改每个类。\n向一组数据结构中添加新函数很容易，只需添加函数，无需其他改变。\n向一组类中添加新类型很容易，只需添加新类即可。\n向一组数据结构中添加新类型很困难，必须更改每个函数。\n\n\n是的，相反。以一种有趣的方式对立。我的意思是，如果您知道要向一组类型中添加新函数，则应该使用数据结构。但是，如果您知道要添加新的类型，则可以使用类。\n\n说得好！但是，今天我们还有最后一件事要考虑。数据结构和类的对立还有另一种方式，与依赖关系有关。\n\n依赖关系？\n\n是的，源代码的依赖方向。\n\n具体来说呢？\n\n考虑数据结构的情况。每个函数都有一个switch语句，该语句根据类型码选择适当的实现。\n\n对，然后？\n\n考虑对area函数的调用。调用者依赖于area函数，而area函数依赖于每个特定的实现。\n\n您所说的“依赖”是什么意思？\n\n想象一下，area的每个实现都被写入了单独的函数中。所以有circleArea，squareArea和triangleArea。\n\nOK，switch语句会调用这几个函数。\n\n想象一下这几个函数在不同的源文件中。\n\n那么，包含有switch语句的源文件就必须import，use或include这些源文件。\n\n对。这就是源代码依赖性。一个源文件依赖于另一个源文件。这种依赖的方向是什么？\n\n带有switch语句的源文件依赖于包含实现的源文件。\n\n那area函数的调用者呢？\n\narea函数的调用者依赖于包含switch语句的源文件，该文件的switch语句依赖于各个实现。\n\n正确。从调用者到实现，所有源文件依赖性都指向调用的方向。因此，如果您对其中的一种实现进行了微小的更改……\n\n好的，我知道您的意思。对任何一种实现的更改将导致重新编译带有switch语句的源文件，从而导致每个调用switch语句的人重新编译。\n\n对。至少对于依赖于源文件的更改日期来确定应编译哪些模块的语言系统而言，这么说是正确的。\n\n几乎所有使用静态类型的语言，对吗？\n\n是的，有些非静态的也会。\n\n大量的重新编译。\n\n还有大量的重新部署。\n\n是的，但是在类的情况下这是相反的吗？\n\n是的，因为area函数的调用者依赖于接口，而函数实现也依赖于该接口。\n\n我明白你的意思了。Square类的源文件将import，use或include Shape接口的源文件。\n\n对。实现的源文件指向调用的相反方向。他们从实现指向调用者。至少对于静态类型的语言来说是这样。对于动态类型的语言，area函数的调用者完全不依赖任何内容。链接在运行时确定。\n\n对，因此，如果您更改其中一种实现方式…\n\n仅更改的文件需要重新编译或重新部署。\n\n那是因为源文件之间的依赖关系指向调用方向的反方向。\n\n对。我们称之为依赖倒置。\n\n好，让我看看我是否可以总结一下。类和数据结构在至少三种不同的方式上是相反的。\n\n类使函数可见，隐藏数据。数据结构使数据可见，隐藏函数。\n类使添加类型变得容易，但是却难以添加函数。数据结构使添加函数变得容易，但难以添加类型。\n数据结构导致调用者重新编译和重新部署。类将调用者与重新编译和重新部署隔离开。\n\n\n你说对了。这些都是每个优秀的软件设计人员和架构师都需要牢记的问题。\n\n\n\n\n\n","tags":["Uncle Bob"]},{"title":"软件需求膨胀系数","url":"/blog/2020/05/22/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%86%A8%E8%83%80/","content":"泡水膨胀球\n\n这是一种小玩具，干燥时拿在手里，小巧紧致。\n泡在水里，一段时间之后，浑圆饱满，一只手都未必能捧的住。\n放在干燥通风的地方晾晒，一段时间过后，又可以恢复原本的大小。\n软件需求软件需求与泡水膨胀球也有类似之处。\n一开始时看似简单明了且完备正交，做起来发现越做越大，越做越多。\n原本一只手能抓好几个的小球，后来变成两只手都抓不住一个。\n然后的结果要么是超预算多花钱做完，要么是转嫁成本给乙方要求对方做完，要么是延期，要么是痛苦地去压缩需求。\n无论哪种，都是不健康的。\n膨胀系数小球泡在水里会膨胀，暴露于干燥环境中会缩小。\n这个过程可以用一个简化模型来表示：\n膨胀系数 ≈ 吸水力 - 斥水力\n小球体积 ≈ 初始体积 + 膨胀系数 x 时间\n当吸水力大于斥水力时，膨胀系数为正数，在时间的作用下，球会膨胀。当斥水力大于吸水力时，膨胀系数为负数，在时间的作用下，球会缩小。当两个力接近相互平衡时，膨胀系数约等于零，在时间的作用下，小球体积趋于稳定。\n我们希望看到小球体积怎样变化？一直变肥？那不行。做软件是有成本的，时间人力都是成本。\n持续变瘦？也不行。需求受到过分压抑也是不健康的。\n健康的变化过程应该是：先让小球丰满起来（充分收集需求，以免后面出现始料未及的“惊喜”）然后削减多余的赘肉（使用奥卡姆剃刀）之后长期维持健康范围内的波动\n力的阶段性施加策略时间的流逝是不受我们控制的，因而想要控制体积就要从膨胀系数下手。\n而膨胀系数又与两个力相关，因而想要控制体积就要控制吸水力与斥水力。\n\n\n首先让吸水力尽情释放，这时斥水力蛰伏着静待吸水力的衰减。之后斥水力爬坡，达到与吸水力持平的水准，二者长期和平共处。\n当我们如上使用这两种力的时候，小球体积的变化就会是这样的：\n\n\n总结调研阶段积极创造环境来让吸水力得以释放，先允许小球变肥。然后施加一定的斥水力，让小球苗条下来。\n到了研发阶段，由于吸水力在之前就已经得到了有效的释放，这时施加适量的斥水力来平衡所剩无几的吸水力就能让小球体积的波动维持在可控的范围内。\n在不同的阶段有策略地利用这两种力，则可以趋近前期需求收集充分考虑各方诉求不留大的隐患，后续研发稳定不坐过山车的目的。\n\n\n\n\n","tags":["需求"]},{"title":"《大目标》一书中的有趣观点","url":"/blog/2020/07/05/%E5%A4%A7%E7%9B%AE%E6%A0%87/","content":"引子工业化、现代化、城市化、民主化、自由化、市场化、全球化，不一定要姓“西、资、基”。\n第一章五常的否决权是对大国毁灭性力量的承认。核武器，氢弹，洲际导弹，核潜艇，多弹头分导。\n退缩不会让狼群放弃供给，逃跑不会让狼群放弃追捕，倒下不会让狼群放弃杀戮。\n大国没资格投降。\n美国对日本可以援引《共同防卫协定》只会日本空军。韩国三军的最高指挥权本来就归美军。\n冷战的本质是3.5亿的苏联东欧工业人口和欧美日6亿的工业人口抢全球的资源和市场。\n第二章把人当人看是工业社会才能做到的事。医疗器具，消毒不再昂贵，简单高效。当物质上的富足让社会不再需要合理合法地牺牲掉一些人而保证另一些人的生存时，才能进入文明。\n1962年，中国粮食总产量1.6亿吨。1978年3亿吨。不是靠积极性。而是靠化肥。化肥让农民有了余粮和闲暇，从农业中解放出来的生产力投入工业。\n工业化：用机器造机器，然后用造出来的机器去造别的东西。\n世界上勤俭的不止有中国人，勤俭了几千年也没有变的富裕。工业化才能让勤俭变成资本。\n李鸿章去找“造器之器”，是找造火器的机器，而不是造机器的机器。\n机器用钢铁造的，用的是煤炭或者煤炭生成的电能。欧盟来源于煤钢共同体。\n第三章美国“绿卡战士”的阵亡率比美籍士兵高出一倍。\n钱并不是财富，说“有钱”其实意味着“有货”。\n美元作为结算货币收全球铸币税。各国越小，产业链越分散，美元铸币税收的越开心。\n经济活动的本质是物质生产。\n枪杆子里面出石油。\n第四章工业与手工业的最大区别：工业可以升级。\n西班牙，英国，美国，三个世界性的大帝国。兴起的原因是先进的生产技术，发达的制造业能创造财富也支持了强大的军队。然后不劳而获，停滞衰退。\n第五章与之前的强国相比，苏联的工业化不依赖殖民地的市场和资源。\n重工业是核心，轻工业释放重工业制造的生产能力。\n苏联利用西方几次危机，抄底技术与设备。\n工业化人口数量决定了工业经济的规模，也和工业体系的复杂程度和先进程度密切相关。独立工业体系需要的工业化人口数量是基本配件数量的5到10倍。欧洲走向一体化的原因就在于此。\n苏联的崩溃说到底是因为美国用自己的人口优势率先完成了产业升级。\n在战略对抗中，要掌握比对手更多的工业化人口，要向盟友输出工业化社会，通过输出工业化社会来制造盟友。否则早晚遇到工业升级的人口障碍。\n第六章一切强权、帝国在工业革命面前都是过眼云烟。\n终结大英帝国的是第二次工业革命。\n中国不能靠出口来长期支持我们的工业化进程了。\n第七章没有人会把太监叫做绅士。\n保持不断的进步才能有道理可以讲。\n输出工业化是个长久的买卖，比输出消费品要长久。\n现在一个地市级的地勘力量比工业化之前全国合集还多。\n买办是第一障碍。\n要输出工业化，而不是像殖民主义那样打击当地工业发展。\n\n\n\n\n","tags":["工业党"]},{"title":"TW十四载","url":"/blog/2021/12/17/tw14years/","content":"2007年，我在读大二。\n当时经常会去学校食堂对面的报刊亭买杂志，一本，是《大众软件》，另一本，是《程序员》。\n\n\n印象中当时《程序员》上的多数文章充满了我没听过的各种缩写与稀奇古怪的名词，文风是老成持重，我看不懂，但很是佩服。\n而这当中偶尔会夹杂着几篇文风犀利，睥睨天下的文章，加上作者头像很是非主流，我虽也看不懂，但印象深刻。这些犀利文章的作者，便经常冠有TW的头衔。\n2012年，我在一家小软件公司上了两年的班。当时我们每半年发布一个版本，每到要发布前夕，程序员便都停止写代码，去做回归测试。\n经常会发现半年前发布时还是ok的功能，在这六个月里被改错了，得修。我隐隐觉得这不对劲，再六个月之后还是会出现类似的状况，老是靠大家停工去做回归测试不是个办法，我们总是会“狗熊掰棒子，掰一根丢一根”。\n\n\n恰在此时，邮箱收到了来自TW的面试邀请。到了这会，我其实已经记不清楚大学时看的《程序员》杂志上有什么内容了，不过TW这个名字还是有些印象。再去一查，这家公司还出过不少书，推崇做自动化测试，注重软件质量，而这些正是我当时所在的小公司所缺乏的。\n于是便接受了面试邀请，做了Mars Rover的题目，去参加了办公室面试。面试时还见到了《软件设计精要与模式》的作者。之后便加入TW成为了一名21世纪的程序员。\n从第一次看到《程序员》杂志上的文章到眼下的2021年，有14年了。14年挺长的，从上小学到高中毕业，也才12年。\n时间跨度长，变化也就多，不过当时持有的很朴素的观念不太容易变：软件至少要做对，一旦做对了之后，要避免“狗熊掰棒子，掰一根丢一根”。\n就好像一个木匠师傅，用了锛凿斧锯，费力做成了板凳，肯定是不希望这个凳子给人坐了两天之后就开始“嘎吱吱”。\n码匠师傅，亦当如是。\n\n\n\n\n","tags":["TW"]},{"title":"一些关于银行的散碎知识","url":"/blog/2022/01/29/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E9%93%B6%E8%A1%8C%E7%9A%84%E6%95%A3%E7%A2%8E%E7%9F%A5%E8%AF%86/","content":"金本位时期金融机构的层级结构19th century nation state financial institution hierarchy \n\n央行的负债≈银行的资产≈货币\n银行的负债≈私营部门的资产≈存款\n亏钱先亏哪儿？\n假设左侧亏了5块钱，且左右必须平，则右侧也必须减少5。\n不能先减liability，因为债权人优先级较高，只能先减equity。\nLiquidity和Solvency\ncash reserve &gt; 0，则具有一定的流动性\nnet worth &gt; 0，则具有一定的偿付能力\n流动性和偿付能力的高低则取决于到底比零大多少。\n资金来源\n活期存款 (Demand deposit)\n存款证书&#x2F;大额存单 (Certificate of deposit)\n附买回协议（repurchase agreement、repo，也称为附买回协定、附买回交易，回购协议、卖出回购或正回购）\n商业票据（Commercial Paper）\n负债业务是商业银行形成资金来源的业务\n存款是银行对存款人的负债，是银行最主要的资金来源\n四种风险银行的风险种类较多，最主要的风险有四种：\n信用风险、市场风险、流动性风险和操作风险 \n信用风险是指借款人因各种原因未能及时、足额偿还债务或银行贷款而违约的可能性。发生违约时，债权人或银行必将因为未能得到预期的收益而承担财务上的损失。 \n市场风险是指未来市场价格（利率、汇率、股票价格和商品价格）的不确定性对企业实现其既定目标的影响 \n流动性风险是指因市场成交量不足或缺乏愿意交易的对手，导致未能在理想的时点完成买卖的风险；或银行本身掌握的流动资产不能满足即时支付到期负债的需要，从而使银行丧失清偿能力和造成损失的可能性。 流动性风险，一方面是一种本原性风险，是由于流动性不足造成的；另一方面也是最常见的情况，是其他各类风险长期隐藏、积聚，最后以流动性风险的形式爆发出来。从这种意义上讲，流动性风险是一种派生性风险，即流动性不足，可能是由于利率风险、信用风险、经营风险、管理风险、法律风险、国家风险、汇率风险等风险源所造成的，银行最终陷入流动性风险中不能自拔。 \n操作风险的正式定义是：由于内部程序、人员和系统的不完备或失效，或由于外部事件造成损失的风险\n\n\n\n\n","tags":["银行"]},{"title":"卢瑟经济学","url":"/blog/2022/10/28/loser-economy/","content":"\n此书讲什么马克思《资本论》讲的三件事：\n\n原始积累靠暴力\n贫富差距会扩大\n最终自毁\n\n经济与政治经济学是有阶级属性的。\n哪个阶级现在说了算，哪个阶级的经济学就流行。\n反之亦然，可以通过观察哪个学说流行来倒推谁说了算。\n\n地主： 重农主义\n商人： 重商主义\n新兴资产阶级： 自由市场和劳动价值论\n工人阶级： 劳动价值论\n资产阶级卷土重来： 边际效用价值论\n\n不同的阶级有不同的价值理论，这就如同不同的宗教信仰对善行的定义是不一样的。统治阶级的经济学，是为统治阶级寻找合法性的。被统治阶级的经济学，自然是为被统治阶级申诉的，顺便控诉对方。市场是不是真的有效，到底什么创造价值，其实就看谁来解释。\n按照卢瑟经济学，土地没有价值。土地的所有制，使土地所有者有权向在土地上生活工作的人要求贡赋。土地所有权越垄断，要求的地租就越高。土地垄断程度高的地方，绝对地租就高。所以房子的昂贵并不是土地的价值昂贵，而是土地的所有权高度垄断，导致地租昂贵。\n危机的表征与对其的解释\n妈妈，天这么冷，我们家为什么不生火呢？\n因为你爸爸失业了，我们没有钱去买煤。\n小孩继续问：“妈妈，爸爸为什么失业呢？”\n他妈妈说：“因为你爸爸的煤矿倒闭了。〞\n小孩接着问：“妈妈，爸爸的煤矿为什么会倒闭呢？”\n他妈妈说：“因为没有人买你爸爸的煤矿的煤，煤卖不出去，所以煤矿倒闭了。”\n\n与封建时期的危机不同，资本主义条件下的危机的特点：\n\n不是产品不足而是产品过剩\n不是劳动力被透支而是劳动力被闲置\n不是没稂食吃，而是产能过剩导致企业破产，然后大家下岗，没钱买粮食吃\n产能有的是，就是没销路；粮食有的是，就是没钱买；劳动力有的是，就是没活干\n这种危机有很强的周期性，按时袭击经济\n\n工业化的资本主义生产的特点是所有的人，都为别人生产商品，所有的人都消费别人生产的商品。\n工人一旦失业就很难找到原有工资待遇水平类似的工作。因为全社会的资本家几乎在一夜之间觉得他们的劳动不值钱了。到处都是堆积的商品，老板做什么也不赚钱，索性停产，老板不生产，工人的劳动也就不值钱了，对老板就没有用了。\n稳拿经济学假设工人工资水平下降，老板会增加劳动力的需求。问题是，老板的需求与产品的销售有关，当销售情况不改善的时候，工人工资再便宜，老板也没有兴趣多雇人。\n社会金字塔的平级之间是可以自动调节的，但是上下级之间却不能自由调节。当社会需要的产品与资本家提供的产品不对称的时候，资本家能自行改变产品结构。当社会需要的劳动力与工人能提供的劳动力不对称的时候，工人能自动改行。但是当塔的上级不愿意投资和消费的时候，塔的下级却没有能力去代替上级投资或消费。这才是真正的困难。\n凯恩斯1936年，凯恩斯在他的著作《就业、利息和货币通论》中提出在资本主义制度下不是产品做得出就卖得掉，有很大一部分产品注定无法消费，如此必然导致资本家压缩生产，工人失业。为了挽救资本主义，多余的产品需要政府帮助消费掉，甚至是浪费掉。无法消费的产品的量随着贫富差距的增大而增大，换句话说，贫富差距越大的经济体，失业问题越严重。\n消费需求不足和投资需求不足将产生大量的失业，形成生产过剩的经济危机。\n当投资的利润还不如利率的时候，资本家就都不投资，持币观望，转而存银行吃利息。如果这个时候利率高，那么投资就非常少了。其实还是消费需求不足。因为投资需求归根到底完全仰仗消费品的销售情况。\n觊恩斯主义是用通胀换就业：后遗症就是通货膨胀。\n弗里德曼在弗里德曼看来，政府\n\n第一要务是国防\n第二要务是保证契约的实施\n而财富分配则属于是一个人认为有益，另一个人认为是有害的\n\n但是如果我们换一个角度看弗里德曼的要求的话，就会发现三件事说起来冠冕堂皇：\n\n第一是不要外来势力干涉稳拿\n第二是要求法律是保证契约的执行，不要插手稳拿利用契约合法地抢劫卢瑟 \n第三是不要试图触碰，甚至返还抢来的赃物\n\n对弱者来说，与强者费厄泼赖就是最大的不公平。自愿和双方获利，只有在双方经济地位接近的时候才能存在。\n关税保护了幼年时期的美国资本，避免被英国资本吞噬，避免成为英国的经济殖民地\n弗里德曼和凯恩斯的理论冲突，与李嘉图和马尔萨斯的冲突异曲同工。都是两个集团在争夺经济主导权。\n财产具有自我汇集的效应，古往今来小农经济就没有长期稳定存在过。小农如果不能进化为大地主，那么迟早会被地主吞并。\n资本主义社会的矛盾的核心不是生产力的发展，而是资本主义分配制度。\n自由市场加私有产权，只要一代人就能在社会上建立起人与人之间不可逾越的鸿沟。能力的竞争最多在一代人之同发挥作用，一代人之后资产确立统治地位。\n其实，对大资本家来讲，周期性的经济危机未必是坏事。经济危机可以促进资本汇聚到强者也就是大资本家手中。\n认识经济危机并不复杂，解决经济危机（至少从理论上）也不复杂，复杂的是后面纠葛的利益。经济危机袭扰人类将近 200 年了，解决的办法，无论是书面还是实战的都不少：\n\n希特勒的解决方式是寻求生存空间。从经济殖民地获得廉价的原材料，过剩的产品向经济殖民地倾销。\n凯恩斯的解决方式，是政府印钱，由政府创造需求。多余的产能浪费掉，资本家不是没钱不生产，不雇用工人吗？用印钞机给他们钱就是了。政府有印钞机还愁没钱支付？后果是通货膨胀或者资产泡沫。\n罗斯福的解决方案，是给工人更大的权利，支持他们与资本家斗争。增加财产税让稳拿出血，通过转移支付，给卢瑟更多的福利。\n\n这么多方法，多数效果都不好。这是因为稳拿处于塔尖的地位，直接调节总量而不触动分配模式的解决方案，不过是给稳拿更多的发财的机会，导致更严重的分配不公。如果触动分配模式，又难免遭到稳拿的强大阻碍，很可能半途而废。\n资产的属性对产来说，具体选择哪种方式，取决于哪种方式来钱最容易，或者说风险更小，效率更高。产是否发展生产，并不确定，是否会改善多数人的生活则更不确定。我们没有任何理由认为，产权明晰加自由市场经济一定会发展生产力，提供更多物美价廉的产品。\n对苏联这样的前社会主义国家来说，完全市场化和产权私有化（或者说产权明晰化）的结果，唯一能确定的就是私人产权迅速膨胀，出现一批人造寡头，其余的多数人则沦为这些寡头的奴隶。\n稳拿经济学追求帕累托最优，认为在这种情况下各种资源得到最有效地利用，紧缺资源获得最大价值。稳拿经济学认为，自由的市场，最终会达到帕累托最优：就是不可能再改善某些人的境况，而不使任何其他人受损。在市场中，社会的各类人群在不断追求自身利益最大化的过程中，可以使整个社会的经济资源得到最合理的配置。\n自由市场会导致帕累托最优，这是完全正确的。但是这种帕累托最优，却不是多数人之福—既不是卢瑟之福，也不是稳拿之福。自由的市场最终会造成财产的高度集中，拥有这些产的稳拿对社会总产品有极大的分配权。数量众多的卢瑟，却只有极其有限的分配权。所以，每次天下大乱以前，社会都处于或接近帕暴托最优的状态：不伤害地主的利益，农民就无法改着自己的生活，就要死于饥寒交迫，这时农民就不再尊重市场交易规则，采用暴力推翻产的权威。\n亚当斯密 &amp; 科斯亚当.斯密提出，个人满足私欲的活动将促进社会福利，只要自由放任，市场的看不见的手发挥作用，最终就将实现全社会的富足。科斯提出只要产权明晰，把一切交给市场中看不见的手来发挥作用；然后就能建立安宁祥和的社会，一切都会万事大吉。在斯密的时代，正是大饼迅猛变大的时代。那时资本主义刚刚登场不久，每一个资本家的资本量都很小，社会中还有大量封建残余。资本主义处于自由竟争时期，正在经历第一次产业革命，从手工作坊向大工厂过渡，劳动者还有当小老板或者当雇用工人的選擇。那时对产来说最有效率的自我增值的手段是发展生产力，资本主义相对封建残余来说极大地推动了生产力发展，所以这样说并不为过。经过200多年以后，到今天还这样说，那就是彻头彻尾的胡说了。\n稳拿经济学提出只要交易就能改善全社会的福利。卢瑟经济学认为改善福利的过程复杂得多。价值来自生产劳动，市场并不创造价值。个人也许可以通过炒房子炒地皮获得极大的收益，但是社会总体生活不会改善，因为总消费品的量，无论是产量，还是销售量都并没增加。\n可能存在大饼整体萎缩，大家吃得越来越少，某些个体却吃得越来越多的情况。\n资本论想说明的事情之一：工人创造的剩余价值越多，资本家的资产越多，工人与资本家之间差距不断拉大，最终成为资本的奴隶：死劳动（工人以前创造的剩余价值）牢牢抓住活劳动（工人）。\n产是什么：产是用于获得剩余价值依据的物化的媒介。人类社会总产品是块大饼，产是稳拿用来切大饼的刀。\n土地价格的攀升，不是土地自己产生价值，而是土地上产业资本不断壮大，地主要求其支付的贡税越来越多。如果土地上的产业萧条，土地价格必然暴跌。\n依靠土地获得剩余价值，是对资本主义的阻力而不是动力。土地所有权高度集中，产业资本家获得的利润太薄，他们很难有足够的剩余价值扩大再生产。此外，土地垄断会造成土地利润高于社会平均利润，资本家的剩余资本必然会选择投机土地，而不是投资于原料或设备进行扩大再生产。引申一步，如果土地成为资本的主体，那么社会必然停滞不前，甚至倒退。历史上，土地所有权高度集中的地区很难诞生资本主义。\n分配绝大多数的交易，不过是从甲账户转移到乙账户。如果我们把金融机构看为一个整体的话，就会发现几乎所有的货币都在金融机构的手里。\n资本主义世界的特点之一，就是强者恒强，这不仅仅表现在获得利润的时候强者有权先享用大饼，也表现在遇到危机的时候强者付出的代价更少。\n国家是经济上占统治地位的阶级进行阶级统治的政治权力机构。是一个成长于社会之中而又凌驾于社会之上的、以暴力或合法性为基础的、带有相当抽象性的权力机构。国家有阶级性，国家由经济上占优势地位的阶级控制。国家有暴力性，而且是最终的暴力。国家的存在是为了维护统治阶级的经济利益。国家是一个阶级压迫另一个阶级的机器，是使一切被支配的阶级受一个阶级控制的机器。\n由于暴力是唯一能对抗资本的要素，而代表国家行使暴力的官僚并不总是靠得住的。对资本来说，暴力的忠诚度是值得怀疑的。所以，资产阶级成为统治阶级以后，一直试图把国家的作用局限在最小的范围。对内保证社会治安，对外抵御外敌人侵，是资本主义国家的主要任务。至于维护社会的公平，扶助弱小，是资本家最忌讳的事情。\n如果所有的劳动者都去大学深造，最终的结果将是大学深造对提高工资收入水平的作用目益下降。\n产销过程消费与生产是对立统一的，没有消费，就不会有生产。我们无法想象一个社会开采矿石，制造机器，最终的目的仅仅是为了开采更多的矿石和制造更多的机器。生产的各种产品最终都会被消费。\n希望每当社会总需求不足的时候，就能出现新一轮技术革新导致投资高潮，进而消化掉多余产能，這是不现实的事情。\n资本家投资的目的是获得更多的货币。如果社会1000万资本的平均利润率是10%，那么资本家如果投入1000万购买新设备、雇用新工人，那么他必然要求 100 万的利润。换句话说，原先社会存在1000 万的需求不足的缺口，在资本家投资以后，1000万的缺口消失了。但是，在1000万的投资实现产能以后，就将出现1100 万的需求缺口。所以，长期靠资本家投资替代工人需求是不现实的。\n消费不足，并不见得是产业资本剥削得太严重，而是整个稳拿集团剥削得太严重。工人贡獻的剩余价值，在产业资本、土地，金融和暴力之间分配。\n如果大批企业贷款偿还能力都发生了回题，那么银行会发现自己几乎在一夜之间成为最大的实业资本家，大批的货币资本收不回來，变成抵押物。更糟糕的是，这些抵押物没有人要，而且在不断贬值。\n自从资本主义诞生起，尽管绝对消费水平不断上升，但是相对消费不足一直没有克服。\n垄断每次经济危机都会成为大资本屠杀小资本的过程。年次危机结束后所有的幸存者都有机会廉价获得遇难者的一切生产资源，包括原料、生产设备、熟练工，当然也包括他们的市场。\n自然界的进化，物种由多样归于多样，面人类社会资本的进化，最终归于“一”。这个过程是单向、清晰、不可逆的。\n如果把社会总生产看成一个庞大的网络，那么我们可以看到一些最基本的生产、生活要素在极少数企业的控制之下，这些企业就是真正的帝王资本。他们控制交叉的行业，影响、操纵整体经济。在他们之下，则是一些诸候。他们垄断本行业，影响、操纵某一种或几种商品。在这些诸侯之下，则是一些中、小资本，他们为上面帝王和诸候资本服务，是“臣民资本”。再向下，则是一些零散的资本，他们数量很多，充满帝王和诸候触角不愿触及的“鸡肋”行业，彼此之间激烈竟争。至于劳动力，则处于完全不入流的状态。\n垄断帝国则是在“暴力归公”的基础上，完全依靠财产的力量，在市场交易中逐步建立起来的。需要注意的是，这里的暴力的“归公”、是归资产阶级的“公”，而不是全民的“公”，这里的暴力，是资产阶级的暴力，这种暴力不在资产阶级内部使用，却不吝于镇压无产阶级。\n暴力和资本走到一起，有两种方式：资本领导暴力；暴力领导资本。两种方式的起源与各个资本主义国家历史进程有关。不论哪种方式，最终殊途同归：最终都將建立资本与暴力结合的密严阶级专政，这个专政將处于官僚统治集团的统治之下，如果我们认为垄断大企业的管理层也是一种准官僚集团的话。\n统治阶级争夺被统治阶级的时候，彼此是仇敌。一旦一方彻底认输，统治阶级内部的阶级感情又重新油然而生。\n并不是衣食足不足的问题，而是达到一个社会阶层之后，对普通劳动者紧缺的生活必需品，对某个阶层中人已经不再是紧缺的，而是极大丰富的。对普通人来说很珍贵的东西，对这个层次上的人来说，已经不值得为此发生冲突了。为这些基本生活必需品发生冲突，对这个层面的人来说，是丢脸的事情。这个层次的稳拿，在彼此谦逊礼貌的气氛中，瓜分着社会总产品的大饼。底层之间争斗的越激烈，顶层吃到的大饼份额越多。\n如果要维护人类社会系统的长期存在就必须从两个方面着手：第一，为领导阶层引入新鲜血液，避免小范围通婚造成的种群退化；第二，破解财富的单向流动过程，避免财富过度集中导致社会内部压力持续上升。\n由于强者恒强，任何人类社会的终极形态，不论是官僚主动或者资本家主动，地主主导或者奴隶主主导，如果不干涉的话，都是通往奴役之路。\n\n\n\n\n","tags":["读书","经济"]},{"title":"当测试代码使用随机生成的输入数据时，该如何去做出断言","url":"/blog/2023/03/18/generative-tests/","content":"一份有意思的代码最近看到了一份使用随机生成的数据作为测试输入的有趣代码，把其大致思路用伪代码描述如下 \n需要被测的实现代码function calculateSomething(inputData) &#123;    // 使用inputData来计算结果    // 假装这里有一些很复杂的逻辑    return result;&#125;\n\n这是被测的函数，在此不管它算的是什么，总之它接受input，返回result。\n测试代码的helpersfunction generateInputData()&#123;    // 用来生成测试所需的input数据    // 所生成的数据具有一定的随机性    return randomlyGeneratedInputData;&#125;fuction calculateExpectedResult(inputData)&#123;    // 用来计算assertion所需要的expected值    return expectedResult;&#125;\n\n这是测试代码的helper函数，一个用来生成测试所需的input，一个用来计算expected的值。\n测试代码var repeatTimes = 100; //总之是一个较大的数字，不一定非得是100for (i=0; i&lt;repeatTimes; i++)&#123;    var randomInputData = generateInputData(); //生成具有一定随机性的输入    var expected = calculatedExpectedResult(randomInputData); //用测试helper算出expected    var actual = calculateSomething(randomInputData); //用被测方法算出actual    expect(actual).toEqual(expected); //断言二者相等&#125;\n\n这是测试代码，反复运行多次，每次都生成具有随机性的input，然后把input传递给calculatedExpectedResult和calculateSomething，最后断言二者返回值是一致的。\n这份代码和常见的测试不同，它使用的input data不是预先设定好的，而是运行时随机生成的。这也是它有趣的原因。\n如何解读测试结果通常来说，当测试通过时，它意味着针对给定的输入，程序给出了符合预期的输出。\n但是对于这一份代码来说，却并非如此。因为它的expected值是由一个helper函数计算得来，而非是一个已经被验证过是正确的值。\n那么，如果上述的测试代码能够执行通过，它是在传递什么信息给开发者呢？\n\n它意味着calculatedExpectedResult这个helper函数和calculateSomething这个被测函数之间，具有较高的相似性，二者针对多组一样的输入，可以给出一样的输出\n\n如果我们把repeatTimes的数值调到非常高，测试还能通过的话，那就说明calculatedExpectedResult这个helper函数和calculateSomething这个被测函数之间的相似性非常高，简直可以达到同卵双胞胎甚至是克隆体这种以假乱真的程度\n\n\n这是我们需要的吗？\n我们需要去探寻世界上是否存在那么一个函数，它的行为可以做到和calculateSomething极其贴近吗？\n我认为我们是不需要的。\n我们需要的是去验证calculateSomething的行为是符合预期的。而不是去验证我能写出另一个和它的行为很像的函数来。\n这就如同是：如果我去测试洗衣机的话，我希望验证的是某款洗衣机可以把衣服洗涤干净，并且不会损伤衣物。\n而不是希望验证存在另一台洗衣机和我手里这一台表现一样。\n要不然的话，我说不定会得到两台洗不干净衣服，还会损伤布料的洗衣机😄\n当测试代码使用随机生成的输入数据时，该如何去做出断言上面的代码虽然做的并不妥当，但是想要用随机生成的input数据去做测试其实并不是一个不合理的想法。\n当我们人工编制的测试数据对于整体样本空间来说显得太小时，用随机数据去作为input数据也是一个不错的补充。\n其关键在于，当我们给input引入了随机性的时候，我们该如何去assert其output是符合预期的？\n如果我们还是想要和常规测试一样，严格地去assert输出的值和预期相等，那么就会陷入上述代码的误区里。\n但是如果思路换一下，不一定非得强求能够严格地去assert输出的值和预期相等，而是去assert输出值符合一定的规则。这样，就无需在测试代码里重复去实现一遍，而只需要描述我们预期输入和输出之间符合哪种规则。\nProperty Based Testing而这，恰好就是Property Based Testing。\nProperty Based Testing是一种基于属性规约的测试方法，通过使用随机输入数据来验证程序的行为是否符合预期的属性规约。\n在 Property Based Testing 中，测试用例是基于属性规约自动生成的。\nProperty Based Testing 的基本流程如下：\n\n定义属性规约：定义程序的行为应该满足的属性规约，这些规约通常是通用的、可重用的、抽象的，而不是特定的测试用例。\n\n生成随机数据：通过随机数据生成器生成随机数据，并将随机数据输入到程序中。\n\n检查属性规约：将实际输出与定义的属性规约进行比较，如果程序的输出符合属性规约，则测试通过，否则测试失败。\n\n修复代码：如果测试失败，则需要对程序进行修复，直到程序能够符合所有属性规约。\n\n\n一些常用的 Property Based Testing 框架包括 QuickCheck、Hypothesis、ScalaCheck、fast-check 等。\n下面是一段使用Property Based Testing的样例代码：\nconst fc = require(&#x27;fast-check&#x27;);// Property-Based Testing，测试加法函数test(&#x27;加法满足交换律&#x27;, () =&gt; &#123;    fc.assert(fc.property(fc.integer(), fc.integer(), (x, y) =&gt; &#123;        return add(x, y) === add(y, x);    &#125;));&#125;);test(&#x27;加0不影响结果&#x27;, () =&gt; &#123;    fc.assert(fc.property(fc.integer(), (x) =&gt; &#123;        return add(x, 0) === x;    &#125;));&#125;);test(&#x27;正数加负数，结果小于原数&#x27;, () =&gt; &#123;    fc.assert(fc.property(fc.integer(1000, 1), fc.integer(-1, -1000), (x, y) =&gt; &#123;        return add(x, y) &lt; x;    &#125;));&#125;);test(&#x27;负数加正数，结果大于原数&#x27;, () =&gt; &#123;    fc.assert(fc.property(fc.integer(-1000, -1), fc.integer(1, 1000), (x, y) =&gt; &#123;        return add(x, y) &gt; x;    &#125;));&#125;);test(&#x27;负数加负数，结果小于原数&#x27;, () =&gt; &#123;    fc.assert(fc.property(fc.integer(-1000, -1), fc.integer(-1000, -1), (x, y) =&gt; &#123;        return add(x, y) &lt; x;    &#125;));&#125;);test(&#x27;正数加正数，结果大于原数&#x27;, () =&gt; &#123;    fc.assert(fc.property(fc.integer(1, 1000), fc.integer(1, 1000), (x, y) =&gt; &#123;        return add(x, y) &gt; x;    &#125;));&#125;);test(&#x27;任何数加自己，结果是两倍&#x27;, () =&gt; &#123;    fc.assert(fc.property(fc.integer(), (x) =&gt; &#123;        return add(x, x) === x * 2;    &#125;));&#125;);\n\n以上代码中所使用的fast-check(fc)会帮助我们生成大量的具有随机性的输入数据，但是我们并没有去assert add的返回值等于某个具体的数字，而是去判断add这个函数在其输入值符合特定规则时其返回值符合我们通过fc定义的规律。\n\n\n\n\n","tags":["testing"]},{"title":"Spring Integration JDBC分布式锁 - TTL","url":"/blog/2023/07/29/spring%20integration%20jdbc%20distributed%20lock/","content":"最近在项目中需要使用Spring Integration提供的基于JDBC实现的分布式锁。\n在实践的过程中，我们遇到了一些有趣的问题，现在在此记录和总结一下。\n一共遇到了两个问题，第一个和time to live有关，第二个还是和time to live有关。\n第一个问题：由于time to live默认值不够长而导致被动失去锁的问题sequenceDiagram\n\nactor event_initiator\nparticipant instance_1\nparticipant instance_2\n\nevent_initiator-&gt;&gt;instance_1: do something\n\nnote over instance_1: instance 1 获得了 lock\n\ninstance_1-&gt;&gt;instance_1: start doing its thing\n\nevent_initiator-&gt;&gt;instance_2: do another thing\n\nnote over instance_2: instance 2 等待 lock\nnote over instance_2: 等 ......\nnote over instance_2: 等 ......\n\nnote over instance_1: lock的超时时间TTL到，instance 1还没干完活，但是它失去了 lock&lt;br&gt;失去不同于主动release&lt;br&gt;失去lock后，instance 1还会继续干活&lt;br&gt;而这些活里面可能会有SQL写操作\n\nnote over instance_2: instance 2 获得了 lock\n\ninstance_2-&gt;&gt;instance_2: start doing its thing\n\nnote over instance_1,instance_2: 此时二者同时干活，有撞车的风险，因为二者干活的先后顺序没有保证&lt;br&gt; instance 1尚未把它干完活后才能确定的状态写入DB，而instance 2已经开始干活了\n\nnote over event_initiator,instance_2: 为了降低风险，可以： &lt;br&gt; ① 想办法尽量让instance 1能在超时前干完活 &lt;br&gt; ② 以防万一可以考虑在合适的时间节点延长锁的过期时间\n\n根据上图所示，我们有两个实例。\n事件的触发者首先让第一个实例去处理一个事件。第一个实例获取了一个锁并开始执行相应的任务。\n此时，事件的触发者又让第二个实例去处理另一个事件。第二个实例也想获取同一个锁，但由于第一个实例已经开始处理了，第二个实例无法获取锁，只能等待。\n在理想情况下，第一个实例会在完成任务后释放锁，然后第二个实例就可以获取锁并开始执行相应的任务，这样就不会有任何问题。\n但是，如果由于某种原因第一个实例处理任务的速度太慢，就会出现问题。\n因为Spring Integration JDBC分布式锁会遵循Time to Live的参数，该参数确定了在获取锁后最长可持有锁的时间。\n如果超出了这个时间，而另一个人想要获取该锁，则可以获取到锁。这是为了避免锁的持有者挂掉而导致其他人全部干等的防死锁机制。\n在这种情况下，就会有两个人同时运行。\n我们本意是让锁保护资源以避免同时访问，但在这种情况下，资源会被同时访问。\n如果这些访问中涉及到读取共享状态以决定后续行为以及写入其他人可能会读取的状态的操作，那么就会出现混乱。\n在这种情况下，我们可以选择进行两个操作。\n给time to live一个合理的值实际上，相当于需要对运行时间进行合理的估算，然后尽量将time to live设置为能够覆盖该估算值的数值。\n把这个估算出来的数字赋值给default lock repository的time to live就好了。\n/** * Specify the time (in milliseconds) to expire deadlocks. * @param timeToLive the time to expire deadlocks. */public void setTimeToLive(int timeToLive) &#123;\tthis.ttl = Duration.ofMillis(timeToLive);&#125;\n\nDefaultLockRepository\n选择在合适的时机renew即使我们进行了合理的估算，但这只是一个估计值，不是绝对精确的值。\n换言之，在某些情况下，运行时间仍可能延续到time to live过期之后，从而面临两个人同时访问的风险。\n为了避免这种情况，可以在适当的时候进行renew操作。\n例如，在执行耗时较长的操作之前调用lock registry的renewLock方法，这样就相当于在执行耗时较长的操作之前重新获取了一次锁。\npublic interface RenewableLockRegistry extends LockRegistry &#123;\t/**\t * Renew the time to live of the lock is associated with the parameter object.\t * The lock must be held by the current thread\t * @param lockKey The object with which the lock is associated.\t */\tvoid renewLock(Object lockKey);&#125;\nRenewableLockRegistry\n第二个问题：time to live对于运行在同一个进程中的两个线程来说是不会自动生效的sequenceDiagram\n\nactor event_initiator\nparticipant instance_1\nparticipant instance_2\n\nevent_initiator-&gt;&gt;instance_1: do something\n\nnote over instance_1: instance 1 获得了 lock\n\ninstance_1-&gt;&gt;instance_1: start doing its thing\n\nevent_initiator-&gt;&gt;instance_2: do another thing\n\nnote over instance_2: instance 2 等待 lock\nnote over instance_2: 等 ......\nnote over instance_2: 等 ......\n\nnote over instance_1:instance 1的当前线程由于某种原因卡死了，没机会释放锁\n\nnote over instance_1: lock的超时时间TTL到\n\nnote over instance_2: instance 2 获得了 lock\n\ninstance_2-&gt;&gt;instance_2: start doing its thing\n\nnote over event_initiator,instance_2: instance 1的线程由于某种原因卡死而没机会释放锁&lt;br&gt;在TTL过后instance 2可以拿到锁并做事&lt;br&gt;这是我们希望看到的事情，因为这样可以避免由于一个线程卡死不释放锁而导致别人干等的局面\n\n在上述图中，我们描述了两个实例，即在不同机器（或容器）上运行的两个不同Java进程。这是跨进程协作的情况，这正是我们需要分布式锁的主要原因。\n在这种场景下，time to live是有效的。它可以防止一个进程无法释放锁，从而导致其他进程一直等待锁而无法继续工作的局面的出现。\n在跨进程协作中，time to live可以发挥作用，那对于同一个进程中的两个线程，是否同样有效呢？\n从概念上来说，如果能将其设计成同样有效的，则可以减轻使用者的认知负担。\n但是，在Spring Integration JDBC的分布式锁实现中，time to live并不是这样的。它对于同一个Java进程中的两个线程来说是不会自动生效的。\n下面的图是一个它不会生效的具体例子。 \nsequenceDiagram\n\nactor event_initiator\n\nevent_initiator-&gt;&gt;instance_1: do something\n\ninstance_1-&gt;&gt;instance_1_thread_1: 分配工作给线程1\n\nnote over instance_1_thread_1: instance 1 - thread 1 获得了 lock\n\ninstance_1_thread_1-&gt;&gt;instance_1_thread_1: start doing its thing\n\nevent_initiator-&gt;&gt;instance_1: do another thing\n\ninstance_1-&gt;&gt;instance_1_thread_2: 分配工作给线程2\n\nnote over instance_1_thread_2: instance 1 - thread 2 等待 lock\nnote over instance_1_thread_2: 等 ......\nnote over instance_1_thread_2: 等 ......\n\nnote over instance_1_thread_1: thread 1由于某种原因卡死了，没机会释放锁\n\nnote over instance_1_thread_1: lock的超时时间TTL到\n\nnote over instance_1_thread_2: thread 2 仍然获获取不到 lock\nnote over instance_1_thread_2: 继续等也没用\n\n正如上图所示，第二个线程或同一个进程中的任何其他线程，即使继续等待锁，也无济于事。这也解释了time to live在这种情况下的无效性。\n这份代码可以重现上面两幅图所描述的场景\n要解决这种情况下的问题，则需要用到下面提到的这个expireUnusedOlderThan方法。\npublic interface ExpirableLockRegistry extends LockRegistry &#123;\t/**\t * Remove locks last acquired more than &#x27;age&#x27; ago that are not currently locked.\t * @param age the time since the lock was last obtained.\t * @throws IllegalStateException if the registry configuration does not support this feature.\t */\tvoid expireUnusedOlderThan(long age);&#125;\n\nExpirableLockRegistry \n如果一个Java进程中的一个线程因为某种原因卡死了，从而无法释放锁。在TTL过期之后，另一个线程在尝试获取同一个锁之前，可以调用expireUnusedOlderThan来强制释放该锁。然后再尝试获取锁，就可以成功获取并继续工作。\n为什么不把time to live设计的更具有概念上的一致性？当涉及到跨越两个进程时，time to live会发挥作用。但是对于同一个进程中的两个线程来说，time to live就不再有效。这种同一个概念在不同的场景下表现出不同的行为，缺乏概念上的一致性，这可能会增加使用者的认知负担。\n那Spring为什么要把它设计成这样呢？\n以下是我的解读：\n在分布式系统中，如果两个进程想要获得同一个锁，那么来得晚一些的进程实际上并不知道前一个进程目前处于什么状态，它是否已经死亡。在这种情况下，time to live成为了决策的唯一依据。如果time to live还没有过期，那么来得晚的进程认为它不应该获取该锁。一旦time to live过期，后续进程将把锁置于自己的控制之下，而不管前一个进程是否仍然活着。简而言之，由于缺少其他的决策依据，这种情况下只能选择依照time to live来简单粗暴的办事。\n然而，对于同一个进程中的两个线程来说，情况就不同了。它们共享同一块内存空间(从实现层面来讲，同一个进程中的两个线程是共享同一份registry和repository的)。如果后续线程发现前一个线程在TTL过后还没有释放锁，则默认认为前一个线程仍然有继续工作的能力，因此它默认不会强制抢占锁。除非他在TTL之后等过一段时间之后觉得等不及了，这时候他可以选择强制把锁抢过来。\n举个例子，就像在古代缺乏无线电通信的战争中。一支小队去执行任务，另一支小队待命。三个小时后，不论先前的小队是否成功，后续小队都必须出发参加战斗。因为除了这三个小时之外，你没有其他的决策依据。只要时间到了，我就开始行动。\n但是，如果是同一支小队中的两个士兵，后面的士兵实际上可以在目视距离内看到前面的士兵是否仍然在执行任务。因此，即便是战友行动太慢了，他也可以选择多等待一会，让前面的士兵可以继续完成任务。当然，如果后面的士兵等不及了，想要立即行动，他也可以选择这样做。在这种情况下，后面的士兵具有更多的决策依据，因此他可以选择多等待一段时间或立即采取行动。\n总结第一个问题：由于time to live默认值不够长，而导致在还不该失去锁的时间点上过早地失去了锁（防死锁机制过早地介入了），解决方法是把TTL设置的足够大，以及在合适的时机做renew从而避免过早地失去锁。\n第二个问题：time to live对于运行在同一个进程中的两个线程来说是不会默认生效的，从而导致应该失去锁的时间已经过了，但卡住的线程还没有释放锁，进而导致后续的线程拿不到锁的情况。解决方法是可以选择让同一个进程内的后来者线程使用expireUnusedOlderThan来强制剥夺锁(同一个进程中的两个线程，其中后来的那个具有更高的自由裁量权，不必只依据TTL一个指标来行事)。\nmindmap\n  root(Spring Integration JDBC Distributed Lock)\n    默认TTL太短\n        设置长一些\n        renew\n    卡死了，没机会释放锁\n        其它进程可以在TTL过后拿到锁\n        同一个进程内的其它线程可以选择使用expireUnusedOlderThan\n\n锁的事，该失去就失去，不失去也强制失去。\n锁的事，不该失去就不能失去，要失去也不许失去。\n\n\n\n\n\n","tags":["Java","分布式","锁"]},{"title":"内存涨上去不肯下来 - 未必是内存泄漏","url":"/blog/2023/08/26/not-mem-leak/","content":"在一个Kubernetes（K8s）集群中，部署了Prometheus和Grafana用于监控集群本身和应用的状态。\n在其中一个Java应用对应的Pod级别观察到了内存上升的现象。具体而言，当该应用刚启动时，内存占用并不高。如果不发送请求给应用，内存将保持在启动时的水平上。\n如果大量发送请求给应用并在短时间内持续发送，内存会迅速增加。这在一定程度上是正常的。\n一旦内存增加之后，即使停止发送请求和压力，内存使用也不会下降，一直保持在高峰水平。\n上面的状况是由Grafana中观察到的。\n观察到的现象看起来像是内存泄漏，但实际上并不一定是内存泄漏。\n原因有以下两点：\n1 在K8s中运行的Prometheus默认只使用了Node Exporter这意味着Prometheus收集的数据是从操作系统的角度来看进程的内存使用情况，而不是从Java虚拟机（JVM）进程内部观察。\n如果想要从JVM内部的视角观察堆内存的使用情况，例如堆的大小和使用情况，就需要让应用容器内包含有Prometheus的jmx exporter。\n2 关键是要观察堆内存的使用情况要检查和确诊Java应用的内存泄漏，不能仅仅从操作系统的角度观察整个进程的内存使用情况，认为内存没有释放就是泄漏。这种观察方式是不准确的。\n应该从JVM内部观察堆内存的使用情况，即使进行了垃圾回收（GC），堆内存仍然无法下降是一个明确的征兆。\n例如，堆使用量（heap usage）基本上接近堆大小（heap size），并且堆使用量出现了频繁的小锯齿波动，这基本上表明GC在尝试清理旧的内存，但无法成功清理，这就是比较明显的迹象了。\n因为JVM有时候不愿意释放从操作系统那里要来的内存。因此，仅仅根据从操作系统的角度观察内存是否增加而不下降来诊断为Java的内存泄漏是不准确的。\n\n\n\n\n","tags":["Java","jvm","内存"]},{"title":"Spring Integration JDBC分布式锁 - Transactions与Threads","url":"/blog/2023/12/25/spring-integration-jdbc-distributed-lock-with-transaction-and-threads/","content":"第一个问题：在多个线程中同时运行隔离级别为serializable的事务而导致的无法重试获取锁的问题Spring Integration JDBC分布式锁的实现会需要使用一个serializable级别的事务来获取锁。\n如果多个线程同时尝试获取锁，这些事务之间可能会出现顺序问题。\n具体而言，可能会遇到以下错误：\norg.postgresql.util.PSQLException: ERROR: could not serialize access due to read/write dependencies among transactions\n\n发生这样的问题其实也不可怕，因为JDBC锁会进行重试。\n然而，当使用JPA Transaction Manager时，由于某些异常类型的原因，JDBC锁无法在发生这种错误的情况下进行重试。\n可以在以下GitHub Issue中查看详细信息：https://github.com/spring-projects/spring-integration/issues/3733\n可以使用以下代码重现此问题：https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/service/Problem1Service.java\n使用Data Source Transaction Manager来workaround第一个问题可以明确指定让JDBC锁不使用JPA Transaction Manager，而是使用Data Source Transaction Manager来绕过此问题。\n具体代码请参考：https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/configs/CustomJDBCLockConfigs.java\n可以执行该代码以观察workaround的效果：https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/service/Problem1FixService.java\n第二个问题：在同一个线程中先使用JpaTransactionManager启动一个事务，然后尝试用DataSourceTransactionManager获取JDBC锁所导致的事务隔离级别变化的问题该问题的显著特征是：如果在一个方法上标注了@Transactional，然后在该方法内部先执行了一些JPA的SQL操作，然后再尝试获取JDBC分布式锁，就会出现无法更改事务隔离级别的问题。\n问题的关键在于并行流（parallel stream）并不总是仅利用其自己线程池中的线程，它也会利用当前线程。而恰好落在当前线程上的那一次尝试获取JDBC分布式锁的操作就会出现无法更改事务隔离级别的问题。\n这是因为我们用来解决第一个问题而引入的DataSourceTransactionManager的文档中提及它具有如下行为：\n\nNote: The DataSource that this transaction manager operates on needs to return independent Connections. The Connections typically come from a connection pool but the DataSource must not return specifically scoped or constrained Connections. This transaction manager will associate Connections with thread-bound transactions, according to the specified propagation behavior. It assumes that a separate, independent Connection can be obtained even during an ongoing transaction.\n\n可以通过以下代码观察parallel stream的行为：https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/TestParallelStreamThreads.java\n可以使用以下代码重现该问题：https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/service/Problem2Service.java\n第二个问题的不完善解决方法：强制parallel stream不使用当前线程在解决该问题的过程中，我尝试了一种不太明智的方法，在这里也记录一下。\n我最初的想法是，既然parallel stream会利用当前线程，从而导致落在当前线程上的那一次获取锁的操作失败，那么我干脆强制它不要使用当前线程。然而，这是一种非常简单粗暴的做法。\n尽管这样做可以成功获取JDBC锁，但它也会导致一部分SQL游离在事务之外执行。不仅仅是这个解决方法，上述的三份代码也都会有这个问题。\n不太理想的解决方法的代码如下：https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/service/Problem2BadFixService.java\n第二个问题的较优解决方法：缩小事务范围，避免将业务操作和获取JDBC锁的操作混合在同一个被@Transactional标注的方法内上述四份代码都存在一个共同的缺点，即@Transactional注解的范围太广。\n这容易导致JPA Transaction Manager的范畴以及用于获取JDBC分布式锁的Data Source Transaction Manager的范畴互相交叉。\n当这两者混在一起时，很容易出现DataSourceTransactionManager试图去改变一个已经被open过的transaction的隔离级别的问题。\n第二个问题的较优解决方法的代码请参考：https://github.com/cuipengfei/Spikes/blob/master/jpa/lock-transaction-threads/src/main/java/com/github/spring/example/service/Problem2GoodFixService.java\n用图来总结一下flowchart TD\n    \n    style dstm fill:lightgreen,stroke:#333,stroke-width:4px\n    style nrt fill:#FFCCCB,stroke:#333,stroke-width:4px\n\n    jl[JDBC分布式锁]\n    str[Serializable级别的事务]\n    mt[多个线程]\n    jtm[JPA Transaction Manager]\n    dstm[❤️Data Source Transaction Manager❤️]\n    nrt[🪳无法重试获取锁🪳]\n    se[Serialization Error]\n    se2[Serialization Error]\n\n    subgraph 在多个线程中同时运行隔离级别为serializable的事务而导致的无法重试获取锁的问题\n    jl--&gt;|默认使用|str\n    mt--&gt;|同时获取|jl\n    jl--&gt;|恰好用了|jtm\n    str--&gt;|容易撞车而导致|se\n    jtm--&gt;|hold不住|se\n    se--&gt;|从而导致|nrt\n    jl--&gt;|替换成使用|dstm\n    dstm--&gt;|可以hold住|se2\n    se2--&gt;|从而解决|nrt\n    end\n\nflowchart TD\n    \n    style nd fill:lightgreen,stroke:#333,stroke-width:4px\n    style ile fill:#FFCCCB,stroke:#333,stroke-width:4px\n\n    st[同一个线程中]\n    t[事务]\n    t2[事务]\n    tm[一个范围很宽的标注了@Transactional的方法]\n    js[JPA的SQL操作]\n    tl[获取JDBC分布式锁]\n    js2[JPA的SQL操作]\n    tl2[获取JDBC分布式锁]\n    ps[Parallel Stream]\n    op[其自己线程池中的线程]\n    ct[当前线程]\n    ile[🪳无法更改事务隔离级别的问题🪳]\n    nd[❤️正确做法应该是缩小@Transactional的范围❤️]\n\n    subgraph 在同一个线程中先使用JpaTransactionManager启动一个事务然后尝试用DataSourceTransactionManager获取JDBC锁所导致的事务隔离级别变化的问题\n    ps--&gt;|并不总是仅利用|op\n    ps--&gt;|也会利用|ct\n    ct--&gt;|那么就会在|st\n    st--&gt;|跑|tm\n    tm--&gt;|先执行了一些|js\n    tm--&gt;|然后再尝试|tl\n    js--&gt;|已经open了|t\n    tl--&gt;|再去试图更改其隔离等级|t\n    t--&gt;|从而导致|ile\n\n    nd--&gt;|可以及时关闭|t2\n    t2--&gt;|避免把二者混在一起|js2\n    t2--&gt;|避免把二者混在一起|tl2\n    js2--&gt;|从而避免|ile\n    tl2--&gt;|从而避免|ile\n    end\n\n补充Redis上面的问题都是由于业务代码和获取锁的代码二者同时依赖于同一个数据库。\n而Spring Integration的分布式锁除了可以使用JDBC，其实也可以使用Redis或其他底层技术。如果把上述代码中的JdbcLockRegistry全部替换为RedisLockRegistry，而保持其它代码不变，所有错误都会消失，不会再重现。\n因为无论用到了哪一个线程，哪一个DB Transaction，也无论@Transactional标记的宽或者窄，Redis总是不会和JDBC&#x2F;DB撞车的。\n可以通过修改上述代码中的此处来试用Redis：https://github.com/cuipengfei/Spikes/blob/c887a6f802bbfffc45ee29cbb91dac731243b7cd/jpa/lock-transaction-threads/src/main/resources/application.properties#L17-L18\nSpring Boot 3如果升级到Spring Boot 3.1.5 + JDK 17，则Spring Integration JDBC会升到6.1.4(上述代码用的是5.x)，甚至不用替换成Data Source Transaction Manager，上述问题也会消失。\n因为这一版本的Spring Integration JDBC的分布式锁实现在acquire lock时不再使用serializable的事务，而是改成了read committed。\n这样，自然就规避了第一个问题，不再有serializable事务撞车。\n而由于不再需要给锁使用Data Source Transaction Manager，自然也就解决了第二个问题，不再有同一个线程上两个transaction managers打架的问题。不过，即便如此，缩小@Transactional的范围仍然是值得建议的。\n\n\n\n\n","tags":["Java","分布式","锁"]},{"title":"解决 LibreOffice 导出Excel 到 PDF 超链接丢失问题","url":"/blog/2024/07/28/libre-jod-single-page-excel/","content":"问题描述在使用LibreOffice的Calc组件将电子表格导出为PDF文件时，如果启用了“Whole sheet export”（整页导出）选项，导出的PDF文件中的超链接将不会保留原始的URL，而是显示为本地文件路径。\n这个问题在\n\nLibreOffice 官方论坛上的提问\nStack Overflow 上的提问\n\n上都有讨论。\n解决思路为了解决这个问题，我们考虑使用LibreOffice的UNO API来实现一个自定义的解决方案。这个方案的核心思想是：\n\n遍历Calc文档中的每个工作表。\n计算每个工作表内容适应一页所需的总宽度和高度。\n根据这些尺寸为每个工作表生成自定义的纸张大小。\n使用自定义纸张大小导出PDF，同时确保不使用“Whole sheet export”选项，以保留超链接。\n\nExcelSinglePageFilter解决方案针对上述问题，ExcelSinglePageFilterJava类实现了自定义的PDF导出过滤器。\n以下是该过滤器如何解决问题的详细解析。\n过滤器初始化与文档检查ExcelSinglePageFilter首先检查传入的文档是否为Excel文档。如果不是，它将直接调用链式调用chain.doFilter继续处理。\nXSpreadsheetDocument xSpreadsheetDocument = queryInterface(XSpreadsheetDocument.class, document);if (xSpreadsheetDocument == null) &#123;    chain.doFilter(context, document);    return;&#125;\n\n工作表遍历与处理接着，该过滤器遍历所有工作表，并为每个工作表异步执行调整操作。对于隐藏的工作表，它将跳过处理。\nString[] sheetNames = xSpreadsheetDocument.getSheets().getElementNames();CompletableFuture[] futures = Arrays.stream(sheetNames).map(sheetName -&gt; CompletableFuture.runAsync(() -&gt; &#123;    // ... 省略部分代码 ...    adjustOneSheet(sheetName, sheet, xPageStyles);&#125;)).toList().toArray(new CompletableFuture[0]);\n\n处理每个工作表对于每个工作表，代码首先检查工作表是否可见，然后计算工作表的总宽度和高度，包括单元格和图形对象。\nprivate static void adjustOneSheet(String sheetName, XSpreadsheet sheet, XNameAccess xPageStyles) &#123;    // 计算工作表的总宽度和高度    int totalWidth = getTotalWidth(getxColumnRowRange(sheet), getLastColumn(sheet));    int totalHeight = getTotalHeight(getxColumnRowRange(sheet), getLastRow(sheet));    // 包括图形对象的尺寸    Size graphicalSize = getGraphicalObjectsSize(sheet);    totalWidth = Math.max(totalWidth, graphicalSize.Width);    totalHeight = Math.max(totalHeight, graphicalSize.Height);    // 设置页面样式属性    XPropertySet xPageStyleProps = getPageStyleProps(sheet, xPageStyles);    xPageStyleProps.setPropertyValue(&quot;Size&quot;, new Size(totalWidth, totalHeight));    setMarginToZero(xPageStyleProps);    xPageStyleProps.setPropertyValue(&quot;ScaleToPages&quot;, (short) 1);&#125;\n\n计算图形对象尺寸getGraphicalObjectsSize方法用于计算工作表中所有图形对象所占的最大宽度和高度。\nprivate static Size getGraphicalObjectsSize(XSpreadsheet sheet) &#123;    XDrawPageSupplier drawPageSupplier = queryInterface(XDrawPageSupplier.class, sheet);    XDrawPage drawPage = drawPageSupplier.getDrawPage();    int count = drawPage.getCount();    int maxWidth = 0;    int maxHeight = 0;    for (int i = 0; i &lt; count; i++) &#123;        XShape shape = queryInterface(XShape.class, drawPage.getByIndex(i));        Point position = shape.getPosition();        Size size = shape.getSize();        maxWidth = Math.max(maxWidth, position.X + size.Width);        maxHeight = Math.max(maxHeight, position.Y + size.Height);    &#125;    return new Size(maxWidth, maxHeight);&#125;\n\n计算总宽度和总高度getTotalWidth和getTotalHeight方法分别用于计算工作表的总宽度和总高度。\nprivate static int getTotalWidth(XColumnRowRange columnRowRange, int endColumn) &#123;    int totalWidth = 0;    for (int j = 0; j &lt;= endColumn; j++) &#123;        Object column = columnRowRange.getColumns().getByIndex(j);        XPropertySet columnProps = queryInterface(XPropertySet.class, column);        totalWidth += (int) columnProps.getPropertyValue(&quot;Width&quot;);    &#125;    return totalWidth;&#125;private static int getTotalHeight(XColumnRowRange columnRowRange, int endRow) &#123;    int totalHeight = 0;    for (int i = 0; i &lt;= endRow; i++) &#123;        Object row = columnRowRange.getRows().getByIndex(i);        XPropertySet rowProps = queryInterface(XPropertySet.class, row);        totalHeight += (int) rowProps.getPropertyValue(&quot;Height&quot;);    &#125;    return totalHeight;&#125;\n\n完成导出最后，等待所有异步任务完成后，调用链式调用chain.doFilter继续执行标准的PDF导出流程。\nCompletableFuture.allOf(futures).join();chain.doFilter(context, document);\n\n代码链接上述解决方案的原始代码可以在GitHub上找到，链接为：\nhttps://github.com/cuipengfei/jodconverter-samples/blob/main/samples/spring-boot-rest/src/main/java/org/jodconverter/sample/rest/ExcelSinglePageFilter.java\n总结ExcelSinglePageFilter通过自定义的PDF导出逻辑，成功避免了使用“Whole sheet export”选项，从而解决了超链接在PDF中丢失的问题。这种方法不仅保留了超链接的完整性，而且还提供了一种灵活的方式来调整每个工作表的显示尺寸，确保它们在PDF中以单页的形式呈现。\n\n\n\n\n","tags":["LibreOffice","PDF","JODConverter"]},{"title":"如何给 GitHub Copilot \"洗脑”，让 AI 精准遵循指令产出高质量代码","url":"/blog/2025/06/17/how-to-brainwash-copilot-to-follow-orders/","content":"引子：把 AI 新兵改造成精锐士兵GitHub Copilot 就像一个天赋异禀但野路子出身的“新兵”。它枪法精准（编码能力强），但缺乏战场纪律（工程规范）。\n你让它冲锋，它能迅速拿下山头，但阵地上一片狼藉：没有构筑工事（错误处理），不关心侧翼安全（边界情况），弹药随意堆放（命名混乱）。\n我们需要的不是一个只会冲锋的“莽夫”，而是一个懂得协同作战、遵守战场纪律的“精锐士兵”。因此，我决定为它编写一套严格的“作战条令”（Prompts），对它进行一次彻底的“军事化改造”，让它乖乖听话。\n不是魔法，是系统指令经过一段时间的研究和实践，我发现 Copilot 这类 AI 工具实际上可以被深度”引导”，甚至达到一种”洗脑”的效果，让它们按照我们的意愿来行动。\n它们并不是魔术盒子，而是遵循一套输入-输出原则的系统。如果我们能给它提供明确的指导和原则，它就能相应地调整自己的输出。\n这个思路促使我整理了一个专门用来给 GitHub Copilot”洗脑”的指令集：prompts。\n这个仓库里不是代码，而是一系列指导 AI 行为的 Markdown 文件。每个文件就像是给 AI 的一份规范或指南，告诉它应该怎样思考和行动。\n这套指令能解决什么问题？使用 AI 编程助手时，我们通常会遇到这些问题：\n\n生成的代码能运行，但结构混乱，难以维护\n没有考虑边界情况和异常处理\n代码风格不一致，命名随意\n缺乏适当的测试覆盖\n不遵循项目已有的架构模式\n\n这套指令集就是为了解决这些问题而设计的。它告诉 AI 该如何思考软件设计、如何编写清晰的代码、如何进行测试驱动开发，以及如何分解复杂问题。\n指令集的构成整个指令集分为几个主要部分：\n\n核心行为定义：这部分告诉 AI 应该如何进行思考和工作，包括：\n\n如何保持项目知识的连贯性（memory-bank）\n如何有条理地回应用户（response-and-prompt-guidelines）\n如何遵循 TDD 工作流（programming-workflow）\n如何分解复杂任务（workflow-and-task-splitting）\n\n\n代码质量规范：这部分告诉 AI 什么是好代码，什么是坏代码：\n\n代码标准和最佳实践（code-standards）\n代码异味和应避免的反模式（avoid-bad-smells）\n如何编写有效的测试（testing-guidelines）\n\n\n流程模板：这部分提供了从需求到实现的结构化方法：\n\n如何将模糊的想法转化为明确的计划（req）\n如何协助业务分析师编写用户故事（ba）\n\n\n工具使用指南：这部分包含了一些高级技巧：\n\n如何使用顺序思考解决问题（sequential-thinking）\n快捷指令系统（shortcut-system-instruction）\n\n\n\n这些“作战条令”是如何生效的？你可能会好奇，为什么几份 Markdown 文件就能驯服一个复杂的 AI？\n其根本原因在于，我们利用了大型语言模型的一个核心特性：它是一个基于上下文的、概率性的序列生成器。它本身没有真正的“理解”或“意识”，它的所有行为都是在预测“在当前上下文中，下一个最可能的词是什么”。\n因此，这套指令的本质，就是一场**“上下文污染”（Context Contamination），或者说“概率空间操纵”（Probability Space Manipulation）**。\n通过在它的工作环境中注入一套强有力的、结构化的规则（我们的“作战条令”），我们极大地改变了它进行概率计算的“初始条件”。当“编写单元测试”、“考虑异常”这些概念在上下文中被反复强调时，生成符合这些规范的代码的概率就被显著提高了。\n我们不是在“教”它，而是在塑造一个让它“不得不”表现得更专业的环境。\n这套“作战条令”的核心，就是用规则约束 AI 的“自由意志”：\n\n“慢思考”条令，强制它在行动前必须进行“沙盘推演”（展示思考过程）。\n“自我批判”条令，要求它在每次“战斗”后必须提交“战后复盘报告”（自我评估）。\n结构化的模板，则像是规定了标准的“军事作业程序”（SOP），确保它在任何情况下都能做出标准、可靠的战术动作。\n\n说白了，这套指令的核心就是不让 AI “想当然”。它必须按照预设的流程来工作，该问的问题不能跳过，该考虑的边界情况不能遗漏。\n如何在实际工作中使用这套指令经过实践，我发现在 VS Code 中配置 Copilot 使用这些指令非常简单：\n\n打开 VS Code 设置（Ctrl+, 或 Cmd+,）\n搜索 github.copilot.chat.codeGeneration.instructions\n添加指向指令文件的配置，例如：\n\n&quot;github.copilot.chat.codeGeneration.instructions&quot;: [    &#123; &quot;text&quot;: &quot;避免生成与公共代码完全匹配的代码&quot; &#125;,    &#123; &quot;file&quot;: &quot;../prompts/.github/instructions/req.md&quot; &#125;,    &#123; &quot;file&quot;: &quot;../prompts/.github/instructions/ba.md&quot; &#125;,    // 其它指令文件...    &#123; &quot;file&quot;: &quot;../prompts/.github/instructions/shortcut-system-instruction.md&quot; &#125;]\n\n需要注意的是，文件路径要正确。这里的路径是相对于你的 workspace 的。如果你的 prompts 仓库和当前项目不在同一位置，可能需要调整路径。\n设置完成后，你会发现 Copilot 生成的代码质量明显提升：更规范、更健壮、考虑更周全。\n一点思考：我们究竟在训练谁？为 AI 制定“作战条令”的过程，其实和带新人有些相似 —— 你需要清晰地表达期望，提供良好的指导和范例，然后持续进行纠正和反馈。\n但更有趣的是，这个过程在某种程度上也是对我们自己的“训练”。为了能给 AI 写出清晰的指令，我们必须首先在自己脑中将“好的代码”、“好的设计”、“好的流程”这些模糊的概念给形式化、结构化。\n我们究竟是在训练 AI，还是在通过训练 AI 的过程，强迫自己进行更深层次的思考，从而成为更好的工程师？\n这套指令系统的价值，或许不仅在于提升了 AI 的输出质量，更在于它像一面镜子，照见了我们自身在软件工程实践中的知识盲区，并促使我们去填补它。\n\n如果你也在使用 AI 编程助手，不妨试试这套“作战条令”。如果有任何想法或改进建议，欢迎到 prompts 仓库提交 PR 或 Issue。\n\n\n\n\n","categories":["技术思考"],"tags":["AI","GitHub Copilot","软件开发","代码质量","提示工程"]},{"title":"AI 时代，我们是在写代码，还是在“写知识”？—— 极客时间 8x 课程笔记","url":"/blog/2025/06/28/geektime-8x-ai/","content":"\n本文是极客时间 8x 课程的读书笔记。我本想取名 G8 (Geekbang 8x)，但听起来不太对劲，所以就有了现在这个标题。\n\n\n“软件的价值，最终由其承载的知识决定。代码，只是这些知识的可执行形态。”\n\n\n引言：从“构建者”到“知识工程师”的身份转变我们习惯于将软件开发看作一种“建造”活动，谈论“构建”软件、“编写”代码。\n但随着 AI 大语言模型（LLM）的普及，我们或许需要换个角度审视自己的工作。\n如果说编码是软件开发的“最后一公里”，那在此之前的需求讨论、架构设计和技术选型，又是什么呢？\n这些过程，更像是一种知识的传递、提炼与组织。\n本文想探讨一个观点：在 AI 时代，软件工程的核心正从“构造软件”转向“管理知识”。\n这一转变，对我们的日常工作意味着什么？\n一、软件：一种可执行的知识让我们暂时抛开代码，思考软件的本质。\n\n软件是知识的载体：真正的“产品”，是软件中蕴含的业务逻辑、领域规则和架构决策。代码只是这些知识的最终表现形式。\n软件是知识的“可执行”形态：它让抽象的知识能够在现实世界中产生具体影响。\n软件开发的核心，是知识的获取、学习与传递：编码只是这一漫长知识旅程的最终环节。\n\n代码是最终产物，但真正的价值在于其背后的业务逻辑、领域规则和架构决策。这些才是软件的核心“知识”。\nLLM：认知杠杆，而非认知替代LLM 在这个新范式中扮演什么角色？它是一个强大的认知杠杆，极大地提升了知识转化为代码的效率，但它并未替代人类的认知过程。\n\n人的认知水平是协作的上限：人与 LLM 协作的最终产出质量，取决于人对问题的理解深度和判断力。\nLLM 的核心能力是基于上下文的理解与生成：通过提供精准的上下文，我们可以将其“调教”为特定领域的辅助专家。\nLLM 存在固有技术限制：\n上下文与 Token 限制，使其难以一次性处理庞杂的系统。\n“幻觉”现象，意味着其产出需要严格验证。\n\n\n\n因此，将 LLM 视为无所不能的“代码生成器”是一种误解。\n它的真正价值在于成为知识传递链条中的高效“处理器”，而我们则需要成为高效的“知识管理者”。\n二、知识工程：一种新的工作模式如果软件开发是知识工作，我们该如何实践？\n知识工程，可以理解为：将软件开发视为一个“提取、组织知识，使其能被 LLM 理解，并最终通过 LLM 将这些知识转化为可工作软件”的完整过程。\n这里的关键瓶颈，不再是编码速度，而是知识传递的效率与保真度。\n1. 知识与任务分离：与 LLM 精准对话与 LLM 交互时，清晰地分离**知识（背景信息）与任务（具体指令）**至关重要。这能帮助 LLM 建立正确的上下文，形成明确的关注点。\n坦白说，我最初也尝试过一种不太明智的方法：将一份长达数页的需求文档直接丢给 LLM，期望它能“一口吃成个胖子”，直接生成整个模块。结果可想而知，它要么陷入逻辑混乱，要么给出一堆看似正确却无法组合的“代码碎片”。\n这次失败让我意识到，与 LLM 协作，我们不能扮演“甩手掌柜”的角色，而必须成为一名**“知识主厨”**。我们需要亲手将大块的“需求原料”精心切分、预处理，才能让 LLM 这位“超级副厨”高效地烹饪出佳肴。\n例如，与其直接说“写一个登录函数”，不如先提供知识：\n\n知识（Context）：“系统使用 JWT 认证，密码采用 bcrypt 加密，用户信息存储在 users 表中。”\n任务（Task）：“基于以上信息，编写一个 login(username, password) 函数，验证成功后返回 JWT。”\n\n有趣的是，敏捷开发中的用户故事（User Story），恰好是一种优秀的知识管理工具。它天然地侧重于定义问题（“我是谁”、“我想要什么”、“为什么”），而非预设解决方案，这使其成为向 LLM 传递需求的理想形式。\n2. 通过反馈迭代：提炼隐性知识知识工程并非单向传递，而是一个双向的、迭代的探索过程。\n\n通过 LLM 的反馈来反思并修正我们对知识的描述，是知识工程的核心循环。\n\n我们可以将这个过程，比作请一位超级画师（LLM）为我们画一幅肖像画。我们与 LLM 的每一次交互，都是在向它描述自己的特征。当发现它画出的细节（生成的代码）有偏差时，问题往往不在于它的“画技”，而在于我们这位“模特”没有描述清楚自己的样貌。\nLLM 的“误解”就像一面镜子，忠实地反射出我们自身知识表达的模糊与缺漏。因此，这个迭代过程，与其说是“调试机器”，不如说是**“校准自我”**。它的最终目标是得到一幅双方都认可的、纤毫毕现的“知识蓝图”，而非仅仅“修复代码”。当 LLM 对你的描述产生“误解”时，我们首先要反思的是，自己对知识的表达是否足够清晰、准确。\n3. 驾驭不同类型的知识软件开发涉及的知识远非单一类型，我们必须学会驾驭它们：\n\n显式知识（Explicit Knowledge）：能够被清晰表达、记录和传播的”know-what”，如技术文档、业务规则。\n隐式知识（Implicit Knowledge）：尚未被记录，但可以通过交流和文档化转为显式知识。\n默会知识（Tacit Knowledge）：这是最宝贵也最难处理的部分。它是个人经验、直觉、技能的核心，是难以形式化的”know-how”。例如，一位资深架构师在众多方案中做出权衡的直觉，或是一位高级工程师对代码“坏味道”的敏锐嗅觉。定义问题通常比解决问题更难，而对问题的敏锐感知，正是默会知识的体现。\n\n为何同样的技术文档（显式知识）在不同人手中，会产生天壤之别的实现？\n为何有经验的工程师能在看似平静的代码中，直觉性地感知到潜在的设计缺陷？\n这些都体现了默会知识的核心价值。\n三、研发流程重塑：从代码管理到知识管理在新范式下，现有研发流程需要重构为以知识为中心的管理过程，其核心目标是从流程中捕获关键知识，并通过 LLM 有效沉淀。\n围绕“默会知识”的传递来构建流程，是实现知识工程的关键。\n1. 应用与提取“默会知识”\n应用知识：对于成熟的、有明确解决方案的问题（例如，为新项目搭建 CI&#x2F;CD 流水线），我们可以通过提示词模板对成熟的任务流程进行建模，高效应用那些已被充分学习的默会知识。\n提取知识：默会知识的提取，本质上是**提炼“思维链”（Chain of Thought, CoT）**的过程。通过鼓励 LLM 解释其推理过程，我们可以反向形式化那些隐性的专家经验。RAG（检索增强生成）等模式，同样有助于新知识的学习与提取。\n\n2. 应对认知偏差：先对齐思路，再写代码认知偏差是团队协作中的巨大障碍：不同成员对同一问题可能持有完全不同的假设和理解，导致共识难以形成。\n这种分歧的后果是：团队难以形成统一共识，讨论陷入循环，新人培养周期延长，系统设计出现不一致，引入大量隐蔽的质量缺陷。我们是否曾困惑，为何同样的技术讨论，有些团队能迅速聚焦并达成一致，而有些团队却在表面问题上争论不休？认知偏差往往是根源。\n知识工程强调先对齐思路，再动手编码。\n\n推行任务审查（Task Review）：将审查的重心从代码（Code Review）上移至任务本身，在编码前，就通过讨论、文档或图表，确保团队对“做什么”和“为什么做”达成一致。这看似增加了前期的沟通成本，但相较于修复因认知偏差导致的大量后期代码返工和隐蔽缺陷，这种“前期投入”的收益是巨大的。这是一种典型的“左移”（Shift-Left）思想在知识管理上的体现。\n建立认知行为基线：管理者应着力于建立团队统一的认知与行为基线，确保对问题的理解和处理方式有一致的标准。\n\n3. 混乱中的清醒：及时止损当个体或团队对问题感到混乱（Chaotic）——即无法理解问题、被恐慌驱动而盲目行动时，任何试图“解决”问题的努力都可能加剧混乱。\n此时，理性地及时止损，暂停行动，回归问题的澄清与理解，是避免大量返工的明智选择。\n四、任务划分与质量内建：新范式下的交付关键1. 任务划分：与 LLM 协作的“接口”由于 LLM 的技术限制，需求必须被分解为足够小的、原子化的任务，才能转化为高质量的提示词。这个过程并非随意的拆分，而需同时兼顾软件架构与测试策略。\n可测试性（Testability）是进程内架构最重要的属性之一。一个好的任务划分，本身就应该导向一个易于测试的实现。\n2. 质量控制优先于生成效率在 LLM 辅助开发中，我们的精力分配需要发生根本转变：将更多精力投入质量控制，而非一味追求生成效率。\n反馈循环的瓶颈在于如何高效验证 LLM 生成结果的正确性与有效性。因此，我们必须大力倡导**内建质量（Build Quality In）**的理念，通过测试驱动（TDD&#x2F;BDD）来提炼需要给予 LLM 的精准反馈，而非仅仅依赖于编码后的手动调试。\n我们应当转变思维，从”如何修复 LLM 生成的错误代码”到”如何设计流程，使 LLM 更容易生成正确代码”。\n当我们过于关注生成速度时，往往因大量调试修复而降低总体效率；而当我们专注于质量时，整体进度反而可能加快。\n这是否意味着，在 AI 时代，“慢即是快”可能成为新的工程法则？\n五、工程师的转型：从“编码者”到“知识工程师”这场范式转型，最终将重塑工程师的核心价值。\n\n角色转变：从专注于编码实现的**“编码者”（Coder），转向侧重于知识管理、任务分解与验证的“知识工程师”（Knowledge Engineer）。对纯粹编码技能的要求或许会降低，但对知识提炼、系统思考、质量保障**等能力的要求将显著提升。\n技能重组正在发生：\n\n知识提炼能力：从复杂、模糊的业务需求中提取清晰、结构化的知识。\n系统性思考：在碎片化任务中保持整体视角，确保局部解决方案符合全局最优。\n元认知水平：对自身思考过程的觉察、监控与调整能力。\n跨学科整合：将技术、业务、用户体验等多维度知识有机融合。\n\n\n核心价值：工程师的核心价值，在于为 LLM 提供足够丰富且精准的上下文信息——这包括功能需求、业务知识、架构决策、测试策略等一切关乎“生产正确代码”的关键信息。\n\n\n我们的关注点，正从“如何构造软件”，历史性地转向**“如何提取和组织知识，让知识变成 LLM 能够理解的形式”**。\n从这个角度看，“提示词工程”的本质，是如何精准地组织与表达知识。\n因此，“知识工程”，或许是一个更合理、也更深刻的名称。\n结语AI 时代的软件开发，核心挑战从编码转向了知识管理。掌握好知识提炼、任务分解和质量控制这些技能，将是工程师适应新环境的关键。\n\n\n      {\"content\":\"AI &#x65f6;&#x4ee3;&#xff1a;&#x8f6f;&#x4ef6;=&#x77e5;&#x8bc6;&#x5de5;&#x7a0b;\",\"children\":[{\"content\":\"&#x5f15;&#x8a00;\",\"children\":[{\"content\":\"&#x8f6f;&#x4ef6;&#x5f00;&#x53d1;&#x672c;&#x8d28;&#x662f;&#x77e5;&#x8bc6;&#x4f20;&#x9012;&#x4e0e;&#x7ec4;&#x7ec7;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"9,10\"}},{\"content\":\"AI &#x4fc3;&#x4f7f;&#x5de5;&#x7a0b;&#x5e08;&#x4ece;&#x201c;&#x6784;&#x5efa;&#x8005;&#x201d;&#x8f6c;&#x5411;&#x201c;&#x77e5;&#x8bc6;&#x5de5;&#x7a0b;&#x5e08;&#x201d;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"10,12\"}}],\"payload\":{\"tag\":\"h2\",\"lines\":\"7,8\"}},{\"content\":\"&#x8f6f;&#x4ef6;&#x672c;&#x8d28;\",\"children\":[{\"content\":\"&#x8f6f;&#x4ef6;&#x662f;&#x4e1a;&#x52a1;&#x4e0e;&#x67b6;&#x6784;&#x77e5;&#x8bc6;&#x7684;&#x53ef;&#x6267;&#x884c;&#x8f7d;&#x4f53;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"14,15\"}},{\"content\":\"&#x4ee3;&#x7801;&#x53ea;&#x662f;&#x77e5;&#x8bc6;&#x7684;&#x6700;&#x7ec8;&#x8868;&#x73b0;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"15,16\"}},{\"content\":\"&#x5f00;&#x53d1;&#x6838;&#x5fc3;&#x662f;&#x77e5;&#x8bc6;&#x7684;&#x83b7;&#x53d6;&#x3001;&#x5b66;&#x4e60;&#x4e0e;&#x4f20;&#x9012;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"16,18\"}}],\"payload\":{\"tag\":\"h2\",\"lines\":\"12,13\"}},{\"content\":\"&#x77e5;&#x8bc6;&#x5de5;&#x7a0b;\",\"children\":[{\"content\":\"&#x5173;&#x952e;&#x74f6;&#x9888;&#x662f;&#x77e5;&#x8bc6;&#x4f20;&#x9012;&#x6548;&#x7387;&#x4e0e;&#x4fdd;&#x771f;&#x5ea6;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"20,21\"}},{\"content\":\"&#x660e;&#x786e;&#x533a;&#x5206;&#x77e5;&#x8bc6;&#xff08;&#x80cc;&#x666f;&#xff09;&#x4e0e;&#x4efb;&#x52a1;&#xff08;&#x6307;&#x4ee4;&#xff09;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"21,22\"}},{\"content\":\"&#x7528;&#x6237;&#x6545;&#x4e8b;&#x662f;&#x7406;&#x60f3;&#x7684;&#x77e5;&#x8bc6;&#x7ba1;&#x7406;&#x5de5;&#x5177;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"22,23\"}},{\"content\":\"&#x901a;&#x8fc7;&#x53cd;&#x9988;&#x8fed;&#x4ee3;&#x63d0;&#x70bc;&#x9690;&#x6027;&#x77e5;&#x8bc6;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"23,24\"}},{\"content\":\"&#x9a7e;&#x9a6d;&#x663e;&#x5f0f;&#x3001;&#x9690;&#x5f0f;&#x3001;&#x9ed8;&#x4f1a;&#x4e09;&#x7c7b;&#x77e5;&#x8bc6;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"24,26\"}}],\"payload\":{\"tag\":\"h2\",\"lines\":\"18,19\"}},{\"content\":\"&#x6d41;&#x7a0b;&#x91cd;&#x5851;\",\"children\":[{\"content\":\"&#x4ee5;&#x77e5;&#x8bc6;&#x4e3a;&#x4e2d;&#x5fc3;&#x91cd;&#x6784;&#x7814;&#x53d1;&#x6d41;&#x7a0b;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"28,29\"}},{\"content\":\"&#x6d41;&#x7a0b;&#x9700;&#x6355;&#x83b7;&#x5e76;&#x6c89;&#x6dc0;&#x5173;&#x952e;&#x77e5;&#x8bc6;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"29,30\"}},{\"content\":\"&#x9ed8;&#x4f1a;&#x77e5;&#x8bc6;&#x4f20;&#x9012;&#x662f;&#x6d41;&#x7a0b;&#x8bbe;&#x8ba1;&#x5173;&#x952e;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"30,31\"}},{\"content\":\"&#x5e94;&#x7528;&#xff1a;&#x7528;&#x6a21;&#x677f;&#x9ad8;&#x6548;&#x590d;&#x7528;&#x6210;&#x719f;&#x77e5;&#x8bc6;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"31,32\"}},{\"content\":\"&#x63d0;&#x53d6;&#xff1a;&#x9f13;&#x52b1;&#x601d;&#x7ef4;&#x94fe;&#xff0c;&#x53cd;&#x5411;&#x5f62;&#x5f0f;&#x5316;&#x4e13;&#x5bb6;&#x7ecf;&#x9a8c;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"32,33\"}},{\"content\":\"&#x5148;&#x5bf9;&#x9f50;&#x601d;&#x8def;&#xff0c;&#x518d;&#x5199;&#x4ee3;&#x7801;&#xff0c;&#x63a8;&#x884c;&#x4efb;&#x52a1;&#x5ba1;&#x67e5;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"33,34\"}},{\"content\":\"&#x5efa;&#x7acb;&#x56e2;&#x961f;&#x8ba4;&#x77e5;&#x884c;&#x4e3a;&#x57fa;&#x7ebf;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"34,35\"}},{\"content\":\"&#x6df7;&#x4e71;&#x65f6;&#x53ca;&#x65f6;&#x6b62;&#x635f;&#xff0c;&#x56de;&#x5f52;&#x6f84;&#x6e05;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"35,37\"}}],\"payload\":{\"tag\":\"h2\",\"lines\":\"26,27\"}},{\"content\":\"&#x4efb;&#x52a1;&#x4e0e;&#x8d28;&#x91cf;\",\"children\":[{\"content\":\"&#x9700;&#x6c42;&#x9700;&#x539f;&#x5b50;&#x5316;&#xff0c;&#x4fbf;&#x4e8e; LLM &#x7406;&#x89e3;&#x4e0e;&#x751f;&#x6210;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"39,40\"}},{\"content\":\"&#x4efb;&#x52a1;&#x5212;&#x5206;&#x9700;&#x517c;&#x987e;&#x67b6;&#x6784;&#x4e0e;&#x6d4b;&#x8bd5;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"40,41\"}},{\"content\":\"&#x53ef;&#x6d4b;&#x8bd5;&#x6027;&#x662f;&#x67b6;&#x6784;&#x6838;&#x5fc3;&#x5c5e;&#x6027;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"41,42\"}},{\"content\":\"&#x8d28;&#x91cf;&#x63a7;&#x5236;&#x4f18;&#x5148;&#x4e8e;&#x751f;&#x6210;&#x6548;&#x7387;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"42,43\"}},{\"content\":\"&#x53cd;&#x9988;&#x5faa;&#x73af;&#x74f6;&#x9888;&#x5728;&#x4e8e;&#x9ad8;&#x6548;&#x9a8c;&#x8bc1;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"43,44\"}},{\"content\":\"&#x63a8;&#x5d07;&#x5185;&#x5efa;&#x8d28;&#x91cf;&#xff08;TDD/BDD&#xff09;&#xff0c;&#x7cbe;&#x51c6;&#x53cd;&#x9988;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"44,46\"}}],\"payload\":{\"tag\":\"h2\",\"lines\":\"37,38\"}},{\"content\":\"&#x5de5;&#x7a0b;&#x5e08;&#x8f6c;&#x578b;\",\"children\":[{\"content\":\"&#x89d2;&#x8272;&#xff1a;&#x4ece;&#x7f16;&#x7801;&#x8005;&#x5230;&#x77e5;&#x8bc6;&#x5de5;&#x7a0b;&#x5e08;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"48,49\"}},{\"content\":\"&#x80fd;&#x529b;&#x91cd;&#x7ec4;&#xff1a;\",\"children\":[{\"content\":\"&#x77e5;&#x8bc6;&#x63d0;&#x70bc;&#xff1a;&#x7ed3;&#x6784;&#x5316;&#x590d;&#x6742;&#x9700;&#x6c42;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"50,51\"}},{\"content\":\"&#x7cfb;&#x7edf;&#x6027;&#x601d;&#x8003;&#xff1a;&#x5168;&#x5c40;&#x89c6;&#x89d2;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"51,52\"}},{\"content\":\"&#x5143;&#x8ba4;&#x77e5;&#xff1a;&#x81ea;&#x6211;&#x89c9;&#x5bdf;&#x4e0e;&#x8c03;&#x6574;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"52,53\"}},{\"content\":\"&#x8de8;&#x5b66;&#x79d1;&#x6574;&#x5408;&#xff1a;&#x878d;&#x5408;&#x6280;&#x672f;&#x3001;&#x4e1a;&#x52a1;&#x3001;&#x4f53;&#x9a8c;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"53,54\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"49,54\"}},{\"content\":\"&#x6838;&#x5fc3;&#x4ef7;&#x503c;&#xff1a;&#x4e3a; LLM &#x63d0;&#x4f9b;&#x4e30;&#x5bcc;&#x7cbe;&#x51c6;&#x4e0a;&#x4e0b;&#x6587;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"54,55\"}},{\"content\":\"&#x5173;&#x6ce8;&#x70b9;&#x8f6c;&#x5411;&#x77e5;&#x8bc6;&#x7ec4;&#x7ec7;&#x4e0e;&#x8868;&#x8fbe;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"55,57\"}}],\"payload\":{\"tag\":\"h2\",\"lines\":\"46,47\"}},{\"content\":\"&#x7ed3;&#x8bed;\",\"children\":[{\"content\":\"&#x77e5;&#x8bc6;&#x59cb;&#x7ec8;&#x662f;&#x8f6f;&#x4ef6;&#x6838;&#x5fc3;&#x4ef7;&#x503c;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"59,60\"}},{\"content\":\"&#x6709;&#x6548;&#x4f20;&#x9012;&#x4e0e;&#x7ec4;&#x7ec7;&#x77e5;&#x8bc6;&#x51b3;&#x5b9a;&#x6210;&#x8d25;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"60,61\"}},{\"content\":\"&#x8f6f;&#x4ef6;&#x5de5;&#x7a0b;&#x6b63;&#x8fc8;&#x5411;&#x8ba4;&#x77e5;&#x79d1;&#x5b66;&#x65b0;&#x8303;&#x5f0f;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"61,62\"}}],\"payload\":{\"tag\":\"h2\",\"lines\":\"57,58\"}}],\"payload\":{\"tag\":\"h1\",\"lines\":\"5,6\"}}\n      {\"colorFreezeLevel\":2}\n    \n\n\n\n\n","categories":["技术思考","AI","软件工程"],"tags":["软件开发","知识工程","LLM","认知模型"]},{"title":"基于LibreOffice的MS Office文档格式转换","url":"/blog/2024/02/04/libre-jod/","content":"将Microsoft Office文件转换为其他格式的场景在一些情况下，可能需要将Microsoft Office文件转换为其他格式：\n\n兼容性问题：与不同的办公软件或操作系统进行交互，可能需要将MS Office文件转换为更通用的格式。例如，如果要与没有安装Microsoft Office的人分享文档，将其转换为PDF格式可能更合适。\n归档和存档：将Office文件转换为更稳定、可持久保存的格式可以确保文件的长期保存和归档。某些文件格式（如PDF&#x2F;A）专门用于长期存档目的，以确保文件内容的完整性和可访问性。\n数据提取：你可能只对文档中的特定数据或内容感兴趣。通过将Office文件转换为其他格式（如纯文本或CSV），可以更容易地提取所需的数据，并在其他应用程序中进行分析或处理。\n网页发布：如果要将MS Office文件发布到网页上，可能需要将其转换为HTML或其他网页友好的格式，以确保文件在网页上正确显示。\n\nLibreOffice - 微软Office的开源替代LibreOffice是一个免费、开源的办公套件，在某种程度上可以被视为微软Office的开源替代品。\n\nLibreOffice Writer：对应于Microsoft Word。\nLibreOffice Calc：对应于Microsoft Excel。\nLibreOffice Impress：对应于Microsoft PowerPoint。\n\n\nLibreOffice支持的转换格式LibreOffice支持广泛的转换格式。具体请参考如下的表格：\n\n    Format FamilyFrom (any of)To (any of)\n    \n        Text\n        \n            *.odt&nbsp;&nbsp;&nbsp;&nbsp;OpenDocument Text\n            *.ott&nbsp;&nbsp;&nbsp;&nbsp;OpenDocument Text Template\n            *.sxw&nbsp;&nbsp;&nbsp;&nbsp;OpenOffice.org 1.0 Text\n            *.rtf&nbsp;&nbsp;&nbsp;&nbsp;Rich Text Format\n            *.doc&nbsp;&nbsp;&nbsp;&nbsp;Microsoft Word\n            *.docx&nbsp;&nbsp;&nbsp;Microsoft Word XML\n            *.wpd&nbsp;&nbsp;&nbsp;&nbsp;WordPerfect\n            *.txt&nbsp;&nbsp;&nbsp;&nbsp;Plain Text\n            *.html&nbsp;&nbsp;&nbsp;HTML\n        \n        \n            *.pdf&nbsp;&nbsp;&nbsp;&nbsp;Portable Document Format\n            *.odt&nbsp;&nbsp;&nbsp;&nbsp;OpenDocument Text\n            *.ott&nbsp;&nbsp;&nbsp;&nbsp;OpenDocument Text Template\n            *.sxw&nbsp;&nbsp;&nbsp;&nbsp;OpenOffice.org 1.0 Text\n            *.rtf&nbsp;&nbsp;&nbsp;&nbsp;Rich Text Format\n            *.doc&nbsp;&nbsp;&nbsp;&nbsp;Microsoft Word\n            *.docx&nbsp;&nbsp;&nbsp;Microsoft Word XML\n            *.txt&nbsp;&nbsp;&nbsp;&nbsp;Plain Text\n            *.html&nbsp;&nbsp;&nbsp;HTML\n            *.wiki&nbsp;&nbsp;&nbsp;MediaWiki wikitext\n        \n    \n    \n        Spreadsheet\n        \n            *.ods&nbsp;&nbsp;&nbsp;&nbsp;OpenDocument Spreadsheet\n            *.ots&nbsp;&nbsp;&nbsp;&nbsp;OpenDocument Spreadsheet Template\n            *.sxc&nbsp;&nbsp;&nbsp;&nbsp;OpenOffice.org 1.0 Spreadsheet\n            *.xls&nbsp;&nbsp;&nbsp;&nbsp;Microsoft Excel\n            *.xlsx&nbsp;&nbsp;&nbsp;Microsoft Excel XML\n            *.csv&nbsp;&nbsp;&nbsp;&nbsp;Comma-Separated Values\n            *.tsv&nbsp;&nbsp;&nbsp;&nbsp;Tab-Separated Values\n        \n        \n            *.pdf&nbsp;&nbsp;&nbsp;&nbsp;Portable Document Format\n            *.ods&nbsp;&nbsp;&nbsp;&nbsp;OpenDocument Spreadsheet\n            *.ots&nbsp;&nbsp;&nbsp;&nbsp;OpenDocument Spreadsheet Template\n            *.sxc&nbsp;&nbsp;&nbsp;&nbsp;OpenOffice.org 1.0 Spreadsheet\n            *.xls&nbsp;&nbsp;&nbsp;&nbsp;Microsoft Excel\n            *.xlsx&nbsp;&nbsp;&nbsp;Microsoft Excel XML\n            *.csv&nbsp;&nbsp;&nbsp;&nbsp;Comma-Separated Values\n            *.tsv&nbsp;&nbsp;&nbsp;&nbsp;Tab-Separated Values\n            *.html&nbsp;&nbsp;&nbsp;HTML\n        \n    \n    \n        Presentation\n        \n            *.odp&nbsp;&nbsp;&nbsp;&nbsp;OpenDocument Presentation\n            *.otp&nbsp;&nbsp;&nbsp;&nbsp;OpenDocument Presentation Template\n            *.sxi&nbsp;&nbsp;&nbsp;&nbsp;OpenOffice.org 1.0 Presentation\n            *.ppt&nbsp;&nbsp;&nbsp;&nbsp;Microsoft PowerPoint\n            *.pptx&nbsp;&nbsp;&nbsp;Microsoft PowerPoint XML\n        \n        \n            *.pdf&nbsp;&nbsp;&nbsp;&nbsp;Portable Document Format\n            *.swf&nbsp;&nbsp;&nbsp;&nbsp;Macromedia Flash\n            *.odp&nbsp;&nbsp;&nbsp;&nbsp;OpenDocument Presentation\n            *.otp&nbsp;&nbsp;&nbsp;&nbsp;OpenDocument Presentation Template\n            *.sxi&nbsp;&nbsp;&nbsp;&nbsp;OpenOffice.org 1.0 Presentation\n            *.ppt&nbsp;&nbsp;&nbsp;&nbsp;Microsoft PowerPoint\n            *.pptx&nbsp;&nbsp;&nbsp;Microsoft PowerPoint XML\n            *.html&nbsp;&nbsp;&nbsp;HTML\n        \n    \n    \n        Drawing\n        \n            *.odg&nbsp;&nbsp;&nbsp;&nbsp;OpenDocument Drawing\n            *.otg&nbsp;&nbsp;&nbsp;&nbsp;OpenDocument Drawing Template\n        \n        \n            *.svg&nbsp;&nbsp;&nbsp;&nbsp;Scalable Vector Graphics\n            *.swf&nbsp;&nbsp;&nbsp;&nbsp;Macromedia Flash\n        \n    \n\n\nLibreOffice的headless模式与常见的Chromium的headless模式类似，LibreOffice也提供headless模式。\n\n没有图形用户界面（GUI）：无论是LibreOffice的headless模式还是Chromium的headless模式，都在没有GUI的情况下运行，不会显示可见的窗口或用户界面。\n命令行接口（CLI）控制：通过命令行接口进行控制和操作。可以在命令行中使用特定的命令和参数来执行相应的任务和操作。\n自动化和批处理：LibreOffice的headless模式和Chromium的headless模式都适用于自动化和批处理任务。\n服务器环境中的应用：适用于在服务器环境中使用。\n\n这就给在服务端自动化进行文档类型转换提供了很大的便利。\n资源池管理与容器化 - JodConverterJodConverter是一个用于将Office文档转换为其他格式的Java库。它支持与LibreOffice（也可以是OpenOffice）进行集成。\n我们可以选择自己直接与headless的LibreOffice直接通信来完成文档格式转换，不过由JodConverter来代劳的好处是很明显的：\n\n资源池化\n容器化\n\nJODConverter 的进程管理器（Process Manager）在资源池内维护 LibreOffice 进程。将 LibreOffice 进程保持在资源池内，可以避免每次进行文档转换时都需要启动和终止 LibreOffice 进程的开销。它可以检测到进程的健康状态，例如进程异常退出或崩溃，然后采取相应的措施，如重新启动进程。\nJODConverter 还提供一个基于Debian的基础docker image，其中已经包含了LibreOffice。\n我们的调用JODConverter的Java应用只需要基于该镜像build出来就好。\n\nMS Office存量文件的兼容性 - 字体的开源替代\n上面这张图左侧是原版的PPT，右侧是用JOD + LibreOffice转换出来的PDF。\n可以看到右侧转换出PDF，文字之间出现了互相交叉重叠的现象，整个样式都乱掉了。这其实并不是JOD或者是LibreOffice的bug。\n而是由于左侧的PPT当中使用了一些微软的商用字体。而LibreOffice运行在docker里面，它是拿不到这些微软的商用字体的，我们也不应该把有商用版权的字体置入docker image中。\n这时我们可以使用一些开源的字体来代替微软的商用字体。\n下图来自于LibreOffice的一篇博客： https://blog.documentfoundation.org/blog/2020/09/08/libreoffice-tt-replacing-microsoft-fonts/\n\nLibreOffice提供了一个Font Replacement Table的功能。\n左侧Font列是商用字体，右侧Replace with列是开源字体。例如：当LibreOffice见到一个ppt文件内的某段文字使用了Arial字体时，就会自动用Arimo字体去渲染这段文字。这样，既能够尽量保持视觉效果的一致性，也避免使用商用字体。\n下图是使用了开源字体替代后的转换效果，右侧的PDF和左侧的PPT视觉差异已经不太大了。\n作为一个LibreOffice桌面应用的使用者可以按照上述说明来做配置，从而最大程度的去兼容微软的商用字体。而当我们使用headless模式时该如何做出等效的配置呢？\nLibreOffice - User Profile上面提到的配置项，会被保存在LibreOffice User Profile内，在不同的OS内保存的路径为：\nWindows%APPDATA%\\libreoffice\\4\\user (LibreOffice 4 and above)GNU/Linux/home/&lt;user name&gt;/.config/libreoffice/4/user (LibreOffice 4 and above)\n\n我们可以把开源字体文件以及保存下来的配置文件内置入docker image内。并通过JOD指定启动LibreOffice时的参数，让headless模式下运行的LibreOffice加载到正确的配置文件，进而也能达成上图所示一样转换的效果。\n如下Dockerfile示例中把开源字体和配置文件copy进Docker image\n# support more fontsCOPY cjk-fonts/* /usr/share/fonts/cjk/COPY condensed-fonts/* /usr/share/fonts/condensed/COPY ms-sub-fonts/* /usr/share/fonts/ms-sub-fonts/# add user profile config filesCOPY ./profile/LibreOffice/4/user /tmp/jodconverter/user\n\n如下示例中指定template-profile-dir\njodconverter:  local:    enabled: true    port-numbers: 2002,2003    template-profile-dir: /tmp/jodconverter\n\n这样可以确保JODConverter在启动LibreOffice进程的时候可以明确地告诉LibreOffice去加载哪一份配置文件。\nLinksJODConverter Wiki\njodconverter-runtime docker基础镜像\nLibreOffice PDF转换支持的命令行参数\n宽度过大的Excel转PDF的问题\n微软字体兼容性问题\nLibreOffice User Profile默认路径\n把自定义的字体与User Profile加入Docker Image\n给JODConverter指定User Profile路径\n\n\n\n\n","tags":["LibreOffice","JOD"]},{"title":"Feedly硬广-回归RSS","url":"/blog/2025/01/05/go-back-to-rss/","content":"flowchart TD\n  subgraph 被动信息接收\n    style 被动信息接收 fill:#f9d6c1,stroke:#000,stroke-width:2px;\n    A[被动接受信息] --&gt; B[算法过度控制]\n    B --&gt; C[信息茧房]\n    C --&gt; D[注意力消耗]\n  end\n\n  subgraph 信息主动消费\n    style 信息主动消费 fill:#c1e1f9,stroke:#000,stroke-width:2px;\n    E[回归RSS] --&gt; F[掌握信息主动权]\n    F --&gt; G[自主订阅]\n    G --&gt; H[控制信息摄入质量]\n    H --&gt; I[主动选择信息来源]\n    I --&gt; J[避免无用信息轰炸]\n    J --&gt; K[减少干扰]\n    K --&gt; L[专注高质量内容]\n    L --&gt; M[享受纯粹阅读乐趣]\n    M --&gt; N[高质量阅读体验]\n    N --&gt; O[注意力回归有价值内容]\n    O --&gt; F\n  end\n\n  D --&gt; E\n\n\n\n","tags":["RSS","Feedly"]},{"title":"围墙花园里的阅读游击 - wewe-rss是个好开源项目，Folo是个好APP","url":"/blog/2025/07/21/folo-wewe-rss/","content":"控制权旁落RSS 并未消亡。\n变化的不是协议，而是信息分发领域的权力结构。\n用户在事实上让渡了选择看什么、何时看的权利。\n微信公众号重塑了这种结构，通过两层约束：\n\n技术约束：内容被封装于 App 内，无标准 API，无 RSS 输出通道。\n算法约束：信息流按商业目标而非时间或信息价值排序。\n\n其结果是一种注意力被动引导机制——用户的浏览行为，被用于优化平台的商业目标。\n\n系统解剖graph TD\n    subgraph 微信封闭生态\n        A[公众号文章] --&gt;|技术隔离| B(微信App)\n        B --&gt;|算法黑箱| C&#123;信息流&#125;\n        C --&gt;|注意力收割| D(用户)\n    end\n\n    subgraph RSS 越狱路径\n        A --&gt;|微信读书接口| E(wewe-rss)\n        E --&gt;|标准化 Feed| F[RSS]\n        F --&gt;|任意阅读器| G(Folo)\n        G --&gt;|主权归还| D\n    end\n\n技术隔离层\n无 RSS，无 API，内容被封装在微信内。\n算法黑箱层\n算法根据用户停留时长、交互数据等指标对内容进行排序。用户的每一次点击，都在优化这个系统以更高效地实现其排序目标。\n\n穿孔方案wewe-rss 不破坏系统，它利用其现有接口。通过调用微信读书的同步接口，将公众号内容转化为标准 RSS。这不是破解，是协议嫁接：\n\n接口合法性：使用微信读书官方 API。\n格式标准化：输出 RSS 2.0，兼容任意阅读器。\n延迟容忍：以 15-30 分钟的延迟，换取系统稳定性。\n\n局限依然存在：付费墙内内容无法获取，接口也可能在未来关闭。但这是一种可接受的脆弱性——在绝对控制与完全开放之间，它提供了一个可行的中间路径。\n\n现代终端wewe-rss 解决“源”的问题，Folo 解决“端”的问题。它保留了 RSS 的核心价值（用户控制权），并集成了现代产品的必要特性：\n\n跨端同步：阅读进度、收藏、高亮等状态的实时同步。\nAI 辅助：提供摘要与翻译，但决策权保留给用户。\n社区发现：通过用户创建的订阅列表发现新信源。\n\n\n\n\n维度\n微信公众号\nwewe-rss + Folo\n\n\n\n阅读环境\n高密度干扰\n纯净专注\n\n\n内容排序\n黑箱算法\n时间或自定义\n\n\n数据所有权\n平台持有\n用户可导出\n\n\n开放性\n封闭系统\n开放协议\n\n\n\n脆弱的平衡这套方案的生命周期，取决于微信读书的接口策略，存在不确定性。\n但它证明了：中心化平台的控制并非绝对。\n通过技术工具，个体可以重新取回部分信息控制权。\n这不是颠覆，而是一种结构性再平衡。\nRSS 这个 1999 年的协议，在 2025 年成为制衡平台中心化的有效工具。\n这提示我们：开放协议通常比封闭应用拥有更长的生命周期。\n行动清单\n盘点：识别你真正需要关注的信源。\n转换：使用 wewe-rss 生成 RSS 地址。\n阅读：导入 Folo 或你选择的 RSS 阅读器。\n重塑：用主动拉取替代被动投喂的阅读习惯。\n\n信息控制权的回归，是使用习惯的重塑。\n\n\n\n\n\n","tags":["RSS","Folo","wewe-rss"]}]
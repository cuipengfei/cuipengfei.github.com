# 更好的字节码分析工作流程

基于你的建议，这里是一个更高效的字节码分析工作流程：

## 1. 一次性生成所有字节码分析文件

```bash
# 编译所有类
mvn clean compile

# 一次性生成所有字节码分析文件
javap -v target/classes/com/example/RuntimeTypeBypassDemo.class > bytecode-analysis-RuntimeTypeBypassDemo.txt
javap -v target/classes/com/example/GenericClassDemo.class > bytecode-analysis-GenericClassDemo.txt  
javap -v target/classes/com/example/GenericReflectionTest.class > bytecode-analysis-GenericReflectionTest.txt

# 保存运行时输出
java -cp target/classes com.example.RuntimeTypeBypassDemo > runtime-output-RuntimeTypeBypassDemo.txt 2>&1
java -cp target/classes com.example.GenericReflectionTest > runtime-output-GenericReflectionTest.txt 2>&1
```

## 2. 从保存的文件中提取所需信息

然后使用 `grep`、`sed` 或直接读取文件的相关部分来提取需要的字节码片段。

## 3. 优势

- **避免重复执行**: 不需要多次运行 `javap` 命令
- **完整保存**: 所有字节码信息都被保存，可以随时引用
- **便于对比**: 可以对比不同编译选项下的字节码差异
- **可重现**: 其他人可以直接查看保存的文件，而不需要重新编译

## 4. 文件组织

```
project/
├── src/main/java/...           # 源代码
├── target/classes/...          # 编译后的字节码
├── bytecode-analysis-*.txt     # javap 反编译结果
├── runtime-output-*.txt        # 程序运行输出
└── 类型擦除深度分析.md         # 最终的分析文档
```

这样的工作流程确实更加高效和专业！谢谢你的建议。
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

**重要提醒**: 本项目专为 JVM 类型系统研究设计，主要通过字节码反编译进行对比分析。开发时需关注类型系统实现差异而非常规业务逻辑。

## Project Overview

This is a JVM multi-language demonstration project focused on type system research, specifically designed for studying generics, variance, type erasure, monads, and cross-language interoperability between Java, Scala, and Kotlin. The project serves as a comprehensive platform for bytecode analysis and decompilation-driven exploration of JVM type systems.

## Architecture

### Multi-Language Source Structure

The project is organized into language-specific packages with Maven coordinating compilation:

```
src/main/
├── java/com/example/           # Java implementations
│   ├── advanced/               # Advanced type system features  
│   ├── bridges/                # Bridge method generation demos
│   ├── benchmark/              # Performance testing
│   └── interop/                # Cross-language interoperability
├── scala/com/example/          # Scala implementations
│   ├── advanced/               # Scala 3 advanced types, monads
│   └── freemonads/             # Free monad implementations
└── kotlin/com/example/         # Kotlin implementations
    ├── generics/               # Kotlin-specific generics features
    └── interop/                # Kotlin interop examples
```

### Key Components

- **Generic Containers**: Core generic implementations in all three languages for comparison
- **Variance Demonstrations**: Covariance/contravariance implementations across languages
- **Type Erasure Compensation**: Jackson/Gson-style TypeReference patterns
- **Bridge Method Analysis**: Generated synthetic methods for generic inheritance
- **Cross-Language Interop**: Safe type conversions and function interoperability
- **Free Monads**: Advanced functional programming abstractions (Scala)
- **Performance Benchmarks**: JMH-based type system performance analysis

### Compilation Pipeline

Maven coordinates a specific compilation order to ensure cross-language compatibility:
1. **Java** (JDK 21): Base implementations and interfaces
2. **Scala** (3.6.2): Advanced type features, builds on Java base
3. **Kotlin** (2.1.0): Interops with both Java and Scala compiled classes

## Commands

### Development Commands

```bash
# Build the entire multi-language project
mvn clean compile

# Run the main demonstration program
mvn exec:java -Dexec.mainClass="com.example.Main"

# Run tests (JUnit 5 + Kotlin test)
mvn test

# Generate executable JAR with all dependencies
mvn package

# Run performance benchmarks (when available)
java -cp target/classes com.example.benchmark.TypeSystemBenchmark
```

### Platform-Specific Build Scripts

```bash
# Linux/macOS comprehensive build and analysis
./build.sh

# Windows build (sets Java 21 environment)  
build.bat

# Automated bytecode analysis
./analysis.sh

# Language comparison analysis (Windows)
compare-languages.bat
```

### Decompilation and Analysis Commands

```bash
# View bytecode with generic signatures
javap -v -p target/classes/com/example/GenericContainer.class

# Extract generic signature information
javap -v target/classes/com/example/advanced/TypeReferenceDemo.class | grep -A2 "Signature"

# Analyze bridge methods
javap -v target/classes/com/example/bridges/BridgeMethodDemo\$StringProcessor.class | grep "bridge"

# CFR decompilation (when CFR is available)
java -jar cfr.jar target/classes/com/example/freemonads/FreeMonadDemo.class

# Performance analysis with JVM diagnostics
java -XX:+PrintCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining com.example.Main
```

## Development Workflow

### Research-Driven Development Process

This project follows a **decompilation-first research methodology**:

1. **Implement Feature**: Write equivalent functionality in Java/Scala/Kotlin
2. **Compile to Bytecode**: Use Maven multi-language compilation
3. **Decompile Analysis**: Use javap, CFR, or other tools to analyze bytecode
4. **Cross-Language Comparison**: Compare implementation strategies across languages
5. **Performance Benchmarking**: Measure overhead of different type system features
6. **Document Findings**: Update analysis results and comparative insights

### Key Analysis Points

When analyzing generated bytecode, focus on:

- **Signature Attributes**: How generic information is preserved
- **Bridge Methods**: Compiler-generated synthetic methods
- **Type Erasure**: What information is lost vs. compensated
- **Variance Annotations**: How covariance/contravariance is encoded
- **Cross-Language Bridges**: Interop mechanisms in bytecode

### Testing Strategy

- **Compilation Tests**: Verify all three languages compile together successfully
- **Runtime Type Tests**: Validate type safety across language boundaries  
- **Performance Tests**: JMH benchmarks for type system overhead analysis
- **Decompilation Verification**: Automated bytecode analysis where possible

**注意**: 本项目重点在于类型系统演示，目前测试覆盖有限 (仅在 src/test/java 中有基础测试)。

## Technical Configuration

### Maven Multi-Language Setup

The project uses specialized Maven configuration for JVM polyglot development:

- **Java**: Standard compilation with generics signature preservation
- **Scala**: scala-maven-plugin with Scala 3 compatibility
- **Kotlin**: kotlin-maven-plugin with Java/Scala interoperability
- **Build Order**: Enforced through Maven phase binding to ensure proper compilation sequence

### Dependencies and Versions

- **JDK**: 21 (required for all language compilation targets)
- **Scala**: 3.6.2 (latest stable with advanced type features)
- **Kotlin**: 2.1.0 (with coroutines and advanced generics)
- **Testing**: JUnit 5 + Kotlin Test integration
- **Benchmarking**: JMH 1.37 for performance analysis
- **Type Utilities**: Jackson + Gson for TypeReference demonstrations

### Analysis Results Structure

The project generates analysis artifacts in:
- `analysis_results/` - Automated bytecode analysis outputs
- `analysis-results/comparison/` - Multi-language comparison results from compare-languages.bat
- `target/classes/` - Compiled bytecode for manual inspection  
- `decompiled/` - Decompiled source for comparison (when applicable)

## Research Extensions

### Current Advanced Features (2024)

- **TypeReference Pattern**: Type erasure compensation mechanisms
- **Scala 3 Union/Intersection Types**: Advanced type algebra
- **Existential Types**: Deep wildcard capture scenarios  
- **Free Monads**: Category theory abstractions in practice
- **Cross-Language Monadic Operations**: Type-safe transformations

### Recommended Research Paths

1. **Beginners**: Start with Java generics and type erasure basics
2. **Intermediate**: Compare Scala/Kotlin variance mechanisms  
3. **Advanced**: Analyze cross-language interop bridge generation
4. **Expert**: Study Free Monad bytecode and performance implications

This project is designed for developers and researchers interested in understanding JVM type systems at the bytecode level, providing a structured environment for comparative language analysis.
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"cuipengfei.me","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.23.2","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12,"onmobile":false},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":null,"show_result":true},"fold":{"enable":false,"height":500},"language":false,"highlight_theme":"galactic"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="Reflections on 15 years of Growing Software Guided by Tests关于15年来测试驱动软件成长的反思 About the experts &#x2F; 关于专家Duncan McGregor &#x2F; 邓肯·麦格雷戈Professional software developer based near London, started progr">
<meta property="og:type" content="website">
<meta property="og:title" content="崔鹏飞的Blog">
<meta property="og:url" content="https://cuipengfei.me/tmp/Reflections%20on%2015%20years%20of%20Growing%20Software%20Guided%20by%20Tests%20_%20gotopia.tech.html">
<meta property="og:site_name" content="崔鹏飞的Blog">
<meta property="og:description" content="Reflections on 15 years of Growing Software Guided by Tests关于15年来测试驱动软件成长的反思 About the experts &#x2F; 关于专家Duncan McGregor &#x2F; 邓肯·麦格雷戈Professional software developer based near London, started progr">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-07-26T11:01:14.714Z">
<meta property="article:modified_time" content="2025-07-26T11:01:14.714Z">
<meta property="article:author" content="崔鹏飞">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://cuipengfei.me/tmp/Reflections%20on%2015%20years%20of%20Growing%20Software%20Guided%20by%20Tests%20_%20gotopia.tech">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":false,"lang":"zh-CN","comments":true,"permalink":"https://cuipengfei.me/tmp/Reflections%20on%2015%20years%20of%20Growing%20Software%20Guided%20by%20Tests%20_%20gotopia.tech.html","path":"tmp/Reflections on 15 years of Growing Software Guided by Tests _ gotopia.tech.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title> | 崔鹏飞的Blog
</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-46270419-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-46270419-1","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js" defer></script>








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/pjax.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"options":null,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.7.0/mermaid.min.js","integrity":"sha256-4+IKDqhZ/sXjc8Wtl2/MsxI4e0s1KpEVdbEP7V/Lz8U="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>



  <script src="/js/third-party/pace.js" defer></script>


  




<script data-ad-client="ca-pub-2529393324217872" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2529393324217872"></script>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="崔鹏飞的Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">崔鹏飞的Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="sitemap fa-fw"></i>站点地图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Reflections-on-15-years-of-Growing-Software-Guided-by-Tests"><span class="nav-number">1.</span> <span class="nav-text">Reflections on 15 years of Growing Software Guided by Tests</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E15%E5%B9%B4%E6%9D%A5%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E8%BD%AF%E4%BB%B6%E6%88%90%E9%95%BF%E7%9A%84%E5%8F%8D%E6%80%9D"><span class="nav-number">2.</span> <span class="nav-text">关于15年来测试驱动软件成长的反思</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#About-the-experts-%E5%85%B3%E4%BA%8E%E4%B8%93%E5%AE%B6"><span class="nav-number">2.1.</span> <span class="nav-text">About the experts &#x2F; 关于专家</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Duncan-McGregor-%E9%82%93%E8%82%AF%C2%B7%E9%BA%A6%E6%A0%BC%E9%9B%B7%E6%88%88"><span class="nav-number">2.1.1.</span> <span class="nav-text">Duncan McGregor &#x2F; 邓肯·麦格雷戈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nat-Pryce-%E7%BA%B3%E7%89%B9%C2%B7%E6%99%AE%E8%B5%96%E6%96%AF"><span class="nav-number">2.1.2.</span> <span class="nav-text">Nat Pryce &#x2F; 纳特·普赖斯</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction-%E5%BC%95%E8%A8%80"><span class="nav-number">2.2.</span> <span class="nav-text">Introduction &#x2F; 引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#What-is-GOOS-About-GOOS%E6%98%AF%E5%85%B3%E4%BA%8E%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F"><span class="nav-number">2.3.</span> <span class="nav-text">What is GOOS About? &#x2F; GOOS是关于什么的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-GOOS-Approach-GOOS%E6%96%B9%E6%B3%95"><span class="nav-number">2.4.</span> <span class="nav-text">The GOOS Approach &#x2F; GOOS方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Extreme-Programming-Context-%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B%E8%83%8C%E6%99%AF"><span class="nav-number">2.5.</span> <span class="nav-text">Extreme Programming Context &#x2F; 极限编程背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Outside-In-TDD-vs-Bottom-Up-TDD-%E7%94%B1%E5%A4%96%E8%80%8C%E5%86%85TDD-vs-%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8ATDD"><span class="nav-number">2.6.</span> <span class="nav-text">Outside-In TDD vs Bottom-Up TDD &#x2F; 由外而内TDD vs 自下而上TDD</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mock-Objects-and-Testing-Techniques-%E6%A8%A1%E6%8B%9F%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF"><span class="nav-number">2.7.</span> <span class="nav-text">Mock Objects and Testing Techniques &#x2F; 模拟对象与测试技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Changes-in-Software-Development-Over-15-Years-%E8%BF%87%E5%8E%BB15%E5%B9%B4%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-number">2.8.</span> <span class="nav-text">Changes in Software Development Over 15 Years &#x2F; 过去15年软件开发的变化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Developer-Led-vs-Management-Led-Agile-%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%BB%E5%AF%BC-vs-%E7%AE%A1%E7%90%86%E5%B1%82%E4%B8%BB%E5%AF%BC%E7%9A%84%E6%95%8F%E6%8D%B7"><span class="nav-number">2.9.</span> <span class="nav-text">Developer-Led vs Management-Led Agile &#x2F; 开发者主导 vs 管理层主导的敏捷</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Modern-Challenges-%E7%8E%B0%E4%BB%A3%E6%8C%91%E6%88%98"><span class="nav-number">2.10.</span> <span class="nav-text">Modern Challenges &#x2F; 现代挑战</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Essence-of-GOOS-GOOS%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">2.11.</span> <span class="nav-text">The Essence of GOOS &#x2F; GOOS的本质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Full-Transcript-%E5%AE%8C%E6%95%B4%E6%96%87%E5%AD%97%E7%A8%BF"><span class="nav-number">2.12.</span> <span class="nav-text">Full Transcript &#x2F; 完整文字稿</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">崔鹏飞</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">177</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">70</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/cuipengfei" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cuipengfei" rel="noopener me" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/290284/" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;290284&#x2F;" rel="noopener me" target="_blank"><i class="stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="rss fa-fw"></i>RSS</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
        <div class="pjax">
        </div>
  </aside>


    </div>

    <div class="main-inner page posts-expand">


    
    
    
    <div class="post-block" lang="zh-CN"><header class="post-header">

<h1 class="post-title" itemprop="name headline">
</h1>

<div class="post-meta-container">
</div>

</header>

      
      
      
      <div class="post-body">
          <h1 id="Reflections-on-15-years-of-Growing-Software-Guided-by-Tests"><a href="#Reflections-on-15-years-of-Growing-Software-Guided-by-Tests" class="headerlink" title="Reflections on 15 years of Growing Software Guided by Tests"></a>Reflections on 15 years of Growing Software Guided by Tests</h1><h1 id="关于15年来测试驱动软件成长的反思"><a href="#关于15年来测试驱动软件成长的反思" class="headerlink" title="关于15年来测试驱动软件成长的反思"></a>关于15年来测试驱动软件成长的反思</h1><hr>
<h2 id="About-the-experts-关于专家"><a href="#About-the-experts-关于专家" class="headerlink" title="About the experts &#x2F; 关于专家"></a>About the experts &#x2F; 关于专家</h2><h3 id="Duncan-McGregor-邓肯·麦格雷戈"><a href="#Duncan-McGregor-邓肯·麦格雷戈" class="headerlink" title="Duncan McGregor &#x2F; 邓肯·麦格雷戈"></a>Duncan McGregor &#x2F; 邓肯·麦格雷戈</h3><p>Professional software developer based near London, started programming on ZX81 at age 13. I’ve been lucky enough to ride a wave of demand for developers that started in the 1980s and has continued throughout my career.</p>
<p>专业软件开发人员，工作地点离伦敦足够近以维持生计。我13岁时在ZX81上开始编程。我很幸运地赶上了从1980年代开始并持续至今的开发者需求浪潮。</p>
<h3 id="Nat-Pryce-纳特·普赖斯"><a href="#Nat-Pryce-纳特·普赖斯" class="headerlink" title="Nat Pryce &#x2F; 纳特·普赖斯"></a>Nat Pryce &#x2F; 纳特·普赖斯</h3><p>Co-Author of “Growing Object-Oriented Software” (GOOS)<br>《面向对象软件成长》一书合著者（GOOS）</p>
<hr>
<h2 id="Introduction-引言"><a href="#Introduction-引言" class="headerlink" title="Introduction &#x2F; 引言"></a>Introduction &#x2F; 引言</h2><p><strong>Duncan McGregor:</strong> Hello and welcome to “GOTO Unscripted.” I’m Duncan McGregor, a professional software developer based close enough to London to make a living. I started programming computers on a ZX81 when I was 13. I’ve been lucky enough to ride a wave of demand for developers that started in the 1980s and has continued throughout my career.</p>
<p>**邓肯·麦格雷戈：**大家好，欢迎来到”GOTO Unscripted”。我是邓肯·麦格雷戈，一名专业软件开发人员，工作地点离伦敦足够近以维持生计。我13岁时在ZX81上开始编程。我很幸运地赶上了从1980年代开始并持续至今的开发者需求浪潮。</p>
<p>I first met Nat Pryce in the early 2000s when we were both members of the Extreme Tuesday Club, a meet-up for developers practicing extreme programming, one of the precursors to agile development. Nat Pryce and I recently wrote a Kotlin book together, but up until that career highlight, he was best known for the book he wrote with Steve Freeman titled “Growing Object-Oriented Software, Guided by Tests,” but colloquially known as GOOS. The book was published in 2009 in the Kent Beck Signature Series and was highly influential in the then relatively-infant agile movement. It is still at number 402,655 in Amazon rankings.</p>
<p>我在2000年代初第一次见到纳特·普赖斯，当时我们都是极限周二俱乐部的成员，这是一个为实践极限编程的开发者举办的聚会，是敏捷开发的前身之一。纳特·普赖斯和我最近合写了一本Kotlin书，但在此之前，他最出名的是与史蒂夫·弗里曼合著的《测试驱动的面向对象软件成长》，俗称GOOS。该书于2009年出版，属于Kent Beck签名系列，在当时相对稚嫩的敏捷运动中产生了重要影响。目前在亚马逊排名402,655位。</p>
<p><strong>Nat Pryce:</strong> It’s that good? &#x2F; 有那么好吗？</p>
<p><strong>Duncan McGregor:</strong> I don’t know. &#x2F; 我不知道。</p>
<p><strong>Nat Pryce:</strong> It’s a number. &#x2F; 就是个数字。</p>
<hr>
<h2 id="What-is-GOOS-About-GOOS是关于什么的？"><a href="#What-is-GOOS-About-GOOS是关于什么的？" class="headerlink" title="What is GOOS About? &#x2F; GOOS是关于什么的？"></a>What is GOOS About? &#x2F; GOOS是关于什么的？</h2><p><strong>Nat Pryce:</strong> That makes me feel old. It’s a book about test-driven development and was written to encapsulate everything that we had in the Extreme Tuesday Club…so it wasn’t just me and Steve inventing it. We were the six…let’s talk about the Extreme Tuesday Club and then I can talk about GOOS.</p>
<p>**纳特·普赖斯：**这让我感觉自己老了。这是一本关于测试驱动开发的书，旨在总结我们在极限周二俱乐部中的一切…所以这不只是我和史蒂夫发明的。我们是六个人…让我们先谈谈极限周二俱乐部，然后我可以谈谈GOOS。</p>
<p>The Extreme Tuesday Club was an informal meetup. It’s still going to this day, but it started in the early 2000s, people in London who were interested in extreme programming as it was very new when the sort of meetup started. And it was being publicized on the C2 Wiki and people were really quite inspired by this new way of development that was being publicized by Kent Beck, Ward Cunningham, and people like that, Ron Jeffries, and stuff.</p>
<p>极限周二俱乐部是一个非正式聚会。至今仍在继续，但始于2000年代初，当时伦敦对极限编程感兴趣的人们聚在一起，因为极限编程在当时还很新。它在C2 Wiki上被宣传，人们确实被Kent Beck、Ward Cunningham、Ron Jeffries等人宣传的新的开发方式所启发。</p>
<p>So a bunch of interested people just arranged a meetup in a pub in London. It went from pub to pub. It grew over time. It spawned a bunch of conferences that then ended up spreading around the world. And it also spawned a lot of different technical techniques that people learned and shared and sort of developed in their work and then shared in that sort of meetup.</p>
<p>于是一些感兴趣的人就在伦敦的一家酒吧安排了聚会。它从一家酒吧换到另一家酒吧。随着时间的推移，它不断发展壮大。它催生了一系列会议，最终传播到世界各地。它还催生了许多不同的技术技巧，人们在工作中学到并分享，然后在这种聚会上分享。</p>
<p>So GOOS was us writing about test-driven development and the techniques that had been shared and invented within the Extreme Tuesday Club along with…sort of portrayed as by a long-worked example that was an auction-sniping sort of application that would try and buy things on, I think eBay was quite new at the time, so on something like eBay, and how do you write that in a test-driven development way.</p>
<p>所以GOOS是我们写的关于测试驱动开发的书，以及极限周二俱乐部内分享和发明的技术，通过一个长期工作的例子来展示，这是一个拍卖狙击应用，试图在eBay（当时eBay还很新）这样的平台上购买东西，以及如何以测试驱动开发的方式编写它。</p>
<hr>
<h2 id="The-GOOS-Approach-GOOS方法"><a href="#The-GOOS-Approach-GOOS方法" class="headerlink" title="The GOOS Approach &#x2F; GOOS方法"></a>The GOOS Approach &#x2F; GOOS方法</h2><p>The book showed how you would start from writing a test - writing a test of what the system should do. The system would start off very unstructured because it was very small and didn’t need any structure, and then you’d add more and more tests. As the system grew and you wanted to test various bits more thoroughly, you would have to work out how to carve out those parts and mock bits of them while thoroughly testing other parts. Over the narrative arc of the example, you see how the final result is that the hexagon architecture sort of emerges from the continual refactoring and the pressure of the need for testing the application.</p>
<p>这本书展示了如何从编写测试开始，编写系统应该做什么的测试。系统开始时非常无结构，因为它很小，不需要任何结构，然后你会添加越来越多的测试。随着系统的发展，当你想更彻底地测试各个部分时，你必须想办法将这些部分分离出来，并模拟其中的一些部分，同时彻底测试其他部分。在例子的叙述弧线结束时，你会看到最终结果是六边形架构从持续重构和测试应用的需求压力下逐渐显现出来。</p>
<hr>
<h2 id="Extreme-Programming-Context-极限编程背景"><a href="#Extreme-Programming-Context-极限编程背景" class="headerlink" title="Extreme Programming Context &#x2F; 极限编程背景"></a>Extreme Programming Context &#x2F; 极限编程背景</h2><p><strong>Duncan McGregor:</strong> Extreme programming was one of a few precursors, one of a few ways of writing software that ended up under the umbrella of agile. XP in particular was developer-focused - it told developers how they should be working: pair programming, writing tests first, a bunch of principles and practices. The whole TDD thing was the big difference between XP and other methodologies.</p>
<p>**邓肯·麦格雷戈：**极限编程是几个前身之一，是几种最终被归入敏捷伞下的软件开发方式之一。XP特别是以开发者为中心的，它告诉开发者应该如何工作：结对编程、先写测试、一系列原则和一系列实践。整个TDD（测试驱动开发）是XP与其他方法论之间的主要区别。</p>
<p><strong>Nat Pryce:</strong> There was a whole bunch of agile methods very early on. All the early agile processes definitely said something about how people should write software. XP was more extreme than others - it definitely had rules and practices that mesh together to allow you to evolve and rapidly change your software. Early on, agile was seen as a holistic thing - the way you should develop software has to involve the developers and the people who want the software working together. It’s only later that we ended up with what we see described as agile today, where it’s mostly a management process.</p>
<p>**纳特·普赖斯：**早期有一整套敏捷方法。所有早期的敏捷流程都确实说了些什么。XP比其他方法更极端，它确实规定了你遵循这些规则、这些实践，它们相互配合，使你能够演进并快速改变你的软件。在敏捷的早期，它被视为一个整体的事情，你应该如何开发软件必须涉及开发者和想要软件的人一起工作。只是后来我们才得到我们今天所描述的敏捷，它主要是一个管理流程。</p>
<hr>
<h2 id="Outside-In-TDD-vs-Bottom-Up-TDD-由外而内TDD-vs-自下而上TDD"><a href="#Outside-In-TDD-vs-Bottom-Up-TDD-由外而内TDD-vs-自下而上TDD" class="headerlink" title="Outside-In TDD vs Bottom-Up TDD &#x2F; 由外而内TDD vs 自下而上TDD"></a>Outside-In TDD vs Bottom-Up TDD &#x2F; 由外而内TDD vs 自下而上TDD</h2><p><strong>Duncan McGregor:</strong> The thing that GOOS introduced was a sort of outside-in acceptance test-driven approach. Would you say that was the major innovation?</p>
<p>**邓肯·麦格雷戈：**GOOS向我们介绍的东西是一种由外而内的验收测试驱动方法。你会说这是主要的创新吗？</p>
<p><strong>Nat Pryce:</strong> I don’t know if it was an innovation. It was certainly what we wrote about and it wasn’t what Kent Beck really wrote about as much in his book. There was a lot more bottom-up approach in TDD in the first wave. We took a “let’s try and capture everything and work from outside in” approach.</p>
<p>**纳特·普赖斯：**我不知道它是否是一种创新。它确实是我们写的东西，而Ken Beck在他的书中并没有真正写那么多。在第一波TDD中，可以说有更多的自下而上的方法。我们采取了一种”让我们尝试捕捉一切，从外向内工作”的方法。</p>
<hr>
<h2 id="Mock-Objects-and-Testing-Techniques-模拟对象与测试技术"><a href="#Mock-Objects-and-Testing-Techniques-模拟对象与测试技术" class="headerlink" title="Mock Objects and Testing Techniques &#x2F; 模拟对象与测试技术"></a>Mock Objects and Testing Techniques &#x2F; 模拟对象与测试技术</h2><p><strong>Duncan McGregor:</strong> GOOS publicized and popularized the technique of mock objects.</p>
<p>**邓肯·麦格雷戈：**GOOS宣传、普及了模拟对象的技术。</p>
<p><strong>Nat Pryce:</strong> It’s more of a technique than a technology. A lot of what we were building was event-driven or message-driven, and it was a very natural fit for object-oriented systems built out of state machines. Those protocols by which objects talk are really the design of the system. You can write an object in your class that implements some roles in these protocols, and then it will plug into the right place. You end up writing code by reorganizing graphs of objects rather than writing procedural code.</p>
<p>**纳特·普赖斯：**我认为它更像是一种技术而不是技术。我们构建的很多是事件驱动或消息驱动的，所以它非常适合面向对象的系统，这些系统由状态机组成。它们交谈的协议实际上是系统的设计。你可以在类中写一个对象，实现这些协议中的一些角色，然后它会插入到正确的位置。你最终通过重新组织对象图来编写代码，而不是用过程代码编写。</p>
<hr>
<h2 id="Changes-in-Software-Development-Over-15-Years-过去15年软件开发的变化"><a href="#Changes-in-Software-Development-Over-15-Years-过去15年软件开发的变化" class="headerlink" title="Changes in Software Development Over 15 Years &#x2F; 过去15年软件开发的变化"></a>Changes in Software Development Over 15 Years &#x2F; 过去15年软件开发的变化</h2><p><strong>Nat Pryce:</strong> Well, machines are a lot faster, and that changes how much you can test in one go. There used to be a very strict distinction between unit tests and integration tests - things that do IO, things that touch hardware. Technology has changed - we have SSDs, fantastic machines many orders of magnitude faster. Now we can run more in our tests at one go, so there’s less need to have lots of little unit tests to try and get that fast feedback.</p>
<p>**纳特·普赖斯：**嗯，机器快多了，这改变了你一次可以测试多少。人们曾经非常严格地区分单元测试和集成测试 - 做IO的事情，接触硬件的事情。技术已经改变了，我们现在有SSD，神奇的机器快很多个数量级。所以现在我们可以一次在测试中运行更多，所以不太需要有很多小的单元测试来试图获得快速反馈。</p>
<p>Functional programming: When we wrote GOOS, it was written in Java 6, which didn’t really have much support for functional programming. Now modern languages have much better support for transforming data rather than mutating data.</p>
<p>函数式编程：当我们写GOOS时，是用Java 6写的，Java中并没有真正支持函数式编程。但现在现代语言现在都有更好的支持，转换数据而不是改变数据。</p>
<hr>
<h2 id="Developer-Led-vs-Management-Led-Agile-开发者主导-vs-管理层主导的敏捷"><a href="#Developer-Led-vs-Management-Led-Agile-开发者主导-vs-管理层主导的敏捷" class="headerlink" title="Developer-Led vs Management-Led Agile &#x2F; 开发者主导 vs 管理层主导的敏捷"></a>Developer-Led vs Management-Led Agile &#x2F; 开发者主导 vs 管理层主导的敏捷</h2><p><strong>Duncan McGregor:</strong> XP had the role of a coach and had the role of a customer and then the role of developers. That felt very different from a Scrum Master who is masterful, telling us what we should be doing, and a product owner who’s owning stuff that we’re not owning because we’re only developers.</p>
<p>**邓肯·麦格雷戈：**XP有教练的角色，有客户的角色，然后是开发者的角色。这对我来说至少感觉非常不同于Scrum Master的角色，你知道，Scrum Master是权威的，告诉我们应该做什么，而产品负责人拥有这些东西，我们不拥有，因为我们只是开发者。</p>
<p><strong>Nat Pryce:</strong> The most happy XP projects I was on, the developers often had very deep business knowledge. There wasn’t such a distinct division of responsibilities. Developers were allowed to say, “Hey, wouldn’t it be great if the product did this?” It was much more flexible in the division of responsibilities.</p>
<p>**纳特·普赖斯：**当然，在那些日子里我参与的最快乐的XP项目中，开发者通常有非常深厚的业务知识。没有如此明确的责任分工。开发者被允许说：”嘿，如果产品这样做不是很好吗？”在这种责任分工中更加灵活。</p>
<hr>
<h2 id="Modern-Challenges-现代挑战"><a href="#Modern-Challenges-现代挑战" class="headerlink" title="Modern Challenges &#x2F; 现代挑战"></a>Modern Challenges &#x2F; 现代挑战</h2><p><strong>Duncan McGregor:</strong> I feel that we are able to store and access more data, and we’re able to be more scalable, but I don’t actually feel that we are delivering features any quicker these days.</p>
<p>**邓肯·麦格雷戈：**我觉得我们能够存储和访问更多数据，我们能够更具可扩展性，但我实际上并不觉得我们如今交付功能更快了。</p>
<p><strong>Nat Pryce:</strong> We expect more from our features. Back in the day, people would put up with a desktop UI created by a programmer. Nowadays, they have people who can actually design user interfaces. We’re expected to create websites that work on a wider variety of devices - mobile, desktops, iPads, various operating systems, multiple browsers.</p>
<p>**纳特·普赖斯：**我们对功能的期望更高了。在过去，人们会忍受由程序员创建的桌面用户界面。如今，他们有真正能够设计用户界面的人。我们被期望创建在更广泛的设备上工作的网站 - 移动设备、桌面、iPad、各种操作系统、多个浏览器。</p>
<hr>
<h2 id="The-Essence-of-GOOS-GOOS的本质"><a href="#The-Essence-of-GOOS-GOOS的本质" class="headerlink" title="The Essence of GOOS &#x2F; GOOS的本质"></a>The Essence of GOOS &#x2F; GOOS的本质</h2><p><strong>Duncan McGregor:</strong> The constant focus on “how can I give you value quicker whilst at the same time knowing that I’m going to be able to continue to give you value quickly” - that’s the essence of XP, it’s the essence of Agile, and I think the essence of what GOOS gave us, which was this guided by the tests. It was this outside-in thing, real focus on delivering to the customer, not doing anything that wasn’t focused on delivering value to the customer.</p>
<p>**邓肯·麦格雷戈：**持续关注”我如何能更快地给你价值，同时知道我将能够在下周和下个月等继续快速给你价值”，这是XP的本质，这是敏捷的本质，我认为也是GOOS给我们的本质，这就是由测试引导。这是由外而内的事情，真正专注于交付给客户，不做任何不专注于向客户交付价值的事情。</p>
<hr>
<h2 id="Full-Transcript-完整文字稿"><a href="#Full-Transcript-完整文字稿" class="headerlink" title="Full Transcript &#x2F; 完整文字稿"></a>Full Transcript &#x2F; 完整文字稿</h2><p><strong>Duncan McGregor:</strong> Hello and welcome to “GOTO Unscripted.” I’m Duncan McGregor. I’m a professional software developer based close enough to London to make a living. I started programming computers on a ZX81 when I was 13. I’ve been lucky enough to ride a wave of demand for developers that started in the 1980s and has continued throughout my career.</p>
<p>**邓肯·麦格雷戈：**大家好，欢迎来到”GOTO Unscripted”。我是邓肯·麦格雷戈，一名专业软件开发人员，工作地点离伦敦足够近以维持生计。我13岁时在ZX81上开始编程。我很幸运地赶上了从1980年代开始并持续至今的开发者需求浪潮。</p>
<p>I first met Nat Pryce in the early 2000s when we were both members of the Extreme Tuesday Club, a meet-up for developers practicing extreme programming, one of the precursors to agile development. Nat Pryce and I recently wrote a Kotlin book together, but up until that career highlight, he was best known for the book he wrote with Steve Freeman titled “Growing Object-Oriented Software, Guided by Tests,” but colloquially known as GOOS. The book was published in 2009 in the Kent Beck Signature Series and was highly influential in the then relatively-infant agile movement. It is still at number 402,655 in Amazon rankings.</p>
<p>我在2000年代初第一次见到纳特·普赖斯，当时我们都是极限周二俱乐部的成员，这是一个为实践极限编程的开发者举办的聚会，是敏捷开发的前身之一。纳特·普赖斯和我最近合写了一本Kotlin书，但在此之前，他最出名的是与史蒂夫·弗里曼合著的《测试驱动的面向对象软件成长》，俗称GOOS。该书于2009年出版，属于Kent Beck签名系列，在当时相对稚嫩的敏捷运动中产生了重要影响。目前在亚马逊排名402,655位。</p>
<p><strong>Nat Pryce:</strong> It’s that good?</p>
<p>**纳特·普赖斯：**有那么好吗？</p>
<p><strong>Duncan McGregor:</strong> I don’t know.</p>
<p>**邓肯·麦格雷戈：**我不知道。</p>
<p><strong>Nat Pryce:</strong> It’s a number.</p>
<p>**纳特·普赖斯：**就是个数字。</p>
<p><strong>Duncan McGregor:</strong> It’s a number. Nat, for those in our audience who were still at school when GOOS was published, what’s it about?</p>
<p>**邓肯·麦格雷戈：**就是个数字。纳特，对于我们观众中那些在GOOS出版时还在上学的人来说，这本书是关于什么的？</p>
<p><strong>Nat Pryce:</strong> That makes me feel old. It’s a book about test-driven development and was written to encapsulate everything that we had in the Extreme Tuesday Club…so it wasn’t just me and Steve inventing it. We were the six…let’s talk about the Extreme Tuesday Club and then I can talk about GOOS.</p>
<p>**纳特·普赖斯：**这让我感觉自己老了。这是一本关于测试驱动开发的书，旨在总结我们在极限周二俱乐部中的一切…所以这不只是我和史蒂夫发明的。我们是六个人…让我们先谈谈极限周二俱乐部，然后我可以谈谈GOOS。</p>
<p>The Extreme Tuesday Club was an informal meetup. It’s still going to this day, but it started in the early 2000s, people in London who were interested in extreme programming as it was very new when the sort of meetup started. And it was being publicized on the C2 Wiki and people were really quite inspired by this new way of development that was being publicized by Kent Beck, Ward Cunningham, and people like that, Ron Jeffries, and stuff.</p>
<p>极限周二俱乐部是一个非正式聚会。至今仍在继续，但始于2000年代初，当时伦敦对极限编程感兴趣的人们聚在一起，因为极限编程在当时还很新。它在C2 Wiki上被宣传，人们确实被Kent Beck、Ward Cunningham、Ron Jeffries等人宣传的新的开发方式所启发。</p>
<p>So a bunch of interested people just arranged a meetup in a pub in London. It went from pub to pub. It grew over time. It spawned a bunch of conferences that then ended up spreading around the world. And it also spawned a lot of different technical techniques that people learned and shared and sort of developed in their work and then shared in that sort of meetup.</p>
<p>于是一些感兴趣的人就在伦敦的一家酒吧安排了聚会。它从一家酒吧换到另一家酒吧。随着时间的推移，它不断发展壮大。它催生了一系列会议，最终传播到世界各地。它还催生了许多不同的技术技巧，人们在工作中学到并分享，然后在这种聚会上分享。</p>
<p>So GOOS was us writing about test-driven development and the techniques that had been shared and invented within the Extreme Tuesday Club along with…sort of portrayed as by a long-worked example that was an auction-sniping sort of application that would try and buy things on, I think eBay was quite new at the time, so on something like eBay, and how do you write that in a test-driven development way.</p>
<p>所以GOOS是我们写的关于测试驱动开发的书，以及极限周二俱乐部内分享和发明的技术，通过一个长期工作的例子来展示，这是一个拍卖狙击应用，试图在eBay（当时eBay还很新）这样的平台上购买东西，以及如何以测试驱动开发的方式编写它。</p>
<p>A bit different from probably applications now in that it was a desktop application and it communicated with a protocol that doesn’t exist anymore or no one really uses. But a lot of the principles still apply and we showed how you would start from writing a test, writing a test of what the system should do. The system would start off very unstructured because it was very small and didn’t need any structure, and then you’d add more and more tests. And as the system grew and you wanted to test various bits more thoroughly, you would have to work out how to carve out those parts and mock bits of them while you sort of thoroughly test other parts. And over the narrative arc of the example at the end of it, you see how the final result is that the hexagon architecture sort of emerges from the continual refactoring and the pressure of the need for testing the application.</p>
<p>与现在的应用有些不同，它是一个桌面应用程序，使用了一个现在已经不存在或没人使用的协议进行通信。但很多原则仍然适用，我们展示了如何从编写测试开始，编写系统应该做什么的测试。系统开始时非常无结构，因为它很小，不需要任何结构，然后你会添加越来越多的测试。随着系统的发展，当你想更彻底地测试各个部分时，你必须想办法将这些部分分离出来，并模拟其中的一些部分，同时彻底测试其他部分。在例子的叙述弧线结束时，你会看到最终结果是六边形架构从持续重构和测试应用的需求压力下逐渐显现出来。</p>
<p><strong>Duncan McGregor:</strong> I only relatively infrequently came to XTC. But I do remember the first time I ever did come, Kent Beck turned up, and I just expected that was normal for London. After that, everything went downhill a bit.</p>
<p>**邓肯·麦格雷戈：**我只相对很少地参加过XTC。但我确实记得第一次参加时，Kent Beck出现了，我还以为这对伦敦来说是正常的。之后，一切都有点走下坡路了。</p>
<p><strong>Nat Pryce:</strong> Thanks.</p>
<p>**纳特·普赖斯：**谢谢。</p>
<p><strong>Duncan McGregor:</strong> I do remember that we…extreme programming, which people may or may not know, right? These days I don’t think it’s fashionable. Extreme programming was one of a few precursors, one of a few ways of writing software that ended up under the umbrella of agile. I think XP in particular was developer-focused, wasn’t it? I mean, we’d have Scrum, which really didn’t talk about what developers should be doing most of the time, whereas XP was a thing that told developers how they should be working. It told us that we should be doing pair programming. It told us that we should be writing tests first. It had a bunch of principles and a bunch of practices. But the whole TDD thing I think was the big difference between XP and just other methodologies.</p>
<p>**邓肯·麦格雷戈：**我确实记得我们…极限编程，人们可能知道也可能不知道，对吧？现在我觉得它已经不流行了。极限编程是几个前身之一，是几种最终被归入敏捷伞下的软件开发方式之一。我认为XP特别是以开发者为中心的，不是吗？我的意思是，我们有Scrum，它大部分时间并没有真正谈论开发者应该做什么，而XP则告诉开发者应该如何工作。它告诉我们应该进行结对编程。它告诉我们应该先写测试。它有一系列原则和一系列实践。但我认为整个TDD（测试驱动开发）是XP与其他方法论之间的主要区别。</p>
<p><strong>Nat Pryce:</strong> There was a whole bunch of agile methods very early on. So you’re saying like about luminaries turning up at XTC. So Alistair Cockburn turned up a few times and he was a methodologist at IBM who studied how people wrote software and then captured that in a bunch of methods that he called Crystal. Crystal Clear is a very lightweight method, very similar to XP, but less prescriptive. And then he had a bunch of other methods in the Crystal family for, like, larger and more critical projects.</p>
<p>**纳特·普赖斯：**早期有一整套敏捷方法。所以你提到在XTC出现的知名人士。Alistair Cockburn出现过几次，他是IBM的方法学家，研究人们如何编写软件，然后将其总结为一组他称之为Crystal的方法。Crystal Clear是一种非常轻量级的方法，与XP非常相似，但规定性较少。然后他在Crystal系列中还有一系列其他方法，用于更大和更关键的项目。</p>
<p>I think all the early agile processes definitely said something, apart from Scrum. They definitely said something about how people should write software. XP was more extreme than others. It definitely had, like, you follow these rules, these practices, and they mesh together to allow you to evolve and rapidly change your software, and that’s certainly my experience.</p>
<p>我认为除了Scrum之外，所有早期的敏捷流程都确实说了些什么。它们确实说了人们应该如何编写软件。XP比其他方法更极端。它确实规定了你遵循这些规则、这些实践，它们相互配合，使你能够演进并快速改变你的软件，这确实是我的经验。</p>
<p>But early on in the days of agile, I don’t think it was a developer-focused process but more that agile was seen as a holistic thing. The way you should develop software has to involve the developers and the people who want the software working together with their expertise and guidance coming from different parties involved in a common enterprise. And it’s only later that we end up with what we see described as agile today, where it’s mostly a management process and it says very little about how you should write software. And if software development gets done at all, it’s sort of not really talked about very much.</p>
<p>但在敏捷的早期，我不认为它是一个以开发者为中心的流程，而更多地是敏捷被视为一个整体的事情。你应该如何开发软件必须涉及开发者和想要软件的人一起工作，他们的专业知识和指导来自参与共同事业的不同方面。只是后来我们才得到我们今天所描述的敏捷，它主要是一个管理流程，很少谈论你应该如何编写软件。如果软件开发真的完成了，它似乎并没有被真正谈论太多。</p>
<p><strong>Duncan McGregor:</strong> My recollection of those days is that XP, in particular, was a thing that developers wanted to be doing. Like, we would go to the management and say, “Hey, look, we’ve been trying this stuff and it works. Can we run projects this way rather than a thing where we are brought into a project that is run by a Scrum Master?”</p>
<p>**邓肯·麦格雷戈：**我对那些日子的回忆是，特别是XP，是开发者想要做的事情。就像，我们会去找管理层说：”嘿，看，我们一直在尝试这些东西，它们确实有效。我们能否以这种方式运行项目，而不是被带入一个由Scrum Master运行的项目中？”</p>
<p><strong>Nat Pryce:</strong> Yes. And I think especially in London where a lot of that was happening inside banks and other companies, it was internal产品开发团队或内部项目团队 just adopting it because it works. And there wasn’t quite a strict hierarchy in those teams of product owners then Scrum Master and that, right? And those teams were arguing with their project management and maybe IT management in order to change their process, but also they could have quite a lot of leeway in the way they did things so they didn’t have to say, “We’re going to write tests first. Can we do that?” They just wrote tests first. Or, “Can we do pairing?” They might just sit there next to each other and do some pairing. So again, it depends on company by company. They’re all different.</p>
<p>**纳特·普赖斯：**是的。我认为特别是在伦敦，很多这样的事情发生在银行和其他公司内部，是内部产品开发团队或内部项目团队只是因为它有效而采用它。在这些团队中，并没有产品负责人然后是Scrum Master这样的严格等级制度，对吧？这些团队正在与他们的项目管理和可能的IT管理争论以改变他们的流程，但他们也可以在他们做事的方式上有很大的回旋余地，所以他们不必说：”我们要先写测试。我们能这样做吗？”他们只是先写测试。或者，”我们能结对吗？”他们可能只是坐在一起进行一些结对。所以再次，这取决于公司。它们都不同。</p>
<p><strong>Duncan McGregor:</strong> XP had the role of a coach and had the role of a customer and then the role of developers. And that felt very different, to me at least, from this role of a Scrum Master who is, you know, masterful, telling us what we should be doing and a product owner who’s owning this stuff that we’re not owning because we’re only developers.</p>
<p>**邓肯·麦格雷戈：**XP有教练的角色，有客户的角色，然后是开发者的角色。这对我来说至少感觉非常不同于Scrum Master的角色，你知道，Scrum Master是权威的，告诉我们应该做什么，而产品负责人拥有这些东西，我们不拥有，因为我们只是开发者。</p>
<p><strong>Nat Pryce:</strong> Yes. Certainly the most sort of happy XP projects that I was on in those days, the developers often had very deep business knowledge, right? You know, financial knowledge, so you didn’t have to keep going to a product owner and saying, like, “What should this do? What should that do?” You know, these people knew what particular, I don’t know, derivatives or fixed income instruments or whatever did and how to process them. And that was because everybody in the organization knew that stuff, right? There wasn’t such a distinct division of responsibilities. And also in other places that we’ve worked where people, you know, there were people who were guiding the product, product directors, but developers are allowed to say, “Hey, wouldn’t it be great if the product did this?” And it was much more flexible in this sort of division of responsibilities. And I think Agile and XP works very well there because you are all working together as one team without those strict roles.</p>
<p>**纳特·普赖斯：**是的。当然，在那些日子里我参与的最快乐的XP项目中，开发者通常有非常深厚的业务知识，对吧？你知道，金融知识，所以你不必一直去找产品负责人说，比如，”这个应该做什么？那个应该做什么？”你知道，这些人知道特定的，我不知道，衍生品或固定收益工具或什么的做什么以及如何处理它们。这是因为组织中的每个人都知道这些东西，对吧？没有如此明确的责任分工。而且在我们工作的其他地方，你知道，有人指导产品，产品总监，但开发者被允许说：”嘿，如果产品这样做不是很好吗？”在这种责任分工中更加灵活。我认为敏捷和XP在那里工作得很好，因为你们都在一起作为一个团队工作，没有那些严格的角色。</p>
<p><strong>Duncan McGregor:</strong> The best project, in my experience, we have somebody that wants the software that knows what they want and knows that domain of things, and in the best teams, they see it as their job to teach the software development team that stuff and the software development team see it as their job to teach the people who want the software how to manage a software development team.</p>
<p>**邓肯·麦格雷戈：**根据我的经验，最好的项目是我们有一个想要软件的人，他知道他们想要什么，并且知道那个领域的事情，在最好的团队中，他们认为他们的工作是教软件开发团队这些东西，而软件开发团队认为他们的工作是教想要软件的人如何管理软件开发团队。</p>
<p><strong>Nat Pryce:</strong> Yes. I think what struck people about XP when they first read about it was that it’s, this is a way of working in teams that matches the way that I work when I’m writing software by myself, maybe with some more strict discipline around testing and test driven and refactoring. But if somebody is in charge of their own software, then they’re staying on top of it. We used to call it tidying or something. But they’re constantly refactoring it because they need to stay on top of the complexity because it’s their own project and they’ve only got one brain. And within teams, this XP process took the same approach. You have to stay on top of the complexity, it’s the only way to stay flexible.</p>
<p>**纳特·普赖斯：**是的。我认为当人们第一次读到XP时，打动他们的是，这是一种团队合作的方式，与我独自编写软件时的工作方式相匹配，也许在测试和测试驱动以及重构方面有更严格的纪律。但如果有人负责他们自己的软件，那么他们会掌控它。我们过去称之为整理或什么的。但他们不断重构它，因为他们需要掌控复杂性，因为这是他们自己的项目，他们只有一个大脑。在团队中，这个XP过程采取了同样的方法。你必须掌控复杂性，这是保持灵活性的唯一方法。</p>
<p>The other things that were very innovative about it, at the time, was…I think at the time, so this is like, well, late ‘90s, early 2000s, we’d gone through a period of where teams got stuck in analysis paralysis. No one talks about that anymore, right? With the web and things like that, people can roll stuff out all the time. But back in the day, people would spend months, years doing analysis. I remember joining one area of a company where there’d been this huge effort to sort of come up with some design. This program had been running for ages. It created huge schemas that were so big that they had to buy a special, massive plotter to be able to plot them out and then stick them up on the walls. But at no point had they ever written any software at all. It was just a database schema. They hadn’t even tried to make it in DDL and then put it into a database. Then after 18 months or 2 years or something, eventually management pulled the plug and no software had even been written.</p>
<p>它在当时非常创新的其他事情是…我认为在那个时候，所以这是像，嗯，90年代末，2000年代初，我们经历了一个团队陷入分析瘫痪的时期。现在没人再谈这个了，对吧？有了网络之类的东西，人们可以随时推出东西。但在过去，人们会花几个月、几年的时间进行分析。我记得加入公司的一个领域时，那里有一个巨大的努力来想出一些设计。这个程序已经运行了很长时间。它创建了巨大的模式，如此之大，以至于他们不得不购买一个特殊的、巨大的绘图仪来绘制它们，然后把它们贴在墙上。但在任何时候，他们都没有写过任何软件。它只是一个数据库模式。他们甚至没有尝试用DDL制作它，然后把它放到数据库中。然后18个月或2年后，最终管理层取消了项目，连一行软件都没有写过。</p>
<p>So that’s a kind of project approach that XP was in total diametric opposite of and that we took in the GOOS book as well. Start with a walking skeleton, make it do as little as you possibly can get away with, get it into production, get that past to production, automated, tested, you know, and then you know you can write the next bit and the next bit of functionality knowing that it’s covered and tested and going into production, integrating with whatever environment it has to integrate with. And you’re making these tiny, tiny steps of constant incremental and iterative improvement to the system, deported by tests. And you’re using the tests for feedback about whether design needs to change and adapt and evolve.</p>
<p>所以这是一种项目方法，XP与之完全相反，我们在GOOS书中也采取了这种方法。从一个行走的骨架开始，让它做尽可能少的事情，让它投入生产，让它通过生产，自动化，测试，你知道，然后你知道你可以写下一段和下一段功能，知道它被覆盖和测试，并投入生产，与任何它必须集成的环境集成。你正在对系统进行这些微小的、持续的增量和迭代改进，由测试支持。你正在使用测试来获得关于设计是否需要改变、适应和演进的反馈。</p>
<p>That was very controversial at the time. And I don’t think really people probably now realize quite how controversial it was. People say, “This is nothing but hacking. It’s cowboy coding. This is dreadful. I wouldn’t. You know, so unprofessional.” Well, now a lot of those techniques are so embedded in the way a lot of people expect to work, we forget that someone had to actually sort of come up with them and publicize them.</p>
<p>这在当时是非常有争议的。我不认为现在的人们真的意识到它有多有争议。人们说：”这只不过是黑客行为。这是牛仔编程。这太可怕了。我不会。你知道，太不专业了。”嗯，现在这些技术中的很多已经如此嵌入到很多人期望的工作方式中，我们忘记了必须有人真正想出它们并宣传它们。</p>
<p><strong>Duncan McGregor:</strong> My recollection of the time was that the thing that GOOS introduced us to, wrote about what maybe we’d been doing in London as part of the way we worked was a sort of outside-in acceptance test-driven approach. Would you say that was the major innovation?</p>
<p>**邓肯·麦格雷戈：**我对当时的回忆是，GOOS向我们介绍的东西，写的是我们在伦敦作为工作方式的一部分可能已经做过的东西，是一种由外而内的验收测试驱动方法。你会说这是主要的创新吗？</p>
<p><strong>Nat Pryce:</strong> I don’t know if it was an innovation. It was certainly what we wrote about and it wasn’t what Ken Beck really wrote about as much in his book. There was a lot more bottom-up sort of approach in TDD in the first wave, let’s say. I don’t like the sort of Detroit versus London school or whatever I think. But there’s definitely people who start in the small and sort of grow it out. And we took a sort of “Let’s try and capture everything and work from outside in.” So I don’t know whether that just was a result of the systems we were building that had to integrate with large sorts of IT estates and big organizations.</p>
<p>**纳特·普赖斯：**我不知道它是否是一种创新。它确实是我们写的东西，而Ken Beck在他的书中并没有真正写那么多。在第一波TDD中，可以说有更多的自下而上的方法。我不喜欢底特律与伦敦学派或什么的。但肯定有人从小处开始，然后逐渐扩展。我们采取了一种”让我们尝试捕捉一切，从外向内工作”的方法。所以我不知道这是否只是我们构建的必须与大型IT资产和大型组织集成的系统的结果。</p>
<p><strong>Duncan McGregor:</strong> So maybe you should explain. Detroit was based around the original XP system, wasn’t it? Which was a payroll system for Chrysler, I think.</p>
<p>**邓肯·麦格雷戈：**所以也许你应该解释一下。底特律是基于原始的XP系统，不是吗？我认为是克莱斯勒的薪资系统。</p>
<p><strong>Nat Pryce:</strong> Chrysler, I think.</p>
<p>**纳特·普赖斯：**克莱斯勒，我认为。</p>
<p><strong>Duncan McGregor:</strong> And their TDD was a process where you sort of had this idea for what the low-level building blocks of your software would be and you’d write those and you’d write the test for them. And then you’d say, “Okay, well, now we’ve got this, we can build bigger abstractions based on those and then write tests and then write those.” And then we build software from things that we thought, when we finally plug them together, we’ll make our working software. Whereas GOOS said, “Well, there’s a danger that we’re going to write software that we don’t need or we’ll overwrite it and so on. What happens if we wrote from the outside in and wrote the very minimum set of things that we would have to write to support a particular use case, to support the next feature we’re trying to do?”</p>
<p>**邓肯·麦格雷戈：**他们的TDD是一个过程，你大概对软件的低级构建块有什么想法，你会写这些，你会为它们写测试。然后你会说：”好的，现在我们有了这个，我们可以基于这些构建更大的抽象，然后写测试，然后写这些。”然后我们构建软件，从我们以为的东西，当我们最终把它们插在一起时，我们会做出我们的工作软件。而GOOS说：”嗯，有一个危险，我们要写我们不需要的软件，或者我们会覆盖它等等。如果我们从外向内写，写我们必须写的最小的一组东西来支持特定的用例，来支持我们试图做的下一个功能，会发生什么？”</p>
<p><strong>Nat Pryce:</strong> I don’t know whether that description of Detroit is accurate or not. I can’t imagine it is. I can’t imagine that they sat down and went, “Well, we obviously need, I don’t know, a money-type. So we’ll write money. Okay, now we obviously need a currency-type. And eventually, we’ll get to a payroll.” They must have started at a higher level than that.</p>
<p>**纳特·普赖斯：**我不知道对底特律的描述是否准确。我无法想象它是准确的。我无法想象他们坐下来然后说：”嗯，我们显然需要，我不知道，一个货币类型。所以我们会写货币。好的，现在我们显然需要一个货币类型。最终，我们会得到一个薪资系统。”他们一定是从比这更高的层次开始的。</p>
<p>But certainly in the case of we were working in organizations, particularly some of it came out of banks, some of it came out of telcos, where we were integrating with messaging systems that allowed us to interact with other parts of the organization. And we were integrating with, say, reference data services. So there was a definite, like, there’s certain ways you have to integrate. Otherwise, you cannot make your application work. So there’s clear boundaries. You’re writing a system with clear inputs and outputs that you’re going to plug into. Like, even with the front ends, we would treat that as sort of an input-output.</p>
<p>但在我们工作的组织的情况下，特别是其中一些来自银行，一些来自电信公司，我们与消息系统集成，使我们能够与组织的其他部分交互。我们与参考数据服务等集成。所以有一个明确的，就像，你必须以某些方式集成。否则，你无法让你的应用程序工作。所以有明确的边界。你正在编写一个具有明确输入和输出的系统，你将把它插入。就像，即使是前端，我们也会把它当作一种输入输出。</p>
<p>From that, you can say, well, if we want to, I don’t know, order a broadband line or something. “Well, you’re going to get a message from the telco that looks like this. And you’re going to have to basically ask for payment from that system over there. That’s going to look like that.” So from there, you can easily say from the very outside, “Here’s what we’d expect to see.” And then start thinking about, okay…and then the admin user would see this coming up in a report. Like, you know, a person would see this coming and then start, like, coming up with a structure for those edges. And then you could build up the middle. As long as you’ve got the edge defined, you can refactor as much as you like in the middle, confident that you’re not going to break the system.</p>
<p>从那里，你可以说，嗯，如果我们想，我不知道，订购一条宽带线路或什么的。”嗯，你会从电信公司得到一个看起来像这样的消息。你将基本上必须从那个系统请求付款。那将看起来像这样。”所以从那里，你可以很容易地从最外面说：”这是我们期望看到的。”然后开始思考，好的…然后管理员用户会在报告中看到这一点。就像，你知道，一个人会看到这一点，然后开始，比如，为这些边缘提出一个结构。然后你可以建立中间部分。只要你定义了边缘，你就可以在中间随意重构，确信你不会破坏系统。</p>
<p><strong>Duncan McGregor:</strong> So you’ve managed to not talk about one of the innovations of GOOS and sort of skirt around the edges of it. So if we’re going to build a system from the outside, there’s going to be this point where, for example, we have a bit of the system that we haven’t written yet, but we still want to see whether our whole system works. So that system might be how we save things to disk or how we talk to this system over here or that sort of thing. GOOS publicized, popularized a technology, should we call it, of mock objects.</p>
<p>**邓肯·麦格雷戈：**所以你设法没有谈论GOOS的一项创新，并且有点回避了它的边缘。所以如果我们从外部构建一个系统，会有这样一个点，例如，我们有一个我们还没有编写的系统部分，但我们仍然想看看我们的整个系统是否工作。所以那个系统可能是我们如何保存东西到磁盘，或者我们如何与这里的这个系统或那种东西交谈。GOOS宣传、普及了一种技术，我们应该称之为，模拟对象。</p>
<p><strong>Nat Pryce:</strong> Practice. Technique. Yes.</p>
<p>**纳特·普赖斯：**实践。技术。是的。</p>
<p><strong>Duncan McGregor:</strong> Technique.</p>
<p>**邓肯·麦格雷戈：**技术。</p>
<p><strong>Nat Pryce:</strong> I think it’s more of a technique than a technology, I think. Because you don’t need to use a particular library or something. It’s really, yeah, it was used in a number of ways. So again, a lot of what we were building was event-driven or message-driven. And so it was a very natural fit for object-oriented systems built out of…composed out of state machines. So those state machines fix through states receiving and sending messages, either driven by messages coming in from a message bus or from other object message calls.</p>
<p>**纳特·普赖斯：**我认为它更像是一种技术而不是技术。因为你不需要使用特定的库或什么的。它确实，是的，它被用于多种方式。所以再次，我们构建的很多是事件驱动或消息驱动的。所以它非常适合面向对象的系统，这些系统由…由状态机组成。所以这些状态机通过接收和发送消息来修复状态，要么由来自消息总线的消息驱动，要么由其他对象消息调用驱动。</p>
<p>Those protocols, by which they talk, are really the design of the system. You’ve got a bunch of different protocols between your objects. You can then write an object in your class that implements some roles in these protocols, and then it will plug in into the right place. You can then… As soon as you’ve got enough of that, you’re now writing code by reorganizing graphs of objects rather than writing procedural code in Java or whatever it is.</p>
<p>它们交谈的协议实际上是系统的设计。你的对象之间有一堆不同的协议。然后你可以在类中写一个对象，实现这些协议中的一些角色，然后它会插入到正确的位置。然后你可以…一旦你有了足够的这些，你现在通过重新组织对象图来编写代码，而不是用Java或任何语言编写过程代码。</p>
<p>So how do you represent those protocols and how do you represent them in tests? That was one of the sort of drivers of mock objects. And how do you know if these things are clicking through states? But the way that they expose their behavior to the rest of the system is by sending out messages to other objects, not by exposing data that is queried. How do you know whether they have performed the behavior that they should perform when you plug them into that graph of objects? So again, that’s where mock objects came from. How can you test drive some software without just looking at its internal state, which is an implementation detail in a system that is based around state machines composed together through messaging protocols?</p>
<p>那么你如何表示这些协议，以及你如何在测试中表示它们？这是模拟对象的驱动因素之一。你怎么知道这些东西是否在状态中点击？但它们向系统其余部分暴露其行为的方式是通过向其他对象发送消息，而不是通过暴露被查询的数据。你怎么知道当你把它们插入到对象图中时，它们是否执行了它们应该执行的行为？所以再次，这就是模拟对象的来源。你如何在不只看其内部状态的情况下测试驱动一些软件，而内部状态是基于通过消息协议组合在一起的状态机的系统中的一个实现细节？</p>
<p><strong>Duncan McGregor:</strong> So it’s odd that, in those days, we had beautiful OO design for things. And in those days we had objects whose job was to encapsulate state. That we weren’t supposed to ask about the state, we were supposed to derive interactions. An object would hold onto its state and…encapsulation was the phrase, wasn’t it? Like, we don’t care what state it’s storing, how it’s storing it, providing it can do its job. Provided we can send a message to it to tell it do the next thing in the state or whatever. We don’t work like that anymore. Do we not work like that anymore because we’re not writing desktop applications in Smalltalk or Java Swing?</p>
<p>**邓肯·麦格雷戈：**所以很奇怪，在那些日子里，我们有美丽的事物面向对象设计。在那些日子里，我们有对象，其工作是封装状态。我们不应该询问状态，我们应该推导出交互。一个对象会保持其状态，并且…封装是短语，不是吗？就像，我们不关心它存储什么状态，如何存储它，只要它能完成它的工作。只要我们能向它发送消息，告诉它在状态中做下一件事或什么的。我们不再那样工作了。我们不再那样工作是因为我们不再用Smalltalk或Java Swing编写桌面应用程序吗？</p>
<p><strong>Nat Pryce:</strong> I think we work like that, but just in different places. And we sometimes don’t admit to ourselves that we’re working like that. So we work like that when we’re composing microservices. So we’re working like that at a larger scale. And maybe the idea…who was it, Alan Kay’s idea that everything’s an object and objects are smaller. You can take your computer and you divide it into smaller computers and smaller computers. One of each of these things is an object. At some point, maybe object orientation is not paying off with a fine grain. But at a microservice level, having a clear protocol that things communicate with and clear encapsulation boundaries and not letting other services reach into the database of a different service and just rummage about in it, couple yourselves to it, is a principle that people still apply. They might not use the same terminology, but they still apply it.</p>
<p>**纳特·普赖斯：**我认为我们那样工作，但只是在不同的地方。我们有时不承认我们那样工作。所以我们在组合微服务时那样工作。所以我们在更大的规模上那样工作。也许这个想法…是谁，Alan Kay的想法，一切都是对象，对象更小。你可以把你的电脑分成更小的电脑和更小的电脑。这些东西中的每一个都是一个对象。在某种程度上，也许面向对象在细粒度上没有回报。但在微服务层面，有一个清晰的协议，事物通过它进行通信，清晰的封装边界，不让其他服务进入不同服务的数据库，只是翻找它，将自己与之耦合，是人们仍然应用的原则。他们可能不使用相同的术语，但他们仍然应用它。</p>
<p><strong>Duncan McGregor:</strong> Now we call that a bounded context. So what you’re saying is that we used to have objects that sat in memory that didn’t admit, didn’t expose their representation. Now we have a bounded context that the whole machine or a whole set of microservices that are talking to a database that they don’t expose.</p>
<p>**邓肯·麦格雷戈：**现在我们称之为有界上下文。所以你说的是，我们过去有坐在内存中的对象，这些对象不承认，不暴露它们的表示。现在我们有一个有界上下文，整个机器或一整套微服务，它们正在与一个它们不暴露的数据库交谈。</p>
<p><strong>Nat Pryce:</strong> Yes. It’s similar design principles, right, but just at a larger scale. Where else? Oh, and if you look at, say, RX or Reactive Streams, that’s a fantastic example of a really well-designed object oriented library or framework. I don’t know what you’d call it. Library. And has a design pretty much the same as what we were trying to describe in GOOS, which is you’ve got state machines. You don’t know what’s in them. They talk through very clear, well-defined protocols. Those protocols let you create graphs in different structures that do different things. On top of that, you write some convenience code that then appears to be…that composes these objects and then acts as a very high-level declarative domain-specific language embedded in your 3GL. That’s exactly how we write Reactive Streams code. We write what looks like pure functional code. Underneath it, there’s lots of state machines ticking through and all of that stuff is going on. They all plug together through very clear interfaces that let you put them together into different structures to get different effects. So I think we still do it, right? But we like to describe it in terms of functional programming terms because it makes us sound that we understand maths.</p>
<p>**纳特·普赖斯：**是的。这是类似的设计原则，对吧，只是规模更大。还有哪里？哦，如果你看看，比如说，RX或Reactive Streams，那是一个非常精心设计的面向对象库或框架的绝佳例子。我不知道你会怎么称呼它。库。它的设计与我们在GOOS中试图描述的几乎相同，你有状态机。你不知道里面有什么。它们通过非常清晰、定义良好的协议进行通信。这些协议让你创建不同结构的图，做不同的事情。在此基础上，你编写一些便利代码，然后看起来是…组合这些对象，然后充当嵌入在你的3GL中的非常高级的声明性领域特定语言。这正是我们编写Reactive Streams代码的方式。我们编写看起来像纯函数代码的东西。在它下面，有很多状态机在滴答作响，所有这些东西都在进行。它们都通过非常清晰的接口插在一起，让你把它们组合成不同的结构以获得不同的效果。所以我们仍然这样做，对吧？但我们喜欢用函数式编程术语来描述它，因为这让我们听起来我们理解数学。</p>
<p><strong>Duncan McGregor:</strong> I mean, I do feel that, to me, I still think of myself as an object-oriented programmer, but the thing that’s changed is I don’t think of sending messages to objects to change their state anymore. I send messages to objects to ask them about things and then I mutate them into other objects.</p>
<p>**邓肯·麦格雷戈：**我的意思是，我确实觉得，对我来说，我仍然认为自己是一个面向对象的程序员，但改变的是我不再考虑向对象发送消息来改变它们的状态。我向对象发送消息来询问它们事情，然后把它们突变成其他对象。</p>
<p><strong>Nat Pryce:</strong> Transform them.</p>
<p>**纳特·普赖斯：**转换它们。</p>
<p><strong>Duncan McGregor:</strong> Transform, yes. So this idea of objects encapsulating state is still there, but encapsulating state change, I don’t think is.</p>
<p>**邓肯·麦格雷戈：**转换，是的。所以对象封装状态的想法仍然存在，但封装状态变化，我认为不是。</p>
<p><strong>Nat Pryce:</strong> Yes, apart from some areas of the system, right? I think that’s where the object-orientation-everywhere idea, like, sort of didn’t really work because there’s parts of the system which calculate a result and there’s parts of the system that coordinate activity or, you know… I read a blog post by someone who I can’t remember at all who sort of described as there’s parts of the system that are informatics and there’s parts of the system that are cybernetic, right? The cybernetic systems, their job is to maintain homeostasis. It’s like your server receives an event, right? It processes that result. Processing the result will calculate something that has to be sent back. There’s your informatics bit, right? But then the server goes back to, like, hopefully, being able to receive the next request without having leaked any memory. So that’s your homeostasis bit, right? And OO comes from a cybernetic sort of tradition and functional programming comes from a calculating results sort of informatics tradition. And our systems need both, right? And they need both sort of in different places of the system or in layers. And having just one way of doing things doesn’t actually make building a real system easy. It can make it harder, right?</p>
<p>**纳特·普赖斯：**是的，除了系统的一些领域，对吧？我认为这就是面向对象无处不在的想法，比如，有点不起作用的地方，因为系统中有计算结果的部分，也有协调活动的部分，或者，你知道…我读过一篇博客文章，作者我完全不记得了，他描述为系统中有信息学的部分，也有控制论的部分，对吧？控制论系统，它们的工作是维持稳态。就像你的服务器接收一个事件，对吧？它处理那个结果。处理结果将计算必须发送回去的东西。那是你的信息学部分，对吧？但然后服务器回到，比如，希望能够在没有泄漏任何内存的情况下接收下一个请求。所以那是你的稳态部分，对吧？面向对象来自控制论传统，函数式编程来自计算结果的信息学传统。我们的系统需要两者，对吧？它们需要在系统的不同地方或层中都需要两者。只有一种做事方式实际上并不能使构建真实系统变得容易。它可能使它更难，对吧？</p>
<p><strong>Duncan McGregor:</strong> Thinking back to the days of GOOS, 15 years now, what other changes do you see in the software development landscape?</p>
<p>**邓肯·麦格雷戈：**回想GOOS的日子，15年过去了，你在软件开发领域还看到了哪些其他变化？</p>
<p><strong>Nat Pryce:</strong> Well, machines are a lot faster, right? And that changes how much you can test in one go, right? So there was like a very strict distinction that people were drawing between unit tests and, I don’t know, people didn’t have a good word for it, integration tests, not unit tests, right? Things that do IO, things that touch hardware, right? If you can run everything in memory, it goes fast. Debug is reliable. But mainly people are concerned about fast, right, fast feedback. And then as soon as you touch IO, it goes slowly. Well, that, you know, technology has changed. You can run a lot more, much faster now. We don’t have spinning disks. We have, like, SSDs, you know, fantastic machines, I don’t know, orders of magnitude faster, many orders of magnitude faster. So now we can run more in our tests at one go. And so there’s less need to have lots of little unit tests to try and get that fast feedback.</p>
<p>**纳特·普赖斯：**嗯，机器快多了，对吧？这改变了你一次可以测试多少，对吧？所以人们曾经非常严格地区分单元测试和，我不知道，人们没有好词来形容它，集成测试，不是单元测试，对吧？做IO的事情，接触硬件的事情，对吧？如果你能在内存中运行所有东西，它运行得很快。调试是可靠的。但主要人们关心的是快，对吧，快速反馈。然后一旦你接触IO，它就变慢了。嗯，你知道，技术已经改变了。你现在可以运行更多，快得多。我们没有旋转磁盘。我们有，比如，SSD，你知道，神奇的机器，我不知道，快几个数量级，快很多个数量级。所以现在我们可以一次在测试中运行更多。所以不太需要有很多小的单元测试来试图获得快速反馈。</p>
<p>But you know, if you use something like test containers to spin up a database, you’re still going to have difficulty doing fault injection to sort of exercise your error-handling paths, for example. So there’s still a need for that sort of abstraction level and the seams that let you instantiate and then test the pieces of functionality. But we can also do much more thorough testing of larger scales. That’s one thing I’ve noticed.</p>
<p>但你知道，如果你使用像测试容器这样的东西来启动数据库，你仍然会在进行故障注入以锻炼你的错误处理路径等方面遇到困难，例如。所以仍然需要那种抽象级别和接缝，让你实例化然后测试功能片段。但我们也可以对更大规模进行更彻底的测试。这是我注意到的一件事。</p>
<p>I mean, functional programming, right? That’s the other thing is like, you know, that…when we wrote GOOS, what? It was written in Java 6, I think, and didn’t really have much support for functional programming in Java. But now since then, there is some support for functional programming in Java, but also modern languages, all modern languages now have much better support for that, like you say, transforming data rather than mutating data.</p>
<p>我的意思是，函数式编程，对吧？这是另一件事，就像，你知道，那…当我们写GOOS时，什么？我认为是用Java 6写的，Java中并没有真正支持函数式编程。但现在从那时起，Java中有一些对函数式编程的支持，但现代语言，所有现代语言现在都有更好的支持，就像你说的，转换数据而不是改变数据。</p>
<p><strong>Duncan McGregor:</strong> Yes, I think it’s the thing that we always could do. And I think the Java developers in our audience, should we still have one, will probably remember Guava maybe as the point where functional programming became convenient enough in Java that you could represent things as chains of calculations, composable chains, rather than it was just easier to mutate a list, you know, sort in place and so on, that sort of thing.</p>
<p>**邓肯·麦格雷戈：**是的，我认为这是我们一直可以做的事情。我认为我们的观众中的Java开发者，如果我们还有的话，可能会记得Guava也许是函数式编程在Java中变得足够方便的时候，你可以把事物表示为计算链，可组合的链，而不是只是更容易改变一个列表，你知道，就地排序等等，那种事情。</p>
<p>I like the idea that things are quicker. I’m not like…well, the machines are quicker. I do wonder whether we’re squandering that a bit.</p>
<p>我喜欢事物更快的想法。我不像…嗯，机器更快了。我确实想知道我们是否有点浪费它。</p>
<p><strong>Nat Pryce:</strong> That’s the software development tradition though, isn’t it?</p>
<p>**纳特·普赖斯：**这是软件开发传统，不是吗？</p>
<p><strong>Duncan McGregor:</strong> Personally, I’ve sort of spent the last few weeks looking at how fast tests are to run in IntelliJ, and the answer is simply not at all. Like I would have…it takes 3 seconds to get feedback on practically anything these days. And as far as I can remember, it took 3 seconds to get feedback on the same amount of code 15 years ago.</p>
<p>**邓肯·麦格雷戈：**就我个人而言，我过去几周一直在看IntelliJ中测试运行有多快，答案就是一点也不快。就像我会…现在几乎任何事情都需要3秒钟才能得到反馈。据我所知，15年前，同样数量的代码也需要3秒钟才能得到反馈。</p>
<p><strong>Nat Pryce:</strong> One thing that’s changed though, is, I’ve gone from Java to Kotlin as my main preferred language, the sort of enterprise delivery, whatever, we have a working type system, right? But that type system takes longer to do its type checking, but you can rely on it a lot more than you could in Java, which has complexities in its type system that make it rather inconvenient. And so people rely on Reflection and things like that in Java a lot more than they would need to in Kotlin.</p>
<p>**纳特·普赖斯：**然而，有一件事改变了，我已经从Java转向Kotlin作为我的主要首选语言，那种企业交付，无论什么，我们有一个工作的类型系统，对吧？但那个类型系统需要更长的时间来进行类型检查，但你可以比Java更依赖它，Java的类型系统有复杂性，使它相当不方便。所以人们在Java中更多地依赖反射和类似的东西，比在Kotlin中需要得多。</p>
<p>You’ve got this trade-off with, like you say, with 3 seconds to get a result, but a lot of that might be type checking, and then we could move a lot of our checking into the type system, into a type-level modeling that we would otherwise have had to write unit tests for. So it’s sort of paying off. And then you might not even notice the fact that I’m writing something, and now my ID is underlining stuff in red, and I’m just going to fix it. I’ve not even had to run a test. But in the past, I’d have had to run a test to find out that I’ve just made that mistake. So there’s feedback that’s faster in different ways, and definitely, that’s changed how I think about designing things in a way that is, you know, different.</p>
<p>你有这种权衡，就像你说的，用3秒钟得到一个结果，但很多可能是类型检查，然后我们可以把很多检查移到类型系统中，移到类型级建模中，否则我们就必须写单元测试。所以它有点回报。然后你可能甚至没有注意到我正在写东西，现在我的IDE用红色下划线标出东西，我就去修复它。我甚至不需要运行测试。但在过去，我必须运行测试才能发现我刚刚犯了那个错误。所以有不同的方式更快的反馈，肯定，这改变了我思考设计事物的方式，这是，你知道，不同的。</p>
<p><strong>Duncan McGregor:</strong> Yes, I think we have learned to use the type systems we have and more sophisticated type systems to represent things about our software, haven’t we? The whole making illegal states unrepresentable, I think, has changed the way we write software in the past 15 years. We could always have done it, but we didn’t know that we could, and so we didn’t.</p>
<p>**邓肯·麦格雷戈：**是的，我认为我们已经学会了使用我们拥有的类型系统和更复杂的类型系统来表示关于我们软件的事情，不是吗？使整个非法状态无法表示，我认为已经改变了我们在过去15年编写软件的方式。我们本来一直可以这样做，但我们不知道我们可以，所以我们没有。</p>
<p><strong>Nat Pryce:</strong> Yes. Well, it’s just too inconvenient. I mean, in Java with, like, use-site variance and things like that is just…sometimes it’s just so painful to use and primitive versus reference types. Having to worry about that stuff, you just can’t easily represent certain things. Too awkward. It’ll get better, but Java is a slow-moving beast.</p>
<p>**纳特·普赖斯：**是的。嗯，只是太不方便了。我的意思是，在Java中，比如使用点差异和类似的东西只是…有时使用它太痛苦了，原始类型与引用类型。不得不担心这些东西，你就不能轻易表示某些事情。太笨拙了。它会变得更好，但Java是一个行动缓慢的野兽。</p>
<p><strong>Duncan McGregor:</strong> Do you feel that we’re writing software quicker than 15 years ago?</p>
<p>**邓肯·麦格雷戈：**你觉得我们写软件比15年前更快吗？</p>
<p><strong>Nat Pryce:</strong> Not really, but we’re also doing bigger things, I think. Maybe not justifiably, you know, we write where we would have written a server</p>
<p>**纳特·普赖斯：**并不真的，但我们也在做更大的事情，我认为。也许没有正当理由，你知道，我们写我们本来会写一个服务器的地方</p>
<p>… we now write 20 microservices, and now we have to worry about integrating an APM solution and instrumenting all of our HTTP calls so we know what’s going on in our system, etc. You can say it’s crazy, but at the same time, you think…at some point you’ve got to think, developers prefer to run a distributed system than use the modularization mechanisms in their existing languages, which means that those existing languages must be doing something wrong in the way that they do modules.</p>
<p>…我们现在写20个微服务，现在我们不得不担心集成APM解决方案和检测我们所有的HTTP调用，这样我们就知道我们的系统中发生了什么，等等。你可以说这是疯狂的，但同时，你想…在某个时候你必须想，开发者宁愿运行分布式系统，也不愿使用他们现有语言中的模块化机制，这意味着这些现有语言在它们做模块的方式上一定做错了什么。</p>
<p><strong>Duncan McGregor:</strong> Yes. I think the boundaries are always hard, and then we’re in Conway’s law, and the hard boundary supplied by microservice saves us having to go to somebody’s desk and talk to them, maybe. I feel we have squandered a lot of the advantages that we’ve had over the past 15 years. Software is big in two dimensions, really, isn’t it? It’s big in its ability to scale out, how many requests per second we can handle, or how much data we can store, and then there’s how many features we have, like what it actually does. I feel that we are able to store and access more data, and we’re able to be more scalable, but I don’t actually feel that we are delivering features any quicker these days.</p>
<p>**邓肯·麦格雷戈：**是的。我认为边界总是很难，然后我们在康威定律中，微服务提供的硬边界使我们不必走到某人的办公桌前和他们交谈，也许。我觉得我们已经浪费了过去15年来我们拥有的很多优势。软件在两个维度上很大，不是吗？它在扩展能力方面很大，我们每秒能处理多少请求，或者我们能存储多少数据，然后是我们有多少功能，就像它实际做什么。我觉得我们能够存储和访问更多数据，我们能够更具可扩展性，但我实际上并不觉得我们如今交付功能更快了。</p>
<p><strong>Nat Pryce:</strong> We expect more from our features, right? That’s the other thing. Back in the day, people would be quite, well, I wouldn’t say happy, but they were put up with a desktop user interface created by a programmer in Swing or in .NET. Nowadays, they have people who can actually design user interfaces, explaining to the developers what a good-looking user interface and what a well-working user interface, let’s say, actually should be like. I think we are expected to do more. We’re expected to create websites that work on a wider variety of devices. It’s not just a VGA screen. It has to work on mobile. It has to work on big desktops, iPads, a variety of operating systems, multiple different browsers, each with their own release cadences. That brings a lot of complexity that people just have to deal with. I was rightly joking about the microservices being sort of a crutch because language modularization systems aren’t very good, but at the same time, we have to break our systems up because different parts of our systems have different scalability and failover needs. At that point, we were already running a distributed system, so we then repurpose it for modularization as well.</p>
<p>**纳特·普赖斯：**我们对功能的期望更高了，对吧？这是另一回事。在过去，人们会相当，嗯，我不会说高兴，但他们忍受了由程序员在Swing或.NET中创建的桌面用户界面。如今，他们有真正能够设计用户界面的人，向开发者解释一个好看的用户界面和一个运行良好的用户界面，比如说，实际上应该是什么样的。我认为我们被期望做得更多。我们被期望创建在更广泛的设备上工作的网站。它不仅仅是VGA屏幕。它必须在移动设备上工作。它必须在大型桌面、iPad、各种操作系统、多个不同的浏览器上工作，每个浏览器都有自己的发布节奏。这带来了很多复杂性，人们只是必须处理。我正确地开玩笑说微服务是一种拐杖，因为语言模块化系统不是很好，但同时，我们必须分解我们的系统，因为我们系统的不同部分有不同的可扩展性和故障转移需求。在那时，我们已经运行了一个分布式系统，所以我们也将其重新用于模块化。</p>
<p><strong>Duncan McGregor:</strong> I don’t believe that, to be honest with you. I mean, pushing back, I think we tell ourselves that, but we can scale monoliths. We’ve had the same code base and different bits of it can scale in different directions. If Facebook can run a monolith, I’m sure that we can solve our problems with monoliths. The extent to which we break things up, I think it largely is fashion. And probably there are places where we should have queues and queue consumers, and maybe they should be different processes. But I think most of what we write should probably be sitting in one process that is then duplicated and load-balanced effectively. But moving things between having different microservices in order to have bounded context boundaries, yes, I don’t believe in personally. Bring back the monolith.</p>
<p>**邓肯·麦格雷戈：**老实说，我不相信。我的意思是，反驳，我认为我们告诉自己，但我们可以扩展单体。我们有相同的代码库，它的不同部分可以在不同方向上扩展。如果Facebook可以运行单体，我相信我们可以用单体解决我们的问题。我们把东西分解的程度，我认为很大程度上是时尚。也许有些地方我们应该有队列和队列消费者，也许它们应该是不同的进程。但我认为我们写的大部分东西可能应该坐在一个进程中，然后有效地复制和负载平衡。但为了有界上下文边界而在不同的微服务之间移动东西，是的，我个人不相信。把单体带回来。</p>
<p><strong>Nat Pryce:</strong> All right. We’ve sort of gone off on a bit of a tangent there.</p>
<p>**纳特·普赖斯：**好吧。我们有点跑题了。</p>
<p><strong>Duncan McGregor:</strong> One of the things I remember about those GOOS days, as you say, is that we were, in fact, developing interfaces for internal teams, largely, or simply for the desktop. And one of the places I feel that we really haven’t managed to make agile work is with interaction designers. I feel that, in those days, we were able to be agile because we could sit with a customer, work out what they wanted the thing to look like as part of, “Are we going to do that this iteration?” Whereas interaction designers like things to be designed upfront. And that design upfront actually is the tail that wags the agile dog these days.</p>
<p>**邓肯·麦格雷戈：**我记得那些GOOS日子的一件事，正如你所说，我们实际上是在为内部团队开发接口，主要是，或者仅仅是为桌面。我觉得我们真的没有设法让敏捷工作的一个地方是与交互设计师。我觉得，在那些日子里，我们能够敏捷，是因为我们可以与客户坐在一起，弄清楚他们希望这个东西看起来像什么，作为”我们要在这个迭代中做吗？”的一部分。而交互设计师喜欢事情被预先设计。而预先设计实际上是如今摇动敏捷狗的尾巴。</p>
<p><strong>Nat Pryce:</strong> Yes. I can understand there’s a lot of research that goes into it, especially if you’ve got a site that has to meet the needs of customers around the world. When you’re just working for, I don’t know, like a trading desk and you’ve got like four people that you’re writing software for, what they want goes, right? But when you’ve got to be able to make your software usable by people who you never even meet, you rely very much on the research. But you’re right. I mean, I’ve always struggled with being able to work incrementally and iteratively with designers, being able to say, “Okay, you know, I understand what the final design should be like, but we’re coming in like this. So what’s our first delivery and how can we get value, and then the next one, and the next one, and the next one? And how does the design evolve so that it remains usable as it’s going through these intermediate states?” That’s difficult.</p>
<p>**纳特·普赖斯：**是的。我可以理解其中涉及很多研究，特别是如果你有一个必须满足世界各地客户需求的网站。当你只是为，我不知道，像一个交易台工作，你有像你为之编写软件的四个人，他们想要的就去，对吧？但是当你必须让你从未见过的人能够使用你的软件时，你就非常依赖研究。但你是对的。我的意思是，我一直在努力能够与设计师增量和迭代地工作，能够说：”好的，你知道，我理解最终设计应该是什么样的，但我们像这样进来。那么我们的第一次交付是什么，我们如何获得价值，然后下一次，下一次，下一次？设计如何演进，以便在这些中间状态中保持可用？”这很困难。</p>
<p><strong>Duncan McGregor:</strong> One of my biggest innovations recently has been to take the interaction designers final mock-ups of the thing and say, “Okay, this iteration, we are going to produce this with this scribbled out, this scribbled out, and this scribbled out. And then the next one, we’ll undo some of the scribbling.” Because finding a way to deliver value in the next week is, I guess, really back to what GOOS was about. The very first thing you should be doing is working out how to deliver the system. And then once you deliver the system, what is the smallest increment of value we can give our customers?</p>
<p>**邓肯·麦格雷戈：**我最近最大的创新之一是拿交互设计师的最终模型，说：”好的，这个迭代，我们将产生这个，这个被划掉，这个被划掉，这个被划掉。然后下一次，我们将撤销一些划线。”因为找到一种在下周交付价值的方法，我想，真的回到了GOOS的意义。你应该做的第一件事是弄清楚如何交付系统。然后一旦你交付了系统，我们能给我们的客户的最小价值增量是什么？</p>
<p>As you said about XP, it was how do we develop software that we need ourselves? If I’m writing software to format something for a book or total my bank account or whatever it is, the thing that I do is the smallest thing that will give me value. And if I need to write tests to think that I will be able to maintain that, I’ll do that. If I don’t need to write tests, you know, tests have to be an economic argument. They have to support this thing going on. Often I’ll write them because otherwise if I come back to this later, I won’t be able to do it. But that constant focus on, how can I give you value quicker whilst at the same time knowing that I’m going to be able to continue to give you value quickly for the next week and the next month and so on, that’s the essence of XP, it’s the essence of Agile, and I think the essence of what GOOS gave us, which was this guided by the tests. It was this outside-in thing, real focus on delivering to the customer, not doing anything that wasn’t focused on delivering value to the customer.</p>
<p>正如你所说的关于XP，它是我们如何开发我们自己需要的软件？如果我正在编写软件来为书籍格式化某些东西或总计我的银行账户或无论什么，我所做的是能给我带来价值的最小的事情。如果我需要写测试来认为我将能够维护它，我会这样做。如果我不需要写测试，你知道，测试必须是一个经济论证。它们必须支持这件事的进行。通常我会写它们，因为否则如果我以后回到这里，我将无法做到。但持续关注，我如何能更快地给你价值，同时知道我将能够在下周和下个月等继续快速给你价值，这是XP的本质，这是敏捷的本质，我认为也是GOOS给我们的本质，这就是由测试引导。这是由外而内的事情，真正专注于交付给客户，不做任何不专注于向客户交付价值的事情。</p>
<p><strong>Nat Pryce:</strong> Yes. I think you’re saying, are we doing it as fast as we used to? Has it got faster? I don’t think it has. But at the same time, I think part of it is, at the same time as Agile was happening, open source was happening. Agile and XP focused on continuous integration and then continuous delivery, then continuous deployment. And open source focused on sort of unsolicited changes, review, and that ended up with sort of the pull request. And those two things are coming from different cultures, different…I don’t know if culture is the right word, but definitely different traditions with different constraints and different needs. But we have somehow sort of smashed them together where people in enterprise organizations are using pull requests in order to sort of elaborate in a way that’s less effective than continuous integration was. And that’s the sort of constant argument I see going on.</p>
<p>**纳特·普赖斯：**是的。我认为你在说，我们做得像以前一样快吗？它变得更快了吗？我不这么认为。但同时，我认为部分原因是，在敏捷发生的同时，开源也在发生。敏捷和XP专注于持续集成，然后是持续交付，然后是持续部署。开源专注于未经请求的改变、审查，最终形成了拉取请求。这两件事来自不同的文化，不同的…我不知道文化是否是正确的词，但肯定是来自不同约束和不同需求的不同传统。但我们不知何故把它们混合在一起，企业组织中的人们使用拉取请求，以一种比持续集成效果更差的方式进行阐述。这就是我看到的持续争论。</p>
<p><strong>Duncan McGregor:</strong> It is amazing to me that trunk-based development didn’t have to be a phrase 15 years ago.</p>
<p>**邓肯·麦格雷戈：**15年前，基于主干的开发不必是一个短语，这对我来说是惊人的。</p>
<p><strong>Nat Pryce:</strong> Yes.</p>
<p>**纳特·普赖斯：**是的。</p>
<p><strong>Duncan McGregor:</strong> Because what else was there?</p>
<p>**邓肯·麦格雷戈：**因为还有什么？</p>
<p><strong>Nat Pryce:</strong> It was just the way you did it. You had ClearCase, right, which had branching all over the place and merge requests. And then you had everyone else who didn’t want to use ClearCase because it was so difficult and just did trunk-based development in Perforce and then Subversion and then whatever. And then now we’re all reinventing ClearCase on top of something that doesn’t need to be that complicated.</p>
<p>**纳特·普赖斯：**这只是你做事的方式。你有ClearCase，对吧，它到处都有分支和合并请求。然后你有所有其他人，他们不想使用ClearCase，因为它太难了，只是在Perforce中做基于主干的开发，然后是Subversion，然后是任何。然后现在我们都在不需要那么复杂的东西之上重新发明ClearCase。</p>
<p><strong>Duncan McGregor:</strong> Well, this has been two grumpy old men. I think maybe we should… This would be a good place to wrap it up before we get into a religious war. Thank you so much for your time today, Nat. If people want to find out more about you, where should they look?</p>
<p>**邓肯·麦格雷戈：**嗯，这是两个脾气暴躁的老头。我想也许我们应该…在我们陷入宗教战争之前，这将是一个很好的结束地方。非常感谢你今天的时间，纳特。如果人们想了解更多关于你的信息，他们应该去哪里看？</p>
<p><strong>Nat Pryce:</strong> I’m going to be at KotlinConf in May and Craft in May, end of May, June. So I’ll be speaking there and running a workshop on the topic of…well, with you, we will be running a workshop on the topic of refactoring from OO to functional and looking at sort of how we do that in very, you know, how people build software in practice, as well as your sort of GOOS-style OO.</p>
<p>**纳特·普赖斯：**我将参加5月的KotlinConf和5月底6月的Craft。所以我将在那里发言，并举办一个关于…嗯，与你一起，我们将举办一个关于从面向对象重构到函数式的研讨会，并看看我们如何非常，你知道，人们如何在实践中构建软件，以及你的GOOS风格的面向对象。</p>
<p><strong>Duncan McGregor:</strong> In the context of this, probably characterize that as teaching us how to refactor from the OO style that GOOS championed to, I suppose, functional core imperative shell.</p>
<p>**邓肯·麦格雷戈：**在这种情况下，可能将其描述为教我们如何从GOOS倡导的面向对象风格重构到，我想，函数式核心命令式外壳。</p>
<p><strong>Nat Pryce:</strong> We’ll be looking at like, you know, popular frameworks and sort of the way that they make heavy use of reflection and how we can introduce better typing and things like that.</p>
<p>**纳特·普赖斯：**我们将看看，你知道，流行的框架以及它们如何大量使用反射，以及我们如何引入更好的类型等等。</p>
<p><strong>Duncan McGregor:</strong> We’ll arrange for details of that workshop, how to buy GOOS, and the book that we wrote together, “Java to Kotlin: A Refactoring Guidebook,” to be in the show notes, along with a link to my YouTube channel, Pairing with Duncan McGregor. Thank you for watching.</p>
<p>**邓肯·麦格雷戈：**我们将安排研讨会的详细信息，如何购买GOOS，以及我们合著的书《Java到Kotlin：重构指南》，以及我的YouTube频道”与邓肯·麦格雷戈结对”的链接，放在节目注释中。感谢观看。</p>
<p><strong>Nat Pryce:</strong> Thank you.</p>
<p>**纳特·普赖斯：**谢谢。</p>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>

      </div>
      
      
      
    </div>

    
    


    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="user"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">崔鹏飞</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">387k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">5:52</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/cuipengfei" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"cuipengfeioctopressblog","count":true,"lazyload":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js" defer></script>

</body>
</html>
